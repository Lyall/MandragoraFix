#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: man

#include "Basic.hpp"

#include "man_classes.hpp"
#include "man_parameters.hpp"


namespace SDK
{

// Function man.AbilityBase.AbilityStartedEvent
// (Native, Public)
// Parameters:
// class UAbilityBase*                     pStartedAbility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::AbilityStartedEvent(class UAbilityBase* pStartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "AbilityStartedEvent");

	Params::AbilityBase_AbilityStartedEvent Parms{};

	Parms.pStartedAbility = pStartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPAbilityCustomEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::BPAbilityCustomEvent(class FName CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPAbilityCustomEvent");

	Params::AbilityBase_BPAbilityCustomEvent Parms{};

	Parms.CustomName = CustomName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityBase.BPCustomEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::BPCustomEvent(class FName CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPCustomEvent");

	Params::AbilityBase_BPCustomEvent Parms{};

	Parms.CustomName = CustomName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPEnd
// (Final, Native, Public, BlueprintCallable)

void UAbilityBase::BPEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPGetCaster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityBase::BPGetCaster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetCaster");

	Params::AbilityBase_BPGetCaster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetComponentByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSub                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityComponent*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityComponent* UAbilityBase::BPGetComponentByClass(class UClass* ComponentClass, bool bSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetComponentByClass");

	Params::AbilityBase_BPGetComponentByClass Parms{};

	Parms.ComponentClass = ComponentClass;
	Parms.bSub = bSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetComponentByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ComponentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityComponent*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityComponent* UAbilityBase::BPGetComponentByName(class FName ComponentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetComponentByName");

	Params::AbilityBase_BPGetComponentByName Parms{};

	Parms.ComponentName = ComponentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetDuration
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityBase::BPGetDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetDuration");

	Params::AbilityBase_BPGetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetHitPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbilityBase::BPGetHitPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetHitPosition");

	Params::AbilityBase_BPGetHitPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetInstigatorAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAcrossEntities                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UAbilityBase::BPGetInstigatorAbility(bool bAcrossEntities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetInstigatorAbility");

	Params::AbilityBase_BPGetInstigatorAbility Parms{};

	Parms.bAcrossEntities = bAcrossEntities;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetRemainingTime
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityBase::BPGetRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetRemainingTime");

	Params::AbilityBase_BPGetRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetSummoner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityBase::BPGetSummoner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetSummoner");

	Params::AbilityBase_BPGetSummoner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* UAbilityBase::BPGetTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetTarget");

	Params::AbilityBase_BPGetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPIsRuning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityBase::BPIsRuning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPIsRuning");

	Params::AbilityBase_BPIsRuning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPOnEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityBase::BPOnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPOnPostAdd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityBase::BPOnPostAdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnPostAdd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPOnPostRemove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityBase::BPOnPostRemove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnPostRemove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPOnPreStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityBase::BPOnPreStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnPreStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPOnStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityBase::BPOnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPOnTargetMarked
// (Event, Public, BlueprintEvent)

void UAbilityBase::BPOnTargetMarked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnTargetMarked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.AbilityBase.BPOnTick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::BPOnTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPOnTick");

	Params::AbilityBase_BPOnTick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPSetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    inEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::BPSetEnabled(bool inEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPSetEnabled");

	Params::AbilityBase_BPSetEnabled Parms{};

	Parms.inEnabled = inEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPStart
// (Final, Native, Public, BlueprintCallable)

void UAbilityBase::BPStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.BPStartCondition
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::BPStartCondition(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPStartCondition");

	Params::AbilityBase_BPStartCondition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function man.AbilityBase.GetAbilityController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* UAbilityBase::GetAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetAbilityController");

	Params::AbilityBase_GetAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityBase::GetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetActor");

	Params::AbilityBase_GetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetActorBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActorBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActorBase* UAbilityBase::GetActorBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetActorBase");

	Params::AbilityBase_GetActorBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* UAbilityBase::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetAttributeContainer");

	Params::AbilityBase_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterBase* UAbilityBase::GetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetCharacter");

	Params::AbilityBase_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAbilityBase::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetEditorName");

	Params::AbilityBase_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetEnemyCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UAbilityBase::GetEnemyCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetEnemyCharacter");

	Params::AbilityBase_GetEnemyCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UAbilityBase::GetGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetGameMode");

	Params::AbilityBase_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHeroBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHeroBase* UAbilityBase::GetHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetHero");

	Params::AbilityBase_GetHero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.GetRemainingChaosEffectTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityBase::GetRemainingChaosEffectTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "GetRemainingChaosEffectTime");

	Params::AbilityBase_GetRemainingChaosEffectTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.IsInterrupted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityBase::IsInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "IsInterrupted");

	Params::AbilityBase_IsInterrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.OnAbilityAnimReplacedBase
// (Final, Native, Public)
// Parameters:
// class UAnimID*                          SrcAnimId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          DestAnimId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReplacerObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::OnAbilityAnimReplacedBase(class UAnimID* SrcAnimId, class UAnimID* DestAnimId, class UObject* ReplacerObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnAbilityAnimReplacedBase");

	Params::AbilityBase_OnAbilityAnimReplacedBase Parms{};

	Parms.SrcAnimId = SrcAnimId;
	Parms.DestAnimId = DestAnimId;
	Parms.ReplacerObject = ReplacerObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityBase.OnAnimEventBase
// (Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAbilityBase::OnAnimEventBase(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnAnimEventBase");

	Params::AbilityBase_OnAnimEventBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.AbilityBase.OnAttackSpeedChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAbilityBase::OnAttackSpeedChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnAttackSpeedChanged");

	Params::AbilityBase_OnAttackSpeedChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.AbilityBase.OnPreDamaged
// (Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UAbilityBase::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnPreDamaged");

	Params::AbilityBase_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AbilityBase.OnVisualEntitySpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVisualEntity*                    VisualEntity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityBase::OnVisualEntitySpawned(class AVisualEntity* VisualEntity, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "OnVisualEntitySpawned");

	Params::AbilityBase_OnVisualEntitySpawned Parms{};

	Parms.VisualEntity = VisualEntity;
	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityBase.BPGetHudWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHUDUserWidget*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHUDUserWidget* UAbilityBase::BPGetHudWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetHudWidget");

	Params::AbilityBase_BPGetHudWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityBase.BPGetMaxStackNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAbilityBase::BPGetMaxStackNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityBase", "BPGetMaxStackNum");

	Params::AbilityBase_BPGetMaxStackNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AIBase.OnAbilityEndingBase
// (Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnAbilityEndingBase(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnAbilityEndingBase");

	Params::AIBase_OnAbilityEndingBase Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIBase.OnAbilityStarting
// (Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnAbilityStarting(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnAbilityStarting");

	Params::AIBase_OnAbilityStarting Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIBase.OnAbilityStartingBase
// (Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesire                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnAbilityStartingBase(class UAbilityBase* InAbility, bool bDesire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnAbilityStartingBase");

	Params::AIBase_OnAbilityStartingBase Parms{};

	Parms.InAbility = InAbility;
	Parms.bDesire = bDesire;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIBase.OnAggroVolumeOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnAggroVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnAggroVolumeOverlap");

	Params::AIBase_OnAggroVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIBase.OnRoomenterAbilityEnded
// (Native, Public)
// Parameters:
// class UAbilityBase*                     AbilityEnded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnRoomenterAbilityEnded(class UAbilityBase* AbilityEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnRoomenterAbilityEnded");

	Params::AIBase_OnRoomenterAbilityEnded Parms{};

	Parms.AbilityEnded = AbilityEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIBase.OnRoomenterAnimEvent
// (Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAIBase::OnRoomenterAnimEvent(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnRoomenterAnimEvent");

	Params::AIBase_OnRoomenterAnimEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.BasicAI.BasicAI_IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasicAI::BasicAI_IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "BasicAI_IsCollideSignature");

	Params::BasicAI_BasicAI_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.BasicAI.BasicAI_IsCollideSignatureEx
// (Native, Public, HasOutParams)
// Parameters:
// struct FGroundMovecollideIsCollideSignatureParamParam                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UBasicAI::BasicAI_IsCollideSignatureEx(struct FGroundMovecollideIsCollideSignatureParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "BasicAI_IsCollideSignatureEx");

	Params::BasicAI_BasicAI_IsCollideSignatureEx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.BasicAI.BPStartAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInSkipRoomEnter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSerialize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasicAI::BPStartAggro(bool bInSkipRoomEnter, bool bSerialize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "BPStartAggro");

	Params::BasicAI_BPStartAggro Parms{};

	Parms.bInSkipRoomEnter = bInSkipRoomEnter;
	Parms.bSerialize = bSerialize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BasicAI.OnActorRespawned
// (Final, Native, Public)
// Parameters:
// class AActor*                           RespawnedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasicAI::OnActorRespawned(class AActor* RespawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "OnActorRespawned");

	Params::BasicAI_OnActorRespawned Parms{};

	Parms.RespawnedActor = RespawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BasicAI.OnLanded
// (Final, Native, Public)

void UBasicAI::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BasicAI.OnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBasicAI::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAI", "OnPostDamaged");

	Params::BasicAI_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.CloseRequest
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOpenPauseMenu                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyClose                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::CloseRequest(bool bOpenPauseMenu, bool bOnlyClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "CloseRequest");

	Params::ManUserWidgetBase_CloseRequest Parms{};

	Parms.bOpenPauseMenu = bOpenPauseMenu;
	Parms.bOnlyClose = bOnlyClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.CultureChanged
// (Final, Native, Protected)

void UManUserWidgetBase::CultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "CultureChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.JumpToNextSort
// (Native, Public, BlueprintCallable)

void UManUserWidgetBase::JumpToNextSort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "JumpToNextSort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.JumpToPreviousSort
// (Native, Public, BlueprintCallable)

void UManUserWidgetBase::JumpToPreviousSort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "JumpToPreviousSort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.OnAnalogValueChangedEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnalogValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnAnalogValueChangedEvent(const struct FKey& Key, float AnalogValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnAnalogValueChangedEvent");

	Params::ManUserWidgetBase_OnAnalogValueChangedEvent Parms{};

	Parms.Key = std::move(Key);
	Parms.AnalogValue = AnalogValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnCultureChanged
// (Event, Protected, BlueprintEvent)

void UManUserWidgetBase::OnCultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnCultureChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnErrorHiglight
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractButtonUserWidget*        InteractButtonUserWidget                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnErrorHiglight(class UInteractButtonUserWidget* InteractButtonUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnErrorHiglight");

	Params::ManUserWidgetBase_OnErrorHiglight Parms{};

	Parms.InteractButtonUserWidget = InteractButtonUserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnGamepadAEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadAEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadAEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadBEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadBEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadBEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadDPadDownEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadDPadDownEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadDPadDownEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadDPadLeftEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadDPadLeftEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadDPadLeftEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadDPadRightEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadDPadRightEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadDPadRightEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadDPadUpEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadDPadUpEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadDPadUpEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLBEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLBEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLBEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLeftStickBtnEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLeftStickBtnEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLeftStickBtnEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLeftStickDownEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLeftStickDownEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLeftStickDownEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLeftStickLeftEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLeftStickLeftEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLeftStickLeftEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLeftStickRightEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLeftStickRightEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLeftStickRightEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLeftStickUpEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLeftStickUpEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLeftStickUpEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadLTEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadLTEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadLTEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRBEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRBEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRBEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRightStickBtnEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRightStickBtnEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRightStickBtnEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRightStickDownEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRightStickDownEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRightStickDownEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRightStickLeftEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRightStickLeftEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRightStickLeftEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRightStickRightEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRightStickRightEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRightStickRightEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRightStickUpEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRightStickUpEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRightStickUpEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadRTEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadRTEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadRTEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadXEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadXEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadXEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnGamepadYEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnGamepadYEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnGamepadYEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnHide
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnHide(float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnHide");

	Params::ManUserWidgetBase_OnHide Parms{};

	Parms.AnimDuration = AnimDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnHideFinished
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnHideFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnHideFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnHoldCanceled
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractButtonUserWidget*        InteractButtonUserWidget                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMinTimeCancel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnHoldCanceled(class UInteractButtonUserWidget* InteractButtonUserWidget, bool bMinTimeCancel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnHoldCanceled");

	Params::ManUserWidgetBase_OnHoldCanceled Parms{};

	Parms.InteractButtonUserWidget = InteractButtonUserWidget;
	Parms.bMinTimeCancel = bMinTimeCancel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnHoldFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractButtonUserWidget*        InteractButtonUserWidget                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnHoldFinished(class UInteractButtonUserWidget* InteractButtonUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnHoldFinished");

	Params::ManUserWidgetBase_OnHoldFinished Parms{};

	Parms.InteractButtonUserWidget = InteractButtonUserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnHoldStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractButtonUserWidget*        InteractButtonUserWidget                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnHoldStarted(class UInteractButtonUserWidget* InteractButtonUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnHoldStarted");

	Params::ManUserWidgetBase_OnHoldStarted Parms{};

	Parms.InteractButtonUserWidget = InteractButtonUserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnIngameMenuEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnIngameMenuEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnIngameMenuEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnInit
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnInputDisplayChanged
// (Native, Public)
// Parameters:
// EInputDisplay                           InInputDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           InControlDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnInputDisplayChanged(EInputDisplay InInputDisplay, EInputDisplay InControlDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnInputDisplayChanged");

	Params::ManUserWidgetBase_OnInputDisplayChanged Parms{};

	Parms.InInputDisplay = InInputDisplay;
	Parms.InControlDisplay = InControlDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.OnInventoryEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnInventoryEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnInventoryEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnMapEvent
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnMapEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnMapEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnPostInit
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnPostInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnPostInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnRotateCharacterLeft
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bRotate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnRotateCharacterLeft(bool bRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnRotateCharacterLeft");

	Params::ManUserWidgetBase_OnRotateCharacterLeft Parms{};

	Parms.bRotate = bRotate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnRotateCharacterRight
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bRotate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnRotateCharacterRight(bool bRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnRotateCharacterRight");

	Params::ManUserWidgetBase_OnRotateCharacterRight Parms{};

	Parms.bRotate = bRotate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnSetFocusedWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeFocusByUser                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeFocusByMouse                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnSetFocusedWidget(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget, bool bChangeFocusByUser, bool bChangeFocusByMouse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnSetFocusedWidget");

	Params::ManUserWidgetBase_OnSetFocusedWidget Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;
	Parms.bChangeFocusByUser = bChangeFocusByUser;
	Parms.bChangeFocusByMouse = bChangeFocusByMouse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnSetInputDisplay
// (Event, Public, BlueprintEvent)
// Parameters:
// EInputDisplay                           InInputDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           InControlDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnSetInputDisplay(EInputDisplay InInputDisplay, EInputDisplay InControlDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnSetInputDisplay");

	Params::ManUserWidgetBase_OnSetInputDisplay Parms{};

	Parms.InInputDisplay = InInputDisplay;
	Parms.InControlDisplay = InControlDisplay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnSetTabButtonsVisbility
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InVisibleTabButtonNum                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnSetTabButtonsVisbility(int32 InVisibleTabButtonNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnSetTabButtonsVisbility");

	Params::ManUserWidgetBase_OnSetTabButtonsVisbility Parms{};

	Parms.InVisibleTabButtonNum = InVisibleTabButtonNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnShow
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnShow(float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnShow");

	Params::ManUserWidgetBase_OnShow Parms{};

	Parms.AnimDuration = AnimDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnShowFinished
// (Event, Public, BlueprintEvent)

void UManUserWidgetBase::OnShowFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnShowFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManUserWidgetBase.OnSortChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             SortName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnSortChanged(const class FText& SortName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnSortChanged");

	Params::ManUserWidgetBase_OnSortChanged Parms{};

	Parms.SortName = std::move(SortName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManUserWidgetBase.OnUserScrolled
// (Final, Native, Protected)
// Parameters:
// float                                   CurrentOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::OnUserScrolled(float CurrentOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "OnUserScrolled");

	Params::ManUserWidgetBase_OnUserScrolled Parms{};

	Parms.CurrentOffset = CurrentOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.SetFocusedWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          InFocusedWidget                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeFocusByUser                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeFocusByMouse                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSetLastValidFocusedWidget                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::SetFocusedWidget(class UWidget* InFocusedWidget, bool bAnimate, bool bChangeFocusByUser, bool bChangeFocusByMouse, bool bForceSetLastValidFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "SetFocusedWidget");

	Params::ManUserWidgetBase_SetFocusedWidget Parms{};

	Parms.InFocusedWidget = InFocusedWidget;
	Parms.bAnimate = bAnimate;
	Parms.bChangeFocusByUser = bChangeFocusByUser;
	Parms.bChangeFocusByMouse = bChangeFocusByMouse;
	Parms.bForceSetLastValidFocusedWidget = bForceSetLastValidFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.SetInteractedActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActorBase*                       InInteractedActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::SetInteractedActor(class AActorBase* InInteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "SetInteractedActor");

	Params::ManUserWidgetBase_SetInteractedActor Parms{};

	Parms.InInteractedActor = InInteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.SetNextTab
// (Final, Native, Public, BlueprintCallable)

void UManUserWidgetBase::SetNextTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "SetNextTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.SetPreviousTab
// (Final, Native, Public, BlueprintCallable)

void UManUserWidgetBase::SetPreviousTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "SetPreviousTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.SetTab
// (Native, Public, BlueprintCallable)
// Parameters:
// ETabButtonType                          TabButtonType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowWindow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManUserWidgetBase::SetTab(ETabButtonType TabButtonType, bool bShowWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "SetTab");

	Params::ManUserWidgetBase_SetTab Parms{};

	Parms.TabButtonType = TabButtonType;
	Parms.bShowWindow = bShowWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManUserWidgetBase.BPIsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManUserWidgetBase::BPIsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "BPIsVisible");

	Params::ManUserWidgetBase_BPIsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.GetAnimPlaybackSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UManUserWidgetBase::GetAnimPlaybackSpeed(float AnimDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "GetAnimPlaybackSpeed");

	Params::ManUserWidgetBase_GetAnimPlaybackSpeed Parms{};

	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.GetFilterType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemSlot                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemSlot UManUserWidgetBase::GetFilterType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "GetFilterType");

	Params::ManUserWidgetBase_GetFilterType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.GetFocusedWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UManUserWidgetBase::GetFocusedWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "GetFocusedWidget");

	Params::ManUserWidgetBase_GetFocusedWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.GetNextTab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETabButtonType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETabButtonType UManUserWidgetBase::GetNextTab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "GetNextTab");

	Params::ManUserWidgetBase_GetNextTab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.GetPreviousTab
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETabButtonType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETabButtonType UManUserWidgetBase::GetPreviousTab() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "GetPreviousTab");

	Params::ManUserWidgetBase_GetPreviousTab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.IsHoldProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManUserWidgetBase::IsHoldProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "IsHoldProgress");

	Params::ManUserWidgetBase_IsHoldProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.IsLeftMouseButtonDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManUserWidgetBase::IsLeftMouseButtonDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "IsLeftMouseButtonDown");

	Params::ManUserWidgetBase_IsLeftMouseButtonDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManUserWidgetBase.IsRotateCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManUserWidgetBase::IsRotateCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManUserWidgetBase", "IsRotateCharacter");

	Params::ManUserWidgetBase_IsRotateCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LevelVisualVolume.OnBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelVisualVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVisualVolume", "OnBeginOverlap");

	Params::LevelVisualVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelVisualVolume.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelVisualVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVisualVolume", "OnEndOverlap");

	Params::LevelVisualVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityComponent.GetEditorName
// (Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAbilityComponent::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityComponent", "GetEditorName");

	Params::AbilityComponent_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityEventComponent.GameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityEventComponent::GameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "GameplayEvent");

	Params::AbilityEventComponent_GameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityEventComponent.OnAnimEventBase
// (Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnAnimEventBase(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnAnimEventBase");

	Params::AbilityEventComponent_OnAnimEventBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.AbilityEventComponent.OnDamageCaused
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnDamageCaused(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* Target, class UAbilityBase* InAbility, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnDamageCaused");

	Params::AbilityEventComponent_OnDamageCaused Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.Target = Target;
	Parms.InAbility = InAbility;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityEventComponent.OnDamageTaken
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               TargetArg                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnDamageTaken(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* TargetArg, class UAbilityBase* InAbility, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnDamageTaken");

	Params::AbilityEventComponent_OnDamageTaken Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.TargetArg = TargetArg;
	Parms.InAbility = InAbility;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityEventComponent.OnEntityTeleportPost
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnEntityTeleportPost(const struct FVector& NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnEntityTeleportPost");

	Params::AbilityEventComponent_OnEntityTeleportPost Parms{};

	Parms.NewPosition = std::move(NewPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityEventComponent.OnPostDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnPostDamageCaused");

	Params::AbilityEventComponent_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityEventComponent.OnStatusEffectChange
// (Final, Native, Private)
// Parameters:
// EStatusEffectChange                     Change                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       StatusType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityEventComponent::OnStatusEffectChange(EStatusEffectChange Change, EStatusEffectType StatusType, class AActor* Source, int32 StackNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityEventComponent", "OnStatusEffectChange");

	Params::AbilityEventComponent_OnStatusEffectChange Parms{};

	Parms.Change = Change;
	Parms.StatusType = StatusType;
	Parms.Source = Source;
	Parms.StackNum = StackNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RestoreEnergyAbilityComponent.OnAbilityResourceConsumed
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URestoreEnergyAbilityComponent::OnAbilityResourceConsumed(class UAbilityBase* StartedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RestoreEnergyAbilityComponent", "OnAbilityResourceConsumed");

	Params::RestoreEnergyAbilityComponent_OnAbilityResourceConsumed Parms{};

	Parms.StartedAbility = StartedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestObjective.AddRequiredObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               PreObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjective* UManQuestObjective::AddRequiredObjective(class UManQuestObjective* PreObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestObjective", "AddRequiredObjective");

	Params::ManQuestObjective_AddRequiredObjective Parms{};

	Parms.PreObjective = PreObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestObjective.BPGetObjectiveText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bShowCounterText                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UManQuestObjective::BPGetObjectiveText(bool bShowCounterText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestObjective", "BPGetObjectiveText");

	Params::ManQuestObjective_BPGetObjectiveText Parms{};

	Parms.bShowCounterText = bShowCounterText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManScaledUserWidget.SetCanCacheByTimer
// (Final, Native, Protected)

void UManScaledUserWidget::SetCanCacheByTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManScaledUserWidget", "SetCanCacheByTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilitiesUserWidgetBase.JumpToNextFilter
// (Final, Native, Protected, BlueprintCallable)

void UAbilitiesUserWidgetBase::JumpToNextFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "JumpToNextFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilitiesUserWidgetBase.JumpToPrevFilter
// (Final, Native, Protected, BlueprintCallable)

void UAbilitiesUserWidgetBase::JumpToPrevFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "JumpToPrevFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilitiesUserWidgetBase.OnSetFilterName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             FilterName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EWeaponType                             InWeaponTypeFilter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayChangeFilterSound                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitiesUserWidgetBase::OnSetFilterName(const class FText& FilterName, EWeaponType InWeaponTypeFilter, bool bPlayChangeFilterSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "OnSetFilterName");

	Params::AbilitiesUserWidgetBase_OnSetFilterName Parms{};

	Parms.FilterName = std::move(FilterName);
	Parms.InWeaponTypeFilter = InWeaponTypeFilter;
	Parms.bPlayChangeFilterSound = bPlayChangeFilterSound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitiesUserWidgetBase.OnSetUpgrades
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   MaxUpgrades                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LearnedUpgrades                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitiesUserWidgetBase::OnSetUpgrades(int32 MaxUpgrades, int32 LearnedUpgrades)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "OnSetUpgrades");

	Params::AbilitiesUserWidgetBase_OnSetUpgrades Parms{};

	Parms.MaxUpgrades = MaxUpgrades;
	Parms.LearnedUpgrades = LearnedUpgrades;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitiesUserWidgetBase.OnUpdateDetailsPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             FlavorText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             CostText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Requirements                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxUpgrades                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LearnedUpgrades                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitiesUserWidgetBase::OnUpdateDetailsPanel(const class FText& Name_0, const class FText& Description, const class FText& FlavorText, const class FText& CostText, const class FText& Requirements, const class UTexture2D* Icon, TSubclassOf<class UAbilityBase> AbilityClass, int32 MaxUpgrades, int32 LearnedUpgrades)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "OnUpdateDetailsPanel");

	Params::AbilitiesUserWidgetBase_OnUpdateDetailsPanel Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Description = std::move(Description);
	Parms.FlavorText = std::move(FlavorText);
	Parms.CostText = std::move(CostText);
	Parms.Requirements = std::move(Requirements);
	Parms.Icon = Icon;
	Parms.AbilityClass = AbilityClass;
	Parms.MaxUpgrades = MaxUpgrades;
	Parms.LearnedUpgrades = LearnedUpgrades;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitiesUserWidgetBase.OnUpdateUpgradesPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FText>                     Upgrades                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Requirements                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilitiesUserWidgetBase::OnUpdateUpgradesPanel(const TArray<class FText>& Upgrades, const class FText& Requirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "OnUpdateUpgradesPanel");

	Params::AbilitiesUserWidgetBase_OnUpdateUpgradesPanel Parms{};

	Parms.Upgrades = std::move(Upgrades);
	Parms.Requirements = std::move(Requirements);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitiesUserWidgetBase.SetFilter
// (Native, Protected, BlueprintCallable)
// Parameters:
// EWeaponType                             InWeaponTypeFilter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFilterSlotAnimate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayChangeFilterSound                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitiesUserWidgetBase::SetFilter(EWeaponType InWeaponTypeFilter, bool bFilterSlotAnimate, bool bPlayChangeFilterSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitiesUserWidgetBase", "SetFilter");

	Params::AbilitiesUserWidgetBase_SetFilter Parms{};

	Parms.InWeaponTypeFilter = InWeaponTypeFilter;
	Parms.bFilterSlotAnimate = bFilterSlotAnimate;
	Parms.bPlayChangeFilterSound = bPlayChangeFilterSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.BPOnEndEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityToggleComponent::BPOnEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "BPOnEndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.BPOnStartEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UAbilityToggleComponent::BPOnStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "BPOnStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.GameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::GameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "GameplayEvent");

	Params::AbilityToggleComponent_GameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.OnDamageCaused
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::OnDamageCaused(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* Target, class UAbilityBase* InAbility, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "OnDamageCaused");

	Params::AbilityToggleComponent_OnDamageCaused Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.Target = Target;
	Parms.InAbility = InAbility;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.OnDamageTaken
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               TargetArg                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::OnDamageTaken(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* TargetArg, class UAbilityBase* InAbility, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "OnDamageTaken");

	Params::AbilityToggleComponent_OnDamageTaken Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.TargetArg = TargetArg;
	Parms.InAbility = InAbility;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.OnEntityTeleportPost
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::OnEntityTeleportPost(const struct FVector& NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "OnEntityTeleportPost");

	Params::AbilityToggleComponent_OnEntityTeleportPost Parms{};

	Parms.NewPosition = std::move(NewPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.OnGuardedAbilityEnded
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     AbilityEnded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::OnGuardedAbilityEnded(class UAbilityBase* AbilityEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "OnGuardedAbilityEnded");

	Params::AbilityToggleComponent_OnGuardedAbilityEnded Parms{};

	Parms.AbilityEnded = AbilityEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityToggleComponent.OnStatusEffectChange
// (Final, Native, Private)
// Parameters:
// EStatusEffectChange                     Change                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       StatusType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityToggleComponent::OnStatusEffectChange(EStatusEffectChange Change, EStatusEffectType StatusType, class AActor* Source, int32 StackNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityToggleComponent", "OnStatusEffectChange");

	Params::AbilityToggleComponent_OnStatusEffectChange Parms{};

	Parms.Change = Change;
	Parms.StatusType = StatusType;
	Parms.Source = Source;
	Parms.StackNum = StackNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Timer_AbilityComponent.BPGetElapsedTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimer_AbilityComponent::BPGetElapsedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Timer_AbilityComponent", "BPGetElapsedTime");

	Params::Timer_AbilityComponent_BPGetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Timer_AbilityComponent.BPGetOriginalTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimer_AbilityComponent::BPGetOriginalTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Timer_AbilityComponent", "BPGetOriginalTime");

	Params::Timer_AbilityComponent_BPGetOriginalTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChaoticEnergiesComponent.OnAbilityEnded
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     EndedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticEnergiesComponent::OnAbilityEnded(class UAbilityBase* EndedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticEnergiesComponent", "OnAbilityEnded");

	Params::ChaoticEnergiesComponent_OnAbilityEnded Parms{};

	Parms.EndedAbility = EndedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticEnergiesComponent.OnAbilityResourcesConsumed
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticEnergiesComponent::OnAbilityResourcesConsumed(class UAbilityBase* StartedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticEnergiesComponent", "OnAbilityResourcesConsumed");

	Params::ChaoticEnergiesComponent_OnAbilityResourcesConsumed Parms{};

	Parms.StartedAbility = StartedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticEnergiesComponent.OwnerPostDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChaoticEnergiesComponent::OwnerPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticEnergiesComponent", "OwnerPostDamageCaused");

	Params::ChaoticEnergiesComponent_OwnerPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.KingPriestVoidDarkWall.BPGetExplosionLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidDarkWall::BPGetExplosionLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidDarkWall", "BPGetExplosionLocation");

	Params::KingPriestVoidDarkWall_BPGetExplosionLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.KingPriestVoidDarkWall.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidDarkWall::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidDarkWall", "BPGetTeleportLocation");

	Params::KingPriestVoidDarkWall_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.KingPriestVoidDarkWall.BPIsDarkWallStartedOnLeftSide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKingPriestVoidDarkWall::BPIsDarkWallStartedOnLeftSide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidDarkWall", "BPIsDarkWallStartedOnLeftSide");

	Params::KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LongPressIndicatorUserWidget.OnSetIndicatorRatio
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InIndicatorRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULongPressIndicatorUserWidget::OnSetIndicatorRatio(float InIndicatorRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LongPressIndicatorUserWidget", "OnSetIndicatorRatio");

	Params::LongPressIndicatorUserWidget_OnSetIndicatorRatio Parms{};

	Parms.InIndicatorRatio = InIndicatorRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ForcedChaosEffectAbilityComponent.OnPreAbilityStarted
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForcedChaosEffectAbilityComponent::OnPreAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedChaosEffectAbilityComponent", "OnPreAbilityStarted");

	Params::ForcedChaosEffectAbilityComponent_OnPreAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteAttackLungeOneAndJumpAndTwo.OnParried
// (Final, Native, Public)

void UMarionetteAttackLungeOneAndJumpAndTwo::OnParried()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteAttackLungeOneAndJumpAndTwo", "OnParried");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.BP_AddDisableAutosleepCounter
// (Final, Native, Public, BlueprintCallable)

void AActorBase::BP_AddDisableAutosleepCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BP_AddDisableAutosleepCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.BP_RemoveDisableAutosleepCounter
// (Final, Native, Public, BlueprintCallable)

void AActorBase::BP_RemoveDisableAutosleepCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BP_RemoveDisableAutosleepCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.BPGetFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActorBase::BPGetFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPGetFacing");

	Params::ActorBase_BPGetFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.BPGetForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActorBase::BPGetForwardVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPGetForwardVector");

	Params::ActorBase_BPGetForwardVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.BPGetInteractText
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             DefaultText                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AActorBase::BPGetInteractText(const class FText& DefaultText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPGetInteractText");

	Params::ActorBase_BPGetInteractText Parms{};

	Parms.DefaultText = std::move(DefaultText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.BPOnClosed
// (Event, Public, BlueprintEvent)

void AActorBase::BPOnClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPOnClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActorBase.BPOnOpened
// (Event, Public, BlueprintEvent)

void AActorBase::BPOnOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPOnOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActorBase.BPPostBeginPlay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActorBase::BPPostBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPPostBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.BPPostSaveLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActorBase::BPPostSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPPostSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.BPStartAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActorBase::BPStartAnim(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPStartAnim");

	Params::ActorBase_BPStartAnim Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.BPStopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActorBase::BPStopAnim(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPStopAnim");

	Params::ActorBase_BPStopAnim Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.BPStopDialogue
// (Final, Native, Public, BlueprintCallable)

void AActorBase::BPStopDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "BPStopDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.ForceSleep
// (Final, Native, Public, BlueprintCallable)

void AActorBase::ForceSleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "ForceSleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.ForceWake
// (Final, Native, Public, BlueprintCallable)

void AActorBase::ForceWake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "ForceWake");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.GetAbilityController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* AActorBase::GetAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "GetAbilityController");

	Params::ActorBase_GetAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* AActorBase::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "GetAttributeContainer");

	Params::ActorBase_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.IsInteractable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActorBase::IsInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "IsInteractable");

	Params::ActorBase_IsInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBase.MAN_SetActorHiddenInGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::MAN_SetActorHiddenInGame(bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "MAN_SetActorHiddenInGame");

	Params::ActorBase_MAN_SetActorHiddenInGame Parms{};

	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.OnVfxEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             VfxEventType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::OnVfxEvent(class FName VfxEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "OnVfxEvent");

	Params::ActorBase_OnVfxEvent Parms{};

	Parms.VfxEventType = VfxEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.OnWakeUp
// (Native, Event, Public, BlueprintEvent)

void AActorBase::OnWakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "OnWakeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.PlayerStatistics_OnOpened
// (Final, Native, Public)

void AActorBase::PlayerStatistics_OnOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "PlayerStatistics_OnOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.ResetPreInteract
// (Final, Native, Public, BlueprintCallable)

void AActorBase::ResetPreInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "ResetPreInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.SetLevelSequenceConversationAnimID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::SetLevelSequenceConversationAnimID(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "SetLevelSequenceConversationAnimID");

	Params::ActorBase_SetLevelSequenceConversationAnimID Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.SetLevelSequenceMirrored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMirrored                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::SetLevelSequenceMirrored(bool bMirrored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "SetLevelSequenceMirrored");

	Params::ActorBase_SetLevelSequenceMirrored Parms{};

	Parms.bMirrored = bMirrored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.ToggleIneractability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::ToggleIneractability(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "ToggleIneractability");

	Params::ActorBase_ToggleIneractability Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorBase.ToggleInteractability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorBase::ToggleInteractability(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBase", "ToggleInteractability");

	Params::ActorBase_ToggleInteractability Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CoverTerrainWithActors.BasicAttackHitCounterUpdated
// (Final, Native, Private)
// Parameters:
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverTerrainWithActors::BasicAttackHitCounterUpdated(class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverTerrainWithActors", "BasicAttackHitCounterUpdated");

	Params::CoverTerrainWithActors_BasicAttackHitCounterUpdated Parms{};

	Parms.HitActor = HitActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CoverTerrainWithActors.GetPresumedLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoverTerrainWithActors::GetPresumedLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverTerrainWithActors", "GetPresumedLength");

	Params::CoverTerrainWithActors_GetPresumedLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DeadlyDancePassive.PostDamageDealt
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDeadlyDancePassive::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeadlyDancePassive", "PostDamageDealt");

	Params::DeadlyDancePassive_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ComboPointsManagementComponent.OnPostDamageDone
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UComboPointsManagementComponent::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboPointsManagementComponent", "OnPostDamageDone");

	Params::ComboPointsManagementComponent_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BloodMagicAbilityComponent.PreResourceChecked
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEntityProperty                         Property                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResourceValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodMagicAbilityComponent::PreResourceChecked(EEntityProperty Property, float* ResourceValue, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodMagicAbilityComponent", "PreResourceChecked");

	Params::BloodMagicAbilityComponent_PreResourceChecked Parms{};

	Parms.Property = Property;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResourceValue != nullptr)
		*ResourceValue = Parms.ResourceValue;
}


// Function man.BloodMagicAbilityComponent.PreResourceUsed
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEntityProperty                         Property                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResourceValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodMagicAbilityComponent::PreResourceUsed(EEntityProperty Property, float* ResourceValue, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodMagicAbilityComponent", "PreResourceUsed");

	Params::BloodMagicAbilityComponent_PreResourceUsed Parms{};

	Parms.Property = Property;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResourceValue != nullptr)
		*ResourceValue = Parms.ResourceValue;
}


// Function man.ManTelemetry.GetManTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UManTelemetry*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManTelemetry* UManTelemetry::GetManTelemetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManTelemetry", "GetManTelemetry");

	Params::ManTelemetry_GetManTelemetry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManTelemetry.SendTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MetricCode                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ObjectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManTelemetry::SendTelemetry(const class FString& MetricCode, int32 Value, int32 Level, int32 ObjectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManTelemetry", "SendTelemetry");

	Params::ManTelemetry_SendTelemetry Parms{};

	Parms.MetricCode = std::move(MetricCode);
	Parms.Value = Value;
	Parms.Level = Level;
	Parms.ObjectId = ObjectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManTelemetry.OnJokeHeard
// (Final, Native, Public, BlueprintCallable)

void UManTelemetry::OnJokeHeard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTelemetry", "OnJokeHeard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbilityModifierChange.OnAbilityModifierChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGeneralAbilityModifier                 GeneralID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbilityModifierChange::OnAbilityModifierChanged(bool bAdded, EGeneralAbilityModifier GeneralID, class FName CustomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbilityModifierChange", "OnAbilityModifierChanged");

	Params::CustomEventOnAbilityModifierChange_OnAbilityModifierChanged Parms{};

	Parms.bAdded = bAdded;
	Parms.GeneralID = GeneralID;
	Parms.CustomID = CustomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TrappedSoulsBase.TriggerOnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTrappedSoulsBase::TriggerOnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrappedSoulsBase", "TriggerOnComponentBeginOverlap");

	Params::TrappedSoulsBase_TriggerOnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TrappedSoulsBase.TriggerOnComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrappedSoulsBase::TriggerOnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrappedSoulsBase", "TriggerOnComponentEndOverlap");

	Params::TrappedSoulsBase_TriggerOnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GreenEyePoisonActor.OnPreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void AGreenEyePoisonActor::OnPreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GreenEyePoisonActor", "OnPreDamageDealt");

	Params::GreenEyePoisonActor_OnPreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AdditionalStatusEffectOnStatusEffectComponent.OnStatusEffectCaused
// (Final, Native, Private)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdditionalStatusEffectOnStatusEffectComponent::OnStatusEffectCaused(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdditionalStatusEffectOnStatusEffectComponent", "OnStatusEffectCaused");

	Params::AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AdditionalEffectDuringStatusEffectComponent.StatusEffectApplied
// (Final, Native, Private)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdditionalEffectDuringStatusEffectComponent::StatusEffectApplied(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdditionalEffectDuringStatusEffectComponent", "StatusEffectApplied");

	Params::AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConsumeResourceForStatusEffect.OnPostDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConsumeResourceForStatusEffect::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumeResourceForStatusEffect", "OnPostDamageCaused");

	Params::ConsumeResourceForStatusEffect_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GatheringLight.OnPreDamaged_GatheringLight
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UGatheringLight::OnPreDamaged_GatheringLight(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GatheringLight", "OnPreDamaged_GatheringLight");

	Params::GatheringLight_OnPreDamaged_GatheringLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.PortalMirrorImplement.TriggerOnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPortalMirrorImplement::TriggerOnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PortalMirrorImplement", "TriggerOnComponentBeginOverlap");

	Params::PortalMirrorImplement_TriggerOnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PriestLightBarrierPassive.GetAbsorbComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbsorbDamageAbilityComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbsorbDamageAbilityComponent* UPriestLightBarrierPassive::GetAbsorbComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PriestLightBarrierPassive", "GetAbsorbComponent");

	Params::PriestLightBarrierPassive_GetAbsorbComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PriestLightBarrierPassive.OnAbilityModifierChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bInAdded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGeneralAbilityModifier                 GeneralID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPriestLightBarrierPassive::OnAbilityModifierChanged(bool bInAdded, EGeneralAbilityModifier GeneralID, class FName CustomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PriestLightBarrierPassive", "OnAbilityModifierChanged");

	Params::PriestLightBarrierPassive_OnAbilityModifierChanged Parms{};

	Parms.bInAdded = bInAdded;
	Parms.GeneralID = GeneralID;
	Parms.CustomID = CustomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PriestLightBarrierPassive.PropertyChanged
// (Final, Native, Public)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPriestLightBarrierPassive::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PriestLightBarrierPassive", "PropertyChanged");

	Params::PriestLightBarrierPassive_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PriestLightBarrierPassive.Rest
// (Final, Native, Public)

void UPriestLightBarrierPassive::Rest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PriestLightBarrierPassive", "Rest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbility.OnAbilityEnded
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     EndedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbility::OnAbilityEnded(class UAbilityBase* EndedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbility", "OnAbilityEnded");

	Params::CustomEventOnAbility_OnAbilityEnded Parms{};

	Parms.EndedAbility = EndedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbility.OnAbilityResourceConsumed
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbility::OnAbilityResourceConsumed(class UAbilityBase* StartedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbility", "OnAbilityResourceConsumed");

	Params::CustomEventOnAbility_OnAbilityResourceConsumed Parms{};

	Parms.StartedAbility = StartedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbility.OnAbilityStarted
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbility::OnAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbility", "OnAbilityStarted");

	Params::CustomEventOnAbility_OnAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbility.OnPostAddAbility
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     AddedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbility::OnPostAddAbility(class UAbilityBase* AddedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbility", "OnPostAddAbility");

	Params::CustomEventOnAbility_OnPostAddAbility Parms{};

	Parms.AddedAbility = AddedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnAbility.OnPostRemoveAbility
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     RemovedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnAbility::OnPostRemoveAbility(class UAbilityBase* RemovedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnAbility", "OnPostRemoveAbility");

	Params::CustomEventOnAbility_OnPostRemoveAbility Parms{};

	Parms.RemovedAbility = RemovedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVolumeBase.BPEncompassesPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AManVolumeBase::BPEncompassesPoint(const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVolumeBase", "BPEncompassesPoint");

	Params::ManVolumeBase_BPEncompassesPoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CustomEventOnFadeManager.OnFadeInFinished
// (Final, Native, Private)

void UCustomEventOnFadeManager::OnFadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnFadeManager", "OnFadeInFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnFadeManager.OnFadeOutFinished
// (Final, Native, Private)

void UCustomEventOnFadeManager::OnFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnFadeManager", "OnFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFocus.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDarkFocus::DamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFocus", "DamageDealt");

	Params::DarkFocus_DamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.Execute.OnPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UExecute::OnPostDamageCaused(const struct FPreDamagedEventParam& PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Execute", "OnPostDamageCaused");

	Params::Execute_OnPostDamageCaused Parms{};

	Parms.PreDamagedEventParam = std::move(PreDamagedEventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TimedAbilityManager.OnGameplayEvent
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedAbilityManager::OnGameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedAbilityManager", "OnGameplayEvent");

	Params::TimedAbilityManager_OnGameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OnDamaged_AbilityComponent.OnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnDamaged_AbilityComponent::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnDamaged_AbilityComponent", "OnPostDamaged");

	Params::OnDamaged_AbilityComponent_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.AddTextBubble
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDialogueBubbleType                     DialogueBubbleType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::AddTextBubble(const class FText& Text, float Delay, EDialogueBubbleType DialogueBubbleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "AddTextBubble");

	Params::CharacterBase_AddTextBubble Parms{};

	Parms.Text = std::move(Text);
	Parms.Delay = Delay;
	Parms.DialogueBubbleType = DialogueBubbleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.AddToGameCamera
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::AddToGameCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "AddToGameCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPExecuteCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             commandName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPExecuteCommand(class FName commandName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPExecuteCommand");

	Params::CharacterBase_BPExecuteCommand Parms{};

	Parms.commandName = commandName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPGetAIPhaseIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACharacterBase::BPGetAIPhaseIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPGetAIPhaseIndex");

	Params::CharacterBase_BPGetAIPhaseIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPGetAnimPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterBase::BPGetAnimPlayRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPGetAnimPlayRate");

	Params::CharacterBase_BPGetAnimPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPGetAxisXFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterBase::BPGetAxisXFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPGetAxisXFacing");

	Params::CharacterBase_BPGetAxisXFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPHasEntityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DeathTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPHasEntityTag(class FName DeathTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPHasEntityTag");

	Params::CharacterBase_BPHasEntityTag Parms{};

	Parms.DeathTag = DeathTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPIsBoss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPIsBoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPIsBoss");

	Params::CharacterBase_BPIsBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPIsFalling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPIsFalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPIsFalling");

	Params::CharacterBase_BPIsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPIsRespawnFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPIsRespawnFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPIsRespawnFinished");

	Params::CharacterBase_BPIsRespawnFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPKill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          CustomAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceInterruptAll                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestInvulnerable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPKill(class UAnimID* CustomAnim, bool bForceInterruptAll, bool bTestInvulnerable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPKill");

	Params::CharacterBase_BPKill Parms{};

	Parms.CustomAnim = CustomAnim;
	Parms.bForceInterruptAll = bForceInterruptAll;
	Parms.bTestInvulnerable = bTestInvulnerable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.BPLootDropCondition
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UItemAbility*                     Loot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPLootDropCondition(class UItemAbility* Loot, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPLootDropCondition");

	Params::CharacterBase_BPLootDropCondition Parms{};

	Parms.Loot = Loot;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function man.CharacterBase.BPMoveHorizontal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPMoveHorizontal(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPMoveHorizontal");

	Params::CharacterBase_BPMoveHorizontal Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPMoveVertical
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPMoveVertical(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPMoveVertical");

	Params::CharacterBase_BPMoveVertical Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPOverrideLootSpawnTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       InTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterBase::BPOverrideLootSpawnTransform(const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPOverrideLootSpawnTransform");

	Params::CharacterBase_BPOverrideLootSpawnTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPPostBeginPlay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACharacterBase::BPPostBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPPostBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPPostSaveLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACharacterBase::BPPostSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPPostSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPRecall
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::BPRecall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPRecall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPSetFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           FacingTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPSetFacing(class AActor* FacingTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPSetFacing");

	Params::CharacterBase_BPSetFacing Parms{};

	Parms.FacingTarget = FacingTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPStopDialogue
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::BPStopDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPStopDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPStopMovement
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::BPStopMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPStopMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPTeleportToTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       InTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacterBase::BPTeleportToTransform(const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPTeleportToTransform");

	Params::CharacterBase_BPTeleportToTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPToggleDelayedLoot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bToggle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::BPToggleDelayedLoot(bool bToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPToggleDelayedLoot");

	Params::CharacterBase_BPToggleDelayedLoot Parms{};

	Parms.bToggle = bToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.CanPlayFallingAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::CanPlayFallingAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CanPlayFallingAnim");

	Params::CharacterBase_CanPlayFallingAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.CharacterDissolved
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::CharacterDissolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CharacterDissolved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.CharacterInitializationFinished
// (Event, Public, BlueprintEvent)

void ACharacterBase::CharacterInitializationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CharacterInitializationFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.CharacterRagdollFreezed
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::CharacterRagdollFreezed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CharacterRagdollFreezed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.CommandJump
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::CommandJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CommandJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.CommandStopJumping
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::CommandStopJumping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "CommandStopJumping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.EnableLevelSequenceAnimationOverlay
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::EnableLevelSequenceAnimationOverlay(const TArray<class AActor*>& Actors, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EnableLevelSequenceAnimationOverlay");

	Params::CharacterBase_EnableLevelSequenceAnimationOverlay Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.EventAICombatStateEnded
// (Event, Public, BlueprintEvent)

void ACharacterBase::EventAICombatStateEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EventAICombatStateEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.EventAICombatStateStarted
// (Event, Public, BlueprintEvent)

void ACharacterBase::EventAICombatStateStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EventAICombatStateStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.EventAILivingStarted
// (Event, Public, BlueprintEvent)

void ACharacterBase::EventAILivingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EventAILivingStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.EventOnTeleportEnd
// (Event, Public, BlueprintEvent)

void ACharacterBase::EventOnTeleportEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EventOnTeleportEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.EventOnTeleportStart
// (Event, Public, BlueprintEvent)

void ACharacterBase::EventOnTeleportStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "EventOnTeleportStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterBase.ForceMirrorRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MirrorRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::ForceMirrorRate(float MirrorRate, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "ForceMirrorRate");

	Params::CharacterBase_ForceMirrorRate Parms{};

	Parms.MirrorRate = MirrorRate;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.GetAbilityController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* ACharacterBase::GetAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetAbilityController");

	Params::CharacterBase_GetAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* ACharacterBase::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetAttributeContainer");

	Params::CharacterBase_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetGameCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGameCamera*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameCamera* ACharacterBase::GetGameCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetGameCamera");

	Params::CharacterBase_GetGameCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetHeroDistance
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACharacterBase::GetHeroDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetHeroDistance");

	Params::CharacterBase_GetHeroDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetHeroLookAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterBase::GetHeroLookAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetHeroLookAngle");

	Params::CharacterBase_GetHeroLookAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetStatusEffectController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffectController*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffectController* ACharacterBase::GetStatusEffectController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetStatusEffectController");

	Params::CharacterBase_GetStatusEffectController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.IsRooted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::IsRooted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "IsRooted");

	Params::CharacterBase_IsRooted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.IsWeaknessed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::IsWeaknessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "IsWeaknessed");

	Params::CharacterBase_IsWeaknessed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.LookHAxisBind
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::LookHAxisBind(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "LookHAxisBind");

	Params::CharacterBase_LookHAxisBind Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.LookVAxisBind
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::LookVAxisBind(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "LookVAxisBind");

	Params::CharacterBase_LookVAxisBind Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.LookVAxisBindMouseWheel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::LookVAxisBindMouseWheel(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "LookVAxisBindMouseWheel");

	Params::CharacterBase_LookVAxisBindMouseWheel Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.MAN_SetActorHiddenInGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::MAN_SetActorHiddenInGame(bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "MAN_SetActorHiddenInGame");

	Params::CharacterBase_MAN_SetActorHiddenInGame Parms{};

	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.MoveHorizontal
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::MoveHorizontal(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "MoveHorizontal");

	Params::CharacterBase_MoveHorizontal Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.MoveHorizontalJoystick
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::MoveHorizontalJoystick(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "MoveHorizontalJoystick");

	Params::CharacterBase_MoveHorizontalJoystick Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.MoveVertical
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::MoveVertical(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "MoveVertical");

	Params::CharacterBase_MoveVertical Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.MoveVerticalJoystick
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::MoveVerticalJoystick(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "MoveVerticalJoystick");

	Params::CharacterBase_MoveVerticalJoystick Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnBodyPartDissolved
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnBodyPartDissolved(class FName MaterialSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnBodyPartDissolved");

	Params::CharacterBase_OnBodyPartDissolved Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnDeathScreenFadeComplete
// (Native, Event, Public, BlueprintEvent)

void ACharacterBase::OnDeathScreenFadeComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnDeathScreenFadeComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnHitCameraShake
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class UGameCameraShake>     CameraShake                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnHitCameraShake(TSubclassOf<class UGameCameraShake> CameraShake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnHitCameraShake");

	Params::CharacterBase_OnHitCameraShake Parms{};

	Parms.CameraShake = CameraShake;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnLevelSequence
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       WorldTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   BlendInDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnLevelSequence(class ULevelSequence* LevelSequence, const struct FTransform& WorldTransform, float BlendInDuration, float BlendOutDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnLevelSequence");

	Params::CharacterBase_OnLevelSequence Parms{};

	Parms.LevelSequence = LevelSequence;
	Parms.WorldTransform = std::move(WorldTransform);
	Parms.BlendInDuration = BlendInDuration;
	Parms.BlendOutDuration = BlendOutDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnPlayLevelSequence
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FMovieSceneObjectBindingID>Bindings                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   BlendInDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnPlayLevelSequence(class ULevelSequence* LevelSequence, const TArray<class AActor*>& Actors, const TArray<struct FMovieSceneObjectBindingID>& Bindings, float BlendInDuration, float BlendOutDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnPlayLevelSequence");

	Params::CharacterBase_OnPlayLevelSequence Parms{};

	Parms.LevelSequence = LevelSequence;
	Parms.Actors = std::move(Actors);
	Parms.Bindings = std::move(Bindings);
	Parms.BlendInDuration = BlendInDuration;
	Parms.BlendOutDuration = BlendOutDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnRagdollStarted
// (Native, Event, Public, BlueprintEvent)

void ACharacterBase::OnRagdollStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnRagdollStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnTurnStarted
// (Native, Event, Public, BlueprintEvent)

void ACharacterBase::OnTurnStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnTurnStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnVfxAnimEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnVfxAnimEvent(class UAnimID* AnimID, EAnimEventType AnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnVfxAnimEvent");

	Params::CharacterBase_OnVfxAnimEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimEventType = AnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnVfxAnimStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnVfxAnimStarted(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnVfxAnimStarted");

	Params::CharacterBase_OnVfxAnimStarted Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnVfxAnimStopped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnVfxAnimStopped(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnVfxAnimStopped");

	Params::CharacterBase_OnVfxAnimStopped Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnVfxEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             VfxEventType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::OnVfxEvent(class FName VfxEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnVfxEvent");

	Params::CharacterBase_OnVfxEvent Parms{};

	Parms.VfxEventType = VfxEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.OnWakeUp
// (Native, Event, Public, BlueprintEvent)

void ACharacterBase::OnWakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "OnWakeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.RemoveFromGameCamera
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::RemoveFromGameCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "RemoveFromGameCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.ResetGroom
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::ResetGroom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "ResetGroom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetConversationLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetConversationLookTarget(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetConversationLookTarget");

	Params::CharacterBase_SetConversationLookTarget Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetCustomFace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCharacterSlot*             Face                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetCustomFace(class UCustomCharacterSlot* Face)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetCustomFace");

	Params::CharacterBase_SetCustomFace Parms{};

	Parms.Face = Face;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetCustomHairColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCharacterHairColor*        HairColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetCustomHairColor(class UCustomCharacterHairColor* HairColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetCustomHairColor");

	Params::CharacterBase_SetCustomHairColor Parms{};

	Parms.HairColor = HairColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetCustomHairStyle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCharacterSlot*             HairStyle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetCustomHairStyle(class UCustomCharacterSlot* HairStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetCustomHairStyle");

	Params::CharacterBase_SetCustomHairStyle Parms{};

	Parms.HairStyle = HairStyle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetCustomSkinColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCharacterSkinColor*        SkinColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetCustomSkinColor(class UCustomCharacterSkinColor* SkinColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetCustomSkinColor");

	Params::CharacterBase_SetCustomSkinColor Parms{};

	Parms.SkinColor = SkinColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetCustomTattoo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCharacterTattoo*           Tattoo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetCustomTattoo(class UCustomCharacterTattoo* Tattoo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetCustomTattoo");

	Params::CharacterBase_SetCustomTattoo Parms{};

	Parms.Tattoo = Tattoo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetLevelSequenceCombatMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCombatMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetLevelSequenceCombatMode(bool bCombatMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetLevelSequenceCombatMode");

	Params::CharacterBase_SetLevelSequenceCombatMode Parms{};

	Parms.bCombatMode = bCombatMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetLevelSequenceConversationAnimID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetLevelSequenceConversationAnimID(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetLevelSequenceConversationAnimID");

	Params::CharacterBase_SetLevelSequenceConversationAnimID Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetLevelSequenceFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CharacterFacing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetLevelSequenceFacing(float CharacterFacing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetLevelSequenceFacing");

	Params::CharacterBase_SetLevelSequenceFacing Parms{};

	Parms.CharacterFacing = CharacterFacing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetLevelSequenceMirrored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMirrored                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetLevelSequenceMirrored(bool bMirrored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetLevelSequenceMirrored");

	Params::CharacterBase_SetLevelSequenceMirrored Parms{};

	Parms.bMirrored = bMirrored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetLevelSequenceMirrorRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CharacterMirrorRate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetLevelSequenceMirrorRate(float CharacterMirrorRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetLevelSequenceMirrorRate");

	Params::CharacterBase_SetLevelSequenceMirrorRate Parms{};

	Parms.CharacterMirrorRate = CharacterMirrorRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetVisualSlotsLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLock                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetVisualSlotsLocked(bool bLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetVisualSlotsLocked");

	Params::CharacterBase_SetVisualSlotsLocked Parms{};

	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.SetVisualSlotVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCharacterVisualSlotInfo*         VisualSlots                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::SetVisualSlotVisible(class UCharacterVisualSlotInfo* VisualSlots, bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "SetVisualSlotVisible");

	Params::CharacterBase_SetVisualSlotVisible Parms{};

	Parms.VisualSlots = VisualSlots;
	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.StartRiseRagdoll
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacterBase::StartRiseRagdoll(const TArray<class FName>& BoneNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "StartRiseRagdoll");

	Params::CharacterBase_StartRiseRagdoll Parms{};

	Parms.BoneNames = std::move(BoneNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.StopRiseRagdoll
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacterBase::StopRiseRagdoll(const TArray<class FName>& BoneNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "StopRiseRagdoll");

	Params::CharacterBase_StopRiseRagdoll Parms{};

	Parms.BoneNames = std::move(BoneNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.ToggleAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::ToggleAnim(class UAnimID* AnimID, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "ToggleAnim");

	Params::CharacterBase_ToggleAnim Parms{};

	Parms.AnimID = AnimID;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.ToggleLevelSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::ToggleLevelSequence(const TArray<class AActor*>& Actors, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "ToggleLevelSequence");

	Params::CharacterBase_ToggleLevelSequence Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.UpdateFacingTransform
// (Final, Native, Public, BlueprintCallable)

void ACharacterBase::UpdateFacingTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "UpdateFacingTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.UseCharacterCreationBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCharacterCreationBody                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::UseCharacterCreationBody(bool bCharacterCreationBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "UseCharacterCreationBody");

	Params::CharacterBase_UseCharacterCreationBody Parms{};

	Parms.bCharacterCreationBody = bCharacterCreationBody;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.UseFemaleSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFemaleSlots                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterBase::UseFemaleSlots(bool bFemaleSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "UseFemaleSlots");

	Params::CharacterBase_UseFemaleSlots Parms{};

	Parms.bFemaleSlots = bFemaleSlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterBase.BPIsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterBase::BPIsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "BPIsAlive");

	Params::CharacterBase_BPIsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetLedgeCatchVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacterBase::GetLedgeCatchVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetLedgeCatchVelocity");

	Params::CharacterBase_GetLedgeCatchVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetNumSlotMeshComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACharacterBase::GetNumSlotMeshComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetNumSlotMeshComponents");

	Params::CharacterBase_GetNumSlotMeshComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetSlotMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SlotMeshComponentIndex                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACharacterBase::GetSlotMeshComponent(int32 SlotMeshComponentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetSlotMeshComponent");

	Params::CharacterBase_GetSlotMeshComponent Parms{};

	Parms.SlotMeshComponentIndex = SlotMeshComponentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterBase.GetSlotMeshComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class USkeletalMeshComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class USkeletalMeshComponent*> ACharacterBase::GetSlotMeshComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBase", "GetSlotMeshComponents");

	Params::CharacterBase_GetSlotMeshComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OnKillCaused_AbilityComponent.OnPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnKillCaused_AbilityComponent::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnKillCaused_AbilityComponent", "OnPostDamageCaused");

	Params::OnKillCaused_AbilityComponent_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OnDamageCaused_AbilityComponent.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOnDamageCaused_AbilityComponent::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnDamageCaused_AbilityComponent", "OnPreDamageCaused");

	Params::OnDamageCaused_AbilityComponent_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LootTableListDropAmount.GetEditorName
// (Final, Native, Protected)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULootTableListDropAmount::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootTableListDropAmount", "GetEditorName");

	Params::LootTableListDropAmount_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GrabPoint.BPOnGrabbed
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AHeroBase*                        Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGrabPoint::BPOnGrabbed(class AHeroBase* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrabPoint", "BPOnGrabbed");

	Params::GrabPoint_BPOnGrabbed Parms{};

	Parms.Hero = Hero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TriggerableAbility.BPGetAimAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTriggerableAbility::BPGetAimAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableAbility", "BPGetAimAngle");

	Params::TriggerableAbility_BPGetAimAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DivineHammersAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDivineHammersAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineHammersAbility", "PostDamageDealt");

	Params::DivineHammersAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PeriodicBulletTrapManager.ProjectileShot
// (Final, Native, Private)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPeriodicBulletTrapManager::ProjectileShot(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PeriodicBulletTrapManager", "ProjectileShot");

	Params::PeriodicBulletTrapManager_ProjectileShot Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ShiftingPlatform.BPOnDownState
// (Event, Public, BlueprintEvent)

void AShiftingPlatform::BPOnDownState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShiftingPlatform", "BPOnDownState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ShiftingPlatform.BPOnUpState
// (Event, Public, BlueprintEvent)

void AShiftingPlatform::BPOnUpState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShiftingPlatform", "BPOnUpState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ShiftingPlatform.BPOnWarning
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   TimeRemain                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FullWarningTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDownState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShiftingPlatform::BPOnWarning(float TimeRemain, float FullWarningTime, bool bUpState, bool bDownState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShiftingPlatform", "BPOnWarning");

	Params::ShiftingPlatform_BPOnWarning Parms{};

	Parms.TimeRemain = TimeRemain;
	Parms.FullWarningTime = FullWarningTime;
	Parms.bUpState = bUpState;
	Parms.bDownState = bDownState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ModifyAttributeWithAttribute.OnAttributeChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UModifyAttributeWithAttribute::OnAttributeChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeWithAttribute", "OnAttributeChanged");

	Params::ModifyAttributeWithAttribute_OnAttributeChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.ModifyAttributeAbilityComponent.OnAttributeChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UModifyAttributeAbilityComponent::OnAttributeChanged(EAttribute attribute_0, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "OnAttributeChanged");

	Params::ModifyAttributeAbilityComponent_OnAttributeChanged Parms{};

	Parms.attribute_0 = attribute_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.ModifyAttributeAbilityComponent.OnLanded
// (Final, Native, Public)

void UModifyAttributeAbilityComponent::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifyAttributeAbilityComponent.OnStackNumChanged
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   preValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UModifyAttributeAbilityComponent::OnStackNumChanged(class UAbilityBase* InAbility, int32 preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "OnStackNumChanged");

	Params::ModifyAttributeAbilityComponent_OnStackNumChanged Parms{};

	Parms.InAbility = InAbility;
	Parms.preValue = preValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifyAttributeAbilityComponent.OnStaggerOrStun
// (Final, Native, Public)

void UModifyAttributeAbilityComponent::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifyAttributeAbilityComponent.SetModifierAdd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMod                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UModifyAttributeAbilityComponent::SetModifierAdd(float NewMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "SetModifierAdd");

	Params::ModifyAttributeAbilityComponent_SetModifierAdd Parms{};

	Parms.NewMod = NewMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifyAttributeAbilityComponent.SetModifierMult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMod                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UModifyAttributeAbilityComponent::SetModifierMult(float NewMod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyAttributeAbilityComponent", "SetModifierMult");

	Params::ModifyAttributeAbilityComponent_SetModifierMult Parms{};

	Parms.NewMod = NewMod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ToggleBasicAttackHitSequence.OnItemsChanged
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToggleBasicAttackHitSequence::OnItemsChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToggleBasicAttackHitSequence", "OnItemsChanged");

	Params::ToggleBasicAttackHitSequence_OnItemsChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ToggleBasicAttackHitSequence.OnPostAddAbility
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     AddedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToggleBasicAttackHitSequence::OnPostAddAbility(class UAbilityBase* AddedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToggleBasicAttackHitSequence", "OnPostAddAbility");

	Params::ToggleBasicAttackHitSequence_OnPostAddAbility Parms{};

	Parms.AddedAbility = AddedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ToggleBasicAttackHitSequence.OnPostRemoveAbility
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     RemovedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToggleBasicAttackHitSequence::OnPostRemoveAbility(class UAbilityBase* RemovedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToggleBasicAttackHitSequence", "OnPostRemoveAbility");

	Params::ToggleBasicAttackHitSequence_OnPostRemoveAbility Parms{};

	Parms.RemovedAbility = RemovedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteDollsAI.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMarionetteDollsAI::OnPostDamageCaused(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteDollsAI", "OnPostDamageCaused");

	Params::MarionetteDollsAI_OnPostDamageCaused Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteDollsAI.OnPostDamageTaken
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMarionetteDollsAI::OnPostDamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteDollsAI", "OnPostDamageTaken");

	Params::MarionetteDollsAI_OnPostDamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteDollsAI.OnPreDamagedPriority
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UMarionetteDollsAI::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteDollsAI", "OnPreDamagedPriority");

	Params::MarionetteDollsAI_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ConversationStarter.StartConversationBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bKeepCutsceneMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ConversationName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationStarter::StartConversationBP(bool bKeepCutsceneMode, class FName ConversationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationStarter", "StartConversationBP");

	Params::ConversationStarter_StartConversationBP Parms{};

	Parms.bKeepCutsceneMode = bKeepCutsceneMode;
	Parms.ConversationName = ConversationName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.GetAchievements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManAchievements*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManAchievements* UManGameInstance::GetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "GetAchievements");

	Params::ManGameInstance_GetAchievements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.GetFadeManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFadeManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFadeManager* UManGameInstance::GetFadeManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "GetFadeManager");

	Params::ManGameInstance_GetFadeManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.InitializeAchievements
// (Final, Native, Public, BlueprintCallable)

void UManGameInstance::InitializeAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "InitializeAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.OnExitToDesktopFadeOutFinished
// (Final, Native, Private)

void UManGameInstance::OnExitToDesktopFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "OnExitToDesktopFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.OnExitToDesktopSaveInProgress
// (Final, Native, Private)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameInstance::OnExitToDesktopSaveInProgress(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "OnExitToDesktopSaveInProgress");

	Params::ManGameInstance_OnExitToDesktopSaveInProgress Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.OnExitToMainMenuFadeOutFinished
// (Final, Native, Private)

void UManGameInstance::OnExitToMainMenuFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "OnExitToMainMenuFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.OnExitToMainMenuSaveInProgress
// (Final, Native, Private)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameInstance::OnExitToMainMenuSaveInProgress(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "OnExitToMainMenuSaveInProgress");

	Params::ManGameInstance_OnExitToMainMenuSaveInProgress Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.ReloadDLCs
// (Final, Native, Public)

void UManGameInstance::ReloadDLCs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "ReloadDLCs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.StartLoadingToMainMenu
// (Final, Native, Private)

void UManGameInstance::StartLoadingToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "StartLoadingToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameInstance.GetInputDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputDisplay                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputDisplay UManGameInstance::GetInputDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "GetInputDisplay");

	Params::ManGameInstance_GetInputDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.IsConsoleActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameInstance::IsConsoleActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "IsConsoleActive");

	Params::ManGameInstance_IsConsoleActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.IsFadeManagerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameInstance::IsFadeManagerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "IsFadeManagerActive");

	Params::ManGameInstance_IsFadeManagerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.IsKeyboardInputDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameInstance::IsKeyboardInputDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "IsKeyboardInputDisplay");

	Params::ManGameInstance_IsKeyboardInputDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameInstance.IsMouseInputDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameInstance::IsMouseInputDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManGameInstance", "IsMouseInputDisplay");

	Params::ManGameInstance_IsMouseInputDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BanditBruteBossAttackBomb.BPGetSmokeBombImpactLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBanditBruteBossAttackBomb::BPGetSmokeBombImpactLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BanditBruteBossAttackBomb", "BPGetSmokeBombImpactLocation");

	Params::BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeUserWidget.HideAttributeSelector
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bPlayAkEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideByUnlockVFX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::HideAttributeSelector(bool bPlayAkEvent, bool bPlayAnim, bool bHideByUnlockVFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "HideAttributeSelector");

	Params::SkillTreeUserWidget_HideAttributeSelector Parms{};

	Parms.bPlayAkEvent = bPlayAkEvent;
	Parms.bPlayAnim = bPlayAnim;
	Parms.bHideByUnlockVFX = bHideByUnlockVFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.JumpToNextPanel
// (Final, Native, Protected, BlueprintCallable)

void USkillTreeUserWidget::JumpToNextPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "JumpToNextPanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.JumpToPreviousPanel
// (Final, Native, Protected, BlueprintCallable)

void USkillTreeUserWidget::JumpToPreviousPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "JumpToPreviousPanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.OnHideAttributeSelector
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPlayAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnHideAttributeSelector(bool bPlayAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnHideAttributeSelector");

	Params::SkillTreeUserWidget_OnHideAttributeSelector Parms{};

	Parms.bPlayAnim = bPlayAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnPropertyChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnPropertyChanged");

	Params::SkillTreeUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnSetAttributeSelector
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             BonusText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPlayBonusUnlockedAnim                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllUnlocked                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnSetAttributeSelector(const class FText& BonusText, bool bPlayBonusUnlockedAnim, bool bAllUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnSetAttributeSelector");

	Params::SkillTreeUserWidget_OnSetAttributeSelector Parms{};

	Parms.BonusText = std::move(BonusText);
	Parms.bPlayBonusUnlockedAnim = bPlayBonusUnlockedAnim;
	Parms.bAllUnlocked = bAllUnlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnSetCharacterClassName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             CharacterClassName                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnSetCharacterClassName(const class FText& CharacterClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnSetCharacterClassName");

	Params::SkillTreeUserWidget_OnSetCharacterClassName Parms{};

	Parms.CharacterClassName = std::move(CharacterClassName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnSetTooltipPosition
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESkillTreeTooltipPosition               TooltipPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnSetTooltipPosition(ESkillTreeTooltipPosition TooltipPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnSetTooltipPosition");

	Params::SkillTreeUserWidget_OnSetTooltipPosition Parms{};

	Parms.TooltipPosition = TooltipPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnShowAttributeSelector
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NodeNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnShowAttributeSelector(int32 NodeNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnShowAttributeSelector");

	Params::SkillTreeUserWidget_OnShowAttributeSelector Parms{};

	Parms.NodeNum = NodeNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnShowPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   InAnimDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             CharacterClassName                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkillTreeClassUserWidget*        InCurrentSkillTreeClass                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkillTreeClassUserWidget*        InNextSkillTreeClass                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkillTreeClassUserWidget*        InPrevSkillTreeClass                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::OnShowPanel(float InAnimDuration, const class FText& CharacterClassName, class USkillTreeClassUserWidget* InCurrentSkillTreeClass, class USkillTreeClassUserWidget* InNextSkillTreeClass, class USkillTreeClassUserWidget* InPrevSkillTreeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnShowPanel");

	Params::SkillTreeUserWidget_OnShowPanel Parms{};

	Parms.InAnimDuration = InAnimDuration;
	Parms.CharacterClassName = std::move(CharacterClassName);
	Parms.InCurrentSkillTreeClass = InCurrentSkillTreeClass;
	Parms.InNextSkillTreeClass = InNextSkillTreeClass;
	Parms.InPrevSkillTreeClass = InPrevSkillTreeClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeUserWidget.OnShowPanelAnimFinished
// (Event, Protected, BlueprintEvent)

void USkillTreeUserWidget::OnShowPanelAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "OnShowPanelAnimFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeUserWidget.PropertyChanged
// (Final, Native, Protected)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "PropertyChanged");

	Params::SkillTreeUserWidget_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.ShowAttributeSelector
// (Final, Native, Protected, BlueprintCallable)

void USkillTreeUserWidget::ShowAttributeSelector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "ShowAttributeSelector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.ShowPanel
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterClass                         CharacterClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedFocusOnClassStart                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeUserWidget::ShowPanel(float AnimDuration, ECharacterClass CharacterClass, bool bNeedFocusOnClassStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "ShowPanel");

	Params::SkillTreeUserWidget_ShowPanel Parms{};

	Parms.AnimDuration = AnimDuration;
	Parms.CharacterClass = CharacterClass;
	Parms.bNeedFocusOnClassStart = bNeedFocusOnClassStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeUserWidget.IsAttributeSelectorVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillTreeUserWidget::IsAttributeSelectorVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "IsAttributeSelectorVisible");

	Params::SkillTreeUserWidget_IsAttributeSelectorVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeUserWidget.IsPlayingUnlockVFX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillTreeUserWidget::IsPlayingUnlockVFX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeUserWidget", "IsPlayingUnlockVFX");

	Params::SkillTreeUserWidget_IsPlayingUnlockVFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StackingDamageComponent.OnPreDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UStackingDamageComponent::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackingDamageComponent", "OnPreDamageCaused");

	Params::StackingDamageComponent_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LyMaCallCultistsAbility.OnCultistKilled
// (Final, Native, Public)
// Parameters:
// class UObject*                          Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               KillerAbilityController                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyMaCallCultistsAbility::OnCultistKilled(class UObject* Killer, class UAbilityController* KillerAbilityController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyMaCallCultistsAbility", "OnCultistKilled");

	Params::LyMaCallCultistsAbility_OnCultistKilled Parms{};

	Parms.Killer = Killer;
	Parms.KillerAbilityController = KillerAbilityController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DamageIncreaseByNearbyEnemies.OnPreDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDamageIncreaseByNearbyEnemies::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageIncreaseByNearbyEnemies", "OnPreDamageCaused");

	Params::DamageIncreaseByNearbyEnemies_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.WeaponExpertComponent.OnItemsChanged
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponExpertComponent::OnItemsChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponExpertComponent", "OnItemsChanged");

	Params::WeaponExpertComponent_OnItemsChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManHUD.DrawDebugLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   StartScreenX                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartScreenY                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndScreenX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndScreenY                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManHUD::DrawDebugLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManHUD", "DrawDebugLine");

	Params::ManHUD_DrawDebugLine Parms{};

	Parms.StartScreenX = StartScreenX;
	Parms.StartScreenY = StartScreenY;
	Parms.EndScreenX = EndScreenX;
	Parms.EndScreenY = EndScreenY;
	Parms.LineColor = std::move(LineColor);
	Parms.LineThickness = LineThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManHUD.DrawDebugRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     RectColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenH                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManHUD::DrawDebugRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManHUD", "DrawDebugRect");

	Params::ManHUD_DrawDebugRect Parms{};

	Parms.RectColor = std::move(RectColor);
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManHUD.DrawDebugText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                            Font                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManHUD::DrawDebugText(const class FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManHUD", "DrawDebugText");

	Params::ManHUD_DrawDebugText Parms{};

	Parms.Text = std::move(Text);
	Parms.TextColor = std::move(TextColor);
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.Font = Font;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnchantItemsComponent.OnItemsChanged
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnchantItemsComponent::OnItemsChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnchantItemsComponent", "OnItemsChanged");

	Params::EnchantItemsComponent_OnItemsChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnchantItemsComponent.OnRemoveItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RemovedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnchantItemsComponent::OnRemoveItem(class UInventorySlot* InventorySlot, class UItemAbility* RemovedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnchantItemsComponent", "OnRemoveItem");

	Params::EnchantItemsComponent_OnRemoveItem Parms{};

	Parms.InventorySlot = InventorySlot;
	Parms.RemovedItem = RemovedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FangExecutionerBloodVial.OnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFangExecutionerBloodVial::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FangExecutionerBloodVial", "OnPostDamaged");

	Params::FangExecutionerBloodVial_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManSlotUserWidgetBase.GetParentManUserWidgetBase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UManSlotUserWidgetBase::GetParentManUserWidgetBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "GetParentManUserWidgetBase");

	Params::ManSlotUserWidgetBase_GetParentManUserWidgetBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManSlotUserWidgetBase.IsParentVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManSlotUserWidgetBase::IsParentVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "IsParentVisible");

	Params::ManSlotUserWidgetBase_IsParentVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManSlotUserWidgetBase.OnFocused
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManSlotUserWidgetBase::OnFocused(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "OnFocused");

	Params::ManSlotUserWidgetBase_OnFocused Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManSlotUserWidgetBase.OnHighlighted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManSlotUserWidgetBase::OnHighlighted(bool bHighlighted, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "OnHighlighted");

	Params::ManSlotUserWidgetBase_OnHighlighted Parms{};

	Parms.bHighlighted = bHighlighted;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManSlotUserWidgetBase.OnMouseDown
// (Event, Protected, BlueprintEvent)

void UManSlotUserWidgetBase::OnMouseDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "OnMouseDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManSlotUserWidgetBase.OnMouseUp
// (Event, Public, BlueprintEvent)

void UManSlotUserWidgetBase::OnMouseUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "OnMouseUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManSlotUserWidgetBase.OnUnfocused
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManSlotUserWidgetBase::OnUnfocused(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "OnUnfocused");

	Params::ManSlotUserWidgetBase_OnUnfocused Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManSlotUserWidgetBase.IsFocused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManSlotUserWidgetBase::IsFocused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSlotUserWidgetBase", "IsFocused");

	Params::ManSlotUserWidgetBase_IsFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeNodeUserWidget.OnLearnFinished
// (Event, Public, BlueprintEvent)

void USkillTreeNodeUserWidget::OnLearnFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnLearnFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeNodeUserWidget.OnLearnStart
// (Event, Public, BlueprintEvent)

void USkillTreeNodeUserWidget::OnLearnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnLearnStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeNodeUserWidget.OnLearnStop
// (Event, Public, BlueprintEvent)

void USkillTreeNodeUserWidget::OnLearnStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnLearnStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeNodeUserWidget.OnSetLearnedUpgrades
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<EAttribute>                      UnlockedAttributes                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkillTreeNodeUserWidget::OnSetLearnedUpgrades(const TArray<EAttribute>& UnlockedAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnSetLearnedUpgrades");

	Params::SkillTreeNodeUserWidget_OnSetLearnedUpgrades Parms{};

	Parms.UnlockedAttributes = std::move(UnlockedAttributes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeNodeUserWidget.OnSetLocked
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAkAudioEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeNodeUserWidget::OnSetLocked(bool bInLocked, bool bPlayAkAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnSetLocked");

	Params::SkillTreeNodeUserWidget_OnSetLocked Parms{};

	Parms.bInLocked = bInLocked;
	Parms.bPlayAkAudioEvent = bPlayAkAudioEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeNodeUserWidget.OnSetNode
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NodeName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       NodeIcon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeNodeUserWidget::OnSetNode(const class FText& NodeName, class UTexture2D* NodeIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnSetNode");

	Params::SkillTreeNodeUserWidget_OnSetNode Parms{};

	Parms.NodeName = std::move(NodeName);
	Parms.NodeIcon = NodeIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeNodeUserWidget.OnSetState
// (Event, Public, BlueprintEvent)

void USkillTreeNodeUserWidget::OnSetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "OnSetState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeNodeUserWidget.SetState
// (Final, Native, Public)

void USkillTreeNodeUserWidget::SetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "SetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeNodeUserWidget.GetNodeRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterClass                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterClass USkillTreeNodeUserWidget::GetNodeRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeNodeUserWidget", "GetNodeRegion");

	Params::SkillTreeNodeUserWidget_GetNodeRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InterpolComponentNode.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UInterpolComponentNode::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterpolComponentNode", "GetEditorName");

	Params::InterpolComponentNode_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BladeDanceAbility.GetCurrentCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBladeDanceAbility::GetCurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BladeDanceAbility", "GetCurrentCharge");

	Params::BladeDanceAbility_GetCurrentCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BladeDanceAbility.GetMaxCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBladeDanceAbility::GetMaxCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BladeDanceAbility", "GetMaxCharge");

	Params::BladeDanceAbility_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BladeDanceAbility.ResourceUsed
// (Final, Native, Public)
// Parameters:
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBladeDanceAbility::ResourceUsed(int32 amount, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BladeDanceAbility", "ResourceUsed");

	Params::BladeDanceAbility_ResourceUsed Parms{};

	Parms.amount = amount;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifyDamageTakenAbilityComponent.OnPreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UModifyDamageTakenAbilityComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyDamageTakenAbilityComponent", "OnPreDamaged");

	Params::ModifyDamageTakenAbilityComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ModifyDamageDoneAbilityComponent.OnPreDamageCaused
// (Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UModifyDamageDoneAbilityComponent::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifyDamageDoneAbilityComponent", "OnPreDamageCaused");

	Params::ModifyDamageDoneAbilityComponent_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AbilitySlotUserWidget.OnFilterChanged
// (Event, Public, BlueprintEvent)

void UAbilitySlotUserWidget::OnFilterChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnFilterChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.AbilitySlotUserWidget.OnPlayLearnAbilityAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPlayAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnPlayLearnAbilityAnim(bool bPlayAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnPlayLearnAbilityAnim");

	Params::AbilitySlotUserWidget_OnPlayLearnAbilityAnim Parms{};

	Parms.bPlayAnim = bPlayAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnSetEquips
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAbilitySet1Contain                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbilitySet2Contain                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnSetEquips(bool bAbilitySet1Contain, bool bAbilitySet2Contain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnSetEquips");

	Params::AbilitySlotUserWidget_OnSetEquips Parms{};

	Parms.bAbilitySet1Contain = bAbilitySet1Contain;
	Parms.bAbilitySet2Contain = bAbilitySet2Contain;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnSetSlot
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGhostIcon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnSetSlot(const class UTexture2D* InIcon, bool bGhostIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnSetSlot");

	Params::AbilitySlotUserWidget_OnSetSlot Parms{};

	Parms.InIcon = InIcon;
	Parms.bGhostIcon = bGhostIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnSetUpgrades
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InMaxUpgrades                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLearnedUpgrades                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnSetUpgrades(int32 InMaxUpgrades, int32 InLearnedUpgrades)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnSetUpgrades");

	Params::AbilitySlotUserWidget_OnSetUpgrades Parms{};

	Parms.InMaxUpgrades = InMaxUpgrades;
	Parms.InLearnedUpgrades = InLearnedUpgrades;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleActive");

	Params::AbilitySlotUserWidget_OnToggleActive Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleCrossHighlight
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCrossHighlight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleCrossHighlight(bool bCrossHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleCrossHighlight");

	Params::AbilitySlotUserWidget_OnToggleCrossHighlight Parms{};

	Parms.bCrossHighlight = bCrossHighlight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleEquipped
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleEquipped(bool bEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleEquipped");

	Params::AbilitySlotUserWidget_OnToggleEquipped Parms{};

	Parms.bEquipped = bEquipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleEquipState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEquipState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleEquipState(bool bEquipState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleEquipState");

	Params::AbilitySlotUserWidget_OnToggleEquipState Parms{};

	Parms.bEquipState = bEquipState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleLocked
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             LockedLevel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleLocked(bool bLocked, const class FText& LockedLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleLocked");

	Params::AbilitySlotUserWidget_OnToggleLocked Parms{};

	Parms.bLocked = bLocked;
	Parms.LockedLevel = std::move(LockedLevel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleSelected(bool bSelected, bool bPlayAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleSelected");

	Params::AbilitySlotUserWidget_OnToggleSelected Parms{};

	Parms.bSelected = bSelected;
	Parms.bPlayAnim = bPlayAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleSwapped
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSwapped                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleSwapped(bool bSwapped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleSwapped");

	Params::AbilitySlotUserWidget_OnToggleSwapped Parms{};

	Parms.bSwapped = bSwapped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilitySlotUserWidget.OnToggleUnknown
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUnknown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySlotUserWidget::OnToggleUnknown(bool bUnknown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySlotUserWidget", "OnToggleUnknown");

	Params::AbilitySlotUserWidget_OnToggleUnknown Parms{};

	Parms.bUnknown = bUnknown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HoldAnim.OnHitEvent
// (Final, Native, Public)
// Parameters:
// class ACharacterBase*                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterBase*                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          InAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHoldAnim::OnHitEvent(class ACharacterBase* Source, class ACharacterBase* Target, class UAbilityBase* InAbility, class UAnimID* InAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldAnim", "OnHitEvent");

	Params::HoldAnim_OnHitEvent Parms{};

	Parms.Source = Source;
	Parms.Target = Target;
	Parms.InAbility = InAbility;
	Parms.InAnim = InAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConcetrationSkillController.DamageTaken
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConcetrationSkillController::DamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcetrationSkillController", "DamageTaken");

	Params::ConcetrationSkillController_DamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GroundSlamAbility.OnGameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundSlamAbility::OnGameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundSlamAbility", "OnGameplayEvent");

	Params::GroundSlamAbility_OnGameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GroundSlamAbility.PreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UGroundSlamAbility::PreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundSlamAbility", "PreDamaged");

	Params::GroundSlamAbility_PreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.SkillTreeManager.OnRemoveItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RemovedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeManager::OnRemoveItem(class UInventorySlot* InventorySlot, class UItemAbility* RemovedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeManager", "OnRemoveItem");

	Params::SkillTreeManager_OnRemoveItem Parms{};

	Parms.InventorySlot = InventorySlot;
	Parms.RemovedItem = RemovedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeManager.OnUpdateItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeManager::OnUpdateItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeManager", "OnUpdateItem");

	Params::SkillTreeManager_OnUpdateItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillTreeManager.UnlockAllNodesForUnlockedStartNodes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillTreeManager::UnlockAllNodesForUnlockedStartNodes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeManager", "UnlockAllNodesForUnlockedStartNodes");

	Params::SkillTreeManager_UnlockAllNodesForUnlockedStartNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeManager.UnlockNodeByID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UPrimalSkillTree>  InSkillTree                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUnlock                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillTreeManager::UnlockNodeByID(TSoftObjectPtr<class UPrimalSkillTree> InSkillTree, int32 ID, bool bForceUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeManager", "UnlockNodeByID");

	Params::SkillTreeManager_UnlockNodeByID Parms{};

	Parms.InSkillTree = InSkillTree;
	Parms.ID = ID;
	Parms.bForceUnlock = bForceUnlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeManager.UnlockNodeByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UPrimalSkillTree>  InSkillTree                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NodeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUnlock                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillTreeManager::UnlockNodeByName(TSoftObjectPtr<class UPrimalSkillTree> InSkillTree, const class FString& NodeName, bool bForceUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeManager", "UnlockNodeByName");

	Params::SkillTreeManager_UnlockNodeByName Parms{};

	Parms.InSkillTree = InSkillTree;
	Parms.NodeName = std::move(NodeName);
	Parms.bForceUnlock = bForceUnlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ForceParryAbilityComponent.OnPreDamagedPriority
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UForceParryAbilityComponent::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForceParryAbilityComponent", "OnPreDamagedPriority");

	Params::ForceParryAbilityComponent_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.DynamicPlatformBox.OnKillStateChanged
// (Final, Native, Public)

void UDynamicPlatformBox::OnKillStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicPlatformBox", "OnKillStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.DoApply
// (Final, Native, Protected, BlueprintCallable)

void UOptionsUserWidgetBase::DoApply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "DoApply");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.DoClose
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsUserWidgetBase::DoClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "DoClose");

	Params::OptionsUserWidgetBase_DoClose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsUserWidgetBase.DoResetToDefault
// (Final, Native, Protected, BlueprintCallable)

void UOptionsUserWidgetBase::DoResetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "DoResetToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.OnDialogueResetToDefault
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnDialogueResetToDefault(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnDialogueResetToDefault");

	Params::OptionsUserWidgetBase_OnDialogueResetToDefault Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.OnDialogueSaveChangesResult
// (Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnDialogueSaveChangesResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnDialogueSaveChangesResult");

	Params::OptionsUserWidgetBase_OnDialogueSaveChangesResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.OnSelectorValueChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionsType                            OptionsType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnSelectorValueChanged(EOptionsType OptionsType, int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnSelectorValueChanged");

	Params::OptionsUserWidgetBase_OnSelectorValueChanged Parms{};

	Parms.OptionsType = OptionsType;
	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.OnSetDescription
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnSetDescription(const class FText& InDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnSetDescription");

	Params::OptionsUserWidgetBase_OnSetDescription Parms{};

	Parms.InDescription = std::move(InDescription);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsUserWidgetBase.OnSliderValueChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionsType                            OptionsType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnSliderValueChanged(EOptionsType OptionsType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnSliderValueChanged");

	Params::OptionsUserWidgetBase_OnSliderValueChanged Parms{};

	Parms.OptionsType = OptionsType;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.OnUserInterfaceScaleChanged
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::OnUserInterfaceScaleChanged(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "OnUserInterfaceScaleChanged");

	Params::OptionsUserWidgetBase_OnUserInterfaceScaleChanged Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsUserWidgetBase.RequestTab
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ETabButtonType                          TabButtonType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsUserWidgetBase::RequestTab(ETabButtonType TabButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsUserWidgetBase", "RequestTab");

	Params::OptionsUserWidgetBase_RequestTab Parms{};

	Parms.TabButtonType = TabButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsControllerUserWidget.OnDoubleJumpUnlock
// (Event, Protected, BlueprintEvent)

void UOptionsControllerUserWidget::OnDoubleJumpUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControllerUserWidget", "OnDoubleJumpUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsControllerUserWidget.OnGlideUnlock
// (Event, Protected, BlueprintEvent)

void UOptionsControllerUserWidget::OnGlideUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControllerUserWidget", "OnGlideUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsControllerUserWidget.OnGrapplingHookUnlock
// (Event, Protected, BlueprintEvent)

void UOptionsControllerUserWidget::OnGrapplingHookUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControllerUserWidget", "OnGrapplingHookUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsControllerUserWidget.OnGroundSlamUnlock
// (Event, Protected, BlueprintEvent)

void UOptionsControllerUserWidget::OnGroundSlamUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControllerUserWidget", "OnGroundSlamUnlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsControllerUserWidget.OnSetQuickUseDefault
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bQuickUseDefault                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControllerUserWidget::OnSetQuickUseDefault(bool bQuickUseDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControllerUserWidget", "OnSetQuickUseDefault");

	Params::OptionsControllerUserWidget_OnSetQuickUseDefault Parms{};

	Parms.bQuickUseDefault = bQuickUseDefault;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AddAbility_AbilityComponent.DamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAddAbility_AbilityComponent::DamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AddAbility_AbilityComponent", "DamageTaken");

	Params::AddAbility_AbilityComponent_DamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AirAI.DamageTaken
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAirAI::DamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirAI", "DamageTaken");

	Params::AirAI_DamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AirAI.OnTargetPositionReached
// (Native, Protected)
// Parameters:
// bool                                    AirMoveInterrupted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAirAI::OnTargetPositionReached(bool AirMoveInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirAI", "OnTargetPositionReached");

	Params::AirAI_OnTargetPositionReached Parms{};

	Parms.AirMoveInterrupted = AirMoveInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MeleeAirAI.OnPostDamageDone
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMeleeAirAI::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeAirAI", "OnPostDamageDone");

	Params::MeleeAirAI_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PlayAnim_AbilityComponent.OnAbilityAnimReplaced
// (Final, Native, Public)
// Parameters:
// class UAnimID*                          SrcAnimId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          DestAnimId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReplacerObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayAnim_AbilityComponent::OnAbilityAnimReplaced(class UAnimID* SrcAnimId, class UAnimID* DestAnimId, class UObject* ReplacerObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayAnim_AbilityComponent", "OnAbilityAnimReplaced");

	Params::PlayAnim_AbilityComponent_OnAbilityAnimReplaced Parms{};

	Parms.SrcAnimId = SrcAnimId;
	Parms.DestAnimId = DestAnimId;
	Parms.ReplacerObject = ReplacerObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerBashConditionComponent.DamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBrawlerBashConditionComponent::DamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerBashConditionComponent", "DamageTaken");

	Params::BrawlerBashConditionComponent_DamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerBashConditionComponent.ParryEvent
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerBashConditionComponent::ParryEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerBashConditionComponent", "ParryEvent");

	Params::BrawlerBashConditionComponent_ParryEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FangCultistPriestessAI.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFangCultistPriestessAI::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FangCultistPriestessAI", "IsCollideSignature");

	Params::FangCultistPriestessAI_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.WarriorsMight.OnConstitutionChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWarriorsMight::OnConstitutionChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarriorsMight", "OnConstitutionChanged");

	Params::WarriorsMight_OnConstitutionChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.WarriorsMight.OnDefenseChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWarriorsMight::OnDefenseChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarriorsMight", "OnDefenseChanged");

	Params::WarriorsMight_OnDefenseChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.LevelTransitionUserWidget.OnShowWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelTransitionUserWidget::OnShowWidget(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionUserWidget", "OnShowWidget");

	Params::LevelTransitionUserWidget_OnShowWidget Parms{};

	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityConditionAbilityComponent.OnLanded
// (Final, Native, Public)

void UAbilityConditionAbilityComponent::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityConditionAbilityComponent", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnUserInput.OnUserInput
// (Final, Native, Private)
// Parameters:
// int32                                   InputCommandNum                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnUserInput::OnUserInput(int32 InputCommandNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnUserInput", "OnUserInput");

	Params::CustomEventOnUserInput_OnUserInput Parms{};

	Parms.InputCommandNum = InputCommandNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManProjectile.GetImpactSurfaceNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AManProjectile::GetImpactSurfaceNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "GetImpactSurfaceNormal");

	Params::ManProjectile_GetImpactSurfaceNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.GetKillerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AManProjectile::GetKillerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "GetKillerActor");

	Params::ManProjectile_GetKillerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.GetKillerDamageType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDamageType AManProjectile::GetKillerDamageType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "GetKillerDamageType");

	Params::ManProjectile_GetKillerDamageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.GetProjectileVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AManProjectile::GetProjectileVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "GetProjectileVelocity");

	Params::ManProjectile_GetProjectileVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.GetTargetExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AManProjectile::GetTargetExtent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "GetTargetExtent");

	Params::ManProjectile_GetTargetExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.HasImpactSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AManProjectile::HasImpactSurface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "HasImpactSurface");

	Params::ManProjectile_HasImpactSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.IsParried
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AManProjectile::IsParried()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "IsParried");

	Params::ManProjectile_IsParried Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManProjectile.OnStaticObjectPostCollide
// (Native, Public)
// Parameters:
// TArray<struct FHitResult>               HitResult                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AManProjectile::OnStaticObjectPostCollide(const TArray<struct FHitResult>& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "OnStaticObjectPostCollide");

	Params::ManProjectile_OnStaticObjectPostCollide Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManProjectile.OnStaticObjectPreCollide
// (Native, Public, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               HitResult                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AManProjectile::OnStaticObjectPreCollide(TArray<struct FHitResult>* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManProjectile", "OnStaticObjectPreCollide");

	Params::ManProjectile_OnStaticObjectPreCollide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);
}


// Function man.MotesOfChaosPassive.AbilityChaos
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotesOfChaosPassive::AbilityChaos(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "AbilityChaos");

	Params::MotesOfChaosPassive_AbilityChaos Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.AbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotesOfChaosPassive::AbilityStarted(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "AbilityStarted");

	Params::MotesOfChaosPassive_AbilityStarted Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.DamageCasued
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMotesOfChaosPassive::DamageCasued(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "DamageCasued");

	Params::MotesOfChaosPassive_DamageCasued Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.MoteStaticCollide
// (Final, Native, Public, BlueprintCallable)

void UMotesOfChaosPassive::MoteStaticCollide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "MoteStaticCollide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.ResourceUsed
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotesOfChaosPassive::ResourceUsed(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "ResourceUsed");

	Params::MotesOfChaosPassive_ResourceUsed Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.StatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotesOfChaosPassive::StatusEffectCaused(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "StatusEffectCaused");

	Params::MotesOfChaosPassive_StatusEffectCaused Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MotesOfChaosPassive.WorldReset
// (Final, Native, Public)

void UMotesOfChaosPassive::WorldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotesOfChaosPassive", "WorldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FinishEm.OnAbilityEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     EndedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinishEm::OnAbilityEnded(class UAbilityBase* EndedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinishEm", "OnAbilityEnded");

	Params::FinishEm_OnAbilityEnded Parms{};

	Parms.EndedAbility = EndedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FinishEm.OnPostAbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinishEm::OnPostAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinishEm", "OnPostAbilityStarted");

	Params::FinishEm_OnPostAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WildFire.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UWildFire::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WildFire", "OnPreDamageCaused");

	Params::WildFire_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AddAbilityInAreaComponent.GetDamageHBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UAddAbilityInAreaComponent::GetDamageHBounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AddAbilityInAreaComponent", "GetDamageHBounds");

	Params::AddAbilityInAreaComponent_GetDamageHBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MomentumPassive.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMomentumPassive::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MomentumPassive", "PostDamageDealt");

	Params::MomentumPassive_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpellPenetration.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USpellPenetration::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellPenetration", "OnPreDamageCaused");

	Params::SpellPenetration_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ManTriggerVolumePureBase.OnBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManTriggerVolumePureBase::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTriggerVolumePureBase", "OnBeginOverlap");

	Params::ManTriggerVolumePureBase_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManTriggerVolumePureBase.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManTriggerVolumePureBase::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTriggerVolumePureBase", "OnEndOverlap");

	Params::ManTriggerVolumePureBase_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManTriggerVolumePureBase.OnMatchHasStarted
// (Final, Native, Public)

void AManTriggerVolumePureBase::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTriggerVolumePureBase", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandrakeRootAbility.BPTeleport
// (Final, Native, Public, BlueprintCallable)

void UMandrakeRootAbility::BPTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandrakeRootAbility", "BPTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelUpWindowUserWidget.DecreaseLevel
// (Final, Native, Protected, BlueprintCallable)

void ULevelUpWindowUserWidget::DecreaseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "DecreaseLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelUpWindowUserWidget.IncreaseLevel
// (Final, Native, Protected, BlueprintCallable)

void ULevelUpWindowUserWidget::IncreaseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "IncreaseLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelUpWindowUserWidget.LevelUpAnimFinished
// (Final, Native, Protected, BlueprintCallable)

void ULevelUpWindowUserWidget::LevelUpAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "LevelUpAnimFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelUpWindowUserWidget.OnDecreaseLevel
// (Event, Protected, BlueprintEvent)

void ULevelUpWindowUserWidget::OnDecreaseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "OnDecreaseLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.LevelUpWindowUserWidget.OnIncreaseLevel
// (Event, Protected, BlueprintEvent)

void ULevelUpWindowUserWidget::OnIncreaseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "OnIncreaseLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.LevelUpWindowUserWidget.OnLevelUp
// (Event, Protected, BlueprintEvent)

void ULevelUpWindowUserWidget::OnLevelUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "OnLevelUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.LevelUpWindowUserWidget.OnSetDefaultLevelDiff
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InDefaultLevelDiff                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpWindowUserWidget::OnSetDefaultLevelDiff(int32 InDefaultLevelDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "OnSetDefaultLevelDiff");

	Params::LevelUpWindowUserWidget_OnSetDefaultLevelDiff Parms{};

	Parms.InDefaultLevelDiff = InDefaultLevelDiff;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.LevelUpWindowUserWidget.OnSetMaxLevelText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InMaxLevelText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULevelUpWindowUserWidget::OnSetMaxLevelText(const class FText& InMaxLevelText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpWindowUserWidget", "OnSetMaxLevelText");

	Params::LevelUpWindowUserWidget_OnSetMaxLevelText Parms{};

	Parms.InMaxLevelText = std::move(InMaxLevelText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.DialogueActor.OnLevelsChanged
// (Final, Native, Public)

void ADialogueActor::OnLevelsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueActor", "OnLevelsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DialogueActor.OnTriggerVolumeOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADialogueActor::OnTriggerVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueActor", "OnTriggerVolumeOverlap");

	Params::DialogueActor_OnTriggerVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeatingUpEffect.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UHeatingUpEffect::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeatingUpEffect", "OnPreDamageCaused");

	Params::HeatingUpEffect_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.MapExplorationGridVolume.OnMapGridVolumeBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapExplorationGridVolume::OnMapGridVolumeBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapExplorationGridVolume", "OnMapGridVolumeBeginOverlap");

	Params::MapExplorationGridVolume_OnMapGridVolumeBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AdditionalDamageOnDamageDone.OnPostDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAdditionalDamageOnDamageDone::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdditionalDamageOnDamageDone", "OnPostDamageCaused");

	Params::AdditionalDamageOnDamageDone_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AdditionalDamageOnDamageDone.OnPostDamageCausedGroupFinished
// (Final, Native, Private)
// Parameters:
// int32                                   DamageGroupID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDamageValue>             DamageValues                                           (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAdditionalDamageOnDamageDone::OnPostDamageCausedGroupFinished(int32 DamageGroupID, class AActor* Source, class AActor* Target, const TArray<struct FDamageValue>& DamageValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdditionalDamageOnDamageDone", "OnPostDamageCausedGroupFinished");

	Params::AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished Parms{};

	Parms.DamageGroupID = DamageGroupID;
	Parms.Source = Source;
	Parms.Target = Target;
	Parms.DamageValues = std::move(DamageValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BearTrapHazard.BPKillEvent
// (Native, Event, Public, BlueprintEvent)

void UBearTrapHazard::BPKillEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BearTrapHazard", "BPKillEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BearTrapHazard.BPRespawned
// (Native, Event, Public, BlueprintEvent)

void UBearTrapHazard::BPRespawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BearTrapHazard", "BPRespawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BearTrapHazard.OnWorldReset
// (Final, Native, Public)

void UBearTrapHazard::OnWorldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BearTrapHazard", "OnWorldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HealOverTimeEffectAbilityComponent.OnLanternStateSwitched
// (Final, Native, Public)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealOverTimeEffectAbilityComponent::OnLanternStateSwitched(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealOverTimeEffectAbilityComponent", "OnLanternStateSwitched");

	Params::HealOverTimeEffectAbilityComponent_OnLanternStateSwitched Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Charge_AbilityComponent.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharge_AbilityComponent::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Charge_AbilityComponent", "IsCollideSignature");

	Params::Charge_AbilityComponent_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.GrowCollectibleActor.Collected
// (Event, Public, BlueprintEvent)

void AGrowCollectibleActor::Collected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "Collected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.GrowCollectibleActor.GetGrowthPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGrowCollectibleActor::GetGrowthPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "GetGrowthPercent");

	Params::GrowCollectibleActor_GetGrowthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GrowCollectibleActor.GrowthFinished
// (Event, Public, BlueprintEvent)

void AGrowCollectibleActor::GrowthFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "GrowthFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.GrowCollectibleActor.Harvestable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGrowCollectibleActor::Harvestable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "Harvestable");

	Params::GrowCollectibleActor_Harvestable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GrowCollectibleActor.InteractCustom1
// (Event, Public, BlueprintEvent)

void AGrowCollectibleActor::InteractCustom1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "InteractCustom1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.GrowCollectibleActor.OnGameplayEvent
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGrowCollectibleActor::OnGameplayEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "OnGameplayEvent");

	Params::GrowCollectibleActor_OnGameplayEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GrowCollectibleActor.OnPostHardSleepChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bSleep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGrowCollectibleActor::OnPostHardSleepChanged(bool bSleep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrowCollectibleActor", "OnPostHardSleepChanged");

	Params::GrowCollectibleActor_OnPostHardSleepChanged Parms{};

	Parms.bSleep = bSleep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadMapSlotUserWidget.OnSetSlot
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InSlotName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMapSlotUserWidget::OnSetSlot(class FName InSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapSlotUserWidget", "OnSetSlot");

	Params::LoadMapSlotUserWidget_OnSetSlot Parms{};

	Parms.InSlotName = InSlotName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.DefendAbility.IsInStateDefend
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDefendAbility::IsInStateDefend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefendAbility", "IsInStateDefend");

	Params::DefendAbility_IsInStateDefend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DefendAbility.OnPreDamagedPriority
// (Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDefendAbility::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefendAbility", "OnPreDamagedPriority");

	Params::DefendAbility_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CustomEventOnGlobalAbilityAnimEvent.OnAbilityAnimEvent
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          InAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          InAnimEventType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnGlobalAbilityAnimEvent::OnAbilityAnimEvent(class UAbilityBase* InAbility, class UAnimID* InAnim, EAnimEventType InAnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnGlobalAbilityAnimEvent", "OnAbilityAnimEvent");

	Params::CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent Parms{};

	Parms.InAbility = InAbility;
	Parms.InAnim = InAnim;
	Parms.InAnimEventType = InAnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnGlobalAbilityAnimEvent.OnAbilityEnded
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     EndedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnGlobalAbilityAnimEvent::OnAbilityEnded(class UAbilityBase* EndedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnGlobalAbilityAnimEvent", "OnAbilityEnded");

	Params::CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded Parms{};

	Parms.EndedAbility = EndedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LifeLinkMandragoraHeroInteract.InteractReleased
// (Final, Native, Public)

void ULifeLinkMandragoraHeroInteract::InteractReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LifeLinkMandragoraHeroInteract", "InteractReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HitCounter_AbilityComponent.OnPostDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHitCounter_AbilityComponent::OnPostDamage(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitCounter_AbilityComponent", "OnPostDamage");

	Params::HitCounter_AbilityComponent_OnPostDamage Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HitCounter_AbilityComponent.OnWorldRespawn
// (Final, Native, Public)

void UHitCounter_AbilityComponent::OnWorldRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitCounter_AbilityComponent", "OnWorldRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PooledActor.OnActivated
// (Event, Public, BlueprintEvent)

void APooledActor::OnActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "OnActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.PooledActor.OnDeactivated
// (Event, Public, BlueprintEvent)

void APooledActor::OnDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "OnDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ChaoticRejuvenationPassive.ChaosTriggered
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRejuvenationPassive::ChaosTriggered(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRejuvenationPassive", "ChaosTriggered");

	Params::ChaoticRejuvenationPassive_ChaosTriggered Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRejuvenationPassive.StatusEffectApplied
// (Final, Native, Public)
// Parameters:
// class AActor*                           effecttarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRejuvenationPassive::StatusEffectApplied(class AActor* effecttarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRejuvenationPassive", "StatusEffectApplied");

	Params::ChaoticRejuvenationPassive_StatusEffectApplied Parms{};

	Parms.effecttarget = effecttarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestManagerComponent.OnInfoScreenClose
// (Final, Native, Private)
// Parameters:
// class UInfoScreentDataAsset*            InfoScreenData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManagerComponent::OnInfoScreenClose(class UInfoScreentDataAsset* InfoScreenData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManagerComponent", "OnInfoScreenClose");

	Params::QuestManagerComponent_OnInfoScreenClose Parms{};

	Parms.InfoScreenData = InfoScreenData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SubtitleUserWidget.OnMoveToNormal
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleUserWidget::OnMoveToNormal(float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleUserWidget", "OnMoveToNormal");

	Params::SubtitleUserWidget_OnMoveToNormal Parms{};

	Parms.AnimDuration = AnimDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SubtitleUserWidget.OnMoveToUltrawide
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleUserWidget::OnMoveToUltrawide(float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleUserWidget", "OnMoveToUltrawide");

	Params::SubtitleUserWidget_OnMoveToUltrawide Parms{};

	Parms.AnimDuration = AnimDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SubtitleUserWidget.OnShowSubtitleText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InLineIDText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USubtitleUserWidget::OnShowSubtitleText(const class FText& InText, const class FText& InLineIDText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleUserWidget", "OnShowSubtitleText");

	Params::SubtitleUserWidget_OnShowSubtitleText Parms{};

	Parms.InText = std::move(InText);
	Parms.InLineIDText = std::move(InLineIDText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SubtitleUserWidget.OnSubtitleEnable
// (Final, Native, Protected)
// Parameters:
// bool                                    bSubtitleEnable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleUserWidget::OnSubtitleEnable(bool bSubtitleEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleUserWidget", "OnSubtitleEnable");

	Params::SubtitleUserWidget_OnSubtitleEnable Parms{};

	Parms.bSubtitleEnable = bSubtitleEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeightenedSensesAbilityComponent.OnPreDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UHeightenedSensesAbilityComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeightenedSensesAbilityComponent", "OnPreDamaged");

	Params::HeightenedSensesAbilityComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CustomEventOnItemSlotChange.OnInventorySlotChanged
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnItemSlotChange::OnInventorySlotChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnItemSlotChange", "OnInventorySlotChanged");

	Params::CustomEventOnItemSlotChange_OnInventorySlotChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnItemSlotChange.OnPreRemoveItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RemovedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnItemSlotChange::OnPreRemoveItem(class UInventorySlot* InventorySlot, class UItemAbility* RemovedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnItemSlotChange", "OnPreRemoveItem");

	Params::CustomEventOnItemSlotChange_OnPreRemoveItem Parms{};

	Parms.InventorySlot = InventorySlot;
	Parms.RemovedItem = RemovedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnCodeEvent.OnCheckpointInteracted
// (Final, Native, Private)

void UCustomEventOnCodeEvent::OnCheckpointInteracted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnCodeEvent", "OnCheckpointInteracted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnCodeEvent.OnPostAbilitySlotRotated
// (Final, Native, Private)
// Parameters:
// int32                                   CurrectSubslot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnCodeEvent::OnPostAbilitySlotRotated(int32 CurrectSubslot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnCodeEvent", "OnPostAbilitySlotRotated");

	Params::CustomEventOnCodeEvent_OnPostAbilitySlotRotated Parms{};

	Parms.CurrectSubslot = CurrectSubslot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnCodeEvent.OnSkillTreeReset
// (Final, Native, Private)
// Parameters:
// class UPrimalSkillTree*                 Tree                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnCodeEvent::OnSkillTreeReset(class UPrimalSkillTree* Tree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnCodeEvent", "OnSkillTreeReset");

	Params::CustomEventOnCodeEvent_OnSkillTreeReset Parms{};

	Parms.Tree = Tree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnCodeEvent.OnWorldReset
// (Final, Native, Private)

void UCustomEventOnCodeEvent::OnWorldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnCodeEvent", "OnWorldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BountyBoardNoteUserWidget.OnSetAccepted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInAccepted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBountyBoardNoteUserWidget::OnSetAccepted(bool bInAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardNoteUserWidget", "OnSetAccepted");

	Params::BountyBoardNoteUserWidget_OnSetAccepted Parms{};

	Parms.bInAccepted = bInAccepted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.BountyBoardNoteUserWidget.OnSetCompleted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInCompleted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPlayCompleteAnim                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBountyBoardNoteUserWidget::OnSetCompleted(bool bInCompleted, bool bInPlayCompleteAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardNoteUserWidget", "OnSetCompleted");

	Params::BountyBoardNoteUserWidget_OnSetCompleted Parms{};

	Parms.bInCompleted = bInCompleted;
	Parms.bInPlayCompleteAnim = bInPlayCompleteAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CustomEventOnDamage.OnPostDamageDone
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomEventOnDamage::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnDamage", "OnPostDamageDone");

	Params::CustomEventOnDamage_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CustomEventOnDamage.OnPostDamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomEventOnDamage::OnPostDamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnDamage", "OnPostDamageTaken");

	Params::CustomEventOnDamage_OnPostDamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EquilibriumComponent.OnAbilityResourceConsumed
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquilibriumComponent::OnAbilityResourceConsumed(class UAbilityBase* StartedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquilibriumComponent", "OnAbilityResourceConsumed");

	Params::EquilibriumComponent_OnAbilityResourceConsumed Parms{};

	Parms.StartedAbility = StartedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EquilibriumComponent.OnPreDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UEquilibriumComponent::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquilibriumComponent", "OnPreDamageCaused");

	Params::EquilibriumComponent_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LinkActorsComponent.OnPreDamagedPriority
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void ULinkActorsComponent::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkActorsComponent", "OnPreDamagedPriority");

	Params::LinkActorsComponent_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CustomEventOnHUDMessage.OnHudMessage
// (Final, Native, Private)
// Parameters:
// EHudMessage                             Msg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventOnHUDMessage::OnHudMessage(EHudMessage Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventOnHUDMessage", "OnHudMessage");

	Params::CustomEventOnHUDMessage_OnHudMessage Parms{};

	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GrabAndBite.OnPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGrabAndBite::OnPostDamageCaused(const struct FPreDamagedEventParam& PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrabAndBite", "OnPostDamageCaused");

	Params::GrabAndBite_OnPostDamageCaused Parms{};

	Parms.PreDamagedEventParam = std::move(PreDamagedEventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManageAbilityComponentsByModifier.OnAbilityModifierChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGeneralAbilityModifier                 GeneralID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManageAbilityComponentsByModifier::OnAbilityModifierChanged(bool bAdded, EGeneralAbilityModifier GeneralID, class FName CustomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManageAbilityComponentsByModifier", "OnAbilityModifierChanged");

	Params::ManageAbilityComponentsByModifier_OnAbilityModifierChanged Parms{};

	Parms.bAdded = bAdded;
	Parms.GeneralID = GeneralID;
	Parms.CustomID = CustomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.BtnHotkeyAClickedRequest
// (Final, Native, Protected, BlueprintCallable)

void UCharacterWindowUserWidget::BtnHotkeyAClickedRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "BtnHotkeyAClickedRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnAddItem
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnAddItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnAddItem");

	Params::CharacterWindowUserWidget_OnAddItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnApplyEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnApplyEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnApplyEnchant");

	Params::CharacterWindowUserWidget_OnApplyEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnAttributeChanged
// (Final, Native, Protected)
// Parameters:
// EAttribute                              AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnAttributeChanged(EAttribute AttributeType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnAttributeChanged");

	Params::CharacterWindowUserWidget_OnAttributeChanged Parms{};

	Parms.AttributeType = AttributeType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnEquipItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCharacterWinFilterSlotUserWidget*FilterSlotUserWidget                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlotUserWidget*         InventorySlotUserWidget                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnEquipItem(class UCharacterWinFilterSlotUserWidget* FilterSlotUserWidget, class UInventorySlotUserWidget* InventorySlotUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnEquipItem");

	Params::CharacterWindowUserWidget_OnEquipItem Parms{};

	Parms.FilterSlotUserWidget = FilterSlotUserWidget;
	Parms.InventorySlotUserWidget = InventorySlotUserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnHighlightRequirement
// (Event, Protected, BlueprintEvent)

void UCharacterWindowUserWidget::OnHighlightRequirement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnHighlightRequirement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterWindowUserWidget.OnItemSlotChanged
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnItemSlotChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnItemSlotChanged");

	Params::CharacterWindowUserWidget_OnItemSlotChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnNewItem
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnNewItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnNewItem");

	Params::CharacterWindowUserWidget_OnNewItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnPropertyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnPropertyChanged");

	Params::CharacterWindowUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnRemovedRingItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnRemovedRingItem(class UWidget* Widget, class UItemAbility* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnRemovedRingItem");

	Params::CharacterWindowUserWidget_OnRemovedRingItem Parms{};

	Parms.Widget = Widget;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnRemoveEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnRemoveEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnRemoveEnchant");

	Params::CharacterWindowUserWidget_OnRemoveEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnSetFilterSlot
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EItemSlot                               ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             FilterName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnSetFilterSlot(EItemSlot ItemSlot, const class FText& FilterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnSetFilterSlot");

	Params::CharacterWindowUserWidget_OnSetFilterSlot Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.FilterName = std::move(FilterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnSetFilterView
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInFilterView                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnSetFilterView(bool bInFilterView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnSetFilterView");

	Params::CharacterWindowUserWidget_OnSetFilterView Parms{};

	Parms.bInFilterView = bInFilterView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnSetRequestEquippedItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UItemAbility*                     InItemAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnSetRequestEquippedItem(class UItemAbility* InItemAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnSetRequestEquippedItem");

	Params::CharacterWindowUserWidget_OnSetRequestEquippedItem Parms{};

	Parms.InItemAbility = InItemAbility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnToggleSetIndex
// (Event, Protected, BlueprintEvent)

void UCharacterWindowUserWidget::OnToggleSetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnToggleSetIndex");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterWindowUserWidget.OnToggleStats
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInStatsVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnToggleStats(bool bInStatsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnToggleStats");

	Params::CharacterWindowUserWidget_OnToggleStats Parms{};

	Parms.bInStatsVisible = bInStatsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnUndoUITemp
// (Final, Native, Public)

void UCharacterWindowUserWidget::OnUndoUITemp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUndoUITemp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUnlockAbilityUpgrade
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUnlockAbilityUpgrade(TSubclassOf<class UAbilityBase> AbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUnlockAbilityUpgrade");

	Params::CharacterWindowUserWidget_OnUnlockAbilityUpgrade Parms{};

	Parms.AbilityType = AbilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUpdateDetailsPanel
// (Final, Native, Public)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUpdateDetailsPanel(class UManItemSlotBase* ManItemSlotBase, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUpdateDetailsPanel");

	Params::CharacterWindowUserWidget_OnUpdateDetailsPanel Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUpdateEquippedItemDetailsPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemRequirementText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InComparedItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUpdateEquippedItemDetailsPanel(const class FText& ItemRequirementText, class UItemAbility* InItem, class UItemAbility* InComparedItem, bool bEquipped, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUpdateEquippedItemDetailsPanel");

	Params::CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel Parms{};

	Parms.ItemRequirementText = std::move(ItemRequirementText);
	Parms.InItem = InItem;
	Parms.InComparedItem = InComparedItem;
	Parms.bEquipped = bEquipped;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.OnUpdateItem
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUpdateItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUpdateItem");

	Params::CharacterWindowUserWidget_OnUpdateItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUpdateQuickUseSlot
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUpdateQuickUseSlot(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUpdateQuickUseSlot");

	Params::CharacterWindowUserWidget_OnUpdateQuickUseSlot Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUpdateSlot
// (Final, Native, Public)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUpdateSlot(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUpdateSlot");

	Params::CharacterWindowUserWidget_OnUpdateSlot Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.OnUseItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::OnUseItem(class UWidget* Widget, class UItemAbility* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "OnUseItem");

	Params::CharacterWindowUserWidget_OnUseItem Parms{};

	Parms.Widget = Widget;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWindowUserWidget.PropertyChanged
// (Final, Native, Protected)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "PropertyChanged");

	Params::CharacterWindowUserWidget_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.SetFilterView
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInFilterView                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAkAudioEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWindowUserWidget::SetFilterView(bool bInFilterView, bool bPlayAkAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "SetFilterView");

	Params::CharacterWindowUserWidget_SetFilterView Parms{};

	Parms.bInFilterView = bInFilterView;
	Parms.bPlayAkAudioEvent = bPlayAkAudioEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.SetFocusLastSelectedListItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterWindowUserWidget::SetFocusLastSelectedListItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "SetFocusLastSelectedListItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.ToggleSetIndex
// (Final, Native, Public, BlueprintCallable)

void UCharacterWindowUserWidget::ToggleSetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "ToggleSetIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.UnlockAnimFinished
// (Final, Native, Public, BlueprintCallable)

void UCharacterWindowUserWidget::UnlockAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "UnlockAnimFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.UseFocusedItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterWindowUserWidget::UseFocusedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "UseFocusedItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWindowUserWidget.IsItemEquippedMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterWindowUserWidget::IsItemEquippedMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWindowUserWidget", "IsItemEquippedMode");

	Params::CharacterWindowUserWidget_IsItemEquippedMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BloodTrance.AbilityModifierChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bAddedModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGeneralAbilityModifier                 GeneralID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodTrance::AbilityModifierChanged(bool bAddedModifier, EGeneralAbilityModifier GeneralID, class FName CustomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodTrance", "AbilityModifierChanged");

	Params::BloodTrance_AbilityModifierChanged Parms{};

	Parms.bAddedModifier = bAddedModifier;
	Parms.GeneralID = GeneralID;
	Parms.CustomID = CustomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GremlinSuicideAttack.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UGremlinSuicideAttack::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GremlinSuicideAttack", "OnPreDamagedPriority");

	Params::GremlinSuicideAttack_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LarcenistMBEnvenom.OnPostDamageDone
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULarcenistMBEnvenom::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LarcenistMBEnvenom", "OnPostDamageDone");

	Params::LarcenistMBEnvenom_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRemnantsPassive::AbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "AbilityStart");

	Params::ChaoticRemnantsPassive_AbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.DamageCasued
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChaoticRemnantsPassive::DamageCasued(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "DamageCasued");

	Params::ChaoticRemnantsPassive_DamageCasued Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.RemnantPickedUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActorBase*                       Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRemnantsPassive::RemnantPickedUp(class AActorBase* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "RemnantPickedUp");

	Params::ChaoticRemnantsPassive_RemnantPickedUp Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.RemoveShield
// (Final, Native, Public)

void UChaoticRemnantsPassive::RemoveShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "RemoveShield");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.ResourceUsed
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRemnantsPassive::ResourceUsed(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "ResourceUsed");

	Params::ChaoticRemnantsPassive_ResourceUsed Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticRemnantsPassive.StatusEffectApplied
// (Final, Native, Public)
// Parameters:
// class AActor*                           effecttarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticRemnantsPassive::StatusEffectApplied(class AActor* effecttarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticRemnantsPassive", "StatusEffectApplied");

	Params::ChaoticRemnantsPassive_StatusEffectApplied Parms{};

	Parms.effecttarget = effecttarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SwitchActorBase.StartGameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASwitchActorBase::StartGameplayEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchActorBase", "StartGameplayEvent");

	Params::SwitchActorBase_StartGameplayEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Progress2AbilityComponent.WorldRespawnEvent
// (Final, Native, Public)

void UProgress2AbilityComponent::WorldRespawnEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Progress2AbilityComponent", "WorldRespawnEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.AddQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QuestBlueprint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   QuestPopupShowingDelayTime                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuest*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuest* UManQuestManager::AddQuest(TSubclassOf<class UManQuest> QuestBlueprint, float QuestPopupShowingDelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "AddQuest");

	Params::ManQuestManager_AddQuest Parms{};

	Parms.QuestBlueprint = QuestBlueprint;
	Parms.QuestPopupShowingDelayTime = QuestPopupShowingDelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestManager.AddQuestProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CallSource                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::AddQuestProgress(TSubclassOf<class UManQuest> QClass, class UManQuestObjective* Objective, class FName ObjectiveName, const class FString& CallSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "AddQuestProgress");

	Params::ManQuestManager_AddQuestProgress Parms{};

	Parms.QClass = QClass;
	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;
	Parms.CallSource = std::move(CallSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.CompleteQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::CompleteQuest(TSubclassOf<class UManQuest> QClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "CompleteQuest");

	Params::ManQuestManager_CompleteQuest Parms{};

	Parms.QClass = QClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.GetQuests
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManQuest*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManQuest*> UManQuestManager::GetQuests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "GetQuests");

	Params::ManQuestManager_GetQuests Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestManager.HasQuest
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuestManager::HasQuest(TSubclassOf<class UManQuest> QClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "HasQuest");

	Params::ManQuestManager_HasQuest Parms{};

	Parms.QClass = QClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestManager.IsQuestObjectiveCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuestManager::IsQuestObjectiveCompleted(TSubclassOf<class UManQuest> QClass, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "IsQuestObjectiveCompleted");

	Params::ManQuestManager_IsQuestObjectiveCompleted Parms{};

	Parms.QClass = QClass;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestManager.IsQuestObjectiveFailed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuestManager::IsQuestObjectiveFailed(TSubclassOf<class UManQuest> QClass, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "IsQuestObjectiveFailed");

	Params::ManQuestManager_IsQuestObjectiveFailed Parms{};

	Parms.QClass = QClass;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuestManager.OnActorEnteredZone
// (Final, Native, Private)
// Parameters:
// class AActor*                           ZoneActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorEntered                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::OnActorEnteredZone(class AActor* ZoneActor, class AActor* ActorEntered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnActorEnteredZone");

	Params::ManQuestManager_OnActorEnteredZone Parms{};

	Parms.ZoneActor = ZoneActor;
	Parms.ActorEntered = ActorEntered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.OnEntityKilled
// (Final, Native, Private)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::OnEntityKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnEntityKilled");

	Params::ManQuestManager_OnEntityKilled Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.OnGlobalVariableChanged
// (Final, Native, Private)
// Parameters:
// class FName                             EntryKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::OnGlobalVariableChanged(class FName EntryKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnGlobalVariableChanged");

	Params::ManQuestManager_OnGlobalVariableChanged Parms{};

	Parms.EntryKey = EntryKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.OnItemAdded
// (Final, Native, Private)
// Parameters:
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemStack                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::OnItemAdded(class UItemAbility* Item, int32 ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnItemAdded");

	Params::ManQuestManager_OnItemAdded Parms{};

	Parms.Item = Item;
	Parms.ItemStack = ItemStack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.OnItemsChanged
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::OnItemsChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnItemsChanged");

	Params::ManQuestManager_OnItemsChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.OnWorldReset
// (Final, Native, Private)

void UManQuestManager::OnWorldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "OnWorldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.RemoveQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QuestBlueprint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::RemoveQuest(TSubclassOf<class UManQuest> QuestBlueprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "RemoveQuest");

	Params::ManQuestManager_RemoveQuest Parms{};

	Parms.QuestBlueprint = QuestBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.SetObjectiveFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuestManager::SetObjectiveFailed(TSubclassOf<class UManQuest> QClass, class UManQuestObjective* Objective, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "SetObjectiveFailed");

	Params::ManQuestManager_SetObjectiveFailed Parms{};

	Parms.QClass = QClass;
	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.SetObjectiveQuestMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UManQuestManager::SetObjectiveQuestMarker(TSubclassOf<class UManQuest> QClass, class UManQuestObjective* Objective, class FName ObjectiveName, const struct FQuestMarker& QuestMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "SetObjectiveQuestMarker");

	Params::ManQuestManager_SetObjectiveQuestMarker Parms{};

	Parms.QClass = QClass;
	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;
	Parms.QuestMarker = std::move(QuestMarker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuestManager.SetQuestConclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UManQuest>            QClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InQuestConclusion                                      (Parm, NativeAccessSpecifierPublic)

void UManQuestManager::SetQuestConclusion(TSubclassOf<class UManQuest> QClass, const class FText& InQuestConclusion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuestManager", "SetQuestConclusion");

	Params::ManQuestManager_SetQuestConclusion Parms{};

	Parms.QClass = QClass;
	Parms.InQuestConclusion = std::move(InQuestConclusion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ReflectDamageComponent.OnPreDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UReflectDamageComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReflectDamageComponent", "OnPreDamaged");

	Params::ReflectDamageComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CriticalBatteryPassive.AbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCriticalBatteryPassive::AbilityEnd(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CriticalBatteryPassive", "AbilityEnd");

	Params::CriticalBatteryPassive_AbilityEnd Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CriticalBatteryPassive.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCriticalBatteryPassive::AbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CriticalBatteryPassive", "AbilityStart");

	Params::CriticalBatteryPassive_AbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CriticalBatteryPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCriticalBatteryPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CriticalBatteryPassive", "DamageDealt");

	Params::CriticalBatteryPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TrailEmitter.BPGetTrailLifeTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTrailEmitter::BPGetTrailLifeTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrailEmitter", "BPGetTrailLifeTime");

	Params::TrailEmitter_BPGetTrailLifeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HitCounter.OnHit
// (Final, Native, Public)
// Parameters:
// struct FACOnHitPatam                    OnHitPatam                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UHitCounter::OnHit(const struct FACOnHitPatam& OnHitPatam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitCounter", "OnHit");

	Params::HitCounter_OnHit Parms{};

	Parms.OnHitPatam = std::move(OnHitPatam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HitCounter.OnReset
// (Final, Native, Public)

void UHitCounter::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitCounter", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HitCounter.OnWorldRespawn
// (Final, Native, Public)

void UHitCounter::OnWorldRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitCounter", "OnWorldRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractAbility.BPGetInteractInRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UInteractAbility::BPGetInteractInRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractAbility", "BPGetInteractInRange");

	Params::InteractAbility_BPGetInteractInRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSelectHotkeyUserWidget.OnHotkeyBindingsNotAllowedKey
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectHotkeyUserWidget::OnHotkeyBindingsNotAllowedKey(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectHotkeyUserWidget", "OnHotkeyBindingsNotAllowedKey");

	Params::OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectHotkeyUserWidget.OnHotkeyCancelEvent
// (Event, Protected, BlueprintEvent)

void UOptionsSelectHotkeyUserWidget::OnHotkeyCancelEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectHotkeyUserWidget", "OnHotkeyCancelEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsSelectHotkeyUserWidget.OnHotkeyChangedEvent
// (Event, Protected, BlueprintEvent)

void UOptionsSelectHotkeyUserWidget::OnHotkeyChangedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectHotkeyUserWidget", "OnHotkeyChangedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.InventorySlotUserWidget.GetItemAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemAbility*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemAbility* UInventorySlotUserWidget::GetItemAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "GetItemAbility");

	Params::InventorySlotUserWidget_GetItemAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InventorySlotUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnFocusWidgetChangedEvent");

	Params::InventorySlotUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InventorySlotUserWidget.OnPermanentEnchantIconsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InPermanentEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnPermanentEnchantIconsChanged(const TArray<class UTexture2D*>& InPermanentEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnPermanentEnchantIconsChanged");

	Params::InventorySlotUserWidget_OnPermanentEnchantIconsChanged Parms{};

	Parms.InPermanentEnchantIcons = std::move(InPermanentEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnPlayFocusedAnim
// (Event, Public, BlueprintEvent)

void UInventorySlotUserWidget::OnPlayFocusedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnPlayFocusedAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.InventorySlotUserWidget.OnSetCountdown
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   ElapsedCooldownPercent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TimeLeft                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnSetCountdown(float ElapsedCooldownPercent, const class FText& TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnSetCountdown");

	Params::InventorySlotUserWidget_OnSetCountdown Parms{};

	Parms.ElapsedCooldownPercent = ElapsedCooldownPercent;
	Parms.TimeLeft = std::move(TimeLeft);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnSetEquipState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEquipState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnSetEquipState(bool bEquipState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnSetEquipState");

	Params::InventorySlotUserWidget_OnSetEquipState Parms{};

	Parms.bEquipState = bEquipState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnSetSetIndexes
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<int32>                           InSetIndexes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnSetSetIndexes(const TArray<int32>& InSetIndexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnSetSetIndexes");

	Params::InventorySlotUserWidget_OnSetSetIndexes Parms{};

	Parms.InSetIndexes = std::move(InSetIndexes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnSetSlot
// (Event, Public, BlueprintEvent)
// Parameters:
// class UManItemSlotBase*                 InManItemSlotBase                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItemAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnSetSlot(class UManItemSlotBase* InManItemSlotBase, class UItemAbility* InItemAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnSetSlot");

	Params::InventorySlotUserWidget_OnSetSlot Parms{};

	Parms.InManItemSlotBase = InManItemSlotBase;
	Parms.InItemAbility = InItemAbility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnStackNumChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InStackNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxStackNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsStackable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnStackNumChanged(int32 InStackNum, int32 InMaxStackNum, bool bInIsStackable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnStackNumChanged");

	Params::InventorySlotUserWidget_OnStackNumChanged Parms{};

	Parms.InStackNum = InStackNum;
	Parms.InMaxStackNum = InMaxStackNum;
	Parms.bInIsStackable = bInIsStackable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnTemporaryEnchantIconsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InTemporaryEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnTemporaryEnchantIconsChanged(const TArray<class UTexture2D*>& InTemporaryEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnTemporaryEnchantIconsChanged");

	Params::InventorySlotUserWidget_OnTemporaryEnchantIconsChanged Parms{};

	Parms.InTemporaryEnchantIcons = std::move(InTemporaryEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleEmptySlot
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEmptySlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemSlot                               InSlotType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleEmptySlot(bool bInEmptySlot, EItemSlot InSlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleEmptySlot");

	Params::InventorySlotUserWidget_OnToggleEmptySlot Parms{};

	Parms.bInEmptySlot = bInEmptySlot;
	Parms.InSlotType = InSlotType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleEquipped
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInIsEquipped                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleEquipped(bool bInIsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleEquipped");

	Params::InventorySlotUserWidget_OnToggleEquipped Parms{};

	Parms.bInIsEquipped = bInIsEquipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleNewItemWarning
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAnimate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleNewItemWarning(bool bInVisible, bool bInAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleNewItemWarning");

	Params::InventorySlotUserWidget_OnToggleNewItemWarning Parms{};

	Parms.bInVisible = bInVisible;
	Parms.bInAnimate = bInAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleSelected(bool bSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleSelected");

	Params::InventorySlotUserWidget_OnToggleSelected Parms{};

	Parms.bSelected = bSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleSoldItem
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInSoldItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleSoldItem(bool bInSoldItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleSoldItem");

	Params::InventorySlotUserWidget_OnToggleSoldItem Parms{};

	Parms.bInSoldItem = bInSoldItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.OnToggleUnavailable
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bUnavailable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnavailableByResource                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventorySlotUserWidget::OnToggleUnavailable(bool bUnavailable, bool bUnavailableByResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "OnToggleUnavailable");

	Params::InventorySlotUserWidget_OnToggleUnavailable Parms{};

	Parms.bUnavailable = bUnavailable;
	Parms.bUnavailableByResource = bUnavailableByResource;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventorySlotUserWidget.GetManItemSlotBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UManItemSlotBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManItemSlotBase* UInventorySlotUserWidget::GetManItemSlotBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "GetManItemSlotBase");

	Params::InventorySlotUserWidget_GetManItemSlotBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InventorySlotUserWidget.IsInfiniteAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventorySlotUserWidget::IsInfiniteAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventorySlotUserWidget", "IsInfiniteAmount");

	Params::InventorySlotUserWidget_IsInfiniteAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.HasControllerConnected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::HasControllerConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "HasControllerConnected");

	Params::ConsoleFunctionLibrary_HasControllerConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsConsole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsConsole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsConsole");

	Params::ConsoleFunctionLibrary_IsConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsPlayStation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsPlayStation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsPlayStation");

	Params::ConsoleFunctionLibrary_IsPlayStation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsSteamDeck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsSteamDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsSteamDeck");

	Params::ConsoleFunctionLibrary_IsSteamDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsSwitch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsSwitch");

	Params::ConsoleFunctionLibrary_IsSwitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsWinGDK
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsWinGDK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsWinGDK");

	Params::ConsoleFunctionLibrary_IsWinGDK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsoleFunctionLibrary.IsXbox
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConsoleFunctionLibrary::IsXbox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleFunctionLibrary", "IsXbox");

	Params::ConsoleFunctionLibrary_IsXbox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LaserBeam.GetLaserBeamVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULaserBeam::GetLaserBeamVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LaserBeam", "GetLaserBeamVector");

	Params::LaserBeam_GetLaserBeamVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPActivateDeveloperItemSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SetIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPActivateDeveloperItemSet(int32 SetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPActivateDeveloperItemSet");

	Params::Inventory_BPActivateDeveloperItemSet Parms{};

	Parms.SetIndex = SetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPAddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemAbilityClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConversationAddItemShowingDelayTime                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPAddItem(TSubclassOf<class UItemAbility> ItemAbilityClass, float ConversationAddItemShowingDelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPAddItem");

	Params::Inventory_BPAddItem Parms{};

	Parms.ItemAbilityClass = ItemAbilityClass;
	Parms.ConversationAddItemShowingDelayTime = ConversationAddItemShowingDelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPChangeSetIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SetIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPChangeSetIndex(int32 SetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPChangeSetIndex");

	Params::Inventory_BPChangeSetIndex Parms{};

	Parms.SetIndex = SetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemAbilityClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPEquipItem(TSubclassOf<class UItemAbility> ItemAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPEquipItem");

	Params::Inventory_BPEquipItem Parms{};

	Parms.ItemAbilityClass = ItemAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPFindItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventory::BPFindItemNum(TSubclassOf<class UItemAbility> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPFindItemNum");

	Params::Inventory_BPFindItemNum Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPGetEntropyLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEntropyLantern*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEntropyLantern* UInventory::BPGetEntropyLantern()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPGetEntropyLantern");

	Params::Inventory_BPGetEntropyLantern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPGetItemSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemAbilityClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlot                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInventorySlot UInventory::BPGetItemSlot(TSubclassOf<class UItemAbility> ItemAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPGetItemSlot");

	Params::Inventory_BPGetItemSlot Parms{};

	Parms.ItemAbilityClass = ItemAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPIncreaseFlaskCapacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFlaskItemAbility>    FlaskType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IncreaseNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddCharge                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPIncreaseFlaskCapacity(TSubclassOf<class UFlaskItemAbility> FlaskType, int32 IncreaseNum, bool bAddCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPIncreaseFlaskCapacity");

	Params::Inventory_BPIncreaseFlaskCapacity Parms{};

	Parms.FlaskType = FlaskType;
	Parms.IncreaseNum = IncreaseNum;
	Parms.bAddCharge = bAddCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPIsItemEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::BPIsItemEquipped(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPIsItemEquipped");

	Params::Inventory_BPIsItemEquipped Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPIsItemInInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemAbilityClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::BPIsItemInInventory(TSubclassOf<class UItemAbility> ItemAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPIsItemInInventory");

	Params::Inventory_BPIsItemInInventory Parms{};

	Parms.ItemAbilityClass = ItemAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPOnItemSlotChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPOnItemSlotChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPOnItemSlotChanged");

	Params::Inventory_BPOnItemSlotChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPPostSaveLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UInventory::BPPostSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPPostSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPPutToBackpack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventorySlot*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::BPPutToBackpack(class UInventorySlot* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPPutToBackpack");

	Params::Inventory_BPPutToBackpack Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPRemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemAbility>         ItemAbilityClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::BPRemoveItem(TSubclassOf<class UItemAbility> ItemAbilityClass, int32 StackNum, bool bUseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPRemoveItem");

	Params::Inventory_BPRemoveItem Parms{};

	Parms.ItemAbilityClass = ItemAbilityClass;
	Parms.StackNum = StackNum;
	Parms.bUseItem = bUseItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPShowHUDPopup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConversationAddItemShowingDelayTime                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideNewItemTitle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::BPShowHUDPopup(const class FText& Name_0, const class FText& Description, class UTexture2D* Icon, float Timeout, int32 Number, class UItemAbility* ItemAbility, float ConversationAddItemShowingDelayTime, bool bHideNewItemTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPShowHUDPopup");

	Params::Inventory_BPShowHUDPopup Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Description = std::move(Description);
	Parms.Icon = Icon;
	Parms.Timeout = Timeout;
	Parms.Number = Number;
	Parms.ItemAbility = ItemAbility;
	Parms.ConversationAddItemShowingDelayTime = ConversationAddItemShowingDelayTime;
	Parms.bHideNewItemTitle = bHideNewItemTitle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.BPSwitchQuickUseSlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Slot1Index                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slot2Index                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::BPSwitchQuickUseSlots(int32 Slot1Index, int32 Slot2Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPSwitchQuickUseSlots");

	Params::Inventory_BPSwitchQuickUseSlots Parms{};

	Parms.Slot1Index = Slot1Index;
	Parms.Slot2Index = Slot2Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.BPUnEquipSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreRuningAnims                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemAbility>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UItemAbility> UInventory::BPUnEquipSlot(EInventorySlot Slot, bool bIgnoreRuningAnims, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "BPUnEquipSlot");

	Params::Inventory_BPUnEquipSlot Parms{};

	Parms.Slot = Slot;
	Parms.bIgnoreRuningAnims = bIgnoreRuningAnims;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.ChargeRelicsToFull
// (Final, Native, Public, BlueprintCallable)

void UInventory::ChargeRelicsToFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ChargeRelicsToFull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.ChargeShieldsToFull
// (Final, Native, Public, BlueprintCallable)

void UInventory::ChargeShieldsToFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ChargeShieldsToFull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.GetGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UInventory::GetGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetGameMode");

	Params::Inventory_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.GetHPFlaskEfficiencyModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInventory::GetHPFlaskEfficiencyModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetHPFlaskEfficiencyModifier");

	Params::Inventory_GetHPFlaskEfficiencyModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.GetQuestManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestManager* UInventory::GetQuestManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetQuestManager");

	Params::Inventory_GetQuestManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Inventory.ModifyHealthFlaskEfficiency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::ModifyHealthFlaskEfficiency(float Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ModifyHealthFlaskEfficiency");

	Params::Inventory_ModifyHealthFlaskEfficiency Parms{};

	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.OnCharacterScreenCapture2DHide
// (Final, Native, Public)

void UInventory::OnCharacterScreenCapture2DHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnCharacterScreenCapture2DHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.OnCharacterScreenCapture2DShow
// (Final, Native, Public)

void UInventory::OnCharacterScreenCapture2DShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnCharacterScreenCapture2DShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.OnCharacterWindowClose
// (Final, Native, Public)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::OnCharacterWindowClose(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnCharacterWindowClose");

	Params::Inventory_OnCharacterWindowClose Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.OnCharacterWindowOpen
// (Final, Native, Public)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::OnCharacterWindowOpen(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnCharacterWindowOpen");

	Params::Inventory_OnCharacterWindowOpen Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.OnHeroDie
// (Final, Native, Public)

void UInventory::OnHeroDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnHeroDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.RefillFlasks
// (Final, Native, Public)

void UInventory::RefillFlasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RefillFlasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.ResetRelicCharges
// (Final, Native, Public)

void UInventory::ResetRelicCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ResetRelicCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Inventory.ResetShieldCharges
// (Final, Native, Public)

void UInventory::ResetShieldCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ResetShieldCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CancelAbilitiesComponent.RegisterCanceledAbilityOnPreCompStart
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class UAbilityBase*>             AbilitiesCanceled                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCancelAbilitiesComponent::RegisterCanceledAbilityOnPreCompStart(TArray<class UAbilityBase*>* AbilitiesCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CancelAbilitiesComponent", "RegisterCanceledAbilityOnPreCompStart");

	Params::CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AbilitiesCanceled != nullptr)
		*AbilitiesCanceled = std::move(Parms.AbilitiesCanceled);
}


// Function man.FireShield.OnPreProjectileContact
// (Final, Native, Public)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireShield::OnPreProjectileContact(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireShield", "OnPreProjectileContact");

	Params::FireShield_OnPreProjectileContact Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFireImpAI.OnImpKilled
// (Final, Native, Protected)
// Parameters:
// class UObject*                          Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               KillerAbilityController                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkFireImpAI::OnImpKilled(class UObject* Killer, class UAbilityController* KillerAbilityController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFireImpAI", "OnImpKilled");

	Params::DarkFireImpAI_OnImpKilled Parms{};

	Parms.Killer = Killer;
	Parms.KillerAbilityController = KillerAbilityController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ModifySpellDamage.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UModifySpellDamage::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModifySpellDamage", "OnPreDamageCaused");

	Params::ModifySpellDamage_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ManLootTable.GetEntityLootTable
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEntityLootTable*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEntityLootTable* UManLootTable::GetEntityLootTable(TSubclassOf<class AActor> ActorClass, bool bForceReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootTable", "GetEntityLootTable");

	Params::ManLootTable_GetEntityLootTable Parms{};

	Parms.ActorClass = ActorClass;
	Parms.bForceReload = bForceReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChannelAbility.EventRequestEnd
// (Final, Native, Public)

void UChannelAbility::EventRequestEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChannelAbility", "EventRequestEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ChannelAbility.GetChargeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChannelAbility::GetChargeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChannelAbility", "GetChargeRate");

	Params::ChannelAbility_GetChargeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CStalkerChargeAbility.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCStalkerChargeAbility::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CStalkerChargeAbility", "IsCollideSignature");

	Params::CStalkerChargeAbility_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.CStalkerChargeAbility.IsCollideSignatureEx_Pre
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGroundMovecollideIsCollideSignatureParamParam                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCStalkerChargeAbility::IsCollideSignatureEx_Pre(struct FGroundMovecollideIsCollideSignatureParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CStalkerChargeAbility", "IsCollideSignatureEx_Pre");

	Params::CStalkerChargeAbility_IsCollideSignatureEx_Pre Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.BlessedWeaponComponent.EntityAbilityAnimEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlessedWeaponComponent::EntityAbilityAnimEvent(class UAbilityBase* SourceAbility, class UAnimID* Anim, EAnimEventType AnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedWeaponComponent", "EntityAbilityAnimEvent");

	Params::BlessedWeaponComponent_EntityAbilityAnimEvent Parms{};

	Parms.SourceAbility = SourceAbility;
	Parms.Anim = Anim;
	Parms.AnimEventType = AnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BlessedWeaponComponent.OnDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlessedWeaponComponent::OnDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedWeaponComponent", "OnDamageDealt");

	Params::BlessedWeaponComponent_OnDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManBtnUserWidget.IsBtnEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManBtnUserWidget::IsBtnEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManBtnUserWidget", "IsBtnEnabled");

	Params::ManBtnUserWidget_IsBtnEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManBtnUserWidget.OnSetBtnEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInBtnEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManBtnUserWidget::OnSetBtnEnabled(bool bInBtnEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManBtnUserWidget", "OnSetBtnEnabled");

	Params::ManBtnUserWidget_OnSetBtnEnabled Parms{};

	Parms.bInBtnEnabled = bInBtnEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManBtnUserWidget.OnSetText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UManBtnUserWidget::OnSetText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManBtnUserWidget", "OnSetText");

	Params::ManBtnUserWidget_OnSetText Parms{};

	Parms.Text = std::move(Text);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManBtnUserWidget.SetBtnEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInBtnEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManBtnUserWidget::SetBtnEnabled(bool bInBtnEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManBtnUserWidget", "SetBtnEnabled");

	Params::ManBtnUserWidget_SetBtnEnabled Parms{};

	Parms.bInBtnEnabled = bInBtnEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnvenomComponent.OnDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnvenomComponent::OnDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvenomComponent", "OnDamageDealt");

	Params::EnvenomComponent_OnDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ComponentCooldown.OnWorldRespawn
// (Final, Native, Public)

void UComponentCooldown::OnWorldRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentCooldown", "OnWorldRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorItemSlotUserWidget.OnHighlighted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorItemSlotUserWidget::OnHighlighted(bool bHighlighted, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItemSlotUserWidget", "OnHighlighted");

	Params::VendorItemSlotUserWidget_OnHighlighted Parms{};

	Parms.bHighlighted = bHighlighted;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorItemSlotUserWidget.OnPermanentEnchantIconsChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InPermanentEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorItemSlotUserWidget::OnPermanentEnchantIconsChanged(const TArray<class UTexture2D*>& InPermanentEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItemSlotUserWidget", "OnPermanentEnchantIconsChanged");

	Params::VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged Parms{};

	Parms.InPermanentEnchantIcons = std::move(InPermanentEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorItemSlotUserWidget.OnSetSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorItemSlotUserWidget::OnSetSlot(const class UTexture2D* InIcon, const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItemSlotUserWidget", "OnSetSlot");

	Params::VendorItemSlotUserWidget_OnSetSlot Parms{};

	Parms.InIcon = InIcon;
	Parms.InName = std::move(InName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorItemSlotUserWidget.OnSetSlotCost
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InCost                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAvailable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorItemSlotUserWidget::OnSetSlotCost(int32 InCost, int32 InAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItemSlotUserWidget", "OnSetSlotCost");

	Params::VendorItemSlotUserWidget_OnSetSlotCost Parms{};

	Parms.InCost = InCost;
	Parms.InAvailable = InAvailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorItemSlotUserWidget.OnTemporaryEnchantIconsChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InTemporaryEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorItemSlotUserWidget::OnTemporaryEnchantIconsChanged(const TArray<class UTexture2D*>& InTemporaryEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItemSlotUserWidget", "OnTemporaryEnchantIconsChanged");

	Params::VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged Parms{};

	Parms.InTemporaryEnchantIcons = std::move(InTemporaryEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryFilterSlotUserWidget.OnSetEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryFilterSlotUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryFilterSlotUserWidget", "OnSetEnabled");

	Params::NPCBestiaryFilterSlotUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryFilterSlotUserWidget.OnSetSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryFilterSlotUserWidget::OnSetSelected(bool bInSelected, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryFilterSlotUserWidget", "OnSetSelected");

	Params::NPCBestiaryFilterSlotUserWidget_OnSetSelected Parms{};

	Parms.bInSelected = bInSelected;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryFilterSlotUserWidget.OnToggleNewRegistry
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryFilterSlotUserWidget::OnToggleNewRegistry(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryFilterSlotUserWidget", "OnToggleNewRegistry");

	Params::NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryFilterSlotUserWidget.IsFilterEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCBestiaryFilterSlotUserWidget::IsFilterEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryFilterSlotUserWidget", "IsFilterEnabled");

	Params::NPCBestiaryFilterSlotUserWidget_IsFilterEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArcaneCultistBlink.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UArcaneCultistBlink::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArcaneCultistBlink", "BPGetTeleportLocation");

	Params::ArcaneCultistBlink_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SQ26SecondaryQuest.OnPreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USQ26SecondaryQuest::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SQ26SecondaryQuest", "OnPreDamaged");

	Params::SQ26SecondaryQuest_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.InquisitorDivineHammer.ProjectileShot
// (Final, Native, Public)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInquisitorDivineHammer::ProjectileShot(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorDivineHammer", "ProjectileShot");

	Params::InquisitorDivineHammer_ProjectileShot Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CameraTriggerBox.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACameraTriggerBox::SetActive(bool NewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraTriggerBox", "SetActive");

	Params::CameraTriggerBox_SetActive Parms{};

	Parms.NewActive = NewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CameraTriggerBox.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACameraTriggerBox::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraTriggerBox", "IsActive");

	Params::CameraTriggerBox_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StopAnimOnStaggerOrStun.OnStaggerOrStun
// (Final, Native, Public)

void UStopAnimOnStaggerOrStun::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StopAnimOnStaggerOrStun", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorDuoAI.OnTurnEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInquisitorDuoAI::OnTurnEnded(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorDuoAI", "OnTurnEnded");

	Params::InquisitorDuoAI_OnTurnEnded Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeSlotUserWidget.OnCultureChanged
// (Event, Public, BlueprintEvent)

void UAttributeSlotUserWidget::OnCultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnCultureChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.AttributeSlotUserWidget.OnSetActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetActive");

	Params::AttributeSlotUserWidget_OnSetActive Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetActualValue
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetActualValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetActualValue");

	Params::AttributeSlotUserWidget_OnSetActualValue Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetCurrentValue
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetCurrentValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetCurrentValue");

	Params::AttributeSlotUserWidget_OnSetCurrentValue Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetLeftButtonEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetLeftButtonEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetLeftButtonEnabled");

	Params::AttributeSlotUserWidget_OnSetLeftButtonEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetNewValue
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetNewValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetNewValue");

	Params::AttributeSlotUserWidget_OnSetNewValue Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetRightButtonEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetRightButtonEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetRightButtonEnabled");

	Params::AttributeSlotUserWidget_OnSetRightButtonEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.OnSetShowCurrentValue
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::OnSetShowCurrentValue(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "OnSetShowCurrentValue");

	Params::AttributeSlotUserWidget_OnSetShowCurrentValue Parms{};

	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AttributeSlotUserWidget.SetActualValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::SetActualValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "SetActualValue");

	Params::AttributeSlotUserWidget_SetActualValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeSlotUserWidget.SetCurrentValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::SetCurrentValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "SetCurrentValue");

	Params::AttributeSlotUserWidget_SetCurrentValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeSlotUserWidget.SetNewValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::SetNewValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "SetNewValue");

	Params::AttributeSlotUserWidget_SetNewValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeSlotUserWidget.SetShowCurrentValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeSlotUserWidget::SetShowCurrentValue(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "SetShowCurrentValue");

	Params::AttributeSlotUserWidget_SetShowCurrentValue Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeSlotUserWidget.GetFormattedAttributeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAttributeSlotUserWidget::GetFormattedAttributeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "GetFormattedAttributeName");

	Params::AttributeSlotUserWidget_GetFormattedAttributeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeSlotUserWidget.GetFormattedValueText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAttributeSlotUserWidget::GetFormattedValueText(float Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "GetFormattedValueText");

	Params::AttributeSlotUserWidget_GetFormattedValueText Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeSlotUserWidget.IsShowActualValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAttributeSlotUserWidget::IsShowActualValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeSlotUserWidget", "IsShowActualValue");

	Params::AttributeSlotUserWidget_IsShowActualValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetGamepadHotkeyImages
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputDisplay                           InInputDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UInteractButtonUserWidget::GetGamepadHotkeyImages(EInputDisplay InInputDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetGamepadHotkeyImages");

	Params::InteractButtonUserWidget_GetGamepadHotkeyImages Parms{};

	Parms.InInputDisplay = InInputDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetHotkeyIconUserWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UImage*>                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UImage*> UInteractButtonUserWidget::GetHotkeyIconUserWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetHotkeyIconUserWidgets");

	Params::InteractButtonUserWidget_GetHotkeyIconUserWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetHotkeyTextBorderUserWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UBorder*>                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UBorder*> UInteractButtonUserWidget::GetHotkeyTextBorderUserWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetHotkeyTextBorderUserWidgets");

	Params::InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetHotkeyTextUserWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTextBlock*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UTextBlock*> UInteractButtonUserWidget::GetHotkeyTextUserWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetHotkeyTextUserWidgets");

	Params::InteractButtonUserWidget_GetHotkeyTextUserWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetKeyboardHotkeyImages
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bOnlyPrimary                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlySecondary                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UInteractButtonUserWidget::GetKeyboardHotkeyImages(bool bOnlyPrimary, bool bOnlySecondary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetKeyboardHotkeyImages");

	Params::InteractButtonUserWidget_GetKeyboardHotkeyImages Parms{};

	Parms.bOnlyPrimary = bOnlyPrimary;
	Parms.bOnlySecondary = bOnlySecondary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.GetKeyboardHotkeyText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bOnlyPrimary                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlySecondary                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UInteractButtonUserWidget::GetKeyboardHotkeyText(bool bOnlyPrimary, bool bOnlySecondary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetKeyboardHotkeyText");

	Params::InteractButtonUserWidget_GetKeyboardHotkeyText Parms{};

	Parms.bOnlyPrimary = bOnlyPrimary;
	Parms.bOnlySecondary = bOnlySecondary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.HandleButtonDisabledPressed
// (Final, Native, Protected)

void UInteractButtonUserWidget::HandleButtonDisabledPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "HandleButtonDisabledPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractButtonUserWidget.HandleButtonPressed
// (Final, Native, Protected)

void UInteractButtonUserWidget::HandleButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "HandleButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractButtonUserWidget.HandleButtonReleased
// (Final, Native, Protected)

void UInteractButtonUserWidget::HandleButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "HandleButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractButtonUserWidget.OnSetHold
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInHold                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractButtonUserWidget::OnSetHold(bool bInHold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "OnSetHold");

	Params::InteractButtonUserWidget_OnSetHold Parms{};

	Parms.bInHold = bInHold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InteractButtonUserWidget.OnSetHotkeyImages
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               HotkeyImages                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInteractButtonUserWidget::OnSetHotkeyImages(const TArray<class UTexture2D*>& HotkeyImages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "OnSetHotkeyImages");

	Params::InteractButtonUserWidget_OnSetHotkeyImages Parms{};

	Parms.HotkeyImages = std::move(HotkeyImages);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InteractButtonUserWidget.OnSetHotkeyText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FText>                     HotkeyTexts                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInteractButtonUserWidget::OnSetHotkeyText(const TArray<class FText>& HotkeyTexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "OnSetHotkeyText");

	Params::InteractButtonUserWidget_OnSetHotkeyText Parms{};

	Parms.HotkeyTexts = std::move(HotkeyTexts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InteractButtonUserWidget.OnSetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInCaption1Active                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCaption2Active                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractButtonUserWidget::OnSetState(bool bInCaption1Active, bool bInCaption2Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "OnSetState");

	Params::InteractButtonUserWidget_OnSetState Parms{};

	Parms.bInCaption1Active = bInCaption1Active;
	Parms.bInCaption2Active = bInCaption2Active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InteractButtonUserWidget.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCaption1Active                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCaption2Active                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractButtonUserWidget::SetState(bool bInCaption1Active, bool bInCaption2Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "SetState");

	Params::InteractButtonUserWidget_SetState Parms{};

	Parms.bInCaption1Active = bInCaption1Active;
	Parms.bInCaption2Active = bInCaption2Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractButtonUserWidget.GetElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractButtonUserWidget::GetElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "GetElapsedTime");

	Params::InteractButtonUserWidget_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractButtonUserWidget::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "IsActive");

	Params::InteractButtonUserWidget_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InteractButtonUserWidget.IsHold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractButtonUserWidget::IsHold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractButtonUserWidget", "IsHold");

	Params::InteractButtonUserWidget_IsHold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsHotkeyBtnUserWidget.OnSetEmpty
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEmpty                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsHotkeyBtnUserWidget::OnSetEmpty(bool bInEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsHotkeyBtnUserWidget", "OnSetEmpty");

	Params::OptionsHotkeyBtnUserWidget_OnSetEmpty Parms{};

	Parms.bInEmpty = bInEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsHotkeyBtnUserWidget.OnSetLocked
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsHotkeyBtnUserWidget::OnSetLocked(bool bInLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsHotkeyBtnUserWidget", "OnSetLocked");

	Params::OptionsHotkeyBtnUserWidget_OnSetLocked Parms{};

	Parms.bInLocked = bInLocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsHotkeyBtnUserWidget.OnSetWaiting
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInWaiting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsHotkeyBtnUserWidget::OnSetWaiting(bool bInWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsHotkeyBtnUserWidget", "OnSetWaiting");

	Params::OptionsHotkeyBtnUserWidget_OnSetWaiting Parms{};

	Parms.bInWaiting = bInWaiting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsHotkeyBtnUserWidget.SetWaiting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInWaiting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsHotkeyBtnUserWidget::SetWaiting(bool bInWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsHotkeyBtnUserWidget", "SetWaiting");

	Params::OptionsHotkeyBtnUserWidget_SetWaiting Parms{};

	Parms.bInWaiting = bInWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EventOnHit.OnPostDamageDone
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEventOnHit::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventOnHit", "OnPostDamageDone");

	Params::EventOnHit_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractiveCatAbility.OnLevelsChanged
// (Final, Native, Public)

void UInteractiveCatAbility::OnLevelsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveCatAbility", "OnLevelsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PrimalVFX.InterpolateMaterials
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstance*>        Sources                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           Alphas                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ScalarParameterNames                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     VectorParameterNames                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             UniquenessWeightParameterName                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   UniquenessWeightPower                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimalVFX::InterpolateMaterials(class UMeshComponent* MeshComponent, const TArray<class UMaterialInstance*>& Sources, const TArray<float>& Alphas, const TArray<class FName>& ScalarParameterNames, const TArray<class FName>& VectorParameterNames, class FName UniquenessWeightParameterName, float UniquenessWeightPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVFX", "InterpolateMaterials");

	Params::PrimalVFX_InterpolateMaterials Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.Sources = std::move(Sources);
	Parms.Alphas = std::move(Alphas);
	Parms.ScalarParameterNames = std::move(ScalarParameterNames);
	Parms.VectorParameterNames = std::move(VectorParameterNames);
	Parms.UniquenessWeightParameterName = UniquenessWeightParameterName;
	Parms.UniquenessWeightPower = UniquenessWeightPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaosTenticles.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaosTenticles::AbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosTenticles", "AbilityStart");

	Params::ChaosTenticles_AbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaosTenticles.AnimEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaosTenticles::AnimEvent(class UAbilityBase* Ability, class UAnimID* Anim, EAnimEventType AnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosTenticles", "AnimEvent");

	Params::ChaosTenticles_AnimEvent Parms{};

	Parms.Ability = Ability;
	Parms.Anim = Anim;
	Parms.AnimEventType = AnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaosTenticles.ResourceUsed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaosTenticles::ResourceUsed(EEntityProperty resource, float* Delta, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosTenticles", "ResourceUsed");

	Params::ChaosTenticles_ResourceUsed Parms{};

	Parms.resource = resource;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Delta != nullptr)
		*Delta = Parms.Delta;
}


// Function man.ItemAbility.BPGetEnchantItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UItemEnchantItemAbility*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UItemEnchantItemAbility*> UItemAbility::BPGetEnchantItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetEnchantItems");

	Params::ItemAbility_BPGetEnchantItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetItemFlavorText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemAbility::BPGetItemFlavorText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetItemFlavorText");

	Params::ItemAbility_BPGetItemFlavorText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetItemName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemAbility::BPGetItemName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetItemName");

	Params::ItemAbility_BPGetItemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetPermanentEnchantIcons
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UItemAbility::BPGetPermanentEnchantIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetPermanentEnchantIcons");

	Params::ItemAbility_BPGetPermanentEnchantIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetTemporaryEnchantIcons
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UItemAbility::BPGetTemporaryEnchantIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetTemporaryEnchantIcons");

	Params::ItemAbility_BPGetTemporaryEnchantIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UItemAbility::BPGetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetIcon");

	Params::ItemAbility_BPGetIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemAbility.BPGetIconTransparent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UItemAbility::BPGetIconTransparent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAbility", "BPGetIconTransparent");

	Params::ItemAbility_BPGetIconTransparent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsVideoUserWidget.OnDialogueKeepResolutionResult
// (Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsVideoUserWidget::OnDialogueKeepResolutionResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoUserWidget", "OnDialogueKeepResolutionResult");

	Params::OptionsVideoUserWidget_OnDialogueKeepResolutionResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsVideoUserWidget.OnSetVramText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             VRamText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsVideoUserWidget::OnSetVramText(const class FText& VRamText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoUserWidget", "OnSetVramText");

	Params::OptionsVideoUserWidget_OnSetVramText Parms{};

	Parms.VRamText = std::move(VRamText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsVideoUserWidget.SetDisplayModeIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewDisplayModeIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsVideoUserWidget::SetDisplayModeIndex(int32 NewDisplayModeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoUserWidget", "SetDisplayModeIndex");

	Params::OptionsVideoUserWidget_SetDisplayModeIndex Parms{};

	Parms.NewDisplayModeIndex = NewDisplayModeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsVideoUserWidget.SetResolutionIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewResolutionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsVideoUserWidget::SetResolutionIndex(int32 NewResolutionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoUserWidget", "SetResolutionIndex");

	Params::OptionsVideoUserWidget_SetResolutionIndex Parms{};

	Parms.NewResolutionIndex = NewResolutionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsVideoUserWidget.HasResolutionChanged
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsVideoUserWidget::HasResolutionChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoUserWidget", "HasResolutionChanged");

	Params::OptionsVideoUserWidget_HasResolutionChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorUserWidgetBase.BPSetFilter
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UVendorFilterSlotUserWidget*      VendorFilterSlotUserWidget                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::BPSetFilter(class UVendorFilterSlotUserWidget* VendorFilterSlotUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "BPSetFilter");

	Params::VendorUserWidgetBase_BPSetFilter Parms{};

	Parms.VendorFilterSlotUserWidget = VendorFilterSlotUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.CloseWindowRequest
// (Native, Protected, BlueprintCallable)

void UVendorUserWidgetBase::CloseWindowRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "CloseWindowRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.DecreaseSelectedCount
// (Final, Native, Protected, BlueprintCallable)

void UVendorUserWidgetBase::DecreaseSelectedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "DecreaseSelectedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.GetFocusedItemHeroInventoryStackNum
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorUserWidgetBase::GetFocusedItemHeroInventoryStackNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "GetFocusedItemHeroInventoryStackNum");

	Params::VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorUserWidgetBase.IncreaseSelectedCount
// (Final, Native, Protected, BlueprintCallable)

void UVendorUserWidgetBase::IncreaseSelectedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "IncreaseSelectedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.JumpToNextFilter
// (Final, Native, Protected, BlueprintCallable)

void UVendorUserWidgetBase::JumpToNextFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "JumpToNextFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.JumpToPrevFilter
// (Final, Native, Protected, BlueprintCallable)

void UVendorUserWidgetBase::JumpToPrevFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "JumpToPrevFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.OnSetCurrency
// (Event, Protected, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnSetCurrency(EHeroProperty PropertyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnSetCurrency");

	Params::VendorUserWidgetBase_OnSetCurrency Parms{};

	Parms.PropertyType = PropertyType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUserWidgetBase.OnSetFilterSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EItemSlot                               ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             FilterName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnSetFilterSlot(EItemSlot ItemSlot, const class FText& FilterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnSetFilterSlot");

	Params::VendorUserWidgetBase_OnSetFilterSlot Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.FilterName = std::move(FilterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUserWidgetBase.OnSetSelectedItemProperty
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InItemIcon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InItemName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InSelectedCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InPriceText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InPriceGoldValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InPriceEssenceValue                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InRequirementText                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InItemTypeText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bHasEnoughGold                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasEnoughEssence                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnSetSelectedItemProperty(class UTexture2D* InItemIcon, const class FText& InItemName, int32 InSelectedCount, int32 InMaxCount, const class FText& InPriceText, const class FText& InPriceGoldValue, const class FText& InPriceEssenceValue, const class FText& InRequirementText, const class FText& InItemTypeText, bool bHasEnoughGold, bool bHasEnoughEssence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnSetSelectedItemProperty");

	Params::VendorUserWidgetBase_OnSetSelectedItemProperty Parms{};

	Parms.InItemIcon = InItemIcon;
	Parms.InItemName = std::move(InItemName);
	Parms.InSelectedCount = InSelectedCount;
	Parms.InMaxCount = InMaxCount;
	Parms.InPriceText = std::move(InPriceText);
	Parms.InPriceGoldValue = std::move(InPriceGoldValue);
	Parms.InPriceEssenceValue = std::move(InPriceEssenceValue);
	Parms.InRequirementText = std::move(InRequirementText);
	Parms.InItemTypeText = std::move(InItemTypeText);
	Parms.bHasEnoughGold = bHasEnoughGold;
	Parms.bHasEnoughEssence = bHasEnoughEssence;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUserWidgetBase.OnSetVendorName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             VendorName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnSetVendorName(const class FText& VendorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnSetVendorName");

	Params::VendorUserWidgetBase_OnSetVendorName Parms{};

	Parms.VendorName = std::move(VendorName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUserWidgetBase.OnUpdateDetailsPanel
// (Native, Public)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnUpdateDetailsPanel(class UManItemSlotBase* ManItemSlotBase, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnUpdateDetailsPanel");

	Params::VendorUserWidgetBase_OnUpdateDetailsPanel Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorUserWidgetBase.OnUpdateSelectedItemDetailsPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemRequirementText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InComparedItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUserWidgetBase::OnUpdateSelectedItemDetailsPanel(const class FText& ItemRequirementText, class UItemAbility* InItem, class UItemAbility* InComparedItem, bool bEquipped, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "OnUpdateSelectedItemDetailsPanel");

	Params::VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel Parms{};

	Parms.ItemRequirementText = std::move(ItemRequirementText);
	Parms.InItem = InItem;
	Parms.InComparedItem = InComparedItem;
	Parms.bEquipped = bEquipped;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUserWidgetBase.GetFocusedInventorySlotUserWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventorySlotUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventorySlotUserWidget* UVendorUserWidgetBase::GetFocusedInventorySlotUserWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "GetFocusedInventorySlotUserWidget");

	Params::VendorUserWidgetBase_GetFocusedInventorySlotUserWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorUserWidgetBase.IsChangeValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorUserWidgetBase::IsChangeValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUserWidgetBase", "IsChangeValue");

	Params::VendorUserWidgetBase_IsChangeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorSellUserWidget.BPSellItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorSellUserWidget::BPSellItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorSellUserWidget", "BPSellItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorSellUserWidget.BPSellMaxItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorSellUserWidget::BPSellMaxItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorSellUserWidget", "BPSellMaxItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorSellUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorSellUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorSellUserWidget", "OnFocusWidgetChangedEvent");

	Params::VendorSellUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorSellUserWidget.OnSellItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FSellHistoryItem                 SellHistoryItem                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UVendorSellUserWidget::OnSellItem(const struct FSellHistoryItem& SellHistoryItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorSellUserWidget", "OnSellItem");

	Params::VendorSellUserWidget_OnSellItem Parms{};

	Parms.SellHistoryItem = std::move(SellHistoryItem);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterTransform.BPContinueGameplay
// (Final, Native, Public, BlueprintCallable)

void UCharacterTransform::BPContinueGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterTransform", "BPContinueGameplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterTransform.BPSpawnTarget
// (Final, Native, Public, BlueprintCallable)

void UCharacterTransform::BPSpawnTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterTransform", "BPSpawnTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterTransform.OnAnimEventBase_Target
// (Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterTransform::OnAnimEventBase_Target(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterTransform", "OnAnimEventBase_Target");

	Params::CharacterTransform_OnAnimEventBase_Target Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.VisualEntity.AttachParentAnimEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          InAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          InAnimEventType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::AttachParentAnimEvent(class UAbilityBase* InAbility, class UAnimID* InAnim, EAnimEventType InAnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "AttachParentAnimEvent");

	Params::VisualEntity_AttachParentAnimEvent Parms{};

	Parms.InAbility = InAbility;
	Parms.InAnim = InAnim;
	Parms.InAnimEventType = InAnimEventType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VisualEntity.AttachParentWeaponTrail
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::AttachParentWeaponTrail(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "AttachParentWeaponTrail");

	Params::VisualEntity_AttachParentWeaponTrail Parms{};

	Parms.bStart = bStart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VisualEntity.Kill
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDetachFromActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::Kill(bool bDetachFromActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "Kill");

	Params::VisualEntity_Kill Parms{};

	Parms.bDetachFromActor = bDetachFromActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.OnCascadeSystemFinished
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent*         PSystem                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::OnCascadeSystemFinished(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "OnCascadeSystemFinished");

	Params::VisualEntity_OnCascadeSystemFinished Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.OnKill
// (Event, Protected, BlueprintEvent)

void AVisualEntity::OnKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "OnKill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VisualEntity.OnNiagaraSystemFinished
// (Final, Native, Protected)
// Parameters:
// class UNiagaraComponent*                PSystem                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::OnNiagaraSystemFinished(class UNiagaraComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "OnNiagaraSystemFinished");

	Params::VisualEntity_OnNiagaraSystemFinished Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetDeathFadeRate
// (Final, Native, Protected)
// Parameters:
// float                                   DeathFadeRate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSet                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetDeathFadeRate(float DeathFadeRate, bool bForceSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetDeathFadeRate");

	Params::VisualEntity_SetDeathFadeRate Parms{};

	Parms.DeathFadeRate = DeathFadeRate;
	Parms.bForceSet = bForceSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetDecalColorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetDecalColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetDecalColorParameter");

	Params::VisualEntity_SetDecalColorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetDecalFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetDecalFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetDecalFloatParameter");

	Params::VisualEntity_SetDecalFloatParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetParticleColorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetParticleColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetParticleColorParameter");

	Params::VisualEntity_SetParticleColorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetParticleFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetParticleFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetParticleFloatParameter");

	Params::VisualEntity_SetParticleFloatParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.SetParticleVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisualEntity::SetParticleVectorParameter(class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "SetParticleVectorParameter");

	Params::VisualEntity_SetParticleVectorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VisualEntity.VisualEntityConstructionFinished
// (Event, Protected, BlueprintEvent)

void AVisualEntity::VisualEntityConstructionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisualEntity", "VisualEntityConstructionFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.KingPriestAttackCatharsis.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestAttackCatharsis::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestAttackCatharsis", "BPGetTeleportLocation");

	Params::KingPriestAttackCatharsis_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntropyLantern.GetLifeAuraRadiusRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEntropyLantern::GetLifeAuraRadiusRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyLantern", "GetLifeAuraRadiusRate");

	Params::EntropyLantern_GetLifeAuraRadiusRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntropyLantern.GetLifeAuraRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEntropyLantern::GetLifeAuraRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyLantern", "GetLifeAuraRate");

	Params::EntropyLantern_GetLifeAuraRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntropyLantern.GetLifeAuraValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEntropyLantern::GetLifeAuraValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyLantern", "GetLifeAuraValue");

	Params::EntropyLantern_GetLifeAuraValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntropyLantern.GetMaxLifeAuraValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEntropyLantern::GetMaxLifeAuraValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyLantern", "GetMaxLifeAuraValue");

	Params::EntropyLantern_GetMaxLifeAuraValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntropyLantern.IsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEntropyLantern::IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyLantern", "IsActive");

	Params::EntropyLantern_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.KingPriestSelfProjection.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestSelfProjection::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestSelfProjection", "BPGetTeleportLocation");

	Params::KingPriestSelfProjection_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PanningAgentBase.EnableHeroCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APanningAgentBase::EnableHeroCollision(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanningAgentBase", "EnableHeroCollision");

	Params::PanningAgentBase_EnableHeroCollision Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PanningAgentBase.EnableHeroGodmode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APanningAgentBase::EnableHeroGodmode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanningAgentBase", "EnableHeroGodmode");

	Params::PanningAgentBase_EnableHeroGodmode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PanningAgentBase.SetHeroLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APanningAgentBase::SetHeroLocation(const struct FVector& NewLocation, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanningAgentBase", "SetHeroLocation");

	Params::PanningAgentBase_SetHeroLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PanningAgentBase.GetHeroGroundSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APanningAgentBase::GetHeroGroundSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanningAgentBase", "GetHeroGroundSpeed");

	Params::PanningAgentBase_GetHeroGroundSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PanningAgentBase.GetHeroLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APanningAgentBase::GetHeroLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanningAgentBase", "GetHeroLocation");

	Params::PanningAgentBase_GetHeroLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationPortraitUserWidget.GetVideoDimensions
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIdleBridge                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UConversationPortraitUserWidget::GetVideoDimensions(bool bIdleBridge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "GetVideoDimensions");

	Params::ConversationPortraitUserWidget_GetVideoDimensions Parms{};

	Parms.bIdleBridge = bIdleBridge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationPortraitUserWidget.OnHideSlot
// (Event, Protected, BlueprintEvent)

void UConversationPortraitUserWidget::OnHideSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "OnHideSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ConversationPortraitUserWidget.OnMediaIdleBridgeReachedEnd
// (Final, Native, Protected)

void UConversationPortraitUserWidget::OnMediaIdleBridgeReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "OnMediaIdleBridgeReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationPortraitUserWidget.OnMediaReachedEnd
// (Final, Native, Protected)

void UConversationPortraitUserWidget::OnMediaReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "OnMediaReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationPortraitUserWidget.OnMediaSecondReachedEnd
// (Final, Native, Protected)

void UConversationPortraitUserWidget::OnMediaSecondReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "OnMediaSecondReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationPortraitUserWidget.OnShowSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FConversationSpeakerInfo         InSpeakerInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationPortraitUserWidget::OnShowSlot(const struct FConversationSpeakerInfo& InSpeakerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "OnShowSlot");

	Params::ConversationPortraitUserWidget_OnShowSlot Parms{};

	Parms.InSpeakerInfo = std::move(InSpeakerInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationPortraitUserWidget.PlayVideo
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           VideoUrl                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIdleBridge                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationPortraitUserWidget::PlayVideo(const class FString& VideoUrl, bool bIdleBridge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationPortraitUserWidget", "PlayVideo");

	Params::ConversationPortraitUserWidget_PlayVideo Parms{};

	Parms.VideoUrl = std::move(VideoUrl);
	Parms.bIdleBridge = bIdleBridge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorComponentBase.GetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorComponentBase::GetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetActor");

	Params::ActorComponentBase_GetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.GetActorBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActorBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActorBase* UActorComponentBase::GetActorBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetActorBase");

	Params::ActorComponentBase_GetActorBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.GetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterBase* UActorComponentBase::GetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetCharacter");

	Params::ActorComponentBase_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.GetGameFrame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActorComponentBase::GetGameFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetGameFrame");

	Params::ActorComponentBase_GetGameFrame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.GetGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UActorComponentBase::GetGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetGameMode");

	Params::ActorComponentBase_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.GetGameTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorComponentBase::GetGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "GetGameTime");

	Params::ActorComponentBase_GetGameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorComponentBase.IsAlive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentBase::IsAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorComponentBase", "IsAlive");

	Params::ActorComponentBase_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPAddAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UAbilityController::BPAddAbility(TSubclassOf<class UAbilityBase> AbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPAddAbility");

	Params::AbilityController_BPAddAbility Parms{};

	Parms.AbilityClass = AbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPAddHitBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHitBox*                          HitBox                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::BPAddHitBox(class UHitBox* HitBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPAddHitBox");

	Params::AbilityController_BPAddHitBox Parms{};

	Parms.HitBox = HitBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPForcedCombatAdd
// (Final, Native, Public, BlueprintCallable)

void UAbilityController::BPForcedCombatAdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPForcedCombatAdd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPForcedCombatRemove
// (Final, Native, Public, BlueprintCallable)

void UAbilityController::BPForcedCombatRemove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPForcedCombatRemove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPForceOutOfCombatAdd
// (Final, Native, Public, BlueprintCallable)

void UAbilityController::BPForceOutOfCombatAdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPForceOutOfCombatAdd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPForceOutOfCombatRemove
// (Final, Native, Public, BlueprintCallable)

void UAbilityController::BPForceOutOfCombatRemove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPForceOutOfCombatRemove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPGetAbilityByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSub                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UAbilityController::BPGetAbilityByClass(class UClass* AbilityClass, bool bSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPGetAbilityByClass");

	Params::AbilityController_BPGetAbilityByClass Parms{};

	Parms.AbilityClass = AbilityClass;
	Parms.bSub = bSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPGetAbilityByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UAbilityController::BPGetAbilityByName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPGetAbilityByName");

	Params::AbilityController_BPGetAbilityByName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPGetSummoner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilityController::BPGetSummoner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPGetSummoner");

	Params::AbilityController_BPGetSummoner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPGetVarlist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVarlist*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVarlist* UAbilityController::BPGetVarlist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPGetVarlist");

	Params::AbilityController_BPGetVarlist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPKill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               Killer_0                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::BPKill(class UAbilityController* Killer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPKill");

	Params::AbilityController_BPKill Parms{};

	Parms.Killer_0 = Killer_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPRemoveAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubclass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityController::BPRemoveAbility(TSubclassOf<class UAbilityBase> AbilityClass, bool bSubclass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPRemoveAbility");

	Params::AbilityController_BPRemoveAbility Parms{};

	Parms.AbilityClass = AbilityClass;
	Parms.bSubclass = bSubclass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.BPSetGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInGodMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::BPSetGodMode(bool bInGodMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPSetGodMode");

	Params::AbilityController_BPSetGodMode Parms{};

	Parms.bInGodMode = bInGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPStartAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreventHardSleep                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::BPStartAnim(class UAnimID* AnimID, bool bAutoEnd, bool bPreventHardSleep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPStartAnim");

	Params::AbilityController_BPStartAnim Parms{};

	Parms.AnimID = AnimID;
	Parms.bAutoEnd = bAutoEnd;
	Parms.bPreventHardSleep = bPreventHardSleep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.BPStopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::BPStopAnim(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "BPStopAnim");

	Params::AbilityController_BPStopAnim Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityController.GetAFKTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAbilityController::GetAFKTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetAFKTime");

	Params::AbilityController_GetAFKTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAIBase*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAIBase* UAbilityController::GetAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetAI");

	Params::AbilityController_GetAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetAirAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAirAI*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAirAI* UAbilityController::GetAirAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetAirAI");

	Params::AbilityController_GetAirAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* UAbilityController::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetAttributeContainer");

	Params::AbilityController_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetGroundAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBasicAI*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBasicAI* UAbilityController::GetGroundAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetGroundAI");

	Params::AbilityController_GetGroundAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetHeroAbilityData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHeroAbilitiesData*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHeroAbilitiesData* UAbilityController::GetHeroAbilityData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetHeroAbilityData");

	Params::AbilityController_GetHeroAbilityData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetHitReactionPassive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHitReactionPassive*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHitReactionPassive* UAbilityController::GetHitReactionPassive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetHitReactionPassive");

	Params::AbilityController_GetHitReactionPassive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UAbilityController::GetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetInventory");

	Params::AbilityController_GetInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.GetPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UAbilityController::GetPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "GetPlayerController");

	Params::AbilityController_GetPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbilityController.WakeUpSignal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityController::WakeUpSignal(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityController", "WakeUpSignal");

	Params::AbilityController_WakeUpSignal Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.ContinueGameBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UMainMenuUserWidget::ContinueGameBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "ContinueGameBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.HasValidSaveGameSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMainMenuUserWidget::HasValidSaveGameSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "HasValidSaveGameSlot");

	Params::MainMenuUserWidget_HasValidSaveGameSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MainMenuUserWidget.LoadGameBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UMainMenuUserWidget::LoadGameBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "LoadGameBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.NewGameBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UMainMenuUserWidget::NewGameBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "NewGameBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.OnDeleteSaveGame
// (Final, Native, Protected)
// Parameters:
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuUserWidget::OnDeleteSaveGame(bool bSucceeded, int32 SlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "OnDeleteSaveGame");

	Params::MainMenuUserWidget_OnDeleteSaveGame Parms{};

	Parms.bSucceeded = bSucceeded;
	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.OnSaveGameSlotsArrayChanged
// (Event, Public, BlueprintEvent)

void UMainMenuUserWidget::OnSaveGameSlotsArrayChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "OnSaveGameSlotsArrayChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.MainMenuUserWidget.OptionsBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UMainMenuUserWidget::OptionsBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "OptionsBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MainMenuUserWidget.QuitBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UMainMenuUserWidget::QuitBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuUserWidget", "QuitBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NecroEscape.OnLanded
// (Final, Native, Public)

void UNecroEscape::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NecroEscape", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.EternalRagePassive.PropertyChanged
// (Final, Native, Public)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEternalRagePassive::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EternalRagePassive", "PropertyChanged");

	Params::EternalRagePassive_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AbilityUpgradeSlotUserWidget.OnSetConnectionsVisibility
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<ESkillUpgradeConnectionType>     SkillUpgradeConnectionTypes                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAbilityUpgradeSlotUserWidget::OnSetConnectionsVisibility(const TArray<ESkillUpgradeConnectionType>& SkillUpgradeConnectionTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnSetConnectionsVisibility");

	Params::AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility Parms{};

	Parms.SkillUpgradeConnectionTypes = std::move(SkillUpgradeConnectionTypes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityUpgradeSlotUserWidget.OnSetIcon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InIcon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityUpgradeSlotUserWidget::OnSetIcon(const class UTexture2D* InIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnSetIcon");

	Params::AbilityUpgradeSlotUserWidget_OnSetIcon Parms{};

	Parms.InIcon = InIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityUpgradeSlotUserWidget.OnSetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAbilityUpgradeState                    InAbilityUpgradeState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityUpgradeSlotUserWidget::OnSetState(EAbilityUpgradeState InAbilityUpgradeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnSetState");

	Params::AbilityUpgradeSlotUserWidget_OnSetState Parms{};

	Parms.InAbilityUpgradeState = InAbilityUpgradeState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityUpgradeSlotUserWidget.OnSetUpgradeIcon
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   UpgradeIconID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityUpgradeSlotUserWidget::OnSetUpgradeIcon(int32 UpgradeIconID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnSetUpgradeIcon");

	Params::AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon Parms{};

	Parms.UpgradeIconID = UpgradeIconID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.AbilityUpgradeSlotUserWidget.OnUpgradeFinished
// (Event, Public, BlueprintEvent)

void UAbilityUpgradeSlotUserWidget::OnUpgradeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnUpgradeFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.AbilityUpgradeSlotUserWidget.OnUpgradeStart
// (Event, Public, BlueprintEvent)

void UAbilityUpgradeSlotUserWidget::OnUpgradeStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnUpgradeStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.AbilityUpgradeSlotUserWidget.OnUpgradeStop
// (Event, Public, BlueprintEvent)

void UAbilityUpgradeSlotUserWidget::OnUpgradeStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityUpgradeSlotUserWidget", "OnUpgradeStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.EnergyShieldAbilityComponent.OnPreDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UEnergyShieldAbilityComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyShieldAbilityComponent", "OnPreDamaged");

	Params::EnergyShieldAbilityComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AbsorbDamageAbilityComponent.GetLastIncomingDamagePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAbsorbDamageAbilityComponent::GetLastIncomingDamagePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbsorbDamageAbilityComponent", "GetLastIncomingDamagePoint");

	Params::AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AbsorbDamageAbilityComponent.OnPreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UAbsorbDamageAbilityComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbsorbDamageAbilityComponent", "OnPreDamaged");

	Params::AbsorbDamageAbilityComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ActiveAbilFilterSlotUserWidget.OnSetEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilFilterSlotUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "OnSetEnabled");

	Params::ActiveAbilFilterSlotUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilFilterSlotUserWidget.OnSetItemIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ItemIcon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilFilterSlotUserWidget::OnSetItemIcon(class UTexture2D* ItemIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "OnSetItemIcon");

	Params::ActiveAbilFilterSlotUserWidget_OnSetItemIcon Parms{};

	Parms.ItemIcon = ItemIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilFilterSlotUserWidget.OnSetSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilFilterSlotUserWidget::OnSetSelected(bool bInSelected, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "OnSetSelected");

	Params::ActiveAbilFilterSlotUserWidget_OnSetSelected Parms{};

	Parms.bInSelected = bInSelected;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilFilterSlotUserWidget.OnSetVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilFilterSlotUserWidget::OnSetVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "OnSetVisible");

	Params::ActiveAbilFilterSlotUserWidget_OnSetVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilFilterSlotUserWidget.OnToggleHasSkillBook
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilFilterSlotUserWidget::OnToggleHasSkillBook(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "OnToggleHasSkillBook");

	Params::ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilFilterSlotUserWidget.GetAbilityWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponType UActiveAbilFilterSlotUserWidget::GetAbilityWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "GetAbilityWeaponType");

	Params::ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActiveAbilFilterSlotUserWidget.IsFilterEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActiveAbilFilterSlotUserWidget::IsFilterEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilFilterSlotUserWidget", "IsFilterEnabled");

	Params::ActiveAbilFilterSlotUserWidget_IsFilterEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterSlotUserWidget.OnSetEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSlotUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSlotUserWidget", "OnSetEnabled");

	Params::CreateCharacterSlotUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterSlotUserWidget.OnSetFocusAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSlotUserWidget::OnSetFocusAnim(bool bInFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSlotUserWidget", "OnSetFocusAnim");

	Params::CreateCharacterSlotUserWidget_OnSetFocusAnim Parms{};

	Parms.bInFocused = bInFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterSlotUserWidget.OnSetIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSlotUserWidget::OnSetIcon(class UTexture2D* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSlotUserWidget", "OnSetIcon");

	Params::CreateCharacterSlotUserWidget_OnSetIcon Parms{};

	Parms.Icon = Icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapCharacterUserWidget.OnSetFacing
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bLeft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapCharacterUserWidget::OnSetFacing(bool bLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCharacterUserWidget", "OnSetFacing");

	Params::MapCharacterUserWidget_OnSetFacing Parms{};

	Parms.bLeft = bLeft;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManDLCManager.IsManDLCOwned
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EManDLC                                 DLC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManDLCManager::IsManDLCOwned(EManDLC DLC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManDLCManager", "IsManDLCOwned");

	Params::ManDLCManager_IsManDLCOwned Parms{};

	Parms.DLC = DLC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillUpgradeWindowUserWidget.OnHasEnoughResource
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHasEnoughResource                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillUpgradeWindowUserWidget::OnHasEnoughResource(bool bHasEnoughResource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "OnHasEnoughResource");

	Params::SkillUpgradeWindowUserWidget_OnHasEnoughResource Parms{};

	Parms.bHasEnoughResource = bHasEnoughResource;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillUpgradeWindowUserWidget.OnPropertyChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillUpgradeWindowUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "OnPropertyChanged");

	Params::SkillUpgradeWindowUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillUpgradeWindowUserWidget.OnSetSkillsView
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSkillsView                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillUpgradeWindowUserWidget::OnSetSkillsView(bool bInSkillsView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "OnSetSkillsView");

	Params::SkillUpgradeWindowUserWidget_OnSetSkillsView Parms{};

	Parms.bInSkillsView = bInSkillsView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillUpgradeWindowUserWidget.OnUpdateUpgradeDetails
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillUpgradeWindowUserWidget::OnUpdateUpgradeDetails(const class FText& Description, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "OnUpdateUpgradeDetails");

	Params::SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails Parms{};

	Parms.Description = std::move(Description);
	Parms.Cost = Cost;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillUpgradeWindowUserWidget.PropertyChanged
// (Final, Native, Protected)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillUpgradeWindowUserWidget::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "PropertyChanged");

	Params::SkillUpgradeWindowUserWidget_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkillUpgradeWindowUserWidget.SelectSkill
// (Final, Native, Protected, BlueprintCallable)

void USkillUpgradeWindowUserWidget::SelectSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillUpgradeWindowUserWidget", "SelectSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesUpgradeWindow.OnSetAbilityName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             AbilityName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActiveAbilitiesUpgradeWindow::OnSetAbilityName(const class FText& AbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesUpgradeWindow", "OnSetAbilityName");

	Params::ActiveAbilitiesUpgradeWindow_OnSetAbilityName Parms{};

	Parms.AbilityName = std::move(AbilityName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActiveAbilitiesWindowUserWidget.EndEquipState
// (Final, Native, Public, BlueprintCallable)

void UActiveAbilitiesWindowUserWidget::EndEquipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "EndEquipState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesWindowUserWidget.EndUnequipState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilitySlotUserWidget*           NewFocusedAbilitySlotUserWidget                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilitiesWindowUserWidget::EndUnequipState(class UAbilitySlotUserWidget* NewFocusedAbilitySlotUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "EndUnequipState");

	Params::ActiveAbilitiesWindowUserWidget_EndUnequipState Parms{};

	Parms.NewFocusedAbilitySlotUserWidget = NewFocusedAbilitySlotUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesWindowUserWidget.EquipAbility
// (Final, Native, Public, BlueprintCallable)

void UActiveAbilitiesWindowUserWidget::EquipAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "EquipAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesWindowUserWidget.OnAddItem
// (Final, Native, Protected)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActiveAbilitiesWindowUserWidget::OnAddItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "OnAddItem");

	Params::ActiveAbilitiesWindowUserWidget_OnAddItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesWindowUserWidget.OnEndEquipState
// (Event, Public, BlueprintEvent)

void UActiveAbilitiesWindowUserWidget::OnEndEquipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "OnEndEquipState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActiveAbilitiesWindowUserWidget.OnEndUnequipState
// (Event, Public, BlueprintEvent)

void UActiveAbilitiesWindowUserWidget::OnEndUnequipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "OnEndUnequipState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActiveAbilitiesWindowUserWidget.OnStartEquipState
// (Event, Public, BlueprintEvent)

void UActiveAbilitiesWindowUserWidget::OnStartEquipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "OnStartEquipState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActiveAbilitiesWindowUserWidget.OnStartUnequipState
// (Event, Public, BlueprintEvent)

void UActiveAbilitiesWindowUserWidget::OnStartUnequipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "OnStartUnequipState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ActiveAbilitiesWindowUserWidget.UnequipAbility
// (Final, Native, Public, BlueprintCallable)

void UActiveAbilitiesWindowUserWidget::UnequipAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "UnequipAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActiveAbilitiesWindowUserWidget.ViewUpgrades
// (Final, Native, Public, BlueprintCallable)

void UActiveAbilitiesWindowUserWidget::ViewUpgrades()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActiveAbilitiesWindowUserWidget", "ViewUpgrades");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.WeaponIC.GetRelicChargeDamageType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<EDamageType>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EDamageType> UWeaponIC::GetRelicChargeDamageType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponIC", "GetRelicChargeDamageType");

	Params::WeaponIC_GetRelicChargeDamageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WeaponIC.OnAttributeChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWeaponIC::OnAttributeChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponIC", "OnAttributeChanged");

	Params::WeaponIC_OnAttributeChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.WeaponIC.UIRefresh
// (Final, Native, Public)

void UWeaponIC::UIRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponIC", "UIRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AutosaveScreenUserWidget.OnSetTexts
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Count                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAutosaveScreenUserWidget::OnSetTexts(const class FText& Title, const class FText& Description, const class FText& Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutosaveScreenUserWidget", "OnSetTexts");

	Params::AutosaveScreenUserWidget_OnSetTexts Parms{};

	Parms.Title = std::move(Title);
	Parms.Description = std::move(Description);
	Parms.Count = std::move(Count);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActorCheckPoint.BPActivate
// (Final, Native, Public, BlueprintCallable)

void AActorCheckPoint::BPActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorCheckPoint", "BPActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorCheckPoint.IsCheckPointUnlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActorCheckPoint::IsCheckPointUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorCheckPoint", "IsCheckPointUnlocked");

	Params::ActorCheckPoint_IsCheckPointUnlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorCheckPoint.MapManagerLoaded
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCheckpoinUnlocked                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorCheckPoint::MapManagerLoaded(bool bCheckpoinUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorCheckPoint", "MapManagerLoaded");

	Params::ActorCheckPoint_MapManagerLoaded Parms{};

	Parms.bCheckpoinUnlocked = bCheckpoinUnlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActorCheckPoint.OnBPActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFirstUnlock                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorCheckPoint::OnBPActivated(bool bFirstUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorCheckPoint", "OnBPActivated");

	Params::ActorCheckPoint_OnBPActivated Parms{};

	Parms.bFirstUnlock = bFirstUnlock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ActorCheckPoint.OnCheckPointUnlockSequenceEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorCheckPoint::OnCheckPointUnlockSequenceEnd(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorCheckPoint", "OnCheckPointUnlockSequenceEnd");

	Params::ActorCheckPoint_OnCheckPointUnlockSequenceEnd Parms{};

	Parms.bSuccess = bSuccess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.BasicAttackAbility.BPSetAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          inAnimId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasicAttackAbility::BPSetAnim(class UAnimID* inAnimId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicAttackAbility", "BPSetAnim");

	Params::BasicAttackAbility_BPSetAnim Parms{};

	Parms.inAnimId = inAnimId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ActorSoul.GetBondAbilityController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* AActorSoul::GetBondAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSoul", "GetBondAbilityController");

	Params::ActorSoul_GetBondAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorSoul.GetBondActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActorSoul::GetBondActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSoul", "GetBondActor");

	Params::ActorSoul_GetBondActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorSoul.GetBondActorBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActorBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActorBase* AActorSoul::GetBondActorBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSoul", "GetBondActorBase");

	Params::ActorSoul_GetBondActorBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorSoul.GetBondCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLivingOnly                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterBase* AActorSoul::GetBondCharacter(bool bLivingOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSoul", "GetBondCharacter");

	Params::ActorSoul_GetBondCharacter Parms{};

	Parms.bLivingOnly = bLivingOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorSoul.OnGPEvent_ToggleAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActorSoul*                       EventOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 GameplayEventID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbilityName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Add                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Remove                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActorSoul::OnGPEvent_ToggleAbility(class AActorSoul* EventOwner, class UGameplayEventID* GameplayEventID, TSubclassOf<class UAbilityBase> AbilityClass, class FName AbilityName, bool Enable, bool Disable, bool Start, bool End, bool Add, bool Remove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSoul", "OnGPEvent_ToggleAbility");

	Params::ActorSoul_OnGPEvent_ToggleAbility Parms{};

	Parms.EventOwner = EventOwner;
	Parms.GameplayEventID = GameplayEventID;
	Parms.AbilityClass = AbilityClass;
	Parms.AbilityName = AbilityName;
	Parms.Enable = Enable;
	Parms.Disable = Disable;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Add = Add;
	Parms.Remove = Remove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnemyHPBarUserWidget.OnEnemyHealthBarsVisible
// (Final, Native, Protected)
// Parameters:
// bool                                    bEnemyHealthBarsVisible                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyHPBarUserWidget::OnEnemyHealthBarsVisible(bool bEnemyHealthBarsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnEnemyHealthBarsVisible");

	Params::EnemyHPBarUserWidget_OnEnemyHealthBarsVisible Parms{};

	Parms.bEnemyHealthBarsVisible = bEnemyHealthBarsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnemyHPBarUserWidget.OnHideBarrierDamageText
// (Event, Protected, BlueprintEvent)

void UEnemyHPBarUserWidget::OnHideBarrierDamageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnHideBarrierDamageText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.EnemyHPBarUserWidget.OnHideDamageText
// (Event, Protected, BlueprintEvent)

void UEnemyHPBarUserWidget::OnHideDamageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnHideDamageText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.EnemyHPBarUserWidget.OnSetBarrierDamageValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InBarrierDamageValue                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyHPBarUserWidget::OnSetBarrierDamageValue(int32 InBarrierDamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnSetBarrierDamageValue");

	Params::EnemyHPBarUserWidget_OnSetBarrierDamageValue Parms{};

	Parms.InBarrierDamageValue = InBarrierDamageValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.EnemyHPBarUserWidget.OnSetDamageValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InDamageValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCriticalHit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyHPBarUserWidget::OnSetDamageValue(int32 InDamageValue, bool bInCriticalHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnSetDamageValue");

	Params::EnemyHPBarUserWidget_OnSetDamageValue Parms{};

	Parms.InDamageValue = InDamageValue;
	Parms.bInCriticalHit = bInCriticalHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.EnemyHPBarUserWidget.OnShowBarrierDamageText
// (Event, Protected, BlueprintEvent)

void UEnemyHPBarUserWidget::OnShowBarrierDamageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnShowBarrierDamageText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.EnemyHPBarUserWidget.OnShowDamageText
// (Event, Protected, BlueprintEvent)

void UEnemyHPBarUserWidget::OnShowDamageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyHPBarUserWidget", "OnShowDamageText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HUDAnimatedProgressBarUserWidget.BPSetNewMinMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMax                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LengthRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::BPSetNewMinMax(float NewMin, float NewMax, float LengthRatio, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "BPSetNewMinMax");

	Params::HUDAnimatedProgressBarUserWidget_BPSetNewMinMax Parms{};

	Parms.NewMin = NewMin;
	Parms.NewMax = NewMax;
	Parms.LengthRatio = LengthRatio;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.BPSetNewValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHighlightChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedExtraHighlight                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::BPSetNewValue(float NewValue, bool bHighlightChange, bool bAnimate, bool bNeedExtraHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "BPSetNewValue");

	Params::HUDAnimatedProgressBarUserWidget_BPSetNewValue Parms{};

	Parms.NewValue = NewValue;
	Parms.bHighlightChange = bHighlightChange;
	Parms.bAnimate = bAnimate;
	Parms.bNeedExtraHighlight = bNeedExtraHighlight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.DisplayPercentageOnResourceBars
// (Final, Native, Protected)
// Parameters:
// int32                                   bInDisplayPercentageOnResourceBars                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::DisplayPercentageOnResourceBars(int32 bInDisplayPercentageOnResourceBars)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "DisplayPercentageOnResourceBars");

	Params::HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars Parms{};

	Parms.bInDisplayPercentageOnResourceBars = bInDisplayPercentageOnResourceBars;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.OnAttributeChanged
// (Final, Native, Private)
// Parameters:
// EAttribute                              AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnAttributeChanged(EAttribute AttributeType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnAttributeChanged");

	Params::HUDAnimatedProgressBarUserWidget_OnAttributeChanged Parms{};

	Parms.AttributeType = AttributeType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.OnBossHealthBarsVisible
// (Final, Native, Private)
// Parameters:
// bool                                    bBossHealthBarsVisible                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnBossHealthBarsVisible(bool bBossHealthBarsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnBossHealthBarsVisible");

	Params::HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible Parms{};

	Parms.bBossHealthBarsVisible = bBossHealthBarsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.OnDisplayPercentageOnResourceBars
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInDisplayPercentageOnResourceBars                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnDisplayPercentageOnResourceBars(bool bInDisplayPercentageOnResourceBars)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnDisplayPercentageOnResourceBars");

	Params::HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars Parms{};

	Parms.bInDisplayPercentageOnResourceBars = bInDisplayPercentageOnResourceBars;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAnimatedProgressBarUserWidget.OnPropertyChanged
// (Final, Native, Private)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnPropertyChanged");

	Params::HUDAnimatedProgressBarUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAnimatedProgressBarUserWidget.OnSetHealthBarTypeModifier
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<EHealthBarTypeModifier>          InHealthBarTypeModifiers                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnSetHealthBarTypeModifier(const TArray<EHealthBarTypeModifier>& InHealthBarTypeModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnSetHealthBarTypeModifier");

	Params::HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier Parms{};

	Parms.InHealthBarTypeModifiers = std::move(InHealthBarTypeModifiers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAnimatedProgressBarUserWidget.OnSetNewMinMax
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewMin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMax                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LengthRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnSetNewMinMax(float NewMin, float NewMax, float LengthRatio, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnSetNewMinMax");

	Params::HUDAnimatedProgressBarUserWidget_OnSetNewMinMax Parms{};

	Parms.NewMin = NewMin;
	Parms.NewMax = NewMax;
	Parms.LengthRatio = LengthRatio;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAnimatedProgressBarUserWidget.OnSetNewValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHighlightChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedExtraHighlight                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnSetNewValue(float NewValue, bool bHighlightChange, bool bAnimate, bool bNeedExtraHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnSetNewValue");

	Params::HUDAnimatedProgressBarUserWidget_OnSetNewValue Parms{};

	Parms.NewValue = NewValue;
	Parms.bHighlightChange = bHighlightChange;
	Parms.bAnimate = bAnimate;
	Parms.bNeedExtraHighlight = bNeedExtraHighlight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAnimatedProgressBarUserWidget.OnSetPercentageText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             PercentageText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnSetPercentageText(const class FText& PercentageText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnSetPercentageText");

	Params::HUDAnimatedProgressBarUserWidget_OnSetPercentageText Parms{};

	Parms.PercentageText = std::move(PercentageText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAnimatedProgressBarUserWidget.OnSetReservedValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InReservedValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAnimatedProgressBarUserWidget::OnSetReservedValue(float InReservedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAnimatedProgressBarUserWidget", "OnSetReservedValue");

	Params::HUDAnimatedProgressBarUserWidget_OnSetReservedValue Parms{};

	Parms.InReservedValue = InReservedValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NewArea.ZoneTriggered
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANewArea::ZoneTriggered(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewArea", "ZoneTriggered");

	Params::NewArea_ZoneTriggered Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeTransfuse.OnValueChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAttributeTransfuse::OnValueChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeTransfuse", "OnValueChanged");

	Params::AttributeTransfuse_OnValueChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.HUDWarningUserWidget.OnDisplayErrorMessages
// (Final, Native, Protected)
// Parameters:
// bool                                    bDisplayErrorMessages                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDWarningUserWidget::OnDisplayErrorMessages(bool bDisplayErrorMessages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDWarningUserWidget", "OnDisplayErrorMessages");

	Params::HUDWarningUserWidget_OnDisplayErrorMessages Parms{};

	Parms.bDisplayErrorMessages = bDisplayErrorMessages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BeamAbility.GetBeamDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeamAbility::GetBeamDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamAbility", "GetBeamDirection");

	Params::BeamAbility_GetBeamDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BeamAbility.GetDamagedEntities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UBeamAbility::GetDamagedEntities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamAbility", "GetDamagedEntities");

	Params::BeamAbility_GetDamagedEntities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BeamAbility.GetLastBeamEndPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeamAbility::GetLastBeamEndPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamAbility", "GetLastBeamEndPoint");

	Params::BeamAbility_GetLastBeamEndPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BeamAbility.GetLastBeamHitResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UBeamAbility::GetLastBeamHitResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamAbility", "GetLastBeamHitResult");

	Params::BeamAbility_GetLastBeamHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BeamAbility.GetLastBeamStartPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeamAbility::GetLastBeamStartPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamAbility", "GetLastBeamStartPoint");

	Params::BeamAbility_GetLastBeamStartPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArbitersFuryAbility.GetBeamDimensions
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UArbitersFuryAbility::GetBeamDimensions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArbitersFuryAbility", "GetBeamDimensions");

	Params::ArbitersFuryAbility_GetBeamDimensions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArbitersFuryAbility.GetSavedTriggerDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArbitersFuryAbility::GetSavedTriggerDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArbitersFuryAbility", "GetSavedTriggerDelay");

	Params::ArbitersFuryAbility_GetSavedTriggerDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArbitersFuryAbility.GetVirtualChargeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArbitersFuryAbility::GetVirtualChargeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArbitersFuryAbility", "GetVirtualChargeRate");

	Params::ArbitersFuryAbility_GetVirtualChargeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArbitersFuryAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UArbitersFuryAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArbitersFuryAbility", "PostDamageDealt");

	Params::ArbitersFuryAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OlenDWControl.OnSummonerAbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOlenDWControl::OnSummonerAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OlenDWControl", "OnSummonerAbilityStarted");

	Params::OlenDWControl_OnSummonerAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OlenDWControl.OnSummonerGameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOlenDWControl::OnSummonerGameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OlenDWControl", "OnSummonerGameplayEvent");

	Params::OlenDWControl_OnSummonerGameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIActionSequenceNode_UseAbility.EventOnAbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIActionSequenceNode_UseAbility::EventOnAbilityEnd(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIActionSequenceNode_UseAbility", "EventOnAbilityEnd");

	Params::AIActionSequenceNode_UseAbility_EventOnAbilityEnd Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BanditBruteAI.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UBanditBruteAI::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BanditBruteAI", "OnPreDamagedPriority");

	Params::BanditBruteAI_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.HUDTimerUserWidget.IsTimerVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHUDTimerUserWidget::IsTimerVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDTimerUserWidget", "IsTimerVisible");

	Params::HUDTimerUserWidget_IsTimerVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDTimerUserWidget.OnSetTimer
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InTimerText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDTimerUserWidget::OnSetTimer(const class FText& InTimerText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDTimerUserWidget", "OnSetTimer");

	Params::HUDTimerUserWidget_OnSetTimer Parms{};

	Parms.InTimerText = std::move(InTimerText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDTimerUserWidget.SetTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDTimerUserWidget::SetTimer(float Timer, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDTimerUserWidget", "SetTimer");

	Params::HUDTimerUserWidget_SetTimer Parms{};

	Parms.Timer = Timer;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineAegisAbility.IsDoubleSided
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDivineAegisAbility::IsDoubleSided()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineAegisAbility", "IsDoubleSided");

	Params::DivineAegisAbility_IsDoubleSided Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DivineAegisAbility.PostDamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDivineAegisAbility::PostDamageReceived(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineAegisAbility", "PostDamageReceived");

	Params::DivineAegisAbility_PostDamageReceived Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIActionSequenceNode_Turn.EventOnAbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIActionSequenceNode_Turn::EventOnAbilityEnd(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIActionSequenceNode_Turn", "EventOnAbilityEnd");

	Params::AIActionSequenceNode_Turn_EventOnAbilityEnd Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BountyBoardUserWidget.CompletedAnimFinished
// (Final, Native, Public, BlueprintCallable)

void UBountyBoardUserWidget::CompletedAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardUserWidget", "CompletedAnimFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BountyBoardUserWidget.OnHideBountyDetails
// (Event, Protected, BlueprintEvent)

void UBountyBoardUserWidget::OnHideBountyDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardUserWidget", "OnHideBountyDetails");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.BountyBoardUserWidget.OnShowBountyDetails
// (Event, Public, BlueprintEvent)

void UBountyBoardUserWidget::OnShowBountyDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardUserWidget", "OnShowBountyDetails");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.BountyBoardUserWidget.OpenBountyDetails
// (Final, Native, Public, BlueprintCallable)

void UBountyBoardUserWidget::OpenBountyDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardUserWidget", "OpenBountyDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnAnimEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnAnimEvent(class UAnimID* AnimID, EAnimEventType AnimEventType, class UAnimSequenceBase* Animation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnAnimEvent");

	Params::AnimInstanceCore_OnAnimEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimEventType = AnimEventType;
	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnAnimNotifyEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimEventTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnAnimNotifyEvent(class UAnimID* AnimID, EAnimEventType AnimEventType, class UAnimSequenceBase* Animation, const class UAnimNotify* AnimNotify, float AnimEventTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnAnimNotifyEvent");

	Params::AnimInstanceCore_OnAnimNotifyEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimEventType = AnimEventType;
	Parms.Animation = Animation;
	Parms.AnimNotify = AnimNotify;
	Parms.AnimEventTime = AnimEventTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnAnimReplacement
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          ReplacementAnimID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnAnimReplacement(class UAnimID* AnimID, class UAnimID* ReplacementAnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnAnimReplacement");

	Params::AnimInstanceCore_OnAnimReplacement Parms{};

	Parms.AnimID = AnimID;
	Parms.ReplacementAnimID = ReplacementAnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnAnimStartRequest
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnAnimStartRequest(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnAnimStartRequest");

	Params::AnimInstanceCore_OnAnimStartRequest Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnAnimStopRequest
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnAnimStopRequest(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnAnimStopRequest");

	Params::AnimInstanceCore_OnAnimStopRequest Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnClothEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   TargetBlendWeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnClothEvent(float TargetBlendWeight, float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnClothEvent");

	Params::AnimInstanceCore_OnClothEvent Parms{};

	Parms.TargetBlendWeight = TargetBlendWeight;
	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnNamedAnimEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimEventTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnNamedAnimEvent(class UAnimID* AnimID, class FName Name_0, class UAnimSequenceBase* Animation, float AnimEventTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnNamedAnimEvent");

	Params::AnimInstanceCore_OnNamedAnimEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.Name_0 = Name_0;
	Parms.Animation = Animation;
	Parms.AnimEventTime = AnimEventTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnRagdollEvent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ImpulseDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnRagdollEvent(const struct FVector& ImpulseDirection, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnRagdollEvent");

	Params::AnimInstanceCore_OnRagdollEvent Parms{};

	Parms.ImpulseDirection = std::move(ImpulseDirection);
	Parms.ImpulseStrength = ImpulseStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnTextBubbleEvent
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnTextBubbleEvent(const class FText& Text, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnTextBubbleEvent");

	Params::AnimInstanceCore_OnTextBubbleEvent Parms{};

	Parms.Text = std::move(Text);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnVfxEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VfxEventType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnVfxEvent(class UAnimID* AnimID, class FName VfxEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnVfxEvent");

	Params::AnimInstanceCore_OnVfxEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.VfxEventType = VfxEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.OnWalkStartEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   WalkStartOC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WalkStartOH                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WalkStartTH                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::OnWalkStartEvent(float WalkStartOC, float WalkStartOH, float WalkStartTH)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "OnWalkStartEvent");

	Params::AnimInstanceCore_OnWalkStartEvent Parms{};

	Parms.WalkStartOC = WalkStartOC;
	Parms.WalkStartOH = WalkStartOH;
	Parms.WalkStartTH = WalkStartTH;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.ToggleAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceCore::ToggleAnim(class UAnimID* AnimID, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "ToggleAnim");

	Params::AnimInstanceCore_ToggleAnim Parms{};

	Parms.AnimID = AnimID;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceCore.IsAnimToggled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceCore::IsAnimToggled(class UAnimID* AnimID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceCore", "IsAnimToggled");

	Params::AnimInstanceCore_IsAnimToggled Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.ComputeFootIK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSlopeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinHeightUp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHeightUp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinHeightDown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHeightDown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FootTranslationLimitUp                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FootTranslationLimitDown                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FootRotationLimit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RootTranslationLimit                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TranslationRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NormalShearRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GroundDistanceMin                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GroundDistanceMax                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RootSlopeTranslationBlendSpeed                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RootSlopeRotationBlendSpeed                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeFootIK(float TraceStart, float TraceEnd, float TraceOffset, float MinSlopeAngle, float MinHeightUp, float MaxHeightUp, float MinHeightDown, float MaxHeightDown, float FootTranslationLimitUp, float FootTranslationLimitDown, float FootRotationLimit, float RootTranslationLimit, float TranslationRatio, float RotationRatio, float NormalShearRatio, float LerpSpeed, float GroundDistanceMin, float GroundDistanceMax, float RootSlopeTranslationBlendSpeed, float RootSlopeRotationBlendSpeed, float DeltaSeconds, bool DrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeFootIK");

	Params::AnimInstanceBase_ComputeFootIK Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.TraceOffset = TraceOffset;
	Parms.MinSlopeAngle = MinSlopeAngle;
	Parms.MinHeightUp = MinHeightUp;
	Parms.MaxHeightUp = MaxHeightUp;
	Parms.MinHeightDown = MinHeightDown;
	Parms.MaxHeightDown = MaxHeightDown;
	Parms.FootTranslationLimitUp = FootTranslationLimitUp;
	Parms.FootTranslationLimitDown = FootTranslationLimitDown;
	Parms.FootRotationLimit = FootRotationLimit;
	Parms.RootTranslationLimit = RootTranslationLimit;
	Parms.TranslationRatio = TranslationRatio;
	Parms.RotationRatio = RotationRatio;
	Parms.NormalShearRatio = NormalShearRatio;
	Parms.LerpSpeed = LerpSpeed;
	Parms.GroundDistanceMin = GroundDistanceMin;
	Parms.GroundDistanceMax = GroundDistanceMax;
	Parms.RootSlopeTranslationBlendSpeed = RootSlopeTranslationBlendSpeed;
	Parms.RootSlopeRotationBlendSpeed = RootSlopeRotationBlendSpeed;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.DrawDebug = DrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ComputeGearRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationPerAnimation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimationLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::ComputeGearRotation(float Rotation, float RotationPerAnimation, float AnimationLength, float PlayRate, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeGearRotation");

	Params::AnimInstanceBase_ComputeGearRotation Parms{};

	Parms.Rotation = Rotation;
	Parms.RotationPerAnimation = RotationPerAnimation;
	Parms.AnimationLength = AnimationLength;
	Parms.PlayRate = PlayRate;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.ComputeJumpRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   JumpHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   JumpDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceD                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::ComputeJumpRatio(float JumpHeight, float JumpDistance, float MinHeight, float DistanceA, float DistanceB, float MaxHeight, float DistanceC, float DistanceD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeJumpRatio");

	Params::AnimInstanceBase_ComputeJumpRatio Parms{};

	Parms.JumpHeight = JumpHeight;
	Parms.JumpDistance = JumpDistance;
	Parms.MinHeight = MinHeight;
	Parms.DistanceA = DistanceA;
	Parms.DistanceB = DistanceB;
	Parms.MaxHeight = MaxHeight;
	Parms.DistanceC = DistanceC;
	Parms.DistanceD = DistanceD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.ComputeLookAngle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Looking                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAngle                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAngleMin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAngleMax                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAngleHoldMin                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAngleHoldMax                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeLookAngle(bool* Looking, float* LookAngle, float LookAngleMin, float LookAngleMax, float LookAngleHoldMin, float LookAngleHoldMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeLookAngle");

	Params::AnimInstanceBase_ComputeLookAngle Parms{};

	Parms.LookAngleMin = LookAngleMin;
	Parms.LookAngleMax = LookAngleMax;
	Parms.LookAngleHoldMin = LookAngleHoldMin;
	Parms.LookAngleHoldMax = LookAngleHoldMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Looking != nullptr)
		*Looking = Parms.Looking;

	if (LookAngle != nullptr)
		*LookAngle = Parms.LookAngle;
}


// Function man.AnimInstanceBase.ComputeRope
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Sag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeRope(const struct FVector& Target, float Sag, bool DrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeRope");

	Params::AnimInstanceBase_ComputeRope Parms{};

	Parms.Target = std::move(Target);
	Parms.Sag = Sag;
	Parms.DrawDebug = DrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ComputeSlope
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSlopeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeSlope(float TraceStart, float TraceEnd, float TraceDistance, float MinSlopeAngle, float RotationRatio, float LerpSpeed, float DeltaSeconds, bool DrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeSlope");

	Params::AnimInstanceBase_ComputeSlope Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.TraceDistance = TraceDistance;
	Parms.MinSlopeAngle = MinSlopeAngle;
	Parms.RotationRatio = RotationRatio;
	Parms.LerpSpeed = LerpSpeed;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.DrawDebug = DrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ComputeSpine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeSpine(float TraceStart, float TraceEnd, float MinRange, float LerpSpeed, float DeltaSeconds, bool DrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeSpine");

	Params::AnimInstanceBase_ComputeSpine Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.MinRange = MinRange;
	Parms.LerpSpeed = LerpSpeed;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.DrawDebug = DrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ComputeSpineSlopeBiasAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxTraceAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SpineBoneName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ComputeSpineSlopeBiasAngle(float TraceStart, float TraceEnd, float TraceDistance, float MaxTraceAngle, float BlendDuration, float DeltaSeconds, class FName SpineBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ComputeSpineSlopeBiasAngle");

	Params::AnimInstanceBase_ComputeSpineSlopeBiasAngle Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.TraceDistance = TraceDistance;
	Parms.MaxTraceAngle = MaxTraceAngle;
	Parms.BlendDuration = BlendDuration;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.SpineBoneName = SpineBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.EnableLevelSequenceAnimationOverlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::EnableLevelSequenceAnimationOverlay(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "EnableLevelSequenceAnimationOverlay");

	Params::AnimInstanceBase_EnableLevelSequenceAnimationOverlay Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.FitToSlope
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::FitToSlope(float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "FitToSlope");

	Params::AnimInstanceBase_FitToSlope Parms{};

	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.FlipFacing
// (Final, Native, Public, BlueprintCallable)

void UAnimInstanceBase::FlipFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "FlipFacing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ForceIdle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceIdle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ForceIdle(bool bForceIdle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ForceIdle");

	Params::AnimInstanceBase_ForceIdle Parms{};

	Parms.bForceIdle = bForceIdle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ForceMirrorRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MirrorRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ForceMirrorRate(float MirrorRate, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ForceMirrorRate");

	Params::AnimInstanceBase_ForceMirrorRate Parms{};

	Parms.MirrorRate = MirrorRate;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.GetActiveAnimsequences
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UAnimSequenceBase*>        ActiveAnimSequences                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstanceBase::GetActiveAnimsequences(TArray<class UAnimSequenceBase*>* ActiveAnimSequences)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetActiveAnimsequences");

	Params::AnimInstanceBase_GetActiveAnimsequences Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActiveAnimSequences != nullptr)
		*ActiveAnimSequences = std::move(Parms.ActiveAnimSequences);
}


// Function man.AnimInstanceBase.GetAnimID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimID* UAnimInstanceBase::GetAnimID(class UAnimSequenceBase* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetAnimID");

	Params::AnimInstanceBase_GetAnimID Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetAnimLength
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimLength                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::GetAnimLength(class UAnimID* AnimID, float* AnimLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetAnimLength");

	Params::AnimInstanceBase_GetAnimLength Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimLength != nullptr)
		*AnimLength = Parms.AnimLength;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetMaterialIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MaterialName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimInstanceBase::GetMaterialIndex(class FName MaterialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetMaterialIndex");

	Params::AnimInstanceBase_GetMaterialIndex Parms{};

	Parms.MaterialName = MaterialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetParallaxDisplacement
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAnimInstanceBase::GetParallaxDisplacement(class FName SocketName, float Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetParallaxDisplacement");

	Params::AnimInstanceBase_GetParallaxDisplacement Parms{};

	Parms.SocketName = SocketName;
	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetProgressAnimLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetProgressAnimLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetProgressAnimLength");

	Params::AnimInstanceBase_GetProgressAnimLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetRootTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformBySlope                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::GetRootTransform(struct FTransform* Transform, class UAnimSequence* AnimSequence, float AnimTime, bool bTransformBySlope)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetRootTransform");

	Params::AnimInstanceBase_GetRootTransform Parms{};

	Parms.AnimSequence = AnimSequence;
	Parms.AnimTime = AnimTime;
	Parms.bTransformBySlope = bTransformBySlope;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetSocketTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformBySlope                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::GetSocketTransform(struct FTransform* Transform, class FName SocketName, class UAnimSequence* AnimSequence, float AnimTime, bool bTransformBySlope)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetSocketTransform");

	Params::AnimInstanceBase_GetSocketTransform Parms{};

	Parms.SocketName = SocketName;
	Parms.AnimSequence = AnimSequence;
	Parms.AnimTime = AnimTime;
	Parms.bTransformBySlope = bTransformBySlope;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetTwinBoneTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UAnimInstanceBase::GetTwinBoneTransform(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetTwinBoneTransform");

	Params::AnimInstanceBase_GetTwinBoneTransform Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.HideBodyPart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::HideBodyPart(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "HideBodyPart");

	Params::AnimInstanceBase_HideBodyPart Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimEventForceTurnCancel
// (Final, Native, Public, BlueprintCallable)

void UAnimInstanceBase::OnAnimEventForceTurnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimEventForceTurnCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimEventForceTurnEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimTurnType                           TurnType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimEventForceTurnEnd(EAnimTurnType TurnType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimEventForceTurnEnd");

	Params::AnimInstanceBase_OnAnimEventForceTurnEnd Parms{};

	Parms.TurnType = TurnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimEventForceTurnStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimTurnType                           TurnType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurnDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimEventForceTurnStart(EAnimTurnType TurnType, float TurnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimEventForceTurnStart");

	Params::AnimInstanceBase_OnAnimEventForceTurnStart Parms{};

	Parms.TurnType = TurnType;
	Parms.TurnDuration = TurnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimEventReceived
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimEventReceived(class UAnimID* AnimID, EAnimEventType AnimEventType, class UAnimSequenceBase* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimEventReceived");

	Params::AnimInstanceBase_OnAnimEventReceived Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimEventType = AnimEventType;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimStateBegin
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimNotifyStateType                    AnimStateType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimStateBegin(class UAnimID* AnimID, EAnimNotifyStateType AnimStateType, class UAnimSequenceBase* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimStateBegin");

	Params::AnimInstanceBase_OnAnimStateBegin Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimStateType = AnimStateType;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimStateEnd
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimNotifyStateType                    AnimStateType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimStateEnd(class UAnimID* AnimID, EAnimNotifyStateType AnimStateType, class UAnimSequenceBase* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimStateEnd");

	Params::AnimInstanceBase_OnAnimStateEnd Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimStateType = AnimStateType;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnAnimStateTick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimNotifyStateType                    AnimStateType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnAnimStateTick(class UAnimID* AnimID, EAnimNotifyStateType AnimStateType, class UAnimSequenceBase* InAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnAnimStateTick");

	Params::AnimInstanceBase_OnAnimStateTick Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimStateType = AnimStateType;
	Parms.InAnimation = InAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.OnFacingChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::OnFacingChanged(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "OnFacingChanged");

	Params::AnimInstanceBase_OnFacingChanged Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ResetAnimations
// (Final, Native, Public, BlueprintCallable)

void UAnimInstanceBase::ResetAnimations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ResetAnimations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ResetMotionBlurStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ResetMotionBlurStrength(float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ResetMotionBlurStrength");

	Params::AnimInstanceBase_ResetMotionBlurStrength Parms{};

	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SendAnimNotifyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SendAnimNotifyEvent(class UAnimID* AnimID, EAnimEventType AnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SendAnimNotifyEvent");

	Params::AnimInstanceBase_SendAnimNotifyEvent Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimEventType = AnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetDefaultAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetDefaultAnimation(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetDefaultAnimation");

	Params::AnimInstanceBase_SetDefaultAnimation Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetFlipFacingAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetFlipFacingAnim(class UAnimID* AnimID, class UAnimSequenceBase* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetFlipFacingAnim");

	Params::AnimInstanceBase_SetFlipFacingAnim Parms{};

	Parms.AnimID = AnimID;
	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetHidden(bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetHidden");

	Params::AnimInstanceBase_SetHidden Parms{};

	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetLevelSequenceCombatMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCombatMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetLevelSequenceCombatMode(bool bCombatMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetLevelSequenceCombatMode");

	Params::AnimInstanceBase_SetLevelSequenceCombatMode Parms{};

	Parms.bCombatMode = bCombatMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetLevelSequenceConversationAnimID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetLevelSequenceConversationAnimID(class UAnimID* AnimID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetLevelSequenceConversationAnimID");

	Params::AnimInstanceBase_SetLevelSequenceConversationAnimID Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetLevelSequenceMirrored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMirrored                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetLevelSequenceMirrored(bool bMirrored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetLevelSequenceMirrored");

	Params::AnimInstanceBase_SetLevelSequenceMirrored Parms{};

	Parms.bMirrored = bMirrored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetLevelSequenceMirrorRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MirrorRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetLevelSequenceMirrorRate(float MirrorRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetLevelSequenceMirrorRate");

	Params::AnimInstanceBase_SetLevelSequenceMirrorRate Parms{};

	Parms.MirrorRate = MirrorRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetMotionBlurStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MotionBlurAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetMotionBlurStrength(float MotionBlurAmount, float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetMotionBlurStrength");

	Params::AnimInstanceBase_SetMotionBlurStrength Parms{};

	Parms.MotionBlurAmount = MotionBlurAmount;
	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.SetProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Mirrored                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::SetProgress(float Progress, bool Loop, bool Teleport, bool Mirrored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "SetProgress");

	Params::AnimInstanceBase_SetProgress Parms{};

	Parms.Progress = Progress;
	Parms.Loop = Loop;
	Parms.Teleport = Teleport;
	Parms.Mirrored = Mirrored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.StartBodypartPhysics
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ConstraintName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ImpulseStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::StartBodypartPhysics(class FName ConstraintName, class FName BoneName, const struct FVector& ImpulseDirection, float ImpulseStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "StartBodypartPhysics");

	Params::AnimInstanceBase_StartBodypartPhysics Parms{};

	Parms.ConstraintName = ConstraintName;
	Parms.BoneName = BoneName;
	Parms.ImpulseDirection = std::move(ImpulseDirection);
	Parms.ImpulseStrength = ImpulseStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.StartRagdollPhysics
// (Native, Public, BlueprintCallable)

void UAnimInstanceBase::StartRagdollPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "StartRagdollPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.StopBodypartAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::StopBodypartAnimation(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "StopBodypartAnimation");

	Params::AnimInstanceBase_StopBodypartAnimation Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.ToggleLevelSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::ToggleLevelSequence(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "ToggleLevelSequence");

	Params::AnimInstanceBase_ToggleLevelSequence Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.UpdateActorRotationByFacing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstanceBase::UpdateActorRotationByFacing(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "UpdateActorRotationByFacing");

	Params::AnimInstanceBase_UpdateActorRotationByFacing Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.UpdateFacing
// (Final, Native, Public, BlueprintCallable)

void UAnimInstanceBase::UpdateFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "UpdateFacing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.UpdateTurnAngleByFacing
// (Final, Native, Public, BlueprintCallable)

void UAnimInstanceBase::UpdateTurnAngleByFacing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "UpdateTurnAngleByFacing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AnimInstanceBase.DumpAnimReplacements
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   AnimReplacementNames                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstanceBase::DumpAnimReplacements(TArray<class FString>* AnimReplacementNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "DumpAnimReplacements");

	Params::AnimInstanceBase_DumpAnimReplacements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimReplacementNames != nullptr)
		*AnimReplacementNames = std::move(Parms.AnimReplacementNames);
}


// Function man.AnimInstanceBase.DumpToggledAnims
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ToggledAnimNames                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstanceBase::DumpToggledAnims(TArray<class FString>* ToggledAnimNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "DumpToggledAnims");

	Params::AnimInstanceBase_DumpToggledAnims Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ToggledAnimNames != nullptr)
		*ToggledAnimNames = std::move(Parms.ToggledAnimNames);
}


// Function man.AnimInstanceBase.GetFacing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetFacing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetFacing");

	Params::AnimInstanceBase_GetFacing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetFacingTargetAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetFacingTargetAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetFacingTargetAngle");

	Params::AnimInstanceBase_GetFacingTargetAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetGroundDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetGroundDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetGroundDistance");

	Params::AnimInstanceBase_GetGroundDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetHeroCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterBase* UAnimInstanceBase::GetHeroCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetHeroCharacter");

	Params::AnimInstanceBase_GetHeroCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetHeroDistance
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAnimInstanceBase::GetHeroDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetHeroDistance");

	Params::AnimInstanceBase_GetHeroDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetHeroLookAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetHeroLookAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetHeroLookAngle");

	Params::AnimInstanceBase_GetHeroLookAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetJumpDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetJumpDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetJumpDistance");

	Params::AnimInstanceBase_GetJumpDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetJumpHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetJumpHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetJumpHeight");

	Params::AnimInstanceBase_GetJumpHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetRandomAnimIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   CurrentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimInstanceBase::GetRandomAnimIndex(int32 CurrentIndex, int32 MaxIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetRandomAnimIndex");

	Params::AnimInstanceBase_GetRandomAnimIndex Parms{};

	Parms.CurrentIndex = CurrentIndex;
	Parms.MaxIndex = MaxIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetRotatorDeltaAngle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         PrevRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetRotatorDeltaAngle(const struct FRotator& PrevRotation, const struct FRotator& Rotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetRotatorDeltaAngle");

	Params::AnimInstanceBase_GetRotatorDeltaAngle Parms{};

	Parms.PrevRotation = std::move(PrevRotation);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetSmoothValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetSmoothValue(float Value, float Range) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetSmoothValue");

	Params::AnimInstanceBase_GetSmoothValue Parms{};

	Parms.Value = Value;
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetTrackIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseRawData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimInstanceBase::GetTrackIndex(class UAnimSequence* AnimSequence, int32 BoneIndex, bool UseRawData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetTrackIndex");

	Params::AnimInstanceBase_GetTrackIndex Parms{};

	Parms.AnimSequence = AnimSequence;
	Parms.BoneIndex = BoneIndex;
	Parms.UseRawData = UseRawData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetTurnAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetTurnAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetTurnAngle");

	Params::AnimInstanceBase_GetTurnAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.GetTurnTargetAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstanceBase::GetTurnTargetAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "GetTurnTargetAngle");

	Params::AnimInstanceBase_GetTurnTargetAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.HasAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::HasAnim(class UAnimID* AnimID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "HasAnim");

	Params::AnimInstanceBase_HasAnim Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsActorHiddenInGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsActorHiddenInGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsActorHiddenInGame");

	Params::AnimInstanceBase_IsActorHiddenInGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsAnimSequenceMirrored
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsAnimSequenceMirrored(class UAnimSequence* AnimSequence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsAnimSequenceMirrored");

	Params::AnimInstanceBase_IsAnimSequenceMirrored Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsAnyAnimToggled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAnimID*>                  AnimIDs                                                (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsAnyAnimToggled(const TArray<class UAnimID*>& AnimIDs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsAnyAnimToggled");

	Params::AnimInstanceBase_IsAnyAnimToggled Parms{};

	Parms.AnimIDs = std::move(AnimIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsLevelSequenceCombatMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsLevelSequenceCombatMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsLevelSequenceCombatMode");

	Params::AnimInstanceBase_IsLevelSequenceCombatMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsLevelSequenceMirrored
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsLevelSequenceMirrored() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsLevelSequenceMirrored");

	Params::AnimInstanceBase_IsLevelSequenceMirrored Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsLevelSequencePlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsLevelSequencePlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsLevelSequencePlaying");

	Params::AnimInstanceBase_IsLevelSequencePlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsTurnedInside
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsTurnedInside() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsTurnedInside");

	Params::AnimInstanceBase_IsTurnedInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.IsTurning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::IsTurning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "IsTurning");

	Params::AnimInstanceBase_IsTurning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AnimInstanceBase.TraceGround
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstanceBase::TraceGround(class AActor* Character, const struct FVector& TraceLocation, float TraceStart, float TraceEnd, struct FVector* HitLocation, struct FVector* HitNormal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInstanceBase", "TraceGround");

	Params::AnimInstanceBase_TraceGround Parms{};

	Parms.Character = Character;
	Parms.TraceLocation = std::move(TraceLocation);
	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	return Parms.ReturnValue;
}


// Function man.CCCogsAnimInstance.ResetCogs
// (Final, Native, Protected, BlueprintCallable)

void UCCCogsAnimInstance::ResetCogs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCogsAnimInstance", "ResetCogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CCCogsAnimInstance.UpdateCogs
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCCogsAnimInstance::UpdateCogs(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCogsAnimInstance", "UpdateCogs");

	Params::CCCogsAnimInstance_UpdateCogs Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LimitedEntropicTearImplement.OnLevelsChanged
// (Final, Native, Public)

void ULimitedEntropicTearImplement::OnLevelsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitedEntropicTearImplement", "OnLevelsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LimitedEntropicTearImplement.OnPostDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULimitedEntropicTearImplement::OnPostDamage(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitedEntropicTearImplement", "OnPostDamage");

	Params::LimitedEntropicTearImplement_OnPostDamage Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LimitedEntropicTearImplement.TriggerOnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULimitedEntropicTearImplement::TriggerOnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitedEntropicTearImplement", "TriggerOnComponentBeginOverlap");

	Params::LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LimitedEntropicTearImplement.TriggerOnComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitedEntropicTearImplement::TriggerOnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitedEntropicTearImplement", "TriggerOnComponentEndOverlap");

	Params::LimitedEntropicTearImplement_TriggerOnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AIAggroStartAbility.OnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAIAggroStartAbility::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIAggroStartAbility", "OnPostDamaged");

	Params::AIAggroStartAbility_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PushableObject.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPushableObject::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableObject", "OnBeginOverlap");

	Params::PushableObject_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PushableObject.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPushableObject::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableObject", "OnEndOverlap");

	Params::PushableObject_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PushableObject.OnMatchHasStarted
// (Final, Native, Public)

void UPushableObject::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushableObject", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CatCritterAbility.OnLevelsChanged
// (Final, Native, Public)

void UCatCritterAbility::OnLevelsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CatCritterAbility", "OnLevelsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CatCritterAbility.OnMatchHasStarted
// (Final, Native, Public)

void UCatCritterAbility::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CatCritterAbility", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DoorEnterAbility.OnTeleport
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoorEnterAbility::OnTeleport(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorEnterAbility", "OnTeleport");

	Params::DoorEnterAbility_OnTeleport Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternNodeUserWidget.WitchLanternNodeSetState
// (Final, Native, Public)

void UWitchLanternNodeUserWidget::WitchLanternNodeSetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternNodeUserWidget", "WitchLanternNodeSetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterWinFilterSlotUserWidget.GetInventorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInventorySlot*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventorySlot* UCharacterWinFilterSlotUserWidget::GetInventorySlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "GetInventorySlot");

	Params::CharacterWinFilterSlotUserWidget_GetInventorySlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CharacterWinFilterSlotUserWidget.OnInit
// (Event, Public, BlueprintEvent)

void UCharacterWinFilterSlotUserWidget::OnInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterWinFilterSlotUserWidget.OnPermanentEnchantIconsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InPermanentEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnPermanentEnchantIconsChanged(const TArray<class UTexture2D*>& InPermanentEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnPermanentEnchantIconsChanged");

	Params::CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged Parms{};

	Parms.InPermanentEnchantIcons = std::move(InPermanentEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnPlayUnlockAnim
// (Event, Protected, BlueprintEvent)

void UCharacterWinFilterSlotUserWidget::OnPlayUnlockAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnPlayUnlockAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetCountdown
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   ElapsedCooldownPercent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TimeLeft                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetCountdown(float ElapsedCooldownPercent, const class FText& TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetCountdown");

	Params::CharacterWinFilterSlotUserWidget_OnSetCountdown Parms{};

	Parms.ElapsedCooldownPercent = ElapsedCooldownPercent;
	Parms.TimeLeft = std::move(TimeLeft);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetEnabled");

	Params::CharacterWinFilterSlotUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetEquippedItemMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEquippedItemMode                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetEquippedItemMode(bool bInEquippedItemMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetEquippedItemMode");

	Params::CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode Parms{};

	Parms.bInEquippedItemMode = bInEquippedItemMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetItemIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ItemIcon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetItemIcon(class UTexture2D* ItemIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetItemIcon");

	Params::CharacterWinFilterSlotUserWidget_OnSetItemIcon Parms{};

	Parms.ItemIcon = ItemIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetLocked
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetLocked(bool bInLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetLocked");

	Params::CharacterWinFilterSlotUserWidget_OnSetLocked Parms{};

	Parms.bInLocked = bInLocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetSelected(bool bInSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetSelected");

	Params::CharacterWinFilterSlotUserWidget_OnSetSelected Parms{};

	Parms.bInSelected = bInSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetSlotNameText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             SlotNameText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetSlotNameText(const class FText& SlotNameText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetSlotNameText");

	Params::CharacterWinFilterSlotUserWidget_OnSetSlotNameText Parms{};

	Parms.SlotNameText = std::move(SlotNameText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetTransmogSlot
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInTransmogSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetTransmogSlot(bool bInTransmogSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetTransmogSlot");

	Params::CharacterWinFilterSlotUserWidget_OnSetTransmogSlot Parms{};

	Parms.bInTransmogSlot = bInTransmogSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetTwoHandedLocked
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInTwoHandedLocked                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetTwoHandedLocked(bool bInTwoHandedLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetTwoHandedLocked");

	Params::CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked Parms{};

	Parms.bInTwoHandedLocked = bInTwoHandedLocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetUnavailable
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInUnavailable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetUnavailable(bool bInUnavailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetUnavailable");

	Params::CharacterWinFilterSlotUserWidget_OnSetUnavailable Parms{};

	Parms.bInUnavailable = bInUnavailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnSetVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnSetVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnSetVisible");

	Params::CharacterWinFilterSlotUserWidget_OnSetVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnStackNumChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InStackNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsStackable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShadowMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnStackNumChanged(int32 InStackNum, bool bInIsStackable, bool bShadowMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnStackNumChanged");

	Params::CharacterWinFilterSlotUserWidget_OnStackNumChanged Parms{};

	Parms.InStackNum = InStackNum;
	Parms.bInIsStackable = bInIsStackable;
	Parms.bShadowMode = bShadowMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnTemporaryEnchantIconsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UTexture2D*>               InTemporaryEnchantIcons                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnTemporaryEnchantIconsChanged(const TArray<class UTexture2D*>& InTemporaryEnchantIcons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnTemporaryEnchantIconsChanged");

	Params::CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged Parms{};

	Parms.InTemporaryEnchantIcons = std::move(InTemporaryEnchantIcons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterWinFilterSlotUserWidget.OnToggleNewItemWarning
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterWinFilterSlotUserWidget::OnToggleNewItemWarning(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterWinFilterSlotUserWidget", "OnToggleNewItemWarning");

	Params::CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InteractableActor.OnActorOverlapWithAvatarEnd
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractableActor::OnActorOverlapWithAvatarEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnActorOverlapWithAvatarEnd");

	Params::InteractableActor_OnActorOverlapWithAvatarEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractableActor.OnActorOverlapWithAvatarStart
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractableActor::OnActorOverlapWithAvatarStart(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableActor", "OnActorOverlapWithAvatarStart");

	Params::InteractableActor_OnActorOverlapWithAvatarStart Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.KingPriestVoidAI.OnBeginPlatformVolumeOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKingPriestVoidAI::OnBeginPlatformVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidAI", "OnBeginPlatformVolumeOverlap");

	Params::KingPriestVoidAI_OnBeginPlatformVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.KingPriestVoidAI.OnEndPlatformVolumeOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKingPriestVoidAI::OnEndPlatformVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidAI", "OnEndPlatformVolumeOverlap");

	Params::KingPriestVoidAI_OnEndPlatformVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.KingPriestVoidAI.OnHeroDie
// (Final, Native, Protected)

void UKingPriestVoidAI::OnHeroDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidAI", "OnHeroDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.WildSeedAbility.OnStaggerOrStun
// (Final, Native, Private)

void UWildSeedAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WildSeedAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticTouchPassive.AbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticTouchPassive::AbilityEnd(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticTouchPassive", "AbilityEnd");

	Params::ChaoticTouchPassive_AbilityEnd Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticTouchPassive.ChaosTriggered
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticTouchPassive::ChaosTriggered(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticTouchPassive", "ChaosTriggered");

	Params::ChaoticTouchPassive_ChaosTriggered Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaoticTouchPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChaoticTouchPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticTouchPassive", "DamageDealt");

	Params::ChaoticTouchPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AirAttackAbility.OnFacingChanged
// (Final, Native, Private)

void UAirAttackAbility::OnFacingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirAttackAbility", "OnFacingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AirAttackAbility.OnLanded
// (Final, Native, Public)

void UAirAttackAbility::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirAttackAbility", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.AirAttackAbility.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UAirAttackAbility::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirAttackAbility", "OnPreDamageCaused");

	Params::AirAttackAbility_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.DreadscytheAbility.GetCurrentRadius
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDreadscytheAbility::GetCurrentRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreadscytheAbility", "GetCurrentRadius");

	Params::DreadscytheAbility_GetCurrentRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function man.DreadscytheAbility.GetCurrentWidth
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDreadscytheAbility::GetCurrentWidth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreadscytheAbility", "GetCurrentWidth");

	Params::DreadscytheAbility_GetCurrentWidth Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function man.DreadscytheAbility.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDreadscytheAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreadscytheAbility", "PreDamageDealt");

	Params::DreadscytheAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CheckPointActivateAbility.OnCheckPointTravel
// (Final, Native, Private)
// Parameters:
// class UCheckpointData*                  CheckpointData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckPointActivateAbility::OnCheckPointTravel(class UCheckpointData* CheckpointData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckPointActivateAbility", "OnCheckPointTravel");

	Params::CheckPointActivateAbility_OnCheckPointTravel Parms{};

	Parms.CheckpointData = CheckpointData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CheckPointActivateAbility.OnEntityKilledWithRebirth
// (Final, Native, Private)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckPointActivateAbility::OnEntityKilledWithRebirth(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckPointActivateAbility", "OnEntityKilledWithRebirth");

	Params::CheckPointActivateAbility_OnEntityKilledWithRebirth Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CheckPointActivateAbility.OnHudMessage
// (Final, Native, Private)
// Parameters:
// EHudMessage                             Msg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckPointActivateAbility::OnHudMessage(EHudMessage Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckPointActivateAbility", "OnHudMessage");

	Params::CheckPointActivateAbility_OnHudMessage Parms{};

	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PersistentHeroData.GetAreaManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManAreaManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManAreaManager* UPersistentHeroData::GetAreaManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetAreaManager");

	Params::PersistentHeroData_GetAreaManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetConversationManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManConversationManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManConversationManager* UPersistentHeroData::GetConversationManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetConversationManager");

	Params::PersistentHeroData_GetConversationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetHeroAbilitiesData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHeroAbilitiesData*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHeroAbilitiesData* UPersistentHeroData::GetHeroAbilitiesData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetHeroAbilitiesData");

	Params::PersistentHeroData_GetHeroAbilitiesData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetHeroInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UPersistentHeroData::GetHeroInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetHeroInventory");

	Params::PersistentHeroData_GetHeroInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetMapManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapManager*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapManager* UPersistentHeroData::GetMapManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetMapManager");

	Params::PersistentHeroData_GetMapManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetQuestManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestManager* UPersistentHeroData::GetQuestManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetQuestManager");

	Params::PersistentHeroData_GetQuestManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetSkillTreeManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkillTreeManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkillTreeManager* UPersistentHeroData::GetSkillTreeManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetSkillTreeManager");

	Params::PersistentHeroData_GetSkillTreeManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PersistentHeroData.GetVendorManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorManager* UPersistentHeroData::GetVendorManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentHeroData", "GetVendorManager");

	Params::PersistentHeroData_GetVendorManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BountyBoardDetailsUserWidget.OnSetAccepted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAccepted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBountyBoardDetailsUserWidget::OnSetAccepted(bool bAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardDetailsUserWidget", "OnSetAccepted");

	Params::BountyBoardDetailsUserWidget_OnSetAccepted Parms{};

	Parms.bAccepted = bAccepted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.BountyBoardDetailsUserWidget.OnSetDetailsText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             DetailsText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBountyBoardDetailsUserWidget::OnSetDetailsText(const class FText& DetailsText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BountyBoardDetailsUserWidget", "OnSetDetailsText");

	Params::BountyBoardDetailsUserWidget_OnSetDetailsText Parms{};

	Parms.DetailsText = std::move(DetailsText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.WhispersAbility.GetTargetEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UWhispersAbility::GetTargetEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhispersAbility", "GetTargetEnemy");

	Params::WhispersAbility_GetTargetEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WhispersAbility.OnStaggerOrStun
// (Final, Native, Private)

void UWhispersAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhispersAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.WhispersAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWhispersAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhispersAbility", "PostDamageDealt");

	Params::WhispersAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BloodStainBuildupPassive.GetBloodStainRemainingTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBloodStainBuildupPassive::GetBloodStainRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainBuildupPassive", "GetBloodStainRemainingTime");

	Params::BloodStainBuildupPassive_GetBloodStainRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BloodStainBuildupPassive.OnPostDamageDone
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodStainBuildupPassive::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainBuildupPassive", "OnPostDamageDone");

	Params::BloodStainBuildupPassive_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BloodStainBuildupPassive.OnPostDamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBloodStainBuildupPassive::OnPostDamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainBuildupPassive", "OnPostDamageTaken");

	Params::BloodStainBuildupPassive_OnPostDamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CameraBlocker.EnableBlocking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Blocking                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACameraBlocker::EnableBlocking(bool Blocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraBlocker", "EnableBlocking");

	Params::CameraBlocker_EnableBlocking Parms{};

	Parms.Blocking = Blocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDNotificationUserWidget.OnSetData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       InIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItemAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDNotificationUserWidget::OnSetData(const class FText& InName, const class FText& InDescription, class UTexture2D* InIcon, int32 InNumber, class UItemAbility* InItemAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDNotificationUserWidget", "OnSetData");

	Params::HUDNotificationUserWidget_OnSetData Parms{};

	Parms.InName = std::move(InName);
	Parms.InDescription = std::move(InDescription);
	Parms.InIcon = InIcon;
	Parms.InNumber = InNumber;
	Parms.InItemAbility = InItemAbility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDNotificationUserWidget.OnSetNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDNotificationUserWidget::OnSetNumber(int32 InNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDNotificationUserWidget", "OnSetNumber");

	Params::HUDNotificationUserWidget_OnSetNumber Parms{};

	Parms.InNumber = InNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDNotificationUserWidget.RemoveNotification
// (Final, Native, Public, BlueprintCallable)

void UHUDNotificationUserWidget::RemoveNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDNotificationUserWidget", "RemoveNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManWidgetComponent.OnPreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UManWidgetComponent::OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManWidgetComponent", "OnPreDamaged");

	Params::ManWidgetComponent_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.HPBarWidgetComponent.ExecutePostHealthChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHPBarWidgetComponent::ExecutePostHealthChanged(float CurrentHealth, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HPBarWidgetComponent", "ExecutePostHealthChanged");

	Params::HPBarWidgetComponent_ExecutePostHealthChanged Parms{};

	Parms.CurrentHealth = CurrentHealth;
	Parms.MaxHealth = MaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HPBarWidgetComponent.ExecutePostMaxHealthChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   CurrentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHPBarWidgetComponent::ExecutePostMaxHealthChanged(float CurrentHealth, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HPBarWidgetComponent", "ExecutePostMaxHealthChanged");

	Params::HPBarWidgetComponent_ExecutePostMaxHealthChanged Parms{};

	Parms.CurrentHealth = CurrentHealth;
	Parms.MaxHealth = MaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HPBarWidgetComponent.IsEliteEnemy
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHPBarWidgetComponent::IsEliteEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HPBarWidgetComponent", "IsEliteEnemy");

	Params::HPBarWidgetComponent_IsEliteEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HPBarWidgetComponent.OnHealthChanged
// (Final, Native, Private)
// Parameters:
// float                                   preHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   newHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHPBarWidgetComponent::OnHealthChanged(float preHealth, float newHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HPBarWidgetComponent", "OnHealthChanged");

	Params::HPBarWidgetComponent_OnHealthChanged Parms{};

	Parms.preHealth = preHealth;
	Parms.newHealth = newHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HPBarWidgetComponent.OnMaxHealthChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UHPBarWidgetComponent::OnMaxHealthChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HPBarWidgetComponent", "OnMaxHealthChanged");

	Params::HPBarWidgetComponent_OnMaxHealthChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.BrawlerAnimInstance.ComputeEnterSideDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::ComputeEnterSideDoor(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "ComputeEnterSideDoor");

	Params::BrawlerAnimInstance_ComputeEnterSideDoor Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.DumpCombatModeInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           CombatModeInfo                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::DumpCombatModeInfo(class FString* CombatModeInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "DumpCombatModeInfo");

	Params::BrawlerAnimInstance_DumpCombatModeInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CombatModeInfo != nullptr)
		*CombatModeInfo = std::move(Parms.CombatModeInfo);
}


// Function man.BrawlerAnimInstance.EnableGrapplingHook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::EnableGrapplingHook(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "EnableGrapplingHook");

	Params::BrawlerAnimInstance_EnableGrapplingHook Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.GetLeftArmDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBrawlerAnimInstance::GetLeftArmDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "GetLeftArmDirection");

	Params::BrawlerAnimInstance_GetLeftArmDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BrawlerAnimInstance.InitEnterSideDoor
// (Final, Native, Public, BlueprintCallable)

void UBrawlerAnimInstance::InitEnterSideDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "InitEnterSideDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.OnLanded
// (Native, Event, Protected, BlueprintEvent)

void UBrawlerAnimInstance::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.ResetLadderIdleAnim
// (Final, Native, Public, BlueprintCallable)

void UBrawlerAnimInstance::ResetLadderIdleAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "ResetLadderIdleAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.SelectLadderIdleAnim
// (Final, Native, Public, BlueprintCallable)

void UBrawlerAnimInstance::SelectLadderIdleAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "SelectLadderIdleAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.SetConversationLookTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::SetConversationLookTarget(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "SetConversationLookTarget");

	Params::BrawlerAnimInstance_SetConversationLookTarget Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.SetGrapplingHookFootWallDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FootWallDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::SetGrapplingHookFootWallDistance(float FootWallDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "SetGrapplingHookFootWallDistance");

	Params::BrawlerAnimInstance_SetGrapplingHookFootWallDistance Parms{};

	Parms.FootWallDistance = FootWallDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.SetGrapplingHookPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBrawlerAnimInstance::SetGrapplingHookPosition(const struct FVector& TargetPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "SetGrapplingHookPosition");

	Params::BrawlerAnimInstance_SetGrapplingHookPosition Parms{};

	Parms.TargetPosition = std::move(TargetPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerAnimInstance.GetBlendDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBrawlerAnimInstance::GetBlendDuration(class UAnimID* AnimID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "GetBlendDuration");

	Params::BrawlerAnimInstance_GetBlendDuration Parms{};

	Parms.AnimID = AnimID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BrawlerAnimInstance.IsLanding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBrawlerAnimInstance::IsLanding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "IsLanding");

	Params::BrawlerAnimInstance_IsLanding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BrawlerAnimInstance.IsLeftWeaponInHand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBrawlerAnimInstance::IsLeftWeaponInHand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "IsLeftWeaponInHand");

	Params::BrawlerAnimInstance_IsLeftWeaponInHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BrawlerAnimInstance.IsRightWeaponInHand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBrawlerAnimInstance::IsRightWeaponInHand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerAnimInstance", "IsRightWeaponInHand");

	Params::BrawlerAnimInstance_IsRightWeaponInHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChaosShardAbility.IsEmpowerUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChaosShardAbility::IsEmpowerUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosShardAbility", "IsEmpowerUnlocked");

	Params::ChaosShardAbility_IsEmpowerUnlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChaosShardAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChaosShardAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosShardAbility", "PostDamageDealt");

	Params::ChaosShardAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaosShardAbility.ResetStacks
// (Final, Native, Public)

void UChaosShardAbility::ResetStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosShardAbility", "ResetStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ChaosShardAbility.ResourceUsed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaosShardAbility::ResourceUsed(EEntityProperty resource, float* amount, class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosShardAbility", "ResourceUsed");

	Params::ChaosShardAbility_ResourceUsed Parms{};

	Parms.resource = resource;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (amount != nullptr)
		*amount = Parms.amount;
}


// Function man.AnimNotify_AkEventBase.BPGetEvent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UAnimNotify_AkEventBase::BPGetEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_AkEventBase", "BPGetEvent");

	Params::AnimNotify_AkEventBase_BPGetEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDQuickUseSlotUserWidget.OnSetCountdown
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   ElapsedCooldownPercent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TimeLeft                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDQuickUseSlotUserWidget::OnSetCountdown(float ElapsedCooldownPercent, const class FText& TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDQuickUseSlotUserWidget", "OnSetCountdown");

	Params::HUDQuickUseSlotUserWidget_OnSetCountdown Parms{};

	Parms.ElapsedCooldownPercent = ElapsedCooldownPercent;
	Parms.TimeLeft = std::move(TimeLeft);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDQuickUseSlotUserWidget.OnSetQuickUseUsable
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bUsable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDQuickUseSlotUserWidget::OnSetQuickUseUsable(bool bUsable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDQuickUseSlotUserWidget", "OnSetQuickUseUsable");

	Params::HUDQuickUseSlotUserWidget_OnSetQuickUseUsable Parms{};

	Parms.bUsable = bUsable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDQuickUseSlotUserWidget.SetInventorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventorySlot*                   InInventorySlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDQuickUseSlotUserWidget::SetInventorySlot(class UInventorySlot* InInventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDQuickUseSlotUserWidget", "SetInventorySlot");

	Params::HUDQuickUseSlotUserWidget_SetInventorySlot Parms{};

	Parms.InInventorySlot = InInventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AstralGuardiansCastAbility.ResetEmpower
// (Final, Native, Public)

void UAstralGuardiansCastAbility::ResetEmpower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AstralGuardiansCastAbility", "ResetEmpower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NoxiousFocus.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNoxiousFocus::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoxiousFocus", "PostDamageDealt");

	Params::NoxiousFocus_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.JumpPadImplement.TriggerOnComponentBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UJumpPadImplement::TriggerOnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpPadImplement", "TriggerOnComponentBeginOverlap");

	Params::JumpPadImplement_TriggerOnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.JumpPadImplement.TriggerOnComponentEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJumpPadImplement::TriggerOnComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpPadImplement", "TriggerOnComponentEndOverlap");

	Params::JumpPadImplement_TriggerOnComponentEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BossScreenUserWidget.CloseBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UBossScreenUserWidget::CloseBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossScreenUserWidget", "CloseBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BossScreenUserWidget.StoreBtnPressed
// (Final, Native, Public, BlueprintCallable)

void UBossScreenUserWidget::StoreBtnPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossScreenUserWidget", "StoreBtnPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BossScreenUserWidget.StoreBtnReleased
// (Final, Native, Public, BlueprintCallable)

void UBossScreenUserWidget::StoreBtnReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossScreenUserWidget", "StoreBtnReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BurningBloodPassive.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBurningBloodPassive::AbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurningBloodPassive", "AbilityStart");

	Params::BurningBloodPassive_AbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BurningBloodPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBurningBloodPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurningBloodPassive", "DamageDealt");

	Params::BurningBloodPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BurningBloodPassive.EventRequestEnd
// (Final, Native, Public)

void UBurningBloodPassive::EventRequestEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurningBloodPassive", "EventRequestEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.BurningBloodPassive.PreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UBurningBloodPassive::PreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurningBloodPassive", "PreDamaged");

	Params::BurningBloodPassive_PreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.BurningBloodPassive.Rest
// (Final, Native, Public)

void UBurningBloodPassive::Rest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurningBloodPassive", "Rest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InfoScreenUserWidget.GetLeftTextArray
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MaxElementNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UInfoScreenUserWidget::GetLeftTextArray(int32 MaxElementNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfoScreenUserWidget", "GetLeftTextArray");

	Params::InfoScreenUserWidget_GetLeftTextArray Parms{};

	Parms.MaxElementNum = MaxElementNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InfoScreenUserWidget.GetRightTextArray
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MaxElementNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LeftColumnNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UInfoScreenUserWidget::GetRightTextArray(int32 MaxElementNum, int32 LeftColumnNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfoScreenUserWidget", "GetRightTextArray");

	Params::InfoScreenUserWidget_GetRightTextArray Parms{};

	Parms.MaxElementNum = MaxElementNum;
	Parms.LeftColumnNum = LeftColumnNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InfoScreenUserWidget.OnSetData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInfoScreentDataAsset*            InInfoScreenData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfoScreenUserWidget::OnSetData(class UInfoScreentDataAsset* InInfoScreenData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfoScreenUserWidget", "OnSetData");

	Params::InfoScreenUserWidget_OnSetData Parms{};

	Parms.InInfoScreenData = InInfoScreenData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ArachnidAnimInstance.AddRopeImpulse
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArachnidAnimInstance::AddRopeImpulse(float Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "AddRopeImpulse");

	Params::ArachnidAnimInstance_AddRopeImpulse Parms{};

	Parms.Impulse = Impulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ArachnidAnimInstance.FinishMove
// (Final, Native, Protected, BlueprintCallable)

void UArachnidAnimInstance::FinishMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "FinishMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArachnidAnimInstance.InitMove
// (Final, Native, Protected, BlueprintCallable)

void UArachnidAnimInstance::InitMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "InitMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArachnidAnimInstance.StartMove
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArachnidAnimInstance::StartMove(class UAnimSequence* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "StartMove");

	Params::ArachnidAnimInstance_StartMove Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ArachnidAnimInstance.StopMove
// (Final, Native, Protected, BlueprintCallable)

void UArachnidAnimInstance::StopMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "StopMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArachnidAnimInstance.GetHeroLeanAngle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UArachnidAnimInstance::GetHeroLeanAngle(class FName SocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArachnidAnimInstance", "GetHeroLeanAngle");

	Params::ArachnidAnimInstance_GetHeroLeanAngle Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ArmorBreakerPassive.PostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UArmorBreakerPassive::PostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorBreakerPassive", "PostDamageCaused");

	Params::ArmorBreakerPassive_PostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ArmorBreakerPassive.PostDamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UArmorBreakerPassive::PostDamageReceived(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorBreakerPassive", "PostDamageReceived");

	Params::ArmorBreakerPassive_PostDamageReceived Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ArmorBreakerPassive.Rest
// (Final, Native, Public)

void UArmorBreakerPassive::Rest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorBreakerPassive", "Rest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArtbookUserWidget.JumpToNextPage
// (Final, Native, Protected, BlueprintCallable)

void UArtbookUserWidget::JumpToNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtbookUserWidget", "JumpToNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArtbookUserWidget.JumpToPreviousPage
// (Final, Native, Protected, BlueprintCallable)

void UArtbookUserWidget::JumpToPreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtbookUserWidget", "JumpToPreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ArtbookUserWidget.OnSetPage
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InPageNumber                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InCurrentPage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxPage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArtbookUserWidget::OnSetPage(const class FText& InPageNumber, int32 InCurrentPage, int32 InMaxPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtbookUserWidget", "OnSetPage");

	Params::ArtbookUserWidget_OnSetPage Parms{};

	Parms.InPageNumber = std::move(InPageNumber);
	Parms.InCurrentPage = InCurrentPage;
	Parms.InMaxPage = InMaxPage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ArtbookUserWidget.SetPage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InPageIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArtbookUserWidget::SetPage(int32 InPageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtbookUserWidget", "SetPage");

	Params::ArtbookUserWidget_SetPage Parms{};

	Parms.InPageIndex = InPageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.BPGetMaxHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::BPGetMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "BPGetMaxHealth");

	Params::AttributeContainer_BPGetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.BPHasEntityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::BPHasEntityTag(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "BPHasEntityTag");

	Params::AttributeContainer_BPHasEntityTag Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.BPModifyAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeModifier               Modifier                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bApply                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::BPModifyAttribute(EAttribute attribute, const struct FAttributeModifier& Modifier, bool bApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "BPModifyAttribute");

	Params::AttributeContainer_BPModifyAttribute Parms{};

	Parms.attribute = attribute;
	Parms.Modifier = std::move(Modifier);
	Parms.bApply = bApply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.BPModifyAttributeByValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Add                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveMultiply                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::BPModifyAttributeByValue(EAttribute attribute, float Add, float AdditiveMultiply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "BPModifyAttributeByValue");

	Params::AttributeContainer_BPModifyAttributeByValue Parms{};

	Parms.attribute = attribute;
	Parms.Add = Add;
	Parms.AdditiveMultiply = AdditiveMultiply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.BPSetAttributeBaseValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::BPSetAttributeBaseValue(EAttribute attribute, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "BPSetAttributeBaseValue");

	Params::AttributeContainer_BPSetAttributeBaseValue Parms{};

	Parms.attribute = attribute;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.GetAttributeValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::GetAttributeValue(EAttribute attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "GetAttributeValue");

	Params::AttributeContainer_GetAttributeValue Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.IsResourceLessThanPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAttributeContainer::IsResourceLessThanPercent(EEntityProperty resource, float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "IsResourceLessThanPercent");

	Params::AttributeContainer_IsResourceLessThanPercent Parms{};

	Parms.resource = resource;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.ModifyComboPointFractions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Modif                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::ModifyComboPointFractions(int32 Modif)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyComboPointFractions");

	Params::AttributeContainer_ModifyComboPointFractions Parms{};

	Parms.Modif = Modif;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.ModifyComboPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Modif                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::ModifyComboPoints(int32 Modif, bool bFireEvent, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyComboPoints");

	Params::AttributeContainer_ModifyComboPoints Parms{};

	Parms.Modif = Modif;
	Parms.bFireEvent = bFireEvent;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.ModifyEnergy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::ModifyEnergy(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyEnergy");

	Params::AttributeContainer_ModifyEnergy Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.ModifyEntropicEssence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Modification                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUINotif                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::ModifyEntropicEssence(int32 Modification, bool bUINotif)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyEntropicEssence");

	Params::AttributeContainer_ModifyEntropicEssence Parms{};

	Parms.Modification = Modification;
	Parms.bUINotif = bUINotif;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.ModifyEssence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Modification                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUINotif                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyEssenceModifier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdatePlayerStatistics                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttributeContainer::ModifyEssence(int32 Modification, bool bUINotif, bool bApplyEssenceModifier, bool bUpdatePlayerStatistics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyEssence");

	Params::AttributeContainer_ModifyEssence Parms{};

	Parms.Modification = Modification;
	Parms.bUINotif = bUINotif;
	Parms.bApplyEssenceModifier = bApplyEssenceModifier;
	Parms.bUpdatePlayerStatistics = bUpdatePlayerStatistics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AttributeContainer.ModifyRage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::ModifyRage(float Value, bool bTriggerEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyRage");

	Params::AttributeContainer_ModifyRage Parms{};

	Parms.Value = Value;
	Parms.bTriggerEvent = bTriggerEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.ModifyStamina
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeContainer::ModifyStamina(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "ModifyStamina");

	Params::AttributeContainer_ModifyStamina Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AttributeContainer.GetCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bUIName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAttributeContainer::GetCharacterName(bool bUIName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeContainer", "GetCharacterName");

	Params::AttributeContainer_GetCharacterName Parms{};

	Parms.bUIName = bUIName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.AutotesterAI.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UAutotesterAI::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutotesterAI", "OnPreDamageCaused");

	Params::AutotesterAI_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AutotesterAI.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UAutotesterAI::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutotesterAI", "OnPreDamagedPriority");

	Params::AutotesterAI_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.AvatarOfFireAbility.OnAbilityStartEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAvatarOfFireAbility::OnAbilityStartEvent(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarOfFireAbility", "OnAbilityStartEvent");

	Params::AvatarOfFireAbility_OnAbilityStartEvent Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.AvatarOfFireAbility.StatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAvatarOfFireAbility::StatusEffectCaused(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AvatarOfFireAbility", "StatusEffectCaused");

	Params::AvatarOfFireAbility_StatusEffectCaused Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BanditBruteBossAI.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UBanditBruteBossAI::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BanditBruteBossAI", "OnPreDamagedPriority");

	Params::BanditBruteBossAI_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.BarricadeActor.BeginOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABarricadeActor::BeginOverlap(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BarricadeActor", "BeginOverlap");

	Params::BarricadeActor_BeginOverlap Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BarricadeActor.BeginProjectileOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABarricadeActor::BeginProjectileOverlap(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BarricadeActor", "BeginProjectileOverlap");

	Params::BarricadeActor_BeginProjectileOverlap Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BarricadeActor.EndOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABarricadeActor::EndOverlap(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BarricadeActor", "EndOverlap");

	Params::BarricadeActor_EndOverlap Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BarricadeActor.PreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void ABarricadeActor::PreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BarricadeActor", "PreDamaged");

	Params::BarricadeActor_PreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.HeroShadowStepAbility.GetTargetLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroShadowStepAbility::GetTargetLocation(struct FVector* TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroShadowStepAbility", "GetTargetLocation");

	Params::HeroShadowStepAbility_GetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);

	return Parms.ReturnValue;
}


// Function man.BloodStainVisualEntity.BloodStainBuildupPostConstructionFinished
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          DamagePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SplashRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageTakenVFXDataAsset*         BloodSourceAsset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABloodStainVisualEntity::BloodStainBuildupPostConstructionFinished(const struct FVector& DamagePosition, float SplashRadius, int32 Stage, class UDamageTakenVFXDataAsset* BloodSourceAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainVisualEntity", "BloodStainBuildupPostConstructionFinished");

	Params::BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished Parms{};

	Parms.DamagePosition = std::move(DamagePosition);
	Parms.SplashRadius = SplashRadius;
	Parms.Stage = Stage;
	Parms.BloodSourceAsset = BloodSourceAsset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.BloodStainVisualEntity.BloodStainBuildupRefresh
// (Event, Public, BlueprintEvent)

void ABloodStainVisualEntity::BloodStainBuildupRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainVisualEntity", "BloodStainBuildupRefresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.BloodStainVisualEntity.BloodStainBuildupTimeout
// (Event, Public, BlueprintEvent)

void ABloodStainVisualEntity::BloodStainBuildupTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodStainVisualEntity", "BloodStainBuildupTimeout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HeroBase.AbilityFourAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::AbilityFourAxis(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "AbilityFourAxis");

	Params::HeroBase_AbilityFourAxis Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandAbilityFour
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandAbilityOne
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandAbilityOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandAbilityOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandAbilityThree
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandAbilityThree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandAbilityThree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandAbilityTwo
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandAbilityTwo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandAbilityTwo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandRepeatAbilityFour
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandRepeatAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandRepeatAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandRoll
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandStopAbilityFour
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandStopAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandStopAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandStopAbilityOne
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandStopAbilityOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandStopAbilityOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandStopAbilityThree
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandStopAbilityThree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandStopAbilityThree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPCommandStopAbilityTwo
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::BPCommandStopAbilityTwo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPCommandStopAbilityTwo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPGetEntropyLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEntropyLantern*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEntropyLantern* AHeroBase::BPGetEntropyLantern()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPGetEntropyLantern");

	Params::HeroBase_BPGetEntropyLantern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroBase.BPOnGrabpointGrabbed
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AGrabPoint*                       GrabPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::BPOnGrabpointGrabbed(class AGrabPoint* GrabPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPOnGrabpointGrabbed");

	Params::HeroBase_BPOnGrabpointGrabbed Parms{};

	Parms.GrabPoint = GrabPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPTeleportToLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>            LevelReference                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TeleportTargetName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCheckpointData*                  TargetCheckpoint                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::BPTeleportToLevel(TSoftObjectPtr<class UWorld> LevelReference, class FName TeleportTargetName, class UCheckpointData* TargetCheckpoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPTeleportToLevel");

	Params::HeroBase_BPTeleportToLevel Parms{};

	Parms.LevelReference = LevelReference;
	Parms.TeleportTargetName = TeleportTargetName;
	Parms.TargetCheckpoint = TargetCheckpoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.BPTeleportToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipFadeOut                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFadeInStarted                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFadeInFinished                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHeroBase::BPTeleportToLocation(const struct FVector& NewLocation, bool bSkipFadeOut, const TDelegate<void()>& OnFadeInStarted, const TDelegate<void()>& OnFadeInFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "BPTeleportToLocation");

	Params::HeroBase_BPTeleportToLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSkipFadeOut = bSkipFadeOut;
	Parms.OnFadeInStarted = OnFadeInStarted;
	Parms.OnFadeInFinished = OnFadeInFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CheatMaxOutHero
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CheatMaxOutHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CheatMaxOutHero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandAbilityFour
// (Final, Native, Public)

void AHeroBase::CommandAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandAbilityOne
// (Final, Native, Public)

void AHeroBase::CommandAbilityOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandAbilityOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandAbilityThree
// (Final, Native, Public)

void AHeroBase::CommandAbilityThree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandAbilityThree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandAbilityTwo
// (Final, Native, Public)

void AHeroBase::CommandAbilityTwo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandAbilityTwo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandDodge
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandDodge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandInteractWithObject
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandInteractWithObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandInteractWithObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandInteractWithObject_Release
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandInteractWithObject_Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandInteractWithObject_Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandItemSet1
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandItemSet1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandItemSet1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandItemSet2
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandItemSet2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandItemSet2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandNextQuickUseItem
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandNextQuickUseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandNextQuickUseItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandPreviousQuickUseItem
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandPreviousQuickUseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandPreviousQuickUseItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRepeatAbilityFour
// (Final, Native, Public)

void AHeroBase::CommandRepeatAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRepeatAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRoll
// (Final, Native, Public)

void AHeroBase::CommandRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRotateSkillSlot2
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandRotateSkillSlot2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRotateSkillSlot2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRotateSkillSlot2_Release
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandRotateSkillSlot2_Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRotateSkillSlot2_Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRotateSkillSlot2_Repeat
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandRotateSkillSlot2_Repeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRotateSkillSlot2_Repeat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandRotateSkillSlot3
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandRotateSkillSlot3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandRotateSkillSlot3");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandShowIngameMenu
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandShowIngameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandShowIngameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandShowInventory
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandShowInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandShowInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandShowMap
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandShowMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandShowMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandStopAbilityFour
// (Final, Native, Public)

void AHeroBase::CommandStopAbilityFour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandStopAbilityFour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandStopAbilityOne
// (Final, Native, Public)

void AHeroBase::CommandStopAbilityOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandStopAbilityOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandStopAbilityThree
// (Final, Native, Public)

void AHeroBase::CommandStopAbilityThree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandStopAbilityThree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandStopAbilityTwo
// (Final, Native, Public)

void AHeroBase::CommandStopAbilityTwo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandStopAbilityTwo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandToggleConsumable
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandToggleConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandToggleConsumable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandToggleItemSet
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandToggleItemSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandToggleItemSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandToggleWeaponConfig
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandToggleWeaponConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandToggleWeaponConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandToggleWeaponConfigBack
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandToggleWeaponConfigBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandToggleWeaponConfigBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandUseConsumable
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandUseConsumable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandUseConsumable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandUseQuickUseItem
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandUseQuickUseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandUseQuickUseItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.CommandUseQuickUseItem_Release
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::CommandUseQuickUseItem_Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "CommandUseQuickUseItem_Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.FadeInFinished_PureInternalTeleport
// (Final, Native, Public)

void AHeroBase::FadeInFinished_PureInternalTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "FadeInFinished_PureInternalTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.GetOffhandAbilitySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* AHeroBase::GetOffhandAbilitySlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "GetOffhandAbilitySlot");

	Params::HeroBase_GetOffhandAbilitySlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroBase.InteractWithTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHeroBase::InteractWithTarget(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "InteractWithTarget");

	Params::HeroBase_InteractWithTarget Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroBase.OnActorBeginOverlapHandler
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnActorBeginOverlapHandler(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnActorBeginOverlapHandler");

	Params::HeroBase_OnActorBeginOverlapHandler Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnActorEndOverlapHandler
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnActorEndOverlapHandler(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnActorEndOverlapHandler");

	Params::HeroBase_OnActorEndOverlapHandler Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnBeginOverlapVisualComponent
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHeroBase::OnBeginOverlapVisualComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnBeginOverlapVisualComponent");

	Params::HeroBase_OnBeginOverlapVisualComponent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnBossFightStarted
// (Final, Native, Public)

void AHeroBase::OnBossFightStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnBossFightStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnDeathEssencePickup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityBase*                     DeathEssenceAbility                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnDeathEssencePickup(class UAbilityBase* DeathEssenceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnDeathEssencePickup");

	Params::HeroBase_OnDeathEssencePickup Parms{};

	Parms.DeathEssenceAbility = DeathEssenceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnEndOverlapVisualComponent
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnEndOverlapVisualComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnEndOverlapVisualComponent");

	Params::HeroBase_OnEndOverlapVisualComponent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnGrapplingHookEnd
// (Native, Event, Public, BlueprintEvent)

void AHeroBase::OnGrapplingHookEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnGrapplingHookEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnGrapplingHookStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           GrapplingHook                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnGrapplingHookStart(class AActor* GrapplingHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnGrapplingHookStart");

	Params::HeroBase_OnGrapplingHookStart Parms{};

	Parms.GrapplingHook = GrapplingHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnHealthChanged
// (Final, Native, Private)
// Parameters:
// float                                   preHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   newHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnHealthChanged(float preHealth, float newHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnHealthChanged");

	Params::HeroBase_OnHealthChanged Parms{};

	Parms.preHealth = preHealth;
	Parms.newHealth = newHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnMatchHasStarted
// (Final, Native, Public)

void AHeroBase::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnOverlap");

	Params::HeroBase_OnOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnOverlapEnd
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnOverlapEnd");

	Params::HeroBase_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.OnPropertyChanged
// (Final, Native, Private)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "OnPropertyChanged");

	Params::HeroBase_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.PlayerCombatVOEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bTaunt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::PlayerCombatVOEvent(bool bTaunt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "PlayerCombatVOEvent");

	Params::HeroBase_PlayerCombatVOEvent Parms{};

	Parms.bTaunt = bTaunt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HeroBase.ResetStamina
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::ResetStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "ResetStamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.ToggleCapsue
// (Final, Native, Public, BlueprintCallable)

void AHeroBase::ToggleCapsue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "ToggleCapsue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroBase.ToggleChaosFactorBlocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDeactivate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHeroBase::ToggleChaosFactorBlocker(bool bDeactivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroBase", "ToggleChaosFactorBlocker");

	Params::HeroBase_ToggleChaosFactorBlocker Parms{};

	Parms.bDeactivate = bDeactivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerHero.GetListenerPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ABrawlerHero::GetListenerPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerHero", "GetListenerPosition");

	Params::BrawlerHero_GetListenerPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.BrawlerHero.OnLevelSequencePaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABrawlerHero::OnLevelSequencePaused(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerHero", "OnLevelSequencePaused");

	Params::BrawlerHero_OnLevelSequencePaused Parms{};

	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.BrawlerHero.IsCameraUpsideDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABrawlerHero::IsCameraUpsideDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BrawlerHero", "IsCameraUpsideDown");

	Params::BrawlerHero_IsCameraUpsideDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CDryadAI.IsValidTeleportPos
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutOverride                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutValid                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCDryadAI::IsValidTeleportPos(struct FVector* Location, bool* bOutOverride, bool* bOutValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CDryadAI", "IsValidTeleportPos");

	Params::CDryadAI_IsValidTeleportPos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (bOutOverride != nullptr)
		*bOutOverride = Parms.bOutOverride;

	if (bOutValid != nullptr)
		*bOutValid = Parms.bOutValid;
}


// Function man.ChaoticOverchargePassive.OnChaos
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaoticOverchargePassive::OnChaos(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaoticOverchargePassive", "OnChaos");

	Params::ChaoticOverchargePassive_OnChaos Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FuryOfTheElements.BPGetDamageTypeForVFX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDamageType UFuryOfTheElements::BPGetDamageTypeForVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FuryOfTheElements", "BPGetDamageTypeForVFX");

	Params::FuryOfTheElements_BPGetDamageTypeForVFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FuryOfTheElements.OnPreDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFuryOfTheElements::OnPreDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FuryOfTheElements", "OnPreDamageCaused");

	Params::FuryOfTheElements_OnPreDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FuryOfTheElements.OnResourcesConsumed
// (Final, Native, Protected)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFuryOfTheElements::OnResourcesConsumed(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FuryOfTheElements", "OnResourcesConsumed");

	Params::FuryOfTheElements_OnResourcesConsumed Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FuryOfTheElements.Reset
// (Final, Native, Protected)

void UFuryOfTheElements::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FuryOfTheElements", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterNameUserWidget.BtnHotkeyAClickedRequest
// (Final, Native, Protected, BlueprintCallable)

void UCharacterNameUserWidget::BtnHotkeyAClickedRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterNameUserWidget", "BtnHotkeyAClickedRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterNameUserWidget.OnSetErrorText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InErrorText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterNameUserWidget::OnSetErrorText(const class FText& InErrorText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterNameUserWidget", "OnSetErrorText");

	Params::CharacterNameUserWidget_OnSetErrorText Parms{};

	Parms.InErrorText = std::move(InErrorText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CharacterNameUserWidget.OnTextChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterNameUserWidget::OnTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterNameUserWidget", "OnTextChanged");

	Params::CharacterNameUserWidget_OnTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterNameUserWidget.OnTextCommitted
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterNameUserWidget::OnTextCommitted(const class FText& InText, ETextCommit CommitMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterNameUserWidget", "OnTextCommitted");

	Params::CharacterNameUserWidget_OnTextCommitted Parms{};

	Parms.InText = std::move(InText);
	Parms.CommitMethod = CommitMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CharacterScreenCapture2D.OnShutdown
// (Final, Native, Private)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterScreenCapture2D::OnShutdown(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterScreenCapture2D", "OnShutdown");

	Params::CharacterScreenCapture2D_OnShutdown Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteAttackLungeOneAndTwo.OnParried
// (Final, Native, Public)

void UMarionetteAttackLungeOneAndTwo::OnParried()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteAttackLungeOneAndTwo", "OnParried");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PlayerStatsWindowUserWidget.OnSetHeroLevel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             LevelText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerStatsWindowUserWidget::OnSetHeroLevel(const class FText& LevelText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWindowUserWidget", "OnSetHeroLevel");

	Params::PlayerStatsWindowUserWidget_OnSetHeroLevel Parms{};

	Parms.LevelText = std::move(LevelText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerStatsWindowUserWidget.OnSetXp
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   PlayerCurrentXp                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayerXpCurrentLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayerXpNextLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsWindowUserWidget::OnSetXp(float PlayerCurrentXp, float PlayerXpCurrentLevel, float PlayerXpNextLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWindowUserWidget", "OnSetXp");

	Params::PlayerStatsWindowUserWidget_OnSetXp Parms{};

	Parms.PlayerCurrentXp = PlayerCurrentXp;
	Parms.PlayerXpCurrentLevel = PlayerXpCurrentLevel;
	Parms.PlayerXpNextLevel = PlayerXpNextLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ChargeActiveAbility.GetCurrentShieldCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeActiveAbility::GetCurrentShieldCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeActiveAbility", "GetCurrentShieldCharge");

	Params::ChargeActiveAbility_GetCurrentShieldCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChargeActiveAbility.GetMaxShieldCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeActiveAbility::GetMaxShieldCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeActiveAbility", "GetMaxShieldCharge");

	Params::ChargeActiveAbility_GetMaxShieldCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ChargedProjectileShoot.GetCurrentChargedExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UChargedProjectileShoot::GetCurrentChargedExtent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedProjectileShoot", "GetCurrentChargedExtent");

	Params::ChargedProjectileShoot_GetCurrentChargedExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WhirlwindAbility.MaxRampReached_BP
// (Event, Public, BlueprintEvent)

void UWhirlwindAbility::MaxRampReached_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhirlwindAbility", "MaxRampReached_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.WhirlwindAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWhirlwindAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhirlwindAbility", "PostDamageDealt");

	Params::WhirlwindAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WhirlwindAbility.PreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UWhirlwindAbility::PreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WhirlwindAbility", "PreDamagedPriority");

	Params::WhirlwindAbility_PreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.DivineInterventionPassive.OnPreDamaged_DivineIntervention
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDivineInterventionPassive::OnPreDamaged_DivineIntervention(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineInterventionPassive", "OnPreDamaged_DivineIntervention");

	Params::DivineInterventionPassive_OnPreDamaged_DivineIntervention Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.RiftChestActor.OnGameplayEvent
// (Final, Native, Private)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARiftChestActor::OnGameplayEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiftChestActor", "OnGameplayEvent");

	Params::RiftChestActor_OnGameplayEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CogAnimInstance.ResetCogs
// (Final, Native, Protected, BlueprintCallable)

void UCogAnimInstance::ResetCogs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CogAnimInstance", "ResetCogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CogAnimInstance.UpdateCogs
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpeedUp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCogAnimInstance::UpdateCogs(float DeltaSeconds, bool bSpeedUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CogAnimInstance", "UpdateCogs");

	Params::CogAnimInstance_UpdateCogs Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.bSpeedUp = bSpeedUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CollectionUserWidget.OnSetCollectionCountText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InCollectionCountText                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bChanged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectionUserWidget::OnSetCollectionCountText(const class FText& InCollectionCountText, bool bChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionUserWidget", "OnSetCollectionCountText");

	Params::CollectionUserWidget_OnSetCollectionCountText Parms{};

	Parms.InCollectionCountText = std::move(InCollectionCountText);
	Parms.bChanged = bChanged;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CollectionUserWidget.OnUpdateDetailsPanel
// (Final, Native, Protected)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectionUserWidget::OnUpdateDetailsPanel(class UManItemSlotBase* ManItemSlotBase, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionUserWidget", "OnUpdateDetailsPanel");

	Params::CollectionUserWidget_OnUpdateDetailsPanel Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLocalPlayer.GetAbilityController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* UManLocalPlayer::GetAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLocalPlayer", "GetAbilityController");

	Params::ManLocalPlayer_GetAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManLocalPlayer.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* UManLocalPlayer::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLocalPlayer", "GetAttributeContainer");

	Params::ManLocalPlayer_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManLocalPlayer.IsMenuGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManLocalPlayer::IsMenuGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLocalPlayer", "IsMenuGame");

	Params::ManLocalPlayer_IsMenuGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManLocalPlayer.OnSaveGameError
// (Final, Native, Private)

void UManLocalPlayer::OnSaveGameError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLocalPlayer", "OnSaveGameError");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLocalPlayer.OnShowSaveGameFailedDialogeWindowResult
// (Final, Native, Private)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManLocalPlayer::OnShowSaveGameFailedDialogeWindowResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLocalPlayer", "OnShowSaveGameFailedDialogeWindowResult");

	Params::ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CombatState.OnLanded
// (Final, Native, Public)

void UCombatState::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatState", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LootTableItemEntry.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULootTableItemEntry::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootTableItemEntry", "GetEditorName");

	Params::LootTableItemEntry_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MapObjectUserWidget.OnSetCheckpoint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bCheckpoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckpointEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InDisplayName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMapObjectUserWidget::OnSetCheckpoint(bool bCheckpoint, bool bCheckpointEnabled, const class FText& InDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "OnSetCheckpoint");

	Params::MapObjectUserWidget_OnSetCheckpoint Parms{};

	Parms.bCheckpoint = bCheckpoint;
	Parms.bCheckpointEnabled = bCheckpointEnabled;
	Parms.InDisplayName = std::move(InDisplayName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapObjectUserWidget.OnSetCheckpointNameVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapObjectUserWidget::OnSetCheckpointNameVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "OnSetCheckpointNameVisible");

	Params::MapObjectUserWidget_OnSetCheckpointNameVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapObjectUserWidget.OnSetIcon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMiniMapGatewaySide                     InGatewaySide                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMiniMapGatewayState                    InGatewayState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapObjectUserWidget::OnSetIcon(class UTexture2D* InIcon, EMiniMapGatewaySide InGatewaySide, EMiniMapGatewayState InGatewayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "OnSetIcon");

	Params::MapObjectUserWidget_OnSetIcon Parms{};

	Parms.InIcon = InIcon;
	Parms.InGatewaySide = InGatewaySide;
	Parms.InGatewayState = InGatewayState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapObjectUserWidget.OnSetType
// (Event, Public, BlueprintEvent)
// Parameters:
// EMapQuestObjectiveType                  InMapQuestObjectiveType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapObjectUserWidget::OnSetType(EMapQuestObjectiveType InMapQuestObjectiveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "OnSetType");

	Params::MapObjectUserWidget_OnSetType Parms{};

	Parms.InMapQuestObjectiveType = InMapQuestObjectiveType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapObjectUserWidget.IsCheckpoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapObjectUserWidget::IsCheckpoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "IsCheckpoint");

	Params::MapObjectUserWidget_IsCheckpoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MapObjectUserWidget.IsMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapObjectUserWidget::IsMarker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapObjectUserWidget", "IsMarker");

	Params::MapObjectUserWidget_IsMarker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConsecrationAbility.WorldReset
// (Final, Native, Public)

void UConsecrationAbility::WorldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsecrationAbility", "WorldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ControllerDisplayUserWidget.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerDisplayUserWidget::OnSetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerDisplayUserWidget", "OnSetActive");

	Params::ControllerDisplayUserWidget_OnSetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ControllerDisplayUserWidget.OnSetInputDisplay
// (Event, Public, BlueprintEvent)
// Parameters:
// EInputDisplay                           InInputDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           InControlDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bControllerDisplayUserWidgetVisible                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerDisplayUserWidget::OnSetInputDisplay(EInputDisplay InInputDisplay, EInputDisplay InControlDisplay, bool bControllerDisplayUserWidgetVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerDisplayUserWidget", "OnSetInputDisplay");

	Params::ControllerDisplayUserWidget_OnSetInputDisplay Parms{};

	Parms.InInputDisplay = InInputDisplay;
	Parms.InControlDisplay = InControlDisplay;
	Parms.bControllerDisplayUserWidgetVisible = bControllerDisplayUserWidgetVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MarionetteWarlordAI.BPFinishPauseFightBeforePhase2Timer
// (Final, Native, Public, BlueprintCallable)

void UMarionetteWarlordAI::BPFinishPauseFightBeforePhase2Timer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteWarlordAI", "BPFinishPauseFightBeforePhase2Timer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteWarlordAI.BPFinishPauseFightBeforePhase3Timer
// (Final, Native, Public, BlueprintCallable)

void UMarionetteWarlordAI::BPFinishPauseFightBeforePhase3Timer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteWarlordAI", "BPFinishPauseFightBeforePhase3Timer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationBtnUserWidget.GetIconButtonType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimalConversationResponseButtonType   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPrimalConversationResponseButtonType UConversationBtnUserWidget::GetIconButtonType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBtnUserWidget", "GetIconButtonType");

	Params::ConversationBtnUserWidget_GetIconButtonType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationBtnUserWidget.OnClear
// (Event, Public, BlueprintEvent)

void UConversationBtnUserWidget::OnClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBtnUserWidget", "OnClear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ConversationBtnUserWidget.OnSetBtnState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationBtnUserWidget::OnSetBtnState(bool bDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBtnUserWidget", "OnSetBtnState");

	Params::ConversationBtnUserWidget_OnSetBtnState Parms{};

	Parms.bDisabled = bDisabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationBtnUserWidget.TriggerClicked
// (Final, Native, Public, BlueprintCallable)

void UConversationBtnUserWidget::TriggerClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBtnUserWidget", "TriggerClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ConversationClearText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ConversationClearText(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ConversationClearText");

	Params::ConversationFunctionLibrary_ConversationClearText Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ConversationLevelChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            LevelReference                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TeleportTargetName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCheckpointData*                  TargetCheckpoint                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ConversationLevelChange(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> LevelReference, class FName TeleportTargetName, class UCheckpointData* TargetCheckpoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ConversationLevelChange");

	Params::ConversationFunctionLibrary_ConversationLevelChange Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelReference = LevelReference;
	Parms.TeleportTargetName = TeleportTargetName;
	Parms.TargetCheckpoint = TargetCheckpoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ConversationTabButtonsEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ConversationTabButtonsEnabled(class UObject* WorldContextObject, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ConversationTabButtonsEnabled");

	Params::ConversationFunctionLibrary_ConversationTabButtonsEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ConversationTabButtonsVisible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ConversationTabButtonsVisible(class UObject* WorldContextObject, bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ConversationTabButtonsVisible");

	Params::ConversationFunctionLibrary_ConversationTabButtonsVisible Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ConversationUnlockCheckPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCheckpointData*                  UnlockCheckPoint                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetAsRespawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ConversationUnlockCheckPoint(class UObject* WorldContextObject, class UCheckpointData* UnlockCheckPoint, bool bSetAsRespawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ConversationUnlockCheckPoint");

	Params::ConversationFunctionLibrary_ConversationUnlockCheckPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UnlockCheckPoint = UnlockCheckPoint;
	Parms.bSetAsRespawn = bSetAsRespawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.GlobalDictionaryGetBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionaryGetBool(class UObject* WorldContextObject, bool* OutValue, const class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionaryGetBool");

	Params::ConversationFunctionLibrary_GlobalDictionaryGetBool Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionaryGetFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionaryGetFloat(class UObject* WorldContextObject, float* OutValue, const class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionaryGetFloat");

	Params::ConversationFunctionLibrary_GlobalDictionaryGetFloat Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionaryGetInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionaryGetInt(class UObject* WorldContextObject, int32* OutValue, const class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionaryGetInt");

	Params::ConversationFunctionLibrary_GlobalDictionaryGetInt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionaryGetString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionaryGetString(class UObject* WorldContextObject, class FString* OutValue, const class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionaryGetString");

	Params::ConversationFunctionLibrary_GlobalDictionaryGetString Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionaryIsExists
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionaryIsExists(class UObject* WorldContextObject, const class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionaryIsExists");

	Params::ConversationFunctionLibrary_GlobalDictionaryIsExists Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionarySetBool
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionarySetBool(class UObject* WorldContextObject, const class FName Name_0, bool InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionarySetBool");

	Params::ConversationFunctionLibrary_GlobalDictionarySetBool Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionarySetFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionarySetFloat(class UObject* WorldContextObject, const class FName Name_0, float InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionarySetFloat");

	Params::ConversationFunctionLibrary_GlobalDictionarySetFloat Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionarySetInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionarySetInt(class UObject* WorldContextObject, const class FName Name_0, int32 InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionarySetInt");

	Params::ConversationFunctionLibrary_GlobalDictionarySetInt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.GlobalDictionarySetString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValue                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationFunctionLibrary::GlobalDictionarySetString(class UObject* WorldContextObject, const class FName Name_0, const class FString& InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "GlobalDictionarySetString");

	Params::ConversationFunctionLibrary_GlobalDictionarySetString Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Name_0 = Name_0;
	Parms.InValue = std::move(InValue);
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationFunctionLibrary.ShowConversationOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EPrimalConversationResponseButtonType   ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGrayedOut                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ShowConversationOption(class UObject* WorldContextObject, const class UDialogueDataAsset* DialogueDataAsset, const struct FLatentActionInfo& LatentInfo, EPrimalConversationResponseButtonType ButtonType, bool bGrayedOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ShowConversationOption");

	Params::ConversationFunctionLibrary_ShowConversationOption Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.ButtonType = ButtonType;
	Parms.bGrayedOut = bGrayedOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ShowConversationPortrait
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimalConversationSpeaker*       Speaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ShowConversationPortrait(class UObject* WorldContextObject, class UPrimalConversationSpeaker* Speaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ShowConversationPortrait");

	Params::ConversationFunctionLibrary_ShowConversationPortrait Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Speaker = Speaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ShowConversationRandomText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bInstantContinue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ShowConversationRandomText(class UObject* WorldContextObject, const class UDialogueDataAsset* DialogueDataAsset, const struct FLatentActionInfo& LatentInfo, bool bInstantContinue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ShowConversationRandomText");

	Params::ConversationFunctionLibrary_ShowConversationRandomText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bInstantContinue = bInstantContinue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationFunctionLibrary.ShowConversationText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bInstantContinue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationFunctionLibrary::ShowConversationText(class UObject* WorldContextObject, const class UDialogueDataAsset* DialogueDataAsset, const struct FLatentActionInfo& LatentInfo, bool bInstantContinue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationFunctionLibrary", "ShowConversationText");

	Params::ConversationFunctionLibrary_ShowConversationText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bInstantContinue = bInstantContinue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationInfo.BPOnStartConversation
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ConversationName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AConversationInfo::BPOnStartConversation(class FName ConversationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInfo", "BPOnStartConversation");

	Params::ConversationInfo_BPOnStartConversation Parms{};

	Parms.ConversationName = ConversationName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SplinterSwarm.BPGetHitBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplinterSwarm::BPGetHitBoxExtent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplinterSwarm", "BPGetHitBoxExtent");

	Params::SplinterSwarm_BPGetHitBoxExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SplinterSwarm.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USplinterSwarm::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplinterSwarm", "OnPostDamageCaused");

	Params::SplinterSwarm_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SplinterSwarm.Reset
// (Final, Native, Protected)

void USplinterSwarm::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplinterSwarm", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.CloseBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UConversationUserWidget::CloseBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "CloseBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.Continue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ResponseIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::Continue(int32 ResponseIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "Continue");

	Params::ConversationUserWidget_Continue Parms{};

	Parms.ResponseIndex = ResponseIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.OnClearSpeakerLine
// (Event, Public, BlueprintEvent)

void UConversationUserWidget::OnClearSpeakerLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnClearSpeakerLine");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ConversationUserWidget.OnConversationResponseClicked
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ResponseIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnConversationResponseClicked(int32 ResponseIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnConversationResponseClicked");

	Params::ConversationUserWidget_OnConversationResponseClicked Parms{};

	Parms.ResponseIndex = ResponseIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationUserWidget.OnHideOptions
// (Event, Public, BlueprintEvent)

void UConversationUserWidget::OnHideOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnHideOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ConversationUserWidget.OnLineTextVisible
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           LineText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnLineTextVisible(const class FString& LineText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnLineTextVisible");

	Params::ConversationUserWidget_OnLineTextVisible Parms{};

	Parms.LineText = std::move(LineText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.OnSetConversation
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             SpeakerText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             FormattedSpeakerText                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LineIDText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSkippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnSetConversation(const class FText& SpeakerText, const class FText& FormattedSpeakerText, const class FText& LineIDText, bool bSkippable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnSetConversation");

	Params::ConversationUserWidget_OnSetConversation Parms{};

	Parms.SpeakerText = std::move(SpeakerText);
	Parms.FormattedSpeakerText = std::move(FormattedSpeakerText);
	Parms.LineIDText = std::move(LineIDText);
	Parms.bSkippable = bSkippable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationUserWidget.OnSetOpacity
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnSetOpacity(float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnSetOpacity");

	Params::ConversationUserWidget_OnSetOpacity Parms{};

	Parms.Opacity = Opacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationUserWidget.OnShowOptions
// (Event, Public, BlueprintEvent)

void UConversationUserWidget::OnShowOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnShowOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ConversationUserWidget.OnShowSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FConversationSpeakerInfo         SpeakerInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnShowSlot(const struct FConversationSpeakerInfo& SpeakerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnShowSlot");

	Params::ConversationUserWidget_OnShowSlot Parms{};

	Parms.SpeakerInfo = std::move(SpeakerInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationUserWidget.OnSubtitleEnable
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::OnSubtitleEnable(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "OnSubtitleEnable");

	Params::ConversationUserWidget_OnSubtitleEnable Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ConversationUserWidget.SetDialogOptionsVisible
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInDialogOptionsVisible                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationUserWidget::SetDialogOptionsVisible(bool bInDialogOptionsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "SetDialogOptionsVisible");

	Params::ConversationUserWidget_SetDialogOptionsVisible Parms{};

	Parms.bInDialogOptionsVisible = bInDialogOptionsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.Skip
// (Final, Native, Public, BlueprintCallable)

void UConversationUserWidget::Skip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "Skip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConversationUserWidget.GetResponseButtons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UConversationBtnUserWidget*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UConversationBtnUserWidget*> UConversationUserWidget::GetResponseButtons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "GetResponseButtons");

	Params::ConversationUserWidget_GetResponseButtons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ConversationUserWidget.IsDialogOptionsVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationUserWidget::IsDialogOptionsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationUserWidget", "IsDialogOptionsVisible");

	Params::ConversationUserWidget_IsDialogOptionsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VortexActor.OnPostDamageDone
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AVortexActor::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VortexActor", "OnPostDamageDone");

	Params::VortexActor_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CorrosiveAgent.StatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           ToTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCorrosiveAgent::StatusEffectCaused(class AActor* ToTarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CorrosiveAgent", "StatusEffectCaused");

	Params::CorrosiveAgent_StatusEffectCaused Parms{};

	Parms.ToTarget = ToTarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterSelUserWidget.OnSetEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSelUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSelUserWidget", "OnSetEnabled");

	Params::CreateCharacterSelUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterSelUserWidget.OnSetFocusAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSelUserWidget::OnSetFocusAnim(bool bInFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSelUserWidget", "OnSetFocusAnim");

	Params::CreateCharacterSelUserWidget_OnSetFocusAnim Parms{};

	Parms.bInFocused = bInFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterSelUserWidget.OnSetOptionsArray
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FText>                     InOptions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InSelectedIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterSelUserWidget::OnSetOptionsArray(const TArray<class FText>& InOptions, int32 InSelectedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterSelUserWidget", "OnSetOptionsArray");

	Params::CreateCharacterSelUserWidget_OnSetOptionsArray Parms{};

	Parms.InOptions = std::move(InOptions);
	Parms.InSelectedIndex = InSelectedIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.BackToMainMenuRequest
// (Final, Native, Public, BlueprintCallable)

void UCreateCharacterUserWidget::BackToMainMenuRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "BackToMainMenuRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeFaceIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InFaceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeFaceIndex(int32 InFaceIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeFaceIndex");

	Params::CreateCharacterUserWidget_ChangeFaceIndex Parms{};

	Parms.InFaceIndex = InFaceIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeGender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInMale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeGender(bool bInMale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeGender");

	Params::CreateCharacterUserWidget_ChangeGender Parms{};

	Parms.bInMale = bInMale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeHairColorIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHairColorIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeHairColorIndex(int32 InHairColorIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeHairColorIndex");

	Params::CreateCharacterUserWidget_ChangeHairColorIndex Parms{};

	Parms.InHairColorIndex = InHairColorIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeHairStyleIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHairStyleIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeHairStyleIndex(int32 InHairStyleIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeHairStyleIndex");

	Params::CreateCharacterUserWidget_ChangeHairStyleIndex Parms{};

	Parms.InHairStyleIndex = InHairStyleIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeSkinColorIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSkinColorIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeSkinColorIndex(int32 InSkinColorIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeSkinColorIndex");

	Params::CreateCharacterUserWidget_ChangeSkinColorIndex Parms{};

	Parms.InSkinColorIndex = InSkinColorIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeTattooIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InTattooIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeTattooIndex(int32 InTattooIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeTattooIndex");

	Params::CreateCharacterUserWidget_ChangeTattooIndex Parms{};

	Parms.InTattooIndex = InTattooIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.ChangeVoiceIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InVoiceIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::ChangeVoiceIndex(int32 InVoiceIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ChangeVoiceIndex");

	Params::CreateCharacterUserWidget_ChangeVoiceIndex Parms{};

	Parms.InVoiceIndex = InVoiceIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.OnChangeFaceIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InFaceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeFaceIndex(int32 InFaceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeFaceIndex");

	Params::CreateCharacterUserWidget_OnChangeFaceIndex Parms{};

	Parms.InFaceIndex = InFaceIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeGender
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInMale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeGender(bool bInMale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeGender");

	Params::CreateCharacterUserWidget_OnChangeGender Parms{};

	Parms.bInMale = bInMale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeHairColorIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InHairColorIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeHairColorIndex(int32 InHairColorIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeHairColorIndex");

	Params::CreateCharacterUserWidget_OnChangeHairColorIndex Parms{};

	Parms.InHairColorIndex = InHairColorIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeHairStyleIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InHairStyleIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeHairStyleIndex(int32 InHairStyleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeHairStyleIndex");

	Params::CreateCharacterUserWidget_OnChangeHairStyleIndex Parms{};

	Parms.InHairStyleIndex = InHairStyleIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeSkinColorIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InSkinColorIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeSkinColorIndex(int32 InSkinColorIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeSkinColorIndex");

	Params::CreateCharacterUserWidget_OnChangeSkinColorIndex Parms{};

	Parms.InSkinColorIndex = InSkinColorIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeTattooIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InTattooIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeTattooIndex(int32 InTattooIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeTattooIndex");

	Params::CreateCharacterUserWidget_OnChangeTattooIndex Parms{};

	Parms.InTattooIndex = InTattooIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnChangeVoiceIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InVoiceIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnChangeVoiceIndex(int32 InVoiceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnChangeVoiceIndex");

	Params::CreateCharacterUserWidget_OnChangeVoiceIndex Parms{};

	Parms.InVoiceIndex = InVoiceIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnDialogueBackToMainMenuResult
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnDialogueBackToMainMenuResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnDialogueBackToMainMenuResult");

	Params::CreateCharacterUserWidget_OnDialogueBackToMainMenuResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.OnIntroCinematicFinished
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnIntroCinematicFinished(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnIntroCinematicFinished");

	Params::CreateCharacterUserWidget_OnIntroCinematicFinished Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.OnPlayerMonologueCinematicFinished
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnPlayerMonologueCinematicFinished(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnPlayerMonologueCinematicFinished");

	Params::CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.OnSetCharacterName
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InCharacterName                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnSetCharacterName(const class FText& InCharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnSetCharacterName");

	Params::CreateCharacterUserWidget_OnSetCharacterName Parms{};

	Parms.InCharacterName = std::move(InCharacterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnSetCustomizeView
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInCustomizeView                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnSetCustomizeView(bool bInCustomizeView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnSetCustomizeView");

	Params::CreateCharacterUserWidget_OnSetCustomizeView Parms{};

	Parms.bInCustomizeView = bInCustomizeView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnSetFinalView
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInFinalView                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnSetFinalView(bool bInFinalView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnSetFinalView");

	Params::CreateCharacterUserWidget_OnSetFinalView Parms{};

	Parms.bInFinalView = bInFinalView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnShowSkillTooltipByMouse
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnShowSkillTooltipByMouse(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnShowSkillTooltipByMouse");

	Params::CreateCharacterUserWidget_OnShowSkillTooltipByMouse Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.OnStartGameSaveInProgress
// (Final, Native, Protected)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::OnStartGameSaveInProgress(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "OnStartGameSaveInProgress");

	Params::CreateCharacterUserWidget_OnStartGameSaveInProgress Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.PlayVoiceAkPostEventCallback
// (Final, Native, Protected)
// Parameters:
// EAkCallbackType                         CallbackType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*                  CallbackInfo                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::PlayVoiceAkPostEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "PlayVoiceAkPostEventCallback");

	Params::CreateCharacterUserWidget_PlayVoiceAkPostEventCallback Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.RefreshCharacterParams
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bChangeClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::RefreshCharacterParams(bool bChangeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "RefreshCharacterParams");

	Params::CreateCharacterUserWidget_RefreshCharacterParams Parms{};

	Parms.bChangeClass = bChangeClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreateCharacterUserWidget.ResetToDefault
// (Final, Native, Public, BlueprintCallable)

void UCreateCharacterUserWidget::ResetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "ResetToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.SetCustomizeView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCustomizeView                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::SetCustomizeView(bool bInCustomizeView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "SetCustomizeView");

	Params::CreateCharacterUserWidget_SetCustomizeView Parms{};

	Parms.bInCustomizeView = bInCustomizeView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.SetFinalView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInFinalView                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreateCharacterUserWidget::SetFinalView(bool bInFinalView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "SetFinalView");

	Params::CreateCharacterUserWidget_SetFinalView Parms{};

	Parms.bInFinalView = bInFinalView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreateCharacterUserWidget.GetCharacterClassName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCreateCharacterUserWidget::GetCharacterClassName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetCharacterClassName");

	Params::CreateCharacterUserWidget_GetCharacterClassName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetCharacterDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCreateCharacterUserWidget::GetCharacterDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetCharacterDescription");

	Params::CreateCharacterUserWidget_GetCharacterDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetComboPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetComboPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetComboPoint");

	Params::CreateCharacterUserWidget_GetComboPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultFaceIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultFaceIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultFaceIndex");

	Params::CreateCharacterUserWidget_GetDefaultFaceIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultHairColorIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultHairColorIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultHairColorIndex");

	Params::CreateCharacterUserWidget_GetDefaultHairColorIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultHairStyleIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultHairStyleIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultHairStyleIndex");

	Params::CreateCharacterUserWidget_GetDefaultHairStyleIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultSkinColorIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultSkinColorIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultSkinColorIndex");

	Params::CreateCharacterUserWidget_GetDefaultSkinColorIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultTattooIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultTattooIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultTattooIndex");

	Params::CreateCharacterUserWidget_GetDefaultTattooIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetDefaultVoiceIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCustomization*          CharacterCustomization                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCreateCharacterUserWidget::GetDefaultVoiceIndex(class UCharacterCustomization* CharacterCustomization) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetDefaultVoiceIndex");

	Params::CreateCharacterUserWidget_GetDefaultVoiceIndex Parms{};

	Parms.CharacterCustomization = CharacterCustomization;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetEnergy");

	Params::CreateCharacterUserWidget_GetEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetEquipLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetEquipLoad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetEquipLoad");

	Params::CreateCharacterUserWidget_GetEquipLoad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetFaceTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetFaceTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetFaceTexts");

	Params::CreateCharacterUserWidget_GetFaceTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetHairColorIcons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UCreateCharacterUserWidget::GetHairColorIcons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetHairColorIcons");

	Params::CreateCharacterUserWidget_GetHairColorIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetHairColorTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetHairColorTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetHairColorTexts");

	Params::CreateCharacterUserWidget_GetHairColorTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetHairStyleTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetHairStyleTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetHairStyleTexts");

	Params::CreateCharacterUserWidget_GetHairStyleTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetHealth");

	Params::CreateCharacterUserWidget_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetMagicalDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetMagicalDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetMagicalDamage");

	Params::CreateCharacterUserWidget_GetMagicalDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetMobility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetMobility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetMobility");

	Params::CreateCharacterUserWidget_GetMobility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetPhysicalDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetPhysicalDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetPhysicalDamage");

	Params::CreateCharacterUserWidget_GetPhysicalDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetRage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetRage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetRage");

	Params::CreateCharacterUserWidget_GetRage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetRange");

	Params::CreateCharacterUserWidget_GetRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkillClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAbilityBase>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAbilityBase> UCreateCharacterUserWidget::GetSkillClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkillClass");

	Params::CreateCharacterUserWidget_GetSkillClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkillCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCreateCharacterUserWidget::GetSkillCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkillCost");

	Params::CreateCharacterUserWidget_GetSkillCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkillDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCreateCharacterUserWidget::GetSkillDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkillDescription");

	Params::CreateCharacterUserWidget_GetSkillDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkillIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCreateCharacterUserWidget::GetSkillIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkillIcon");

	Params::CreateCharacterUserWidget_GetSkillIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkillName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCreateCharacterUserWidget::GetSkillName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkillName");

	Params::CreateCharacterUserWidget_GetSkillName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkinColorIcons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UCreateCharacterUserWidget::GetSkinColorIcons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkinColorIcons");

	Params::CreateCharacterUserWidget_GetSkinColorIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSkinColorTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetSkinColorTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSkinColorTexts");

	Params::CreateCharacterUserWidget_GetSkinColorTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetStamina
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetStamina");

	Params::CreateCharacterUserWidget_GetStamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetSustain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetSustain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetSustain");

	Params::CreateCharacterUserWidget_GetSustain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetTattooTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetTattooTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetTattooTexts");

	Params::CreateCharacterUserWidget_GetTattooTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetToughness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreateCharacterUserWidget::GetToughness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetToughness");

	Params::CreateCharacterUserWidget_GetToughness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.GetVoiceTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UCreateCharacterUserWidget::GetVoiceTexts() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "GetVoiceTexts");

	Params::CreateCharacterUserWidget_GetVoiceTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreateCharacterUserWidget.IsValidCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCreateCharacterUserWidget::IsValidCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateCharacterUserWidget", "IsValidCharacterName");

	Params::CreateCharacterUserWidget_IsValidCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsControlsUserWidget.SetSwapLeftAndRightSticks
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewSwapLeftAndRightSticks                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsUserWidget::SetSwapLeftAndRightSticks(int32 NewSwapLeftAndRightSticks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsUserWidget", "SetSwapLeftAndRightSticks");

	Params::OptionsControlsUserWidget_SetSwapLeftAndRightSticks Parms{};

	Parms.NewSwapLeftAndRightSticks = NewSwapLeftAndRightSticks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsControlsUserWidget.SetXAxis
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewXAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsUserWidget::SetXAxis(int32 NewXAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsUserWidget", "SetXAxis");

	Params::OptionsControlsUserWidget_SetXAxis Parms{};

	Parms.NewXAxis = NewXAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsControlsUserWidget.SetYAxis
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewYAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsUserWidget::SetYAxis(int32 NewYAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsUserWidget", "SetYAxis");

	Params::OptionsControlsUserWidget_SetYAxis Parms{};

	Parms.NewYAxis = NewYAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreditsObjectUserWidget.OnSetText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InLeftText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InCenterText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InRightText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCreditsObjectUserWidget::OnSetText(const class FText& InLeftText, const class FText& InCenterText, const class FText& InRightText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsObjectUserWidget", "OnSetText");

	Params::CreditsObjectUserWidget_OnSetText Parms{};

	Parms.InLeftText = std::move(InLeftText);
	Parms.InCenterText = std::move(InCenterText);
	Parms.InRightText = std::move(InRightText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CreditsUserWidget.GetScrollSpeed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCreditsUserWidget::GetScrollSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "GetScrollSpeed");

	Params::CreditsUserWidget_GetScrollSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CreditsUserWidget.OnPlayCreditsMusic
// (Event, Protected, BlueprintEvent)

void UCreditsUserWidget::OnPlayCreditsMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "OnPlayCreditsMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CreditsUserWidget.OnPlayMainMenuMusic
// (Event, Protected, BlueprintEvent)

void UCreditsUserWidget::OnPlayMainMenuMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "OnPlayMainMenuMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CreditsUserWidget.OnStopCreditsMusic
// (Event, Protected, BlueprintEvent)

void UCreditsUserWidget::OnStopCreditsMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "OnStopCreditsMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CreditsUserWidget.OnStopMainMenuMusic
// (Event, Protected, BlueprintEvent)

void UCreditsUserWidget::OnStopMainMenuMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "OnStopMainMenuMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.CreditsUserWidget.PlayCreditsMusic
// (Final, Native, Public, BlueprintCallable)

void UCreditsUserWidget::PlayCreditsMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "PlayCreditsMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CreditsUserWidget.PlayMainMenuMusic
// (Final, Native, Public, BlueprintCallable)

void UCreditsUserWidget::PlayMainMenuMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "PlayMainMenuMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CreditsUserWidget.SetScrollSpeed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ECreditsScroolSpeed                     InCreditsScroolSpeed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCreditsUserWidget::SetScrollSpeed(ECreditsScroolSpeed InCreditsScroolSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "SetScrollSpeed");

	Params::CreditsUserWidget_SetScrollSpeed Parms{};

	Parms.InCreditsScroolSpeed = InCreditsScroolSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CreditsUserWidget.StopCreditsMusic
// (Final, Native, Public, BlueprintCallable)

void UCreditsUserWidget::StopCreditsMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "StopCreditsMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CreditsUserWidget.StopMainMenuMusic
// (Final, Native, Public, BlueprintCallable)

void UCreditsUserWidget::StopMainMenuMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreditsUserWidget", "StopMainMenuMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CritterRatAbility.TriggerOnComponentBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCritterRatAbility::TriggerOnComponentBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CritterRatAbility", "TriggerOnComponentBeginOverlap");

	Params::CritterRatAbility_TriggerOnComponentBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MarionetteAttackNeedleStrike.BPGetEndAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMarionetteAttackNeedleStrike::BPGetEndAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteAttackNeedleStrike", "BPGetEndAngle");

	Params::MarionetteAttackNeedleStrike_BPGetEndAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MarionetteAttackNeedleStrike.BPGetStartAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMarionetteAttackNeedleStrike::BPGetStartAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MarionetteAttackNeedleStrike", "BPGetStartAngle");

	Params::MarionetteAttackNeedleStrike_BPGetStartAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CurseAbility.OnDamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCurseAbility::OnDamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurseAbility", "OnDamageTaken");

	Params::CurseAbility_OnDamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MiniMapActorComponent.GetGatewayState
// (Final, Native, Public)
// Parameters:
// EMiniMapGatewayState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMiniMapGatewayState UMiniMapActorComponent::GetGatewayState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapActorComponent", "GetGatewayState");

	Params::MiniMapActorComponent_GetGatewayState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MiniMapActorComponent.GetMiniMapActorState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMiniMapActorState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMiniMapActorState UMiniMapActorComponent::GetMiniMapActorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniMapActorComponent", "GetMiniMapActorState");

	Params::MiniMapActorComponent_GetMiniMapActorState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CutsceneCinematicUserWidget.IsResumeToGame
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCutsceneCinematicUserWidget::IsResumeToGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CutsceneCinematicUserWidget", "IsResumeToGame");

	Params::CutsceneCinematicUserWidget_IsResumeToGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.CutsceneCinematicUserWidget.OnMediaReachedEnd
// (Final, Native, Protected)

void UCutsceneCinematicUserWidget::OnMediaReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CutsceneCinematicUserWidget", "OnMediaReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.CutsceneCinematicUserWidget.OnPauseMenuHide
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCutsceneCinematicUserWidget::OnPauseMenuHide(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CutsceneCinematicUserWidget", "OnPauseMenuHide");

	Params::CutsceneCinematicUserWidget_OnPauseMenuHide Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CutsceneCinematicUserWidget.OnPlayVideo
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           VideoUrl                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCutsceneCinematicUserWidget::OnPlayVideo(const class FString& VideoUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CutsceneCinematicUserWidget", "OnPlayVideo");

	Params::CutsceneCinematicUserWidget_OnPlayVideo Parms{};

	Parms.VideoUrl = std::move(VideoUrl);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.CutsceneCinematicUserWidget.SkipCinematic
// (Final, Native, Protected, BlueprintCallable)

void UCutsceneCinematicUserWidget::SkipCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CutsceneCinematicUserWidget", "SkipCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DamageMatrixAbility.OnAbilityEnd
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     AbilityEnded                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageMatrixAbility::OnAbilityEnd(class UAbilityBase* AbilityEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageMatrixAbility", "OnAbilityEnd");

	Params::DamageMatrixAbility_OnAbilityEnd Parms{};

	Parms.AbilityEnded = AbilityEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WasteNotPassive.ComboPointsChanged
// (Final, Native, Public)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWasteNotPassive::ComboPointsChanged(int32 Delta, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WasteNotPassive", "ComboPointsChanged");

	Params::WasteNotPassive_ComboPointsChanged Parms{};

	Parms.Delta = Delta;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVolumeComponent.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UManVolumeComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVolumeComponent", "OnBeginOverlap");

	Params::ManVolumeComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVolumeComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManVolumeComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVolumeComponent", "OnEndOverlap");

	Params::ManVolumeComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVolumeComponent.OnMatchHasStarted
// (Final, Native, Public)

void UManVolumeComponent::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVolumeComponent", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DamageVFXRelation.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDamageVFXRelation::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageVFXRelation", "GetEditorName");

	Params::DamageVFXRelation_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DarkFissureAbility.OnStaggerOrStun
// (Final, Native, Private)

void UDarkFissureAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFissureActor.BPRemove
// (Event, Public, BlueprintEvent)

void ADarkFissureActor::BPRemove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureActor", "BPRemove");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.DarkFissureActorAbility.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDarkFissureActorAbility::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureActorAbility", "DamageDealt");

	Params::DarkFissureActorAbility_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFissureActorAbility.GetAllGroundActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UDarkFissureActorAbility::GetAllGroundActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureActorAbility", "GetAllGroundActors");

	Params::DarkFissureActorAbility_GetAllGroundActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DarkFissureActorAbility.IsChaosCast
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarkFissureActorAbility::IsChaosCast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureActorAbility", "IsChaosCast");

	Params::DarkFissureActorAbility_IsChaosCast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DarkFissureActorAbility.RegisterHitbox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHitBox*                          HitBox                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoxName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkFissureActorAbility::RegisterHitbox(class UHitBox* HitBox, class FName HitBoxName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureActorAbility", "RegisterHitbox");

	Params::DarkFissureActorAbility_RegisterHitbox Parms{};

	Parms.HitBox = HitBox;
	Parms.HitBoxName = HitBoxName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFissureGroundActor.SpawnBP
// (Event, Public, BlueprintEvent)

void ADarkFissureGroundActor::SpawnBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureGroundActor", "SpawnBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.DarkFissureGroundActor.TriggerBP
// (Event, Public, BlueprintEvent)

void ADarkFissureGroundActor::TriggerBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFissureGroundActor", "TriggerBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.DarkVenomPassive.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDarkVenomPassive::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkVenomPassive", "PostDamageDealt");

	Params::DarkVenomPassive_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkVenomPassive.StatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           ToTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkVenomPassive::StatusEffectCaused(class AActor* ToTarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkVenomPassive", "StatusEffectCaused");

	Params::DarkVenomPassive_StatusEffectCaused Parms{};

	Parms.ToTarget = ToTarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LightTetherAbility.GetSourceLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULightTetherAbility::GetSourceLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightTetherAbility", "GetSourceLocation");

	Params::LightTetherAbility_GetSourceLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LightTetherAbility.GetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULightTetherAbility::GetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightTetherAbility", "GetTargetLocation");

	Params::LightTetherAbility_GetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LightTetherAbility.HasLineOfSightToTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULightTetherAbility::HasLineOfSightToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightTetherAbility", "HasLineOfSightToTarget");

	Params::LightTetherAbility_HasLineOfSightToTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LightTetherAbility.OnStaggerOrStun
// (Final, Native, Private)

void ULightTetherAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightTetherAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DCPHealAbility.BPGetAllyTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDCPHealAbility::BPGetAllyTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPHealAbility", "BPGetAllyTargetActor");

	Params::DCPHealAbility_BPGetAllyTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DieToRespawnAbility.OnEntityTeleportPost
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDieToRespawnAbility::OnEntityTeleportPost(const struct FVector& NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DieToRespawnAbility", "OnEntityTeleportPost");

	Params::DieToRespawnAbility_OnEntityTeleportPost Parms{};

	Parms.NewPosition = std::move(NewPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadMapUserWidget.CloseBtnClicked
// (Final, Native, Public, BlueprintCallable)

void ULoadMapUserWidget::CloseBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapUserWidget", "CloseBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadMapUserWidget.LoadMapBtnClicked
// (Final, Native, Public, BlueprintCallable)

void ULoadMapUserWidget::LoadMapBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapUserWidget", "LoadMapBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FadeToRespawnAbility.OnStartPauseGameplay
// (Final, Native, Public)

void UFadeToRespawnAbility::OnStartPauseGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeToRespawnAbility", "OnStartPauseGameplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorCraftUserWidget.OnCraftItem
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InLevelUp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorCraftUserWidget::OnCraftItem(bool InLevelUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "OnCraftItem");

	Params::VendorCraftUserWidget_OnCraftItem Parms{};

	Parms.InLevelUp = InLevelUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorCraftUserWidget.OnDiagramLearned
// (Final, Native, Protected)

void UVendorCraftUserWidget::OnDiagramLearned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "OnDiagramLearned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorCraftUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorCraftUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "OnFocusWidgetChangedEvent");

	Params::VendorCraftUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorCraftUserWidget.GetCraftItemCalculatedXPText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorCraftUserWidget::GetCraftItemCalculatedXPText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "GetCraftItemCalculatedXPText");

	Params::VendorCraftUserWidget_GetCraftItemCalculatedXPText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorCraftUserWidget.GetCraftItemCalculatedXPValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVendorCraftUserWidget::GetCraftItemCalculatedXPValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "GetCraftItemCalculatedXPValue");

	Params::VendorCraftUserWidget_GetCraftItemCalculatedXPValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorCraftUserWidget.GetItemRequiredLevelText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorCraftUserWidget::GetItemRequiredLevelText(class UManItemSlotBase* ManItemSlotBase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "GetItemRequiredLevelText");

	Params::VendorCraftUserWidget_GetItemRequiredLevelText Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorCraftUserWidget.HasGearFilter
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorCraftUserWidget::HasGearFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftUserWidget", "HasGearFilter");

	Params::VendorCraftUserWidget_HasGearFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DeathScreenUserWidget.IsEntropyDeath
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDeathScreenUserWidget::IsEntropyDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathScreenUserWidget", "IsEntropyDeath");

	Params::DeathScreenUserWidget_IsEntropyDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GrapplingHookProjectile.HookArrived
// (Event, Public, BlueprintEvent)

void AGrapplingHookProjectile::HookArrived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrapplingHookProjectile", "HookArrived");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ChaosSparksProjectile.ToggleDestroyDueToTargetLost
// (Event, Public, BlueprintEvent)

void AChaosSparksProjectile::ToggleDestroyDueToTargetLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosSparksProjectile", "ToggleDestroyDueToTargetLost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ChaosSparksProjectile.ToggleIdleVisual
// (Event, Public, BlueprintEvent)

void AChaosSparksProjectile::ToggleIdleVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosSparksProjectile", "ToggleIdleVisual");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ChaosSparksProjectile.ToggleMovingVisual
// (Event, Public, BlueprintEvent)

void AChaosSparksProjectile::ToggleMovingVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosSparksProjectile", "ToggleMovingVisual");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ChaosSparksProjectile.ToggleRiftVisual
// (Event, Public, BlueprintEvent)

void AChaosSparksProjectile::ToggleRiftVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaosSparksProjectile", "ToggleRiftVisual");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.WaveOfLightProjectile.HeroAbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWaveOfLightProjectile::HeroAbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaveOfLightProjectile", "HeroAbilityStart");

	Params::WaveOfLightProjectile_HeroAbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WaveOfLightProjectile.ParentAbilityCustomEvent
// (Final, Native, Public)
// Parameters:
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWaveOfLightProjectile::ParentAbilityCustomEvent(class FName CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaveOfLightProjectile", "ParentAbilityCustomEvent");

	Params::WaveOfLightProjectile_ParentAbilityCustomEvent Parms{};

	Parms.CustomName = CustomName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume.ActorEnter
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATutorialPromptVolume::ActorEnter(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "ActorEnter");

	Params::TutorialPromptVolume_ActorEnter Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume.ActorExit
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume::ActorExit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "ActorExit");

	Params::TutorialPromptVolume_ActorExit Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume.CheckPointTravel
// (Final, Native, Public)
// Parameters:
// class UCheckpointData*                  Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume::CheckPointTravel(class UCheckpointData* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "CheckPointTravel");

	Params::TutorialPromptVolume_CheckPointTravel Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume.EventFulfilled_BP
// (Event, Public, BlueprintEvent)

void ATutorialPromptVolume::EventFulfilled_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "EventFulfilled_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptVolume.EventSkipped_BP
// (Event, Public, BlueprintEvent)

void ATutorialPromptVolume::EventSkipped_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "EventSkipped_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptVolume.GoToLevel
// (Final, Native, Public)
// Parameters:
// class FString                           LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume::GoToLevel(const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "GoToLevel");

	Params::TutorialPromptVolume_GoToLevel Parms{};

	Parms.LevelName = std::move(LevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume.HeroDeath
// (Final, Native, Public)

void ATutorialPromptVolume::HeroDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume", "HeroDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume_LadderSlide.OnLadderSlideStart
// (Final, Native, Public)
// Parameters:
// class AActorBase*                       LadderActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_LadderSlide::OnLadderSlideStart(class AActorBase* LadderActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_LadderSlide", "OnLadderSlideStart");

	Params::TutorialPromptVolume_LadderSlide_OnLadderSlideStart Parms{};

	Parms.LadderActor = LadderActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DieOfChaosProjectile.DieExplosion
// (Event, Public, BlueprintEvent)

void ADieOfChaosProjectile::DieExplosion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DieOfChaosProjectile", "DieExplosion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.DieOfChaosProjectile.DieStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADieOfChaosProjectile::DieStateChanged(int32 NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DieOfChaosProjectile", "DieStateChanged");

	Params::DieOfChaosProjectile_DieStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MoteProjectile.BPMoteStartFlying
// (Event, Public, BlueprintEvent)

void AMoteProjectile::BPMoteStartFlying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoteProjectile", "BPMoteStartFlying");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.KingPriestVoidAttackEntropicCatharsis2.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidAttackEntropicCatharsis2::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidAttackEntropicCatharsis2", "BPGetTeleportLocation");

	Params::KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WildSeedProjectile.GetCurrentDamageRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWildSeedProjectile::GetCurrentDamageRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WildSeedProjectile", "GetCurrentDamageRadius");

	Params::WildSeedProjectile_GetCurrentDamageRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WildSeedProjectile.GetDetonateDamageRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWildSeedProjectile::GetDetonateDamageRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WildSeedProjectile", "GetDetonateDamageRadius");

	Params::WildSeedProjectile_GetDetonateDamageRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WildSeedProjectile.GetFullGrowthTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWildSeedProjectile::GetFullGrowthTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WildSeedProjectile", "GetFullGrowthTime");

	Params::WildSeedProjectile_GetFullGrowthTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RetreatBladeProjectile.BPEmpowered
// (Event, Public, BlueprintEvent)

void ARetreatBladeProjectile::BPEmpowered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatBladeProjectile", "BPEmpowered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.RetreatBladeProjectile.BPOnRecalled
// (Native, Event, Public, BlueprintEvent)

void ARetreatBladeProjectile::BPOnRecalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatBladeProjectile", "BPOnRecalled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RetreatBladeProjectile.OnTargetRemovedFromWorld
// (Final, Native, Public)

void ARetreatBladeProjectile::OnTargetRemovedFromWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatBladeProjectile", "OnTargetRemovedFromWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RetreatBladeProjectile.PreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void ARetreatBladeProjectile::PreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatBladeProjectile", "PreDamageCaused");

	Params::RetreatBladeProjectile_PreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.TwinFangsProjectile.HitGround
// (Event, Public, BlueprintEvent)

void ATwinFangsProjectile::HitGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFangsProjectile", "HitGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TwinFangsProjectile.StartRicochet
// (Event, Public, BlueprintEvent)

void ATwinFangsProjectile::StartRicochet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFangsProjectile", "StartRicochet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TwinFangsProjectile.UseStaminaRegenBuff
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATwinFangsProjectile::UseStaminaRegenBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFangsProjectile", "UseStaminaRegenBuff");

	Params::TwinFangsProjectile_UseStaminaRegenBuff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RakeProjectile.BPOnLanded
// (Native, Event, Public, BlueprintEvent)

void ARakeProjectile::BPOnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RakeProjectile", "BPOnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RakeProjectile.BPOnRecalled
// (Native, Event, Public, BlueprintEvent)

void ARakeProjectile::BPOnRecalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RakeProjectile", "BPOnRecalled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NetherBladeProjectile.GetTargetEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* ANetherBladeProjectile::GetTargetEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetherBladeProjectile", "GetTargetEnemy");

	Params::NetherBladeProjectile_GetTargetEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.NetherBladeProjectile.GetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANetherBladeProjectile::GetTargetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetherBladeProjectile", "GetTargetRotation");

	Params::NetherBladeProjectile_GetTargetRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FireBoltProjectile.PreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void AFireBoltProjectile::PreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireBoltProjectile", "PreDamageCaused");

	Params::FireBoltProjectile_PreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.DetonateToxinAbility.GetVESourceLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDetonateToxinAbility::GetVESourceLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetonateToxinAbility", "GetVESourceLocation");

	Params::DetonateToxinAbility_GetVESourceLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DetonateToxinAbility.GetVETarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDetonateToxinAbility::GetVETarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetonateToxinAbility", "GetVETarget");

	Params::DetonateToxinAbility_GetVETarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DetonateToxinAbility.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDetonateToxinAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DetonateToxinAbility", "PreDamageDealt");

	Params::DetonateToxinAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.VendorUpgradeSlotUserWidget.OnHighlighted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUpgradeSlotUserWidget::OnHighlighted(bool bHighlighted, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeSlotUserWidget", "OnHighlighted");

	Params::VendorUpgradeSlotUserWidget_OnHighlighted Parms{};

	Parms.bHighlighted = bHighlighted;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUpgradeSlotUserWidget.OnSetSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InRequirements                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInUnlocked                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUpgradeSlotUserWidget::OnSetSlot(const class FText& InName, const class FText& InDescription, const class FText& InRequirements, bool bInUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeSlotUserWidget", "OnSetSlot");

	Params::VendorUpgradeSlotUserWidget_OnSetSlot Parms{};

	Parms.InName = std::move(InName);
	Parms.InDescription = std::move(InDescription);
	Parms.InRequirements = std::move(InRequirements);
	Parms.bInUnlocked = bInUnlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.DialogueWindowUserWidget.CloseDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDialogueButtonType                     DialogueButtonType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogueWindowUserWidget::CloseDialogue(EDialogueButtonType DialogueButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueWindowUserWidget", "CloseDialogue");

	Params::DialogueWindowUserWidget_CloseDialogue Parms{};

	Parms.DialogueButtonType = DialogueButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DialogueWindowUserWidget.OnDescriptionTextChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Desciption                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDialogueWindowUserWidget::OnDescriptionTextChanged(const class FText& Desciption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueWindowUserWidget", "OnDescriptionTextChanged");

	Params::DialogueWindowUserWidget_OnDescriptionTextChanged Parms{};

	Parms.Desciption = std::move(Desciption);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.DialogueWindowUserWidget.OnSetData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDesciption                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InBtnHotkeyAText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InBtnHotkeyXText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InBtnHotkeyBText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDialogueWindowUserWidget::OnSetData(const class FText& InTitle, const class FText& InDesciption, const class FText& InBtnHotkeyAText, const class FText& InBtnHotkeyXText, const class FText& InBtnHotkeyBText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogueWindowUserWidget", "OnSetData");

	Params::DialogueWindowUserWidget_OnSetData Parms{};

	Parms.InTitle = std::move(InTitle);
	Parms.InDesciption = std::move(InDesciption);
	Parms.InBtnHotkeyAText = std::move(InBtnHotkeyAText);
	Parms.InBtnHotkeyXText = std::move(InBtnHotkeyXText);
	Parms.InBtnHotkeyBText = std::move(InBtnHotkeyBText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.DieOfChaosAbility.OnStaggerOrStun
// (Final, Native, Private)

void UDieOfChaosAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DieOfChaosAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineHammersProjectilePassive.ProjectileEvent
// (Final, Native, Public, HasDefaults)
// Parameters:
// EManProjectileEventType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDivineHammersProjectilePassive::ProjectileEvent(EManProjectileEventType Type, const struct FVector& position, class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineHammersProjectilePassive", "ProjectileEvent");

	Params::DivineHammersProjectilePassive_ProjectileEvent Parms{};

	Parms.Type = Type;
	Parms.position = std::move(position);
	Parms.HitActor = HitActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SummonTrackingAbility.OnStaggerOrStun
// (Final, Native, Public)

void USummonTrackingAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonTrackingAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.FamiliarAnimEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimID*                          Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAnimEventType                          AnimEventType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDivineWeaponAttackAbility::FamiliarAnimEvent(class UAbilityBase* Ability, class UAnimID* Anim, EAnimEventType AnimEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "FamiliarAnimEvent");

	Params::DivineWeaponAttackAbility_FamiliarAnimEvent Parms{};

	Parms.Ability = Ability;
	Parms.Anim = Anim;
	Parms.AnimEventType = AnimEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.KillStateChanged
// (Final, Native, Public)

void UDivineWeaponAttackAbility::KillStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "KillStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.OnDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDivineWeaponAttackAbility::OnDamageDealt(const struct FPreDamagedEventParam& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "OnDamageDealt");

	Params::DivineWeaponAttackAbility_OnDamageDealt Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.OnGroupDamageDealt
// (Final, Native, Public)
// Parameters:
// int32                                   DamageGroupID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDamageValue>             DamageValues                                           (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDivineWeaponAttackAbility::OnGroupDamageDealt(int32 DamageGroupID, class AActor* Source, class AActor* DamageTarget, const TArray<struct FDamageValue>& DamageValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "OnGroupDamageDealt");

	Params::DivineWeaponAttackAbility_OnGroupDamageDealt Parms{};

	Parms.DamageGroupID = DamageGroupID;
	Parms.Source = Source;
	Parms.DamageTarget = DamageTarget;
	Parms.DamageValues = std::move(DamageValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.OnHeroAbilityEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDivineWeaponAttackAbility::OnHeroAbilityEnded(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "OnHeroAbilityEnded");

	Params::DivineWeaponAttackAbility_OnHeroAbilityEnded Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DivineWeaponAttackAbility.OnHeroAbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Desired                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDivineWeaponAttackAbility::OnHeroAbilityStarted(class UAbilityBase* Ability, bool Desired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DivineWeaponAttackAbility", "OnHeroAbilityStarted");

	Params::DivineWeaponAttackAbility_OnHeroAbilityStarted Parms{};

	Parms.Ability = Ability;
	Parms.Desired = Desired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.DoorActorBase.BPKillGrabPoints
// (Final, Native, Public, BlueprintCallable)

void ADoorActorBase::BPKillGrabPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorActorBase", "BPKillGrabPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DoorActorBase.BPPlayPortalVfxBeforeTeleport
// (Event, Public, BlueprintEvent)

void ADoorActorBase::BPPlayPortalVfxBeforeTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorActorBase", "BPPlayPortalVfxBeforeTeleport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VampireLordGrabAbility.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UVampireLordGrabAbility::OnPreDamageCaused(struct FPreDamagedEventParam* PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireLordGrabAbility", "OnPreDamageCaused");

	Params::VampireLordGrabAbility_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PreDamagedEventParam != nullptr)
		*PreDamagedEventParam = std::move(Parms.PreDamagedEventParam);
}


// Function man.VampireLordChargeAbility.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVampireLordChargeAbility::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireLordChargeAbility", "IsCollideSignature");

	Params::VampireLordChargeAbility_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.DefensiveStanceAbility.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDefensiveStanceAbility::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DefensiveStanceAbility", "OnPreDamagedPriority");

	Params::DefensiveStanceAbility_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.VendorAlchemistSlotUserWidget.OnHarvestFinished
// (Event, Public, BlueprintEvent)

void UVendorAlchemistSlotUserWidget::OnHarvestFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnHarvestFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistSlotUserWidget.OnHarvestStart
// (Event, Public, BlueprintEvent)

void UVendorAlchemistSlotUserWidget::OnHarvestStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnHarvestStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistSlotUserWidget.OnHarvestStop
// (Event, Public, BlueprintEvent)

void UVendorAlchemistSlotUserWidget::OnHarvestStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnHarvestStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistSlotUserWidget.OnSetCountdown
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   ElapsedCooldownPercent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TimeLeft                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorAlchemistSlotUserWidget::OnSetCountdown(float ElapsedCooldownPercent, const class FText& TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnSetCountdown");

	Params::VendorAlchemistSlotUserWidget_OnSetCountdown Parms{};

	Parms.ElapsedCooldownPercent = ElapsedCooldownPercent;
	Parms.TimeLeft = std::move(TimeLeft);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorAlchemistSlotUserWidget.OnSetSlot
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAkAudioEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorAlchemistSlotUserWidget::OnSetSlot(const class FText& Name_0, const class UTexture2D* Icon, bool bPlayAkAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnSetSlot");

	Params::VendorAlchemistSlotUserWidget_OnSetSlot Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Icon = Icon;
	Parms.bPlayAkAudioEvent = bPlayAkAudioEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorAlchemistSlotUserWidget.OnToggleCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCompleted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorAlchemistSlotUserWidget::OnToggleCompleted(bool bCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnToggleCompleted");

	Params::VendorAlchemistSlotUserWidget_OnToggleCompleted Parms{};

	Parms.bCompleted = bCompleted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorAlchemistSlotUserWidget.OnToggleEquipState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEquipState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorAlchemistSlotUserWidget::OnToggleEquipState(bool bEquipState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnToggleEquipState");

	Params::VendorAlchemistSlotUserWidget_OnToggleEquipState Parms{};

	Parms.bEquipState = bEquipState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorAlchemistSlotUserWidget.OnToggleLocked
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bInLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             LockedLevel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorAlchemistSlotUserWidget::OnToggleLocked(bool bInLocked, const class FText& LockedLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "OnToggleLocked");

	Params::VendorAlchemistSlotUserWidget_OnToggleLocked Parms{};

	Parms.bInLocked = bInLocked;
	Parms.LockedLevel = std::move(LockedLevel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorAlchemistSlotUserWidget.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorAlchemistSlotUserWidget::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistSlotUserWidget", "IsCompleted");

	Params::VendorAlchemistSlotUserWidget_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DarkFireIceBlock.BPOnLanded
// (Native, Event, Public, BlueprintEvent)

void ADarkFireIceBlock::BPOnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFireIceBlock", "BPOnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DarkFireIceBlock.OnBurning
// (Native, Event, Public, BlueprintEvent)

void ADarkFireIceBlock::OnBurning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkFireIceBlock", "OnBurning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VoidRatResurrectAbility.GetResurectTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UVoidRatResurrectAbility::GetResurectTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidRatResurrectAbility", "GetResurectTargets");

	Params::VoidRatResurrectAbility_GetResurectTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.DynamicObstacleActor.BPDestroyActor
// (Final, Native, Public, BlueprintCallable)

void ADynamicObstacleActor::BPDestroyActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicObstacleActor", "BPDestroyActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DynamicObstacleActor.BPDisableCollision
// (Final, Native, Public, BlueprintCallable)

void ADynamicObstacleActor::BPDisableCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicObstacleActor", "BPDisableCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DynamicObstacleActor.BPEnableCollision
// (Final, Native, Public, BlueprintCallable)

void ADynamicObstacleActor::BPEnableCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicObstacleActor", "BPEnableCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.DynamicObstacleActor.BPSetCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicObstacleActor::BPSetCollision(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicObstacleActor", "BPSetCollision");

	Params::DynamicObstacleActor_BPSetCollision Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnemyBlockerVolume.ManSetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemyBlockerVolume::ManSetEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyBlockerVolume", "ManSetEnable");

	Params::EnemyBlockerVolume_ManSetEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorLightBarrier.LightBarrier_OnDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInquisitorLightBarrier::LightBarrier_OnDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorLightBarrier", "LightBarrier_OnDamageDealt");

	Params::InquisitorLightBarrier_LightBarrier_OnDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorLightBarrier.LightBarrier_OnPreDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UInquisitorLightBarrier::LightBarrier_OnPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorLightBarrier", "LightBarrier_OnPreDamaged");

	Params::InquisitorLightBarrier_LightBarrier_OnPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LuckyStreakPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULuckyStreakPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuckyStreakPassive", "DamageDealt");

	Params::LuckyStreakPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropicVacuumActor.DrainOnEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class AHeroBase*                        Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntropicVacuumActor::DrainOnEnd(class AHeroBase* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropicVacuumActor", "DrainOnEnd");

	Params::EntropicVacuumActor_DrainOnEnd Parms{};

	Parms.Hero = Hero;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.EntropicVacuumActor.DrainOnStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class AHeroBase*                        Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntropicVacuumActor::DrainOnStart(class AHeroBase* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropicVacuumActor", "DrainOnStart");

	Params::EntropicVacuumActor_DrainOnStart Parms{};

	Parms.Hero = Hero;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InspirationPassive.AbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInspirationPassive::AbilityEnd(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspirationPassive", "AbilityEnd");

	Params::InspirationPassive_AbilityEnd Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InspirationPassive.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInspirationPassive::AbilityStart(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InspirationPassive", "AbilityStart");

	Params::InspirationPassive_AbilityStart Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropyRiftExitQuestion.OnDialogueEntropyRiftLeave
// (Final, Native, Public)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEntropyRiftExitQuestion::OnDialogueEntropyRiftLeave(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyRiftExitQuestion", "OnDialogueEntropyRiftLeave");

	Params::EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropyRiftImplement.OnBeginRiftVolumeOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEntropyRiftImplement::OnBeginRiftVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyRiftImplement", "OnBeginRiftVolumeOverlap");

	Params::EntropyRiftImplement_OnBeginRiftVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropyRiftMainControl.OnBeginRiftVolumeOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntropyRiftMainControl::OnBeginRiftVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyRiftMainControl", "OnBeginRiftVolumeOverlap");

	Params::EntropyRiftMainControl_OnBeginRiftVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropyRiftMainControl.OnEndRiftVolumeOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntropyRiftMainControl::OnEndRiftVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyRiftMainControl", "OnEndRiftVolumeOverlap");

	Params::EntropyRiftMainControl_OnEndRiftVolumeOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropyRiftMainControl.OnWorldRespawn
// (Final, Native, Public)

void AEntropyRiftMainControl::OnWorldRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropyRiftMainControl", "OnWorldRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.EntropySpawnPortalAbility.BPGetSpawnedActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterBase* UEntropySpawnPortalAbility::BPGetSpawnedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntropySpawnPortalAbility", "BPGetSpawnedActor");

	Params::EntropySpawnPortalAbility_BPGetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EnvenomLatentDebuffPassive.StackNumChanged
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrevStackNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvenomLatentDebuffPassive::StackNumChanged(class UAbilityBase* InAbility, int32 PrevStackNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvenomLatentDebuffPassive", "StackNumChanged");

	Params::EnvenomLatentDebuffPassive_StackNumChanged Parms{};

	Parms.InAbility = InAbility;
	Parms.PrevStackNum = PrevStackNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LadderClimb.OnTeleport
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimb::OnTeleport(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimb", "OnTeleport");

	Params::LadderClimb_OnTeleport Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LadderClimb.OnUserInput
// (Final, Native, Public)
// Parameters:
// int32                                   InputCommandNum                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULadderClimb::OnUserInput(int32 InputCommandNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderClimb", "OnUserInput");

	Params::LadderClimb_OnUserInput Parms{};

	Parms.InputCommandNum = InputCommandNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportBackOnTriggerAbility.IsConnectionWarningActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTeleportBackOnTriggerAbility::IsConnectionWarningActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "IsConnectionWarningActive");

	Params::TeleportBackOnTriggerAbility_IsConnectionWarningActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TeleportBackOnTriggerAbility.OnEntityKilledWithRebirth
// (Final, Native, Private)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeleportBackOnTriggerAbility::OnEntityKilledWithRebirth(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "OnEntityKilledWithRebirth");

	Params::TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportBackOnTriggerAbility.OnHeroDie
// (Final, Native, Private)

void UTeleportBackOnTriggerAbility::OnHeroDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "OnHeroDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportBackOnTriggerAbility.OnHeroPreTravel
// (Final, Native, Private, HasDefaults)
// Parameters:
// class ALevelVisualVolume*               SourceLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelVisualVolume*               TargetLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeleportBackOnTriggerAbility::OnHeroPreTravel(class ALevelVisualVolume* SourceLevelVisualVolume, class ALevelVisualVolume* TargetLevelVisualVolume, const struct FVector& NewPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "OnHeroPreTravel");

	Params::TeleportBackOnTriggerAbility_OnHeroPreTravel Parms{};

	Parms.SourceLevelVisualVolume = SourceLevelVisualVolume;
	Parms.TargetLevelVisualVolume = TargetLevelVisualVolume;
	Parms.NewPos = std::move(NewPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportBackOnTriggerAbility.OnPostDamageDone
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTeleportBackOnTriggerAbility::OnPostDamageDone(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "OnPostDamageDone");

	Params::TeleportBackOnTriggerAbility_OnPostDamageDone Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportBackOnTriggerAbility.OnPreDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UTeleportBackOnTriggerAbility::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportBackOnTriggerAbility", "OnPreDamageCaused");

	Params::TeleportBackOnTriggerAbility_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.LegalWindowUserWidget.ChangeLanguageIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InLanguageIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeByUser                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegalWindowUserWidget::ChangeLanguageIndex(int32 InLanguageIndex, bool bChangeByUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWindowUserWidget", "ChangeLanguageIndex");

	Params::LegalWindowUserWidget_ChangeLanguageIndex Parms{};

	Parms.InLanguageIndex = InLanguageIndex;
	Parms.bChangeByUser = bChangeByUser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LegalWindowUserWidget.OnSetText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULegalWindowUserWidget::OnSetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWindowUserWidget", "OnSetText");

	Params::LegalWindowUserWidget_OnSetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.LegalWindowUserWidget.SetAgeIsOver16
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInAgeIsOver16                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegalWindowUserWidget::SetAgeIsOver16(bool bInAgeIsOver16)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWindowUserWidget", "SetAgeIsOver16");

	Params::LegalWindowUserWidget_SetAgeIsOver16 Parms{};

	Parms.bInAgeIsOver16 = bInAgeIsOver16;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableTrail.AbilityEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnstableTrail::AbilityEnded(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableTrail", "AbilityEnded");

	Params::UnstableTrail_AbilityEnded Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableTrail.AbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnstableTrail::AbilityStarted(class UAbilityBase* Ability, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableTrail", "AbilityStarted");

	Params::UnstableTrail_AbilityStarted Parms{};

	Parms.Ability = Ability;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableTrail.Rest
// (Final, Native, Public)

void UUnstableTrail::Rest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableTrail", "Rest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ExecuteFollowupAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UExecuteFollowupAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExecuteFollowupAbility", "PostDamageDealt");

	Params::ExecuteFollowupAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ExplodingOrbActor.IsLastOrb
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AExplodingOrbActor::IsLastOrb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodingOrbActor", "IsLastOrb");

	Params::ExplodingOrbActor_IsLastOrb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ExplodingOrbActor.TrySpawnLastOrbVFX
// (Event, Public, BlueprintEvent)

void AExplodingOrbActor::TrySpawnLastOrbVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplodingOrbActor", "TrySpawnLastOrbVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.LevelTransitionVFX.LockPlayerControlByFastTravelTransition
// (Final, Native, Public, BlueprintCallable)

void ALevelTransitionVFX::LockPlayerControlByFastTravelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "LockPlayerControlByFastTravelTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelTransitionVFX.LockPlayerControlBySubLevelTransition
// (Final, Native, Public, BlueprintCallable)

void ALevelTransitionVFX::LockPlayerControlBySubLevelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "LockPlayerControlBySubLevelTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelTransitionVFX.SetVFXDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   VFXDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelTransitionVFX::SetVFXDuration(float VFXDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "SetVFXDuration");

	Params::LevelTransitionVFX_SetVFXDuration Parms{};

	Parms.VFXDuration = VFXDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelTransitionVFX.UnlockPlayerControlByFastTravelTransition
// (Final, Native, Public, BlueprintCallable)

void ALevelTransitionVFX::UnlockPlayerControlByFastTravelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "UnlockPlayerControlByFastTravelTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelTransitionVFX.UnlockPlayerControlBySubLevelTransition
// (Final, Native, Public, BlueprintCallable)

void ALevelTransitionVFX::UnlockPlayerControlBySubLevelTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "UnlockPlayerControlBySubLevelTransition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LevelTransitionVFX.GetAbleControlCharacterBeforeFadeOutEndTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALevelTransitionVFX::GetAbleControlCharacterBeforeFadeOutEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelTransitionVFX", "GetAbleControlCharacterBeforeFadeOutEndTime");

	Params::LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FallDamagePassive.OnAnchored
// (Final, Native, Public)

void UFallDamagePassive::OnAnchored()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallDamagePassive", "OnAnchored");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FallDamagePassive.OnLanded
// (Final, Native, Public)

void UFallDamagePassive::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallDamagePassive", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FamiliarBase.OnFamiliarKilled
// (Final, Native, Private)
// Parameters:
// class UObject*                          Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               KillerAbilityController                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFamiliarBase::OnFamiliarKilled(class UObject* Killer, class UAbilityController* KillerAbilityController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FamiliarBase", "OnFamiliarKilled");

	Params::FamiliarBase_OnFamiliarKilled Parms{};

	Parms.Killer = Killer;
	Parms.KillerAbilityController = KillerAbilityController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FamiliarBase.OnFamiliarPostDamageCaused
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AFamiliarBase::OnFamiliarPostDamageCaused(const struct FPreDamagedEventParam& PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FamiliarBase", "OnFamiliarPostDamageCaused");

	Params::FamiliarBase_OnFamiliarPostDamageCaused Parms{};

	Parms.PreDamagedEventParam = std::move(PreDamagedEventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FamiliarBase.OnOwnerTeleported
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          TeleportPos                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFamiliarBase::OnOwnerTeleported(const struct FVector& TeleportPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FamiliarBase", "OnOwnerTeleported");

	Params::FamiliarBase_OnOwnerTeleported Parms{};

	Parms.TeleportPos = std::move(TeleportPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FamiliarBase.OnTargetPositionReached
// (Final, Native, Private)
// Parameters:
// bool                                    AirMoveInterrupted                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFamiliarBase::OnTargetPositionReached(bool AirMoveInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FamiliarBase", "OnTargetPositionReached");

	Params::FamiliarBase_OnTargetPositionReached Parms{};

	Parms.AirMoveInterrupted = AirMoveInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FCP_ShieldAbility.BPGetAllyTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFCP_ShieldAbility::BPGetAllyTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCP_ShieldAbility", "BPGetAllyTargetActor");

	Params::FCP_ShieldAbility_BPGetAllyTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.AddGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWithUninterruptable                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::AddGodMode(bool bWithUninterruptable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "AddGodMode");

	Params::MandragoraGameMode_AddGodMode Parms{};

	Parms.bWithUninterruptable = bWithUninterruptable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.BossMusicBlacklistHasActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::BossMusicBlacklistHasActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BossMusicBlacklistHasActor");

	Params::MandragoraGameMode_BossMusicBlacklistHasActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.BPEndCurrentBossFight
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::BPEndCurrentBossFight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPEndCurrentBossFight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.BPGetCurrentBossFightClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* AMandragoraGameMode::BPGetCurrentBossFightClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPGetCurrentBossFightClass");

	Params::MandragoraGameMode_BPGetCurrentBossFightClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.BPGetEnemiesInCombat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ACharacterBase*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACharacterBase*> AMandragoraGameMode::BPGetEnemiesInCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPGetEnemiesInCombat");

	Params::MandragoraGameMode_BPGetEnemiesInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.BPGetGameTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMandragoraGameMode::BPGetGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPGetGameTime");

	Params::MandragoraGameMode_BPGetGameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.BPLockPlayerControl
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::BPLockPlayerControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPLockPlayerControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.BPMaxOutHero
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::BPMaxOutHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPMaxOutHero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.BPStartBossFight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       BossFightStarter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::BPStartBossFight(class ACharacter* BossFightStarter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPStartBossFight");

	Params::MandragoraGameMode_BPStartBossFight Parms{};

	Parms.BossFightStarter = BossFightStarter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.BPUnlockPlayerControl
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::BPUnlockPlayerControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "BPUnlockPlayerControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.CheatGodModeToggle
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::CheatGodModeToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "CheatGodModeToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.CutsceneModeFadeOutFinished
// (Final, Native, Private)

void AMandragoraGameMode::CutsceneModeFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "CutsceneModeFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.DecreaseGameTime
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::DecreaseGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "DecreaseGameTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.EndCutsceneMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFade                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::EndCutsceneMode(bool bFade, float AnimDuration, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "EndCutsceneMode");

	Params::MandragoraGameMode_EndCutsceneMode Parms{};

	Parms.bFade = bFade;
	Parms.AnimDuration = AnimDuration;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.GetActorByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMandragoraGameMode::GetActorByName(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetActorByName");

	Params::MandragoraGameMode_GetActorByName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.GetConversationManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManConversationManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManConversationManager* AMandragoraGameMode::GetConversationManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetConversationManager");

	Params::MandragoraGameMode_GetConversationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.GetCreationTemplate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCharacterCreationTemplate*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCreationTemplate* AMandragoraGameMode::GetCreationTemplate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetCreationTemplate");

	Params::MandragoraGameMode_GetCreationTemplate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.GetGameplayActorByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMandragoraGameMode::GetGameplayActorByName(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetGameplayActorByName");

	Params::MandragoraGameMode_GetGameplayActorByName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.GetPersistentHeroData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPersistentHeroData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPersistentHeroData* AMandragoraGameMode::GetPersistentHeroData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetPersistentHeroData");

	Params::MandragoraGameMode_GetPersistentHeroData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.GetSurfaceTypeVolumeByPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASurfaceTypeVolume*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASurfaceTypeVolume* AMandragoraGameMode::GetSurfaceTypeVolumeByPosition(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "GetSurfaceTypeVolumeByPosition");

	Params::MandragoraGameMode_GetSurfaceTypeVolumeByPosition Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.IncreaseGameTime
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::IncreaseGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "IncreaseGameTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.IsCaravanCheckPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::IsCaravanCheckPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "IsCaravanCheckPoint");

	Params::MandragoraGameMode_IsCaravanCheckPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.IsCheckPointTravelActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::IsCheckPointTravelActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "IsCheckPointTravelActive");

	Params::MandragoraGameMode_IsCheckPointTravelActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.IsSkipCutsceneActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::IsSkipCutsceneActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "IsSkipCutsceneActive");

	Params::MandragoraGameMode_IsSkipCutsceneActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.LevelsChangedEvent
// (Final, Native, Public)

void AMandragoraGameMode::LevelsChangedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "LevelsChangedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnActorSpawnedDynamicWorld
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::OnActorSpawnedDynamicWorld(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnActorSpawnedDynamicWorld");

	Params::MandragoraGameMode_OnActorSpawnedDynamicWorld Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnActorSpawnedWorld
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::OnActorSpawnedWorld(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnActorSpawnedWorld");

	Params::MandragoraGameMode_OnActorSpawnedWorld Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnBeginPlayFadeOutFinished
// (Final, Native, Public)

void AMandragoraGameMode::OnBeginPlayFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnBeginPlayFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnCutsceneBegin
// (Final, Native, Public)

void AMandragoraGameMode::OnCutsceneBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnCutsceneBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnCutsceneEnd
// (Final, Native, Public)

void AMandragoraGameMode::OnCutsceneEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnCutsceneEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnFastTravelTransitionBegin
// (Final, Native, Public)

void AMandragoraGameMode::OnFastTravelTransitionBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnFastTravelTransitionBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnFastTravelTransitionEnd
// (Final, Native, Public)

void AMandragoraGameMode::OnFastTravelTransitionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnFastTravelTransitionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnSubLevelTransitionBegin
// (Final, Native, Public)

void AMandragoraGameMode::OnSubLevelTransitionBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnSubLevelTransitionBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnSubLevelTransitionEnd
// (Final, Native, Public)

void AMandragoraGameMode::OnSubLevelTransitionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnSubLevelTransitionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnTravelToCheckPointFadeInFinished
// (Final, Native, Public)

void AMandragoraGameMode::OnTravelToCheckPointFadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnTravelToCheckPointFadeInFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnValidateDoOnceMan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::OnValidateDoOnceMan(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnValidateDoOnceMan");

	Params::MandragoraGameMode_OnValidateDoOnceMan Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.OnWindowCloseRequested
// (Final, Native, Private)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::OnWindowCloseRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "OnWindowCloseRequested");

	Params::MandragoraGameMode_OnWindowCloseRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.PlayLevelSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   LevelSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCombatMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::PlayLevelSequence(class ULevelSequence* LevelSequence, float BlendInDuration, float BlendOutDuration, bool bCombatMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "PlayLevelSequence");

	Params::MandragoraGameMode_PlayLevelSequence Parms{};

	Parms.LevelSequence = LevelSequence;
	Parms.BlendInDuration = BlendInDuration;
	Parms.BlendOutDuration = BlendOutDuration;
	Parms.bCombatMode = bCombatMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.RemoveGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWithUninterruptable                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::RemoveGodMode(bool bWithUninterruptable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "RemoveGodMode");

	Params::MandragoraGameMode_RemoveGodMode Parms{};

	Parms.bWithUninterruptable = bWithUninterruptable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.RemoveHeroBPPlayerInput
// (Final, Native, Public)

void AMandragoraGameMode::RemoveHeroBPPlayerInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "RemoveHeroBPPlayerInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.RemoveHeroInvulnerable
// (Final, Native, Public)

void AMandragoraGameMode::RemoveHeroInvulnerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "RemoveHeroInvulnerable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.ResetGameTimeModify
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::ResetGameTimeModify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "ResetGameTimeModify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.ResetLevelLootTable
// (Final, Native, Public, BlueprintCallable)

void AMandragoraGameMode::ResetLevelLootTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "ResetLevelLootTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SetActiveEnemyModifiersTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEnemyModifiersTable*             InEnemyModifiersTable                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::SetActiveEnemyModifiersTable(class UEnemyModifiersTable* InEnemyModifiersTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SetActiveEnemyModifiersTable");

	Params::MandragoraGameMode_SetActiveEnemyModifiersTable Parms{};

	Parms.InEnemyModifiersTable = InEnemyModifiersTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SetForceLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::SetForceLoadingScreen(bool bEnable, class UObject* DebugObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SetForceLoadingScreen");

	Params::MandragoraGameMode_SetForceLoadingScreen Parms{};

	Parms.bEnable = bEnable;
	Parms.DebugObject = DebugObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SetLevelLootTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManLootTable*                    InLootTable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::SetLevelLootTable(class UManLootTable* InLootTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SetLevelLootTable");

	Params::MandragoraGameMode_SetLevelLootTable Parms{};

	Parms.InLootTable = InLootTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SetPanningAgentEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::SetPanningAgentEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SetPanningAgentEnable");

	Params::MandragoraGameMode_SetPanningAgentEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SkipCutsceneModeFadeOutFinished
// (Final, Native, Private)

void AMandragoraGameMode::SkipCutsceneModeFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SkipCutsceneModeFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.SpawnVisualEntity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AVisualEntity>        VisualEntityClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MandatoryAttachTarget                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachTarget                           AttachTargetType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachTargetName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERotationSelector                       Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocAttachRule                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredStart                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         AssociatedAbilityClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVisualEntity*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVisualEntity* AMandragoraGameMode::SpawnVisualEntity(TSubclassOf<class AVisualEntity> VisualEntityClass, class AActor* MandatoryAttachTarget, EAttachTarget AttachTargetType, class FName AttachTargetName, ERotationSelector Rotation, EAttachmentRule LocAttachRule, bool bDeferredStart, TSubclassOf<class UAbilityBase> AssociatedAbilityClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "SpawnVisualEntity");

	Params::MandragoraGameMode_SpawnVisualEntity Parms{};

	Parms.VisualEntityClass = VisualEntityClass;
	Parms.MandatoryAttachTarget = MandatoryAttachTarget;
	Parms.AttachTargetType = AttachTargetType;
	Parms.AttachTargetName = AttachTargetName;
	Parms.Rotation = Rotation;
	Parms.LocAttachRule = LocAttachRule;
	Parms.bDeferredStart = bDeferredStart;
	Parms.AssociatedAbilityClass = AssociatedAbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MandragoraGameMode.StartCutsceneMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFade                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkippable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::StartCutsceneMode(bool bFade, bool bSkippable, float AnimDuration, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "StartCutsceneMode");

	Params::MandragoraGameMode_StartCutsceneMode Parms{};

	Parms.bFade = bFade;
	Parms.bSkippable = bSkippable;
	Parms.AnimDuration = AnimDuration;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.ToggleBossFightSaveLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bToggle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMandragoraGameMode::ToggleBossFightSaveLock(bool bToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "ToggleBossFightSaveLock");

	Params::MandragoraGameMode_ToggleBossFightSaveLock Parms{};

	Parms.bToggle = bToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandragoraGameMode.IsPanningAgentEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMandragoraGameMode::IsPanningAgentEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraGameMode", "IsPanningAgentEnabled");

	Params::MandragoraGameMode_IsPanningAgentEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VLBeastAI.OnEndBossRoomOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVLBeastAI::OnEndBossRoomOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VLBeastAI", "OnEndBossRoomOverlap");

	Params::VLBeastAI_OnEndBossRoomOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VLBeastAI.OnTransformedEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               Src                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Dest                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVLBeastAI::OnTransformedEvent(class UAbilityController* Src, class UAbilityController* Dest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VLBeastAI", "OnTransformedEvent");

	Params::VLBeastAI_OnTransformedEvent Parms{};

	Parms.Src = Src;
	Parms.Dest = Dest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FieryRushAbility.CheckpointRest
// (Final, Native, Public)

void UFieryRushAbility::CheckpointRest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieryRushAbility", "CheckpointRest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FieryRushAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFieryRushAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieryRushAbility", "PostDamageDealt");

	Params::FieryRushAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FieryRushAbility.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UFieryRushAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieryRushAbility", "PreDamageDealt");

	Params::FieryRushAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.FinessePassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFinessePassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinessePassive", "DamageDealt");

	Params::FinessePassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FinessePassive.DamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFinessePassive::DamageReceived(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinessePassive", "DamageReceived");

	Params::FinessePassive_DamageReceived Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FinessePassive.Reset
// (Final, Native, Public)

void UFinessePassive::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinessePassive", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FireDemonAttackFirestarter.BPGetTargetLocations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UFireDemonAttackFirestarter::BPGetTargetLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireDemonAttackFirestarter", "BPGetTargetLocations");

	Params::FireDemonAttackFirestarter_BPGetTargetLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FireDemonAttackFieryPillar.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFireDemonAttackFieryPillar::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireDemonAttackFieryPillar", "BPGetTargetLocation");

	Params::FireDemonAttackFieryPillar_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.InquisitorAI.BPEndCutscene2
// (Final, Native, Public, BlueprintCallable)

void UInquisitorAI::BPEndCutscene2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "BPEndCutscene2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorAI.InquisitorOnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInquisitorAI::InquisitorOnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "InquisitorOnPostDamaged");

	Params::InquisitorAI_InquisitorOnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorAI.OnHeroAbilityEnding
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInquisitorAI::OnHeroAbilityEnding(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "OnHeroAbilityEnding");

	Params::InquisitorAI_OnHeroAbilityEnding Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorAI.OnHeroAbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInquisitorAI::OnHeroAbilityStarted(class UAbilityBase* InAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "OnHeroAbilityStarted");

	Params::InquisitorAI_OnHeroAbilityStarted Parms{};

	Parms.InAbility = InAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorAI.OnOptionsWindowHide
// (Final, Native, Public)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInquisitorAI::OnOptionsWindowHide(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "OnOptionsWindowHide");

	Params::InquisitorAI_OnOptionsWindowHide Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InquisitorAI.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UInquisitorAI::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InquisitorAI", "OnPreDamageCaused");

	Params::InquisitorAI_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.RollAbility.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void URollAbility::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RollAbility", "OnPreDamagedPriority");

	Params::RollAbility_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.FireDemonAttackCharge.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireDemonAttackCharge::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireDemonAttackCharge", "IsCollideSignature");

	Params::FireDemonAttackCharge_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.KingPriestAttackPurgingRain.BPIsRainStartedOnLeftSide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKingPriestAttackPurgingRain::BPIsRainStartedOnLeftSide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestAttackPurgingRain", "BPIsRainStartedOnLeftSide");

	Params::KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FixHotkeyUserWidget.GetHotkeyNameText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UFixHotkeyUserWidget::GetHotkeyNameText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FixHotkeyUserWidget", "GetHotkeyNameText");

	Params::FixHotkeyUserWidget_GetHotkeyNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FixHotkeyUserWidget.OnSetHotkeyNameText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InHotkeyNameText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFixHotkeyUserWidget::OnSetHotkeyNameText(const class FText& InHotkeyNameText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FixHotkeyUserWidget", "OnSetHotkeyNameText");

	Params::FixHotkeyUserWidget_OnSetHotkeyNameText Parms{};

	Parms.InHotkeyNameText = std::move(InHotkeyNameText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SurfaceEffectTypeDataAsset.GetCustomVFXData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* USurfaceEffectTypeDataAsset::GetCustomVFXData(class FName CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceEffectTypeDataAsset", "GetCustomVFXData");

	Params::SurfaceEffectTypeDataAsset_GetCustomVFXData Parms{};

	Parms.CustomName = CustomName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SurfaceEffectTypeDataAsset.GetFootStepDataIdxForActorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USurfaceEffectTypeDataAsset::GetFootStepDataIdxForActorType(TSubclassOf<class AActor> InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceEffectTypeDataAsset", "GetFootStepDataIdxForActorType");

	Params::SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ActorBaseModifiersNode.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UActorBaseModifiersNode::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorBaseModifiersNode", "GetEditorName");

	Params::ActorBaseModifiersNode_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FlyComponent.GetTargetRef
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFlyComponent::GetTargetRef()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyComponent", "GetTargetRef");

	Params::FlyComponent_GetTargetRef Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FlyComponent.SetInitialSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlyComponent::SetInitialSpeed(float NewSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyComponent", "SetInitialSpeed");

	Params::FlyComponent_SetInitialSpeed Parms{};

	Parms.NewSpeed = NewSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorItem.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UVendorItem::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorItem", "GetEditorName");

	Params::VendorItem_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FocalizedManaPassive.OnResourceUsed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFocalizedManaPassive::OnResourceUsed(EEntityProperty resource, float* amount, class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocalizedManaPassive", "OnResourceUsed");

	Params::FocalizedManaPassive_OnResourceUsed Parms{};

	Parms.resource = resource;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (amount != nullptr)
		*amount = Parms.amount;
}


// Function man.FocalizedManaPassive.OnStatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       StatusType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFocalizedManaPassive::OnStatusEffectCaused(class AActor* To, EStatusEffectType StatusType, bool NewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocalizedManaPassive", "OnStatusEffectCaused");

	Params::FocalizedManaPassive_OnStatusEffectCaused Parms{};

	Parms.To = To;
	Parms.StatusType = StatusType;
	Parms.NewEffect = NewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ForkedLightningAbility.OnStaggerOrStun
// (Final, Native, Public)

void UForkedLightningAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForkedLightningAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FreeCamera.GetLocalPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AFreeCamera::GetLocalPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeCamera", "GetLocalPosition");

	Params::FreeCamera_GetLocalPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FreeCamera.GetLocalRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AFreeCamera::GetLocalRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeCamera", "GetLocalRotation");

	Params::FreeCamera_GetLocalRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FreeCamera.GetLocalTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AFreeCamera::GetLocalTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeCamera", "GetLocalTransform");

	Params::FreeCamera_GetLocalTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FreeCamera.ResetLocalTransform
// (Final, Native, Public, BlueprintCallable)

void AFreeCamera::ResetLocalTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeCamera", "ResetLocalTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FreeCamera.ToggleInput
// (Final, Native, Public, BlueprintCallable)

void AFreeCamera::ToggleInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeCamera", "ToggleInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorPortraitsUserWidget.OnShowSlot
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UConversationPortraitUserWidget*  ConversationPortraitUserWidget                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorPortraitsUserWidget::OnShowSlot(class UConversationPortraitUserWidget* ConversationPortraitUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorPortraitsUserWidget", "OnShowSlot");

	Params::VendorPortraitsUserWidget_OnShowSlot Parms{};

	Parms.ConversationPortraitUserWidget = ConversationPortraitUserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.FreecastPassive.AbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFreecastPassive::AbilityEnd(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreecastPassive", "AbilityEnd");

	Params::FreecastPassive_AbilityEnd Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FreecastPassive.AbilityStart
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFreecastPassive::AbilityStart(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreecastPassive", "AbilityStart");

	Params::FreecastPassive_AbilityStart Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FreecastPassive.OnStaggerOrStun
// (Final, Native, Public)

void UFreecastPassive::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreecastPassive", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FreecastPassive.RemoveFreecastStack
// (Final, Native, Public)

void UFreecastPassive::RemoveFreecastStack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreecastPassive", "RemoveFreecastStack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.FreecastPassive.ResourceConsumed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFreecastPassive::ResourceConsumed(EEntityProperty resource, float* amount, class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreecastPassive", "ResourceConsumed");

	Params::FreecastPassive_ResourceConsumed Parms{};

	Parms.resource = resource;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (amount != nullptr)
		*amount = Parms.amount;
}


// Function man.ManAudioTriggerVolume.OnBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManAudioTriggerVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAudioTriggerVolume", "OnBeginOverlap");

	Params::ManAudioTriggerVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManAudioTriggerVolume.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManAudioTriggerVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAudioTriggerVolume", "OnEndOverlap");

	Params::ManAudioTriggerVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FriendlyReminderPassive.StatusEffectCaused
// (Final, Native, Public)
// Parameters:
// class AActor*                           ToTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendlyReminderPassive::StatusEffectCaused(class AActor* ToTarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendlyReminderPassive", "StatusEffectCaused");

	Params::FriendlyReminderPassive_StatusEffectCaused Parms{};

	Parms.ToTarget = ToTarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FrostMageAttackIceRupture.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFrostMageAttackIceRupture::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrostMageAttackIceRupture", "BPGetTargetLocation");

	Params::FrostMageAttackIceRupture_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeConnectionUserWidget.OnSetState
// (Event, Public, BlueprintEvent)

void USkillTreeConnectionUserWidget::OnSetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeConnectionUserWidget", "OnSetState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.SkillTreeConnectionUserWidget.GetNodeRegion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterClass                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterClass USkillTreeConnectionUserWidget::GetNodeRegion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeConnectionUserWidget", "GetNodeRegion");

	Params::SkillTreeConnectionUserWidget_GetNodeRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManCheatManager.MAN_AchievementAddProgress
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_AchievementAddProgress(const class FString& AchievementID, int32 Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementAddProgress");

	Params::ManCheatManager_MAN_AchievementAddProgress Parms{};

	Parms.AchievementID = std::move(AchievementID);
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AchievementReset
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_AchievementReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AchievementSetFlag
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_AchievementSetFlag(const class FString& AchievementID, int32 Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementSetFlag");

	Params::ManCheatManager_MAN_AchievementSetFlag Parms{};

	Parms.AchievementID = std::move(AchievementID);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AchievementShowProgress
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_AchievementShowProgress(const class FString& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementShowProgress");

	Params::ManCheatManager_MAN_AchievementShowProgress Parms{};

	Parms.AchievementID = std::move(AchievementID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AchievementUnlock
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_AchievementUnlock(const class FString& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementUnlock");

	Params::ManCheatManager_MAN_AchievementUnlock Parms{};

	Parms.AchievementID = std::move(AchievementID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AchievementUnlockAll
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_AchievementUnlockAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AchievementUnlockAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ActorPerformanceAnalyze
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_ActorPerformanceAnalyze(int32 Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ActorPerformanceAnalyze");

	Params::ManCheatManager_MAN_ActorPerformanceAnalyze Parms{};

	Parms.Frame = Frame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_AddKSDemoItem
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_AddKSDemoItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_AddKSDemoItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_BestiaryShowUnlockProgress
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_BestiaryShowUnlockProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_BestiaryShowUnlockProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_BestiaryUnlockAll
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_BestiaryUnlockAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_BestiaryUnlockAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_CheatKillOnlyContain
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_CheatKillOnlyContain(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_CheatKillOnlyContain");

	Params::ManCheatManager_MAN_CheatKillOnlyContain Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_CheatKillSkipContain
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_CheatKillSkipContain(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_CheatKillSkipContain");

	Params::ManCheatManager_MAN_CheatKillSkipContain Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_CheatMapGridExploration
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_CheatMapGridExploration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_CheatMapGridExploration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_CheatTeleport
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CheatTeleportName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_CheatTeleport(const class FString& CheatTeleportName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_CheatTeleport");

	Params::ManCheatManager_MAN_CheatTeleport Parms{};

	Parms.CheatTeleportName = std::move(CheatTeleportName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpLoadTime
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpLoadTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpLoadTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpMapExplorationBuiltData
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpMapExplorationBuiltData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpMapExplorationBuiltData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpNiagaraInfo
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpNiagaraInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpNiagaraInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpPlayerLocks
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpPlayerLocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpPlayerLocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpPlayerStatisticsData
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpPlayerStatisticsData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpPlayerStatisticsData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_DumpStackMeasure
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_DumpStackMeasure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_DumpStackMeasure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ExportPersonalCartItems
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ExportPersonalCartItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ExportPersonalCartItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ForceManShaderGenerateProcess
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CurrentLevelMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VisibleMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_ForceManShaderGenerateProcess(int32 CurrentLevelMode, int32 VisibleMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ForceManShaderGenerateProcess");

	Params::ManCheatManager_MAN_ForceManShaderGenerateProcess Parms{};

	Parms.CurrentLevelMode = CurrentLevelMode;
	Parms.VisibleMode = VisibleMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListActiveActors
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListActiveActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListActiveActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListAllActors
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListAllGlobalVariable
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListAllGlobalVariable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListAllGlobalVariable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListAllLevelScriptActor
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListAllLevelScriptActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListAllLevelScriptActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListEnemiesInCombat
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListEnemiesInCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListEnemiesInCombat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListHeroActiveAbilityData
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListHeroActiveAbilityData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListHeroActiveAbilityData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListSleepingActors
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListSleepingActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListSleepingActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_ListUnmanagedActors
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_ListUnmanagedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_ListUnmanagedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_LogActiveQuestInfo
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_LogActiveQuestInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_LogActiveQuestInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_PlayCinematic
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CinematicAsset                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_PlayCinematic(const class FString& CinematicAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_PlayCinematic");

	Params::ManCheatManager_MAN_PlayCinematic Parms{};

	Parms.CinematicAsset = std::move(CinematicAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SearchAbilityComponent
// (Final, Exec, Native, Public)

void UManCheatManager::MAN_SearchAbilityComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SearchAbilityComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SetCustomCharacterSetupTemplate
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CustomCharacterSetupTemplate                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SetCustomCharacterSetupTemplate(const class FString& CustomCharacterSetupTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SetCustomCharacterSetupTemplate");

	Params::ManCheatManager_MAN_SetCustomCharacterSetupTemplate Parms{};

	Parms.CustomCharacterSetupTemplate = std::move(CustomCharacterSetupTemplate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SetHeroHP
// (Final, Exec, Native, Public)
// Parameters:
// float                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SetHeroHP(float HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SetHeroHP");

	Params::ManCheatManager_MAN_SetHeroHP Parms{};

	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SetHP
// (Final, Exec, Native, Public)
// Parameters:
// float                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SetHP(float HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SetHP");

	Params::ManCheatManager_MAN_SetHP Parms{};

	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SetSmallScreenZoomRate
// (Final, Exec, Native, Public)
// Parameters:
// float                                   SmallScreenZoomRate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SetSmallScreenZoomRate(float SmallScreenZoomRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SetSmallScreenZoomRate");

	Params::ManCheatManager_MAN_SetSmallScreenZoomRate Parms{};

	Parms.SmallScreenZoomRate = SmallScreenZoomRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SetTalentPoint
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewPoint                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SetTalentPoint(int32 NewPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SetTalentPoint");

	Params::ManCheatManager_MAN_SetTalentPoint Parms{};

	Parms.NewPoint = NewPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManCheatManager.MAN_SpawnActor
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManCheatManager::MAN_SpawnActor(const class FString& ActorName, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManCheatManager", "MAN_SpawnActor");

	Params::ManCheatManager_MAN_SpawnActor Parms{};

	Parms.ActorName = std::move(ActorName);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.FrostMageEntropicBlink.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFrostMageEntropicBlink::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrostMageEntropicBlink", "BPGetTeleportLocation");

	Params::FrostMageEntropicBlink_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.FrostMageEntropicBlinkToSpawnLocation.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFrostMageEntropicBlinkToSpawnLocation::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrostMageEntropicBlinkToSpawnLocation", "BPGetTeleportLocation");

	Params::FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDBuffBarSlotUserWidget.OnGreyedOut
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInGreyedOut                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnGreyedOut(bool bInGreyedOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnGreyedOut");

	Params::HUDBuffBarSlotUserWidget_OnGreyedOut Parms{};

	Parms.bInGreyedOut = bInGreyedOut;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetCooldown
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InCooldown                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetCooldown(float InCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetCooldown");

	Params::HUDBuffBarSlotUserWidget_OnSetCooldown Parms{};

	Parms.InCooldown = InCooldown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetHighlight
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInHighlight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetHighlight(bool bInHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetHighlight");

	Params::HUDBuffBarSlotUserWidget_OnSetHighlight Parms{};

	Parms.bInHighlight = bInHighlight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetIcon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InBuffIcon                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetIcon(const class UTexture2D* InBuffIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetIcon");

	Params::HUDBuffBarSlotUserWidget_OnSetIcon Parms{};

	Parms.InBuffIcon = InBuffIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetIconID
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InBuffIconID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetIconID(int32 InBuffIconID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetIconID");

	Params::HUDBuffBarSlotUserWidget_OnSetIconID Parms{};

	Parms.InBuffIconID = InBuffIconID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetInnerNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InInnerNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetInnerNumber(int32 InInnerNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetInnerNumber");

	Params::HUDBuffBarSlotUserWidget_OnSetInnerNumber Parms{};

	Parms.InInnerNumber = InInnerNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetInnerNumberVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInInnerNumberVisible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetInnerNumberVisible(bool bInInnerNumberVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetInnerNumberVisible");

	Params::HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible Parms{};

	Parms.bInInnerNumberVisible = bInInnerNumberVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetMaxCooldown
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InMaxCooldown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetMaxCooldown(float InMaxCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetMaxCooldown");

	Params::HUDBuffBarSlotUserWidget_OnSetMaxCooldown Parms{};

	Parms.InMaxCooldown = InMaxCooldown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetOuterNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InOuterNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetOuterNumber(int32 InOuterNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetOuterNumber");

	Params::HUDBuffBarSlotUserWidget_OnSetOuterNumber Parms{};

	Parms.InOuterNumber = InOuterNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetOuterNumberVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInOuterNumberVisible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetOuterNumberVisible(bool bInOuterNumberVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetOuterNumberVisible");

	Params::HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible Parms{};

	Parms.bInOuterNumberVisible = bInOuterNumberVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InBuffText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetText(const class FText& InBuffText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetText");

	Params::HUDBuffBarSlotUserWidget_OnSetText Parms{};

	Parms.InBuffText = std::move(InBuffText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDBuffBarSlotUserWidget.OnSetType
// (Event, Protected, BlueprintEvent)
// Parameters:
// EBuffType                               InBuffType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDBuffBarSlotUserWidget::OnSetType(EBuffType InBuffType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDBuffBarSlotUserWidget", "OnSetType");

	Params::HUDBuffBarSlotUserWidget_OnSetType Parms{};

	Parms.InBuffType = InBuffType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GameCamera.GetCameraParamsForLevelSequencePlayer
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACineCameraActor*                 CineCameraActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CurrentFocalLength                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::GetCameraParamsForLevelSequencePlayer(class ACineCameraActor* CineCameraActor, struct FTransform* Transform, float* CurrentFocalLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "GetCameraParamsForLevelSequencePlayer");

	Params::GameCamera_GetCameraParamsForLevelSequencePlayer Parms{};

	Parms.CineCameraActor = CineCameraActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	if (CurrentFocalLength != nullptr)
		*CurrentFocalLength = Parms.CurrentFocalLength;
}


// Function man.GameCamera.OnCharacterWindowHide
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::OnCharacterWindowHide(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "OnCharacterWindowHide");

	Params::GameCamera_OnCharacterWindowHide Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.OnCharacterWindowShow
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::OnCharacterWindowShow(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "OnCharacterWindowShow");

	Params::GameCamera_OnCharacterWindowShow Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.ResetFreeCameraLocalTransform
// (Final, Native, Public, BlueprintCallable)

void AGameCamera::ResetFreeCameraLocalTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "ResetFreeCameraLocalTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.ResetLocalTransform
// (Final, Native, Public, BlueprintCallable)

void AGameCamera::ResetLocalTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "ResetLocalTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.ResetMotionBlurStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::ResetMotionBlurStrength(float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "ResetMotionBlurStrength");

	Params::GameCamera_ResetMotionBlurStrength Parms{};

	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.SetMotionBlurStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MotionBlurAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::SetMotionBlurStrength(float MotionBlurAmount, float BlendDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "SetMotionBlurStrength");

	Params::GameCamera_SetMotionBlurStrength Parms{};

	Parms.MotionBlurAmount = MotionBlurAmount;
	Parms.BlendDuration = BlendDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.SetPlayerFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewPlayerFocus                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::SetPlayerFocus(bool NewPlayerFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "SetPlayerFocus");

	Params::GameCamera_SetPlayerFocus Parms{};

	Parms.NewPlayerFocus = NewPlayerFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.SetSequencePlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewSequencePlaying                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::SetSequencePlaying(bool NewSequencePlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "SetSequencePlaying");

	Params::GameCamera_SetSequencePlaying Parms{};

	Parms.NewSequencePlaying = NewSequencePlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.SetSmallScreenZoomRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSmallScreenZoomRate                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::SetSmallScreenZoomRate(float NewSmallScreenZoomRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "SetSmallScreenZoomRate");

	Params::GameCamera_SetSmallScreenZoomRate Parms{};

	Parms.NewSmallScreenZoomRate = NewSmallScreenZoomRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.ToggleFreeCameraInput
// (Final, Native, Public, BlueprintCallable)

void AGameCamera::ToggleFreeCameraInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "ToggleFreeCameraInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.UpdateByLevelSequencePlayerCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequencePlayer*             LevelSequencePlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCamera::UpdateByLevelSequencePlayerCamera(class ULevelSequencePlayer* LevelSequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "UpdateByLevelSequencePlayerCamera");

	Params::GameCamera_UpdateByLevelSequencePlayerCamera Parms{};

	Parms.LevelSequencePlayer = LevelSequencePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GameCamera.DumpCameraCharacters
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   CharacterNames                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AGameCamera::DumpCameraCharacters(TArray<class FString>* CharacterNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "DumpCameraCharacters");

	Params::GameCamera_DumpCameraCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CharacterNames != nullptr)
		*CharacterNames = std::move(Parms.CharacterNames);
}


// Function man.GameCamera.GetListenerTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AGameCamera::GetListenerTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "GetListenerTransform");

	Params::GameCamera_GetListenerTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GameCamera.GetManualDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameCamera::GetManualDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "GetManualDistance");

	Params::GameCamera_GetManualDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GameCamera.GetVerticalDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameCamera::GetVerticalDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "GetVerticalDistance");

	Params::GameCamera_GetVerticalDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GameCamera.GetWorldTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AGameCamera::GetWorldTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "GetWorldTransform");

	Params::GameCamera_GetWorldTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GameCamera.IsSequencePlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCamera::IsSequencePlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCamera", "IsSequencePlaying");

	Params::GameCamera_IsSequencePlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystem_Glicko.AddMatch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IRatingObjectInterface>Rating1                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class IRatingObjectInterface>Rating2                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URatingSystem_Glicko::AddMatch(const TScriptInterface<class IRatingObjectInterface>& Rating1, const TScriptInterface<class IRatingObjectInterface>& Rating2, float Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "AddMatch");

	Params::RatingSystem_Glicko_AddMatch Parms{};

	Parms.Rating1 = Rating1;
	Parms.Rating2 = Rating2;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingSystem_Glicko.CreateRatingObject
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IRatingObjectInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class IRatingObjectInterface> URatingSystem_Glicko::CreateRatingObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "CreateRatingObject");

	Params::RatingSystem_Glicko_CreateRatingObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystem_Glicko.GetDSqr
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPlayerRatingProcessInfo         PlayerRatingProcessInfo                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingSystem_Glicko::GetDSqr(const struct FPlayerRatingProcessInfo& PlayerRatingProcessInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "GetDSqr");

	Params::RatingSystem_Glicko_GetDSqr Parms{};

	Parms.PlayerRatingProcessInfo = std::move(PlayerRatingProcessInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystem_Glicko.GetE
// (Final, Native, Protected)
// Parameters:
// float                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rating                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OtherRating                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OtherG                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingSystem_Glicko::GetE(float Score, float Rating, float OtherRating, float OtherG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "GetE");

	Params::RatingSystem_Glicko_GetE Parms{};

	Parms.Score = Score;
	Parms.Rating = Rating;
	Parms.OtherRating = OtherRating;
	Parms.OtherG = OtherG;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystem_Glicko.GetG
// (Final, Native, Protected)
// Parameters:
// float                                   RatingsDeviation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingSystem_Glicko::GetG(float RatingsDeviation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "GetG");

	Params::RatingSystem_Glicko_GetG Parms{};

	Parms.RatingsDeviation = RatingsDeviation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystem_Glicko.Update
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void URatingSystem_Glicko::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingSystem_Glicko.GetSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRatingSystemSettings_GlickoReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FRatingSystemSettings_Glicko URatingSystem_Glicko::GetSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystem_Glicko", "GetSettings");

	Params::RatingSystem_Glicko_GetSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GatheringStormPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGatheringStormPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GatheringStormPassive", "DamageDealt");

	Params::GatheringStormPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.AddedResourceAnimFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::AddedResourceAnimFinished(EHeroProperty PropertyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "AddedResourceAnimFinished");

	Params::HUDUserWidget_AddedResourceAnimFinished Parms{};

	Parms.PropertyType = PropertyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.GetInteractProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHUDUserWidget::GetInteractProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "GetInteractProgress");

	Params::HUDUserWidget_GetInteractProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDUserWidget.OnAddItemAbility
// (Final, Native, Private)
// Parameters:
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnAddItemAbility(class UItemAbility* Item, int32 Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnAddItemAbility");

	Params::HUDUserWidget_OnAddItemAbility Parms{};

	Parms.Item = Item;
	Parms.Stack = Stack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnBossPreDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnBossPreDamaged(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnBossPreDamaged");

	Params::HUDUserWidget_OnBossPreDamaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.HUDUserWidget.OnChangeItemSetIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   ItemSetIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnChangeItemSetIndex(int32 ItemSetIndex, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnChangeItemSetIndex");

	Params::HUDUserWidget_OnChangeItemSetIndex Parms{};

	Parms.ItemSetIndex = ItemSetIndex;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnChangeSkillSetIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   SkillSetIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnChangeSkillSetIndex(int32 SkillSetIndex, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnChangeSkillSetIndex");

	Params::HUDUserWidget_OnChangeSkillSetIndex Parms{};

	Parms.SkillSetIndex = SkillSetIndex;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnComboPointBarVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bComboPointBarVisible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnComboPointBarVisible(bool bComboPointBarVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnComboPointBarVisible");

	Params::HUDUserWidget_OnComboPointBarVisible Parms{};

	Parms.bComboPointBarVisible = bComboPointBarVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnEdgeScreenLowResourceFeedback
// (Final, Native, Public)
// Parameters:
// int32                                   InEdgeScreenLowResourceFeedback                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnEdgeScreenLowResourceFeedback(int32 InEdgeScreenLowResourceFeedback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnEdgeScreenLowResourceFeedback");

	Params::HUDUserWidget_OnEdgeScreenLowResourceFeedback Parms{};

	Parms.InEdgeScreenLowResourceFeedback = InEdgeScreenLowResourceFeedback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnEnergyBarVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnEnergyBarVisibility(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnEnergyBarVisibility");

	Params::HUDUserWidget_OnEnergyBarVisibility Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnExtraAbilitySlotVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnExtraAbilitySlotVisibility(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnExtraAbilitySlotVisibility");

	Params::HUDUserWidget_OnExtraAbilitySlotVisibility Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnHeroDie
// (Event, Public, BlueprintEvent)

void UHUDUserWidget::OnHeroDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnHeroDie");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HUDUserWidget.OnHideHUDBar
// (Event, Public, BlueprintEvent)
// Parameters:
// EHUDBarType                             HUDBarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnHideHUDBar(EHUDBarType HUDBarType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnHideHUDBar");

	Params::HUDUserWidget_OnHideHUDBar Parms{};

	Parms.HUDBarType = HUDBarType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnHideInteract
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UHUDUserWidget::OnHideInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnHideInteract");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HUDUserWidget.OnHUDVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnHUDVisibility(bool bInVisible, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnHUDVisibility");

	Params::HUDUserWidget_OnHUDVisibility Parms{};

	Parms.bInVisible = bInVisible;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnInputRestrict
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInInputRestrict                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnInputRestrict(bool bInInputRestrict)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnInputRestrict");

	Params::HUDUserWidget_OnInputRestrict Parms{};

	Parms.bInInputRestrict = bInInputRestrict;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnLevelUpIndicator
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bMatchHasStarted                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnLevelUpIndicator(bool bMatchHasStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnLevelUpIndicator");

	Params::HUDUserWidget_OnLevelUpIndicator Parms{};

	Parms.bMatchHasStarted = bMatchHasStarted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnManQuestAdd
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   QuestPopupShowingDelayTime                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestAdd(class UManQuest* ManQuest, float Timeout, float QuestPopupShowingDelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestAdd");

	Params::HUDUserWidget_OnManQuestAdd Parms{};

	Parms.ManQuest = ManQuest;
	Parms.Timeout = Timeout;
	Parms.QuestPopupShowingDelayTime = QuestPopupShowingDelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestComplete
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestComplete(class UManQuest* ManQuest, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestComplete");

	Params::HUDUserWidget_OnManQuestComplete Parms{};

	Parms.ManQuest = ManQuest;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestObjectiveAdd
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               CurrentQuestObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               NextQuestObject                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowQuestWindow                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestObjectiveAdd(class UManQuest* ManQuest, class UManQuestObjective* CurrentQuestObject, class UManQuestObjective* NextQuestObject, float Timeout, bool bShowQuestWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestObjectiveAdd");

	Params::HUDUserWidget_OnManQuestObjectiveAdd Parms{};

	Parms.ManQuest = ManQuest;
	Parms.CurrentQuestObject = CurrentQuestObject;
	Parms.NextQuestObject = NextQuestObject;
	Parms.Timeout = Timeout;
	Parms.bShowQuestWindow = bShowQuestWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestObjectiveComplete
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               ManQuestObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestObjectiveComplete(class UManQuest* ManQuest, class UManQuestObjective* ManQuestObject, float Timeout, bool bQuestCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestObjectiveComplete");

	Params::HUDUserWidget_OnManQuestObjectiveComplete Parms{};

	Parms.ManQuest = ManQuest;
	Parms.ManQuestObject = ManQuestObject;
	Parms.Timeout = Timeout;
	Parms.bQuestCompleted = bQuestCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestObjectiveFailed
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               ManQuestObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestObjectiveFailed(class UManQuest* ManQuest, class UManQuestObjective* ManQuestObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestObjectiveFailed");

	Params::HUDUserWidget_OnManQuestObjectiveFailed Parms{};

	Parms.ManQuest = ManQuest;
	Parms.ManQuestObject = ManQuestObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestObjectiveUpdate
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               ManQuestObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowQuestWindow                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestObjectiveUpdate(class UManQuest* ManQuest, class UManQuestObjective* ManQuestObject, float Timeout, bool bShowQuestWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestObjectiveUpdate");

	Params::HUDUserWidget_OnManQuestObjectiveUpdate Parms{};

	Parms.ManQuest = ManQuest;
	Parms.ManQuestObject = ManQuestObject;
	Parms.Timeout = Timeout;
	Parms.bShowQuestWindow = bShowQuestWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnManQuestRemove
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnManQuestRemove(class UManQuest* ManQuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnManQuestRemove");

	Params::HUDUserWidget_OnManQuestRemove Parms{};

	Parms.ManQuest = ManQuest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnNewAreaDiscovered
// (Final, Native, Private)
// Parameters:
// class FText                             NewAreaName                                            (Parm, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnNewAreaDiscovered(const class FText& NewAreaName, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnNewAreaDiscovered");

	Params::HUDUserWidget_OnNewAreaDiscovered Parms{};

	Parms.NewAreaName = std::move(NewAreaName);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnPlayNoStaminaFeedback
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UHUDUserWidget::OnPlayNoStaminaFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnPlayNoStaminaFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HUDUserWidget.OnPlayRiftCombatStartAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   RiftID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnPlayRiftCombatStartAnim(int32 RiftID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnPlayRiftCombatStartAnim");

	Params::HUDUserWidget_OnPlayRiftCombatStartAnim Parms{};

	Parms.RiftID = RiftID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnPropertyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnPropertyChanged");

	Params::HUDUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnQuestTrackingUpdated
// (Final, Native, Private)
// Parameters:
// class UManQuest*                        ManQuestm                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UManQuestObjective*>       Objectives                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnQuestTrackingUpdated(class UManQuest* ManQuestm, const TArray<class UManQuestObjective*>& Objectives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnQuestTrackingUpdated");

	Params::HUDUserWidget_OnQuestTrackingUpdated Parms{};

	Parms.ManQuestm = ManQuestm;
	Parms.Objectives = std::move(Objectives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnRageBarVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnRageBarVisibility(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnRageBarVisibility");

	Params::HUDUserWidget_OnRageBarVisibility Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnRemoveItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RemovedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnRemoveItem(class UInventorySlot* InventorySlot, class UItemAbility* RemovedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnRemoveItem");

	Params::HUDUserWidget_OnRemoveItem Parms{};

	Parms.InventorySlot = InventorySlot;
	Parms.RemovedItem = RemovedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnRemoveQuestNotification
// (Event, Public, BlueprintEvent)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnRemoveQuestNotification(class UManQuest* ManQuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnRemoveQuestNotification");

	Params::HUDUserWidget_OnRemoveQuestNotification Parms{};

	Parms.ManQuest = ManQuest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetAbilitiesAndResourcesDownPosition
// (Final, Native, Public)
// Parameters:
// bool                                    bDownPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetAbilitiesAndResourcesDownPosition(bool bDownPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetAbilitiesAndResourcesDownPosition");

	Params::HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition Parms{};

	Parms.bDownPosition = bDownPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnSetBossBar
// (Event, Public, BlueprintEvent)
// Parameters:
// EHUDBarType                             HUDBarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMiniBoss                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTwoStageBossBar                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMandragora                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetBossBar(EHUDBarType HUDBarType, bool bMiniBoss, bool bTwoStageBossBar, bool bMandragora)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetBossBar");

	Params::HUDUserWidget_OnSetBossBar Parms{};

	Parms.HUDBarType = HUDBarType;
	Parms.bMiniBoss = bMiniBoss;
	Parms.bTwoStageBossBar = bTwoStageBossBar;
	Parms.bMandragora = bMandragora;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetComboPoint
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   CurrentComboPointFraction                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentComboPoint                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxComboPoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetComboPoint(int32 CurrentComboPointFraction, int32 CurrentComboPoint, int32 MaxComboPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetComboPoint");

	Params::HUDUserWidget_OnSetComboPoint Parms{};

	Parms.CurrentComboPointFraction = CurrentComboPointFraction;
	Parms.CurrentComboPoint = CurrentComboPoint;
	Parms.MaxComboPoint = MaxComboPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetFadeQuestTrackerBackgroundVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetFadeQuestTrackerBackgroundVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetFadeQuestTrackerBackgroundVisible");

	Params::HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetHUDBar
// (Event, Public, BlueprintEvent)
// Parameters:
// EHUDBarType                             HUDBarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetHUDBar(EHUDBarType HUDBarType, float CurrentValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetHUDBar");

	Params::HUDUserWidget_OnSetHUDBar Parms{};

	Parms.HUDBarType = HUDBarType;
	Parms.CurrentValue = CurrentValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetInteractMode
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInCanInteract                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetInteractMode(bool bInCanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetInteractMode");

	Params::HUDUserWidget_OnSetInteractMode Parms{};

	Parms.bInCanInteract = bInCanInteract;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetLevelProgress
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   LevelProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetLevelProgress(float LevelProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetLevelProgress");

	Params::HUDUserWidget_OnSetLevelProgress Parms{};

	Parms.LevelProgress = LevelProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetLevelPulseAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetLevelPulseAnim(bool bPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetLevelPulseAnim");

	Params::HUDUserWidget_OnSetLevelPulseAnim Parms{};

	Parms.bPlay = bPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetLightBarrier
// (Event, Public, BlueprintEvent)
// Parameters:
// EHUDBarType                             HUDBarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LightBarrierCurrentValue                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LightBarrierMaxValue                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetLightBarrier(EHUDBarType HUDBarType, float LightBarrierCurrentValue, float LightBarrierMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetLightBarrier");

	Params::HUDUserWidget_OnSetLightBarrier Parms{};

	Parms.HUDBarType = HUDBarType;
	Parms.LightBarrierCurrentValue = LightBarrierCurrentValue;
	Parms.LightBarrierMaxValue = LightBarrierMaxValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSetWarningText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bInShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InWarningText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSetWarningText(bool bInShow, const class FText& InWarningText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSetWarningText");

	Params::HUDUserWidget_OnSetWarningText Parms{};

	Parms.bInShow = bInShow;
	Parms.InWarningText = std::move(InWarningText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowBestiaryUpdatedNotification
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowBestiaryUpdatedNotification(float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowBestiaryUpdatedNotification");

	Params::HUDUserWidget_OnShowBestiaryUpdatedNotification Parms{};

	Parms.Timeout = Timeout;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowHUDBar
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EHUDBarType                             HUDBarType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             HudBarTitle                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReferencePointValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LengthRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowHUDBar(EHUDBarType HUDBarType, const class FText& HudBarTitle, float MinValue, float MaxValue, float CurrentValue, float ReferencePointValue, float LengthRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowHUDBar");

	Params::HUDUserWidget_OnShowHUDBar Parms{};

	Parms.HUDBarType = HUDBarType;
	Parms.HudBarTitle = std::move(HudBarTitle);
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;
	Parms.CurrentValue = CurrentValue;
	Parms.ReferencePointValue = ReferencePointValue;
	Parms.LengthRatio = LengthRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowHUDPopup
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FHUDPopupQueue                   HUDPopupQueue                                          (Parm, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowHUDPopup(const struct FHUDPopupQueue& HUDPopupQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowHUDPopup");

	Params::HUDUserWidget_OnShowHUDPopup Parms{};

	Parms.HUDPopupQueue = std::move(HUDPopupQueue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowInteract
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             InInteractText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAbilityBase*                     InAbilityBase                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowInteract(const class FText& InInteractText, class UAbilityBase* InAbilityBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowInteract");

	Params::HUDUserWidget_OnShowInteract Parms{};

	Parms.InInteractText = std::move(InInteractText);
	Parms.InAbilityBase = InAbilityBase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowPickupNotification
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UHUDNotificationUserWidget*       HUDNotificationUserWidget                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ItemName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ItemDescription                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideNewItemTitle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowPickupNotification(class UHUDNotificationUserWidget* HUDNotificationUserWidget, const class FText& ItemName, const class FText& ItemDescription, class UTexture2D* Icon, float Timeout, int32 Number, class UItemAbility* ItemAbility, bool bHideNewItemTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowPickupNotification");

	Params::HUDUserWidget_OnShowPickupNotification Parms{};

	Parms.HUDNotificationUserWidget = HUDNotificationUserWidget;
	Parms.ItemName = std::move(ItemName);
	Parms.ItemDescription = std::move(ItemDescription);
	Parms.Icon = Icon;
	Parms.Timeout = Timeout;
	Parms.Number = Number;
	Parms.ItemAbility = ItemAbility;
	Parms.bHideNewItemTitle = bHideNewItemTitle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowQuestNotification
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UManQuestObjective*>       Objectives                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowQuestNotification(class UManQuest* ManQuest, const TArray<class UManQuestObjective*>& Objectives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowQuestNotification");

	Params::HUDUserWidget_OnShowQuestNotification Parms{};

	Parms.ManQuest = ManQuest;
	Parms.Objectives = std::move(Objectives);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnShowUseItemNotification
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UHUDNotificationUserWidget*       HUDNotificationUserWidget                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ItemName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnShowUseItemNotification(class UHUDNotificationUserWidget* HUDNotificationUserWidget, const class FText& ItemName, class UTexture2D* Icon, float Timeout, int32 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnShowUseItemNotification");

	Params::HUDUserWidget_OnShowUseItemNotification Parms{};

	Parms.HUDNotificationUserWidget = HUDNotificationUserWidget;
	Parms.ItemName = std::move(ItemName);
	Parms.Icon = Icon;
	Parms.Timeout = Timeout;
	Parms.Number = Number;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnSpecialMovementUlnocked
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESpecialMovementType                    SpecialMovementType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnSpecialMovementUlnocked(ESpecialMovementType SpecialMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnSpecialMovementUlnocked");

	Params::HUDUserWidget_OnSpecialMovementUlnocked Parms{};

	Parms.SpecialMovementType = SpecialMovementType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleAddedResource
// (Event, Protected, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleAddedResource(EHeroProperty PropertyType, int32 Value, bool bShowing, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleAddedResource");

	Params::HUDUserWidget_OnToggleAddedResource Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.bShowing = bShowing;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleExtraLanternDrainEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleExtraLanternDrainEffect(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleExtraLanternDrainEffect");

	Params::HUDUserWidget_OnToggleExtraLanternDrainEffect Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleLowHPBarWarning
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsHPLow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleLowHPBarWarning(bool bIsHPLow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleLowHPBarWarning");

	Params::HUDUserWidget_OnToggleLowHPBarWarning Parms{};

	Parms.bIsHPLow = bIsHPLow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleLowLifeAuraWarning
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsBelowZero                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleLowLifeAuraWarning(bool bIsBelowZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleLowLifeAuraWarning");

	Params::HUDUserWidget_OnToggleLowLifeAuraWarning Parms{};

	Parms.bIsBelowZero = bIsBelowZero;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleResourceBarPosition
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bDownPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleResourceBarPosition(bool bDownPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleResourceBarPosition");

	Params::HUDUserWidget_OnToggleResourceBarPosition Parms{};

	Parms.bDownPosition = bDownPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnToggleSideEffectWarning
// (Event, Protected, BlueprintEvent)
// Parameters:
// EScreenSideEffect                       Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESideEffectWarningType                  SideEffectWarningType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnToggleSideEffectWarning(EScreenSideEffect Effect, bool bActive, ESideEffectWarningType SideEffectWarningType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnToggleSideEffectWarning");

	Params::HUDUserWidget_OnToggleSideEffectWarning Parms{};

	Parms.Effect = Effect;
	Parms.bActive = bActive;
	Parms.SideEffectWarningType = SideEffectWarningType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.OnUpdateItem
// (Final, Native, Private)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnUpdateItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnUpdateItem");

	Params::HUDUserWidget_OnUpdateItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.OnUpdateQuestNotificationObjective
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UManQuestObjective*>       Objectives                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDUserWidget::OnUpdateQuestNotificationObjective(class UManQuest* ManQuest, const TArray<class UManQuestObjective*>& Objectives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "OnUpdateQuestNotificationObjective");

	Params::HUDUserWidget_OnUpdateQuestNotificationObjective Parms{};

	Parms.ManQuest = ManQuest;
	Parms.Objectives = std::move(Objectives);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDUserWidget.PropertyChanged
// (Final, Native, Private)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDUserWidget::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "PropertyChanged");

	Params::HUDUserWidget_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDUserWidget.SetInteractAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityBase*                     InInteractAbilityBase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractParams                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractParams UHUDUserWidget::SetInteractAbility(class UAbilityBase* InInteractAbilityBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "SetInteractAbility");

	Params::HUDUserWidget_SetInteractAbility Parms{};

	Parms.InInteractAbilityBase = InInteractAbilityBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDUserWidget.CanInteractInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHUDUserWidget::CanInteractInCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDUserWidget", "CanInteractInCombat");

	Params::HUDUserWidget_CanInteractInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RakeAbility.OnStaggerOrStun
// (Final, Native, Private)

void URakeAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RakeAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestWindowUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestWindowUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestWindowUserWidget", "OnFocusWidgetChangedEvent");

	Params::QuestWindowUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestWindowUserWidget.OnRebuildQuestList
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InVisibleActiveQuestNum                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InVisibleBountyQuestNum                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InVisibleCompletedQuestNum                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestWindowUserWidget::OnRebuildQuestList(int32 InVisibleActiveQuestNum, int32 InVisibleBountyQuestNum, int32 InVisibleCompletedQuestNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestWindowUserWidget", "OnRebuildQuestList");

	Params::QuestWindowUserWidget_OnRebuildQuestList Parms{};

	Parms.InVisibleActiveQuestNum = InVisibleActiveQuestNum;
	Parms.InVisibleBountyQuestNum = InVisibleBountyQuestNum;
	Parms.InVisibleCompletedQuestNum = InVisibleCompletedQuestNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestWindowUserWidget.OnSetSelectedQuest
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UManQuest*                        ManQuest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             StoryText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestWindowUserWidget::OnSetSelectedQuest(class UManQuest* ManQuest, const class FText& StoryText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestWindowUserWidget", "OnSetSelectedQuest");

	Params::QuestWindowUserWidget_OnSetSelectedQuest Parms{};

	Parms.ManQuest = ManQuest;
	Parms.StoryText = std::move(StoryText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestWindowUserWidget.TrackFocusedQuest
// (Final, Native, Public, BlueprintCallable)

void UQuestWindowUserWidget::TrackFocusedQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestWindowUserWidget", "TrackFocusedQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestWindowUserWidget.UnTrackFocusedQuest
// (Final, Native, Public, BlueprintCallable)

void UQuestWindowUserWidget::UnTrackFocusedQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestWindowUserWidget", "UnTrackFocusedQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.EscapeJumpAbility.OnPostDamageTaken
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEscapeJumpAbility::OnPostDamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeJumpAbility", "OnPostDamageTaken");

	Params::EscapeJumpAbility_OnPostDamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GlideAbility.OnGlideEndRecoveryEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     RecoveryAbility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlideAbility::OnGlideEndRecoveryEnded(class UAbilityBase* RecoveryAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlideAbility", "OnGlideEndRecoveryEnded");

	Params::GlideAbility_OnGlideEndRecoveryEnded Parms{};

	Parms.RecoveryAbility = RecoveryAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GlideAbility.OnLanded
// (Final, Native, Public)

void UGlideAbility::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlideAbility", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.KillingMachinePassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKillingMachinePassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillingMachinePassive", "DamageDealt");

	Params::KillingMachinePassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.StaminaDrain.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaDrain::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaDrain", "IsCollideSignature");

	Params::StaminaDrain_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.GlossarySlotUserWidget.OnSetSeparatorVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlossarySlotUserWidget::OnSetSeparatorVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossarySlotUserWidget", "OnSetSeparatorVisible");

	Params::GlossarySlotUserWidget_OnSetSeparatorVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossarySlotUserWidget.OnSetSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGlossarySlotUserWidget::OnSetSlot(const class FText& InName, const class FText& InDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossarySlotUserWidget", "OnSetSlot");

	Params::GlossarySlotUserWidget_OnSetSlot Parms{};

	Parms.InName = std::move(InName);
	Parms.InDescription = std::move(InDescription);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossaryUserWidget.JumpToNextPage
// (Final, Native, Public, BlueprintCallable)

void UGlossaryUserWidget::JumpToNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "JumpToNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GlossaryUserWidget.JumpToPreviousPage
// (Final, Native, Public, BlueprintCallable)

void UGlossaryUserWidget::JumpToPreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "JumpToPreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GlossaryUserWidget.OnMapShowing
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInMapShowing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlossaryUserWidget::OnMapShowing(bool bInMapShowing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "OnMapShowing");

	Params::GlossaryUserWidget_OnMapShowing Parms{};

	Parms.bInMapShowing = bInMapShowing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossaryUserWidget.OnPageReady
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InPageNumberLeft                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPageNumberRight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInRightPageEmpty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlossaryUserWidget::OnPageReady(int32 InPageNumberLeft, int32 InPageNumberRight, bool bInRightPageEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "OnPageReady");

	Params::GlossaryUserWidget_OnPageReady Parms{};

	Parms.InPageNumberLeft = InPageNumberLeft;
	Parms.InPageNumberRight = InPageNumberRight;
	Parms.bInRightPageEmpty = bInRightPageEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossaryUserWidget.OnSetNextBtnState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlossaryUserWidget::OnSetNextBtnState(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "OnSetNextBtnState");

	Params::GlossaryUserWidget_OnSetNextBtnState Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossaryUserWidget.OnSetPrevBtnState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlossaryUserWidget::OnSetPrevBtnState(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "OnSetPrevBtnState");

	Params::GlossaryUserWidget_OnSetPrevBtnState Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.GlossaryUserWidget.ShowInventoryWindow
// (Final, Native, Private, BlueprintCallable)

void UGlossaryUserWidget::ShowInventoryWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlossaryUserWidget", "ShowInventoryWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.GrapplingHook.DamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            DamageParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGrapplingHook::DamageTaken(const struct FPreDamagedEventParam& DamageParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrapplingHook", "DamageTaken");

	Params::GrapplingHook_DamageTaken Parms{};

	Parms.DamageParams = std::move(DamageParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GrapplingHook.OnCollision
// (Final, Native, Private)
// Parameters:
// TArray<struct FHitResult>               HitResult                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGrapplingHook::OnCollision(const TArray<struct FHitResult>& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrapplingHook", "OnCollision");

	Params::GrapplingHook_OnCollision Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ResonanceAbility.GetCurrentCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UResonanceAbility::GetCurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResonanceAbility", "GetCurrentCharge");

	Params::ResonanceAbility_GetCurrentCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ResonanceAbility.GetMaxCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UResonanceAbility::GetMaxCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResonanceAbility", "GetMaxCharge");

	Params::ResonanceAbility_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ResonanceAbility.ResourceUsed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UResonanceAbility::ResourceUsed(EEntityProperty resource, float* amount, class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ResonanceAbility", "ResourceUsed");

	Params::ResonanceAbility_ResourceUsed Parms{};

	Parms.resource = resource;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (amount != nullptr)
		*amount = Parms.amount;
}


// Function man.RebirthAbility.OnPreGoToLevel
// (Final, Native, Private)
// Parameters:
// class FString                           StrLevelName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebirthAbility::OnPreGoToLevel(const class FString& StrLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebirthAbility", "OnPreGoToLevel");

	Params::RebirthAbility_OnPreGoToLevel Parms{};

	Parms.StrLevelName = std::move(StrLevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GremlinShield.OnPreDamagedPriority
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UGremlinShield::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GremlinShield", "OnPreDamagedPriority");

	Params::GremlinShield_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.VampireBeastSwoopAbility.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVampireBeastSwoopAbility::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireBeastSwoopAbility", "BPGetTargetLocation");

	Params::VampireBeastSwoopAbility_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMove.IsRunSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroundMove::IsRunSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMove", "IsRunSpeed");

	Params::GroundMove_IsRunSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMove.OnTeleportPost
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundMove::OnTeleportPost(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMove", "OnTeleportPost");

	Params::GroundMove_OnTeleportPost Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GroundMove.OnTeleportPre
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundMove::OnTeleportPre(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMove", "OnTeleportPre");

	Params::GroundMove_OnTeleportPre Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SetChangeAbility.OnRecoveryEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     RecoveryAbility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USetChangeAbility::OnRecoveryEnded(class UAbilityBase* RecoveryAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetChangeAbility", "OnRecoveryEnded");

	Params::SetChangeAbility_OnRecoveryEnded Parms{};

	Parms.RecoveryAbility = RecoveryAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GroundMovingAbilityActor.GetCurrentScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGroundMovingAbilityActor::GetCurrentScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "GetCurrentScale");

	Params::GroundMovingAbilityActor_GetCurrentScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMovingAbilityActor.GetCurrentVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGroundMovingAbilityActor::GetCurrentVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "GetCurrentVelocity");

	Params::GroundMovingAbilityActor_GetCurrentVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMovingAbilityActor.GetElapsedTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGroundMovingAbilityActor::GetElapsedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "GetElapsedTime");

	Params::GroundMovingAbilityActor_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMovingAbilityActor.GetFloorNormal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGroundMovingAbilityActor::GetFloorNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "GetFloorNormal");

	Params::GroundMovingAbilityActor_GetFloorNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMovingAbilityActor.GetMaxVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOriginal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGroundMovingAbilityActor::GetMaxVelocity(bool bOriginal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "GetMaxVelocity");

	Params::GroundMovingAbilityActor_GetMaxVelocity Parms{};

	Parms.bOriginal = bOriginal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.GroundMovingAbilityActor.IsCollideSignature
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGroundMovingAbilityActor::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "IsCollideSignature");

	Params::GroundMovingAbilityActor_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.GroundMovingAbilityActor.SetMaxVelocity
// (Final, Native, Public)
// Parameters:
// float                                   newMaxSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGroundMovingAbilityActor::SetMaxVelocity(float newMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "SetMaxVelocity");

	Params::GroundMovingAbilityActor_SetMaxVelocity Parms{};

	Parms.newMaxSpeed = newMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.GroundMovingAbilityActor.VFXEnd
// (Event, Public, BlueprintEvent)

void AGroundMovingAbilityActor::VFXEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundMovingAbilityActor", "VFXEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HealOnCritAbility.OnPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHealOnCritAbility::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealOnCritAbility", "OnPostDamageCaused");

	Params::HealOnCritAbility_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeavyAttackAbility.DealDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHeavyAttackAbility::DealDamage(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyAttackAbility", "DealDamage");

	Params::HeavyAttackAbility_DealDamage Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HeavyAttackAbility.GetChargePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHeavyAttackAbility::GetChargePercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyAttackAbility", "GetChargePercent");

	Params::HeavyAttackAbility_GetChargePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeavyAttackAbility.OnStaggerOrStun
// (Final, Native, Public)

void UHeavyAttackAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyAttackAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HemorrhagePassive.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UHemorrhagePassive::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HemorrhagePassive", "PreDamageDealt");

	Params::HemorrhagePassive_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.HeroAbilitiesData.ActivateAbilityUpgrade
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::ActivateAbilityUpgrade(class UAbilityBase* Ability, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "ActivateAbilityUpgrade");

	Params::HeroAbilitiesData_ActivateAbilityUpgrade Parms{};

	Parms.Ability = Ability;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.CheckForSlotUnlocksByLevel
// (Final, Native, Public)

void UHeroAbilitiesData::CheckForSlotUnlocksByLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "CheckForSlotUnlocksByLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroAbilitiesData.GetAbilityClassByIndex
// (Final, Native, Public)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubSlotIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAbilityBase> UHeroAbilitiesData::GetAbilityClassByIndex(int32 SlotIndex, int32 SubSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetAbilityClassByIndex");

	Params::HeroAbilitiesData_GetAbilityClassByIndex Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SubSlotIndex = SubSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetAbilitySlotByIndex
// (Final, Native, Public)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHeroAbilitySlot                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FHeroAbilitySlot UHeroAbilitiesData::GetAbilitySlotByIndex(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetAbilitySlotByIndex");

	Params::HeroAbilitiesData_GetAbilitySlotByIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetAbilitySlotIndexByAbility
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyActiveSubslot                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAbilitySlotIndexPair>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAbilitySlotIndexPair> UHeroAbilitiesData::GetAbilitySlotIndexByAbility(TSubclassOf<class UAbilityBase> AbilityType, bool bOnlyActiveSubslot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetAbilitySlotIndexByAbility");

	Params::HeroAbilitiesData_GetAbilitySlotIndexByAbility Parms{};

	Parms.AbilityType = AbilityType;
	Parms.bOnlyActiveSubslot = bOnlyActiveSubslot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetAbilitySlotIndexByAbilitySlot
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHeroAbilitySlot                 HeroAbilitySlot                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHeroAbilitiesData::GetAbilitySlotIndexByAbilitySlot(struct FHeroAbilitySlot* HeroAbilitySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetAbilitySlotIndexByAbilitySlot");

	Params::HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HeroAbilitySlot != nullptr)
		*HeroAbilitySlot = std::move(Parms.HeroAbilitySlot);

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetAllHeroAbilities
// (Final, Native, Public)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSubclassOf<class UAbilityBase>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSubclassOf<class UAbilityBase>> UHeroAbilitiesData::GetAllHeroAbilities(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetAllHeroAbilities");

	Params::HeroAbilitiesData_GetAllHeroAbilities Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetHeroCharacter
// (Final, Native, Public)
// Parameters:
// class AHeroBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHeroBase* UHeroAbilitiesData::GetHeroCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetHeroCharacter");

	Params::HeroAbilitiesData_GetHeroCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetLatestPlayerAttackAbility
// (Final, Native, Public)
// Parameters:
// bool                                    CheckInstigatedAbilities                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UHeroAbilitiesData::GetLatestPlayerAttackAbility(bool CheckInstigatedAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetLatestPlayerAttackAbility");

	Params::HeroAbilitiesData_GetLatestPlayerAttackAbility Parms{};

	Parms.CheckInstigatedAbilities = CheckInstigatedAbilities;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetRunningPlayerActiveAbilities
// (Final, Native, Public)
// Parameters:
// bool                                    CheckInstigatedAbilities                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAbilityBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAbilityBase*> UHeroAbilitiesData::GetRunningPlayerActiveAbilities(bool CheckInstigatedAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetRunningPlayerActiveAbilities");

	Params::HeroAbilitiesData_GetRunningPlayerActiveAbilities Parms{};

	Parms.CheckInstigatedAbilities = CheckInstigatedAbilities;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetUnlockedAbilityTypeByName
// (Final, Native, Public)
// Parameters:
// class FName                             InAbilityName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAbilityBase> UHeroAbilitiesData::GetUnlockedAbilityTypeByName(class FName InAbilityName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetUnlockedAbilityTypeByName");

	Params::HeroAbilitiesData_GetUnlockedAbilityTypeByName Parms{};

	Parms.InAbilityName = InAbilityName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetUnlockedHeroAbilities
// (Final, Native, Public)
// Parameters:
// TArray<struct FUnlockedAbilityData>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FUnlockedAbilityData> UHeroAbilitiesData::GetUnlockedHeroAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetUnlockedHeroAbilities");

	Params::HeroAbilitiesData_GetUnlockedHeroAbilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.GetUnlockedUpgrades
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UHeroAbilitiesData::GetUnlockedUpgrades(TSubclassOf<class UAbilityBase> AbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "GetUnlockedUpgrades");

	Params::HeroAbilitiesData_GetUnlockedUpgrades Parms{};

	Parms.AbilityType = AbilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsAbilitySlotable
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubSlotIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EAbilitySlotQuery>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EAbilitySlotQuery> UHeroAbilitiesData::IsAbilitySlotable(TSubclassOf<class UAbilityBase> AbilityType, int32 SlotIndex, int32 SubSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsAbilitySlotable");

	Params::HeroAbilitiesData_IsAbilitySlotable Parms{};

	Parms.AbilityType = AbilityType;
	Parms.SlotIndex = SlotIndex;
	Parms.SubSlotIndex = SubSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsAbilityUnlockable
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::IsAbilityUnlockable(TSubclassOf<class UAbilityBase> AbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsAbilityUnlockable");

	Params::HeroAbilitiesData_IsAbilityUnlockable Parms{};

	Parms.AbilityType = AbilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsAbilityUnlocked
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::IsAbilityUnlocked(TSubclassOf<class UAbilityBase> AbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsAbilityUnlocked");

	Params::HeroAbilitiesData_IsAbilityUnlocked Parms{};

	Parms.AbilityType = AbilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsAbilityUpgradeUnlockable
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::IsAbilityUpgradeUnlockable(TSubclassOf<class UAbilityBase> AbilityType, class FName UpgradeID, bool bIgnoreCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsAbilityUpgradeUnlockable");

	Params::HeroAbilitiesData_IsAbilityUpgradeUnlockable Parms{};

	Parms.AbilityType = AbilityType;
	Parms.UpgradeID = UpgradeID;
	Parms.bIgnoreCost = bIgnoreCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsAbilityUpgradeUnlocked
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::IsAbilityUpgradeUnlocked(TSubclassOf<class UAbilityBase> AbilityType, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsAbilityUpgradeUnlocked");

	Params::HeroAbilitiesData_IsAbilityUpgradeUnlocked Parms{};

	Parms.AbilityType = AbilityType;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.IsInActiveSublot
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::IsInActiveSublot(TSubclassOf<class UAbilityBase> AbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "IsInActiveSublot");

	Params::HeroAbilitiesData_IsInActiveSublot Parms{};

	Parms.AbilityType = AbilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.RotateActiveSubSlots
// (Final, Native, Public)
// Parameters:
// bool                                    bForward                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::RotateActiveSubSlots(bool bForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "RotateActiveSubSlots");

	Params::HeroAbilitiesData_RotateActiveSubSlots Parms{};

	Parms.bForward = bForward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.SetAbilityToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SubSlotIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUICall                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::SetAbilityToSlot(TSubclassOf<class UAbilityBase> AbilityType, int32 SlotIndex, int32 SubSlotIndex, bool bForce, bool bUICall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "SetAbilityToSlot");

	Params::HeroAbilitiesData_SetAbilityToSlot Parms{};

	Parms.AbilityType = AbilityType;
	Parms.SlotIndex = SlotIndex;
	Parms.SubSlotIndex = SubSlotIndex;
	Parms.bForce = bForce;
	Parms.bUICall = bUICall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.UnlockAbility
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::UnlockAbility(TSubclassOf<class UAbilityBase> AbilityType, bool bNewAbility, bool bCheat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "UnlockAbility");

	Params::HeroAbilitiesData_UnlockAbility Parms{};

	Parms.AbilityType = AbilityType;
	Parms.bNewAbility = bNewAbility;
	Parms.bCheat = bCheat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.UnlockAbilityUpgrade
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeroAbilitiesData::UnlockAbilityUpgrade(TSubclassOf<class UAbilityBase> AbilityType, class FName UpgradeID, bool bIgnoreCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "UnlockAbilityUpgrade");

	Params::HeroAbilitiesData_UnlockAbilityUpgrade Parms{};

	Parms.AbilityType = AbilityType;
	Parms.UpgradeID = UpgradeID;
	Parms.bIgnoreCost = bIgnoreCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HeroAbilitiesData.UnlockAllAbilities
// (Final, Native, Public, BlueprintCallable)

void UHeroAbilitiesData::UnlockAllAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "UnlockAllAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HeroAbilitiesData.UnlockAllAbilityUpgrades
// (Final, Native, Public, BlueprintCallable)

void UHeroAbilitiesData::UnlockAllAbilityUpgrades()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroAbilitiesData", "UnlockAllAbilityUpgrades");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.KingPriestVoidSelfProjection.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidSelfProjection::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidSelfProjection", "BPGetTeleportLocation");

	Params::KingPriestVoidSelfProjection_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TentacleAI.TentacleOnAnimToggled
// (Final, Native, Public)
// Parameters:
// class UAnimID*                          Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTentacleAI::TentacleOnAnimToggled(class UAnimID* Anim, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TentacleAI", "TentacleOnAnimToggled");

	Params::TentacleAI_TentacleOnAnimToggled Parms{};

	Parms.Anim = Anim;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.DoItemListCustomNavigation_Down
// (Final, Native, Public)

void UItemsCanvasPanel::DoItemListCustomNavigation_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "DoItemListCustomNavigation_Down");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.DoItemListCustomNavigation_Left
// (Final, Native, Public)

void UItemsCanvasPanel::DoItemListCustomNavigation_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "DoItemListCustomNavigation_Left");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.DoItemListCustomNavigation_Right
// (Final, Native, Public)

void UItemsCanvasPanel::DoItemListCustomNavigation_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "DoItemListCustomNavigation_Right");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.DoItemListCustomNavigation_Up
// (Final, Native, Public)

void UItemsCanvasPanel::DoItemListCustomNavigation_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "DoItemListCustomNavigation_Up");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsCanvasPanel::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "OnFocusWidgetChangedEvent");

	Params::ItemsCanvasPanel_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsCanvasPanel.OnUserScrolled
// (Final, Native, Public)
// Parameters:
// float                                   CurrentOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsCanvasPanel::OnUserScrolled(float CurrentOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsCanvasPanel", "OnUserScrolled");

	Params::ItemsCanvasPanel_OnUserScrolled Parms{};

	Parms.CurrentOffset = CurrentOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HitBox.BPGetScaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UHitBox::BPGetScaledBoxExtent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitBox", "BPGetScaledBoxExtent");

	Params::HitBox_BPGetScaledBoxExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HitBox.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHitBox::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitBox", "OnBeginOverlap");

	Params::HitBox_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HitBox.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitBox::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitBox", "OnEndOverlap");

	Params::HitBox_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemTooltipFunctionLibrary.GetAbilityDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ColoredValueTag                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterBase*                   InCharacterBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetAbilityDescription(class UObject* WorldContextObject, TSubclassOf<class UAbilityBase> AbilityClass, const class FString& ColoredValueTag, class ACharacterBase* InCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetAbilityDescription");

	Params::ItemTooltipFunctionLibrary_GetAbilityDescription Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AbilityClass = AbilityClass;
	Parms.ColoredValueTag = std::move(ColoredValueTag);
	Parms.InCharacterBase = InCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetColonText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPrefix                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetColonText(const class FString& InPrefix, const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetColonText");

	Params::ItemTooltipFunctionLibrary_GetColonText Parms{};

	Parms.InPrefix = std::move(InPrefix);
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetCooldownText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LeftTimeInSecfloat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowZeroNumber                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetCooldownText(class UObject* WorldContextObject, float LeftTimeInSecfloat, bool bShowZeroNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetCooldownText");

	Params::ItemTooltipFunctionLibrary_GetCooldownText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LeftTimeInSecfloat = LeftTimeInSecfloat;
	Parms.bShowZeroNumber = bShowZeroNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetFormattedDescriptionText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     AbilityBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ACharacterBase*                   InCharacterBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetFormattedDescriptionText(class UObject* WorldContextObject, class UAbilityBase* AbilityBase, const class FText& Description, class ACharacterBase* InCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetFormattedDescriptionText");

	Params::ItemTooltipFunctionLibrary_GetFormattedDescriptionText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AbilityBase = AbilityBase;
	Parms.Description = std::move(Description);
	Parms.InCharacterBase = InCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemAttributeText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UItemTooltipFunctionLibrary::GetItemAttributeText(class UObject* WorldContextObject, class UItemAbility* Item, class UItemAbility* ComparedItem, class UItemAbility* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemAttributeText");

	Params::ItemTooltipFunctionLibrary_GetItemAttributeText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemCategoryByItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCustomItemCategory                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoldItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemCategory                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemCategory UItemTooltipFunctionLibrary::GetItemCategoryByItem(class UItemAbility* Item, bool bCustomItemCategory, bool bSoldItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemCategoryByItem");

	Params::ItemTooltipFunctionLibrary_GetItemCategoryByItem Parms{};

	Parms.Item = Item;
	Parms.bCustomItemCategory = bCustomItemCategory;
	Parms.bSoldItem = bSoldItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemDescriptionText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetItemDescriptionText(class UObject* WorldContextObject, class UItemAbility* Item, class UItemAbility* ComparedItem, class UItemAbility* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemDescriptionText");

	Params::ItemTooltipFunctionLibrary_GetItemDescriptionText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemFlavorText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetItemFlavorText(class UObject* WorldContextObject, class UItemAbility* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemFlavorText");

	Params::ItemTooltipFunctionLibrary_GetItemFlavorText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemLargeValueText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UItemTooltipFunctionLibrary::GetItemLargeValueText(class UObject* WorldContextObject, class UItemAbility* Item, class UItemAbility* ComparedItem, class UItemAbility* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemLargeValueText");

	Params::ItemTooltipFunctionLibrary_GetItemLargeValueText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemParamsText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UItemTooltipFunctionLibrary::GetItemParamsText(class UObject* WorldContextObject, class UItemAbility* Item, class UItemAbility* ComparedItem, class UItemAbility* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemParamsText");

	Params::ItemTooltipFunctionLibrary_GetItemParamsText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemRequirementText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetItemRequirementText(class UObject* WorldContextObject, class UManItemSlotBase* ManItemSlotBase, class UItemAbility* ItemAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemRequirementText");

	Params::ItemTooltipFunctionLibrary_GetItemRequirementText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ManItemSlotBase = ManItemSlotBase;
	Parms.ItemAbility = ItemAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemScalingText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UItemTooltipFunctionLibrary::GetItemScalingText(class UObject* WorldContextObject, class UItemAbility* Item, class UItemAbility* ComparedItem, class UItemAbility* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemScalingText");

	Params::ItemTooltipFunctionLibrary_GetItemScalingText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemTooltipFunctionLibrary.GetItemTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemCategory                    ItemCategory                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UItemTooltipFunctionLibrary::GetItemTypeText(class UObject* WorldContextObject, const struct FItemCategory& ItemCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemTooltipFunctionLibrary", "GetItemTypeText");

	Params::ItemTooltipFunctionLibrary_GetItemTypeText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ItemCategory = std::move(ItemCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PressureShiftingPlatform.GameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPressureShiftingPlatform::GameplayEvent(class UAbilityController* AbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PressureShiftingPlatform", "GameplayEvent");

	Params::PressureShiftingPlatform_GameplayEvent Parms{};

	Parms.AbilityController = AbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HitReactionPassive.OnPoiseValueChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttributeChangeDataInstance     preValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UHitReactionPassive::OnPoiseValueChanged(EAttribute attribute, struct FAttributeChangeDataInstance* preValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionPassive", "OnPoiseValueChanged");

	Params::HitReactionPassive_OnPoiseValueChanged Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (preValue != nullptr)
		*preValue = std::move(Parms.preValue);
}


// Function man.LandFromHangingAbility.BPEventTargetMarked
// (Event, Public, BlueprintEvent)

void ULandFromHangingAbility::BPEventTargetMarked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandFromHangingAbility", "BPEventTargetMarked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.LandFromHangingAbility.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandFromHangingAbility::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandFromHangingAbility", "BPGetTargetLocation");

	Params::LandFromHangingAbility_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SomeRestForTheWickedPassive.ComboPointsChanged
// (Final, Native, Public)
// Parameters:
// int32                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     SourceAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USomeRestForTheWickedPassive::ComboPointsChanged(int32 Delta, class UAbilityBase* SourceAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SomeRestForTheWickedPassive", "ComboPointsChanged");

	Params::SomeRestForTheWickedPassive_ComboPointsChanged Parms{};

	Parms.Delta = Delta;
	Parms.SourceAbility = SourceAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HotkeyRichTextBlock.OnInputDisplayChanged
// (Final, Native, Protected)
// Parameters:
// EInputDisplay                           InInputDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           InControlDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHotkeyRichTextBlock::OnInputDisplayChanged(EInputDisplay InInputDisplay, EInputDisplay InControlDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HotkeyRichTextBlock", "OnInputDisplayChanged");

	Params::HotkeyRichTextBlock_OnInputDisplayChanged Parms{};

	Parms.InInputDisplay = InInputDisplay;
	Parms.InControlDisplay = InControlDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HoundMasterAI.HoundReleaseEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHoundMasterAI::HoundReleaseEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoundMasterAI", "HoundReleaseEvent");

	Params::HoundMasterAI_HoundReleaseEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDAbilitySlotUserWidget.IsResonanceAbility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHUDAbilitySlotUserWidget::IsResonanceAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "IsResonanceAbility");

	Params::HUDAbilitySlotUserWidget_IsResonanceAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.HUDAbilitySlotUserWidget.OnAbilityPressed
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSingleUsed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnAbilityPressed(bool bInSingleUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnAbilityPressed");

	Params::HUDAbilitySlotUserWidget_OnAbilityPressed Parms{};

	Parms.bInSingleUsed = bInSingleUsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnAbilityReleased
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSingleUsed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnAbilityReleased(bool bInSingleUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnAbilityReleased");

	Params::HUDAbilitySlotUserWidget_OnAbilityReleased Parms{};

	Parms.bInSingleUsed = bInSingleUsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnRefreshAbilityStates
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInUsable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnRefreshAbilityStates(bool bInUsable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnRefreshAbilityStates");

	Params::HUDAbilitySlotUserWidget_OnRefreshAbilityStates Parms{};

	Parms.bInUsable = bInUsable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAbilityBase*                     AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Cooldown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxCooldown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponType                             RelicType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbility(class UAbilityBase* AbilityType, float Cooldown, float MaxCooldown, EWeaponType RelicType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbility");

	Params::HUDAbilitySlotUserWidget_OnSetAbility Parms{};

	Parms.AbilityType = AbilityType;
	Parms.Cooldown = Cooldown;
	Parms.MaxCooldown = MaxCooldown;
	Parms.RelicType = RelicType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityChargePercentage
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   ChargePercentage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityChargePercentage(float ChargePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityChargePercentage");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage Parms{};

	Parms.ChargePercentage = ChargePercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityCooldown
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CooldownRemain                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityCooldown(float CooldownRemain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityCooldown");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityCooldown Parms{};

	Parms.CooldownRemain = CooldownRemain;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityCost
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             EnergyCost                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             RageCost                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ComboPointCost                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             StaminaCost                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityCost(const class FText& EnergyCost, const class FText& RageCost, const class FText& ComboPointCost, const class FText& StaminaCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityCost");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityCost Parms{};

	Parms.EnergyCost = std::move(EnergyCost);
	Parms.RageCost = std::move(RageCost);
	Parms.ComboPointCost = std::move(ComboPointCost);
	Parms.StaminaCost = std::move(StaminaCost);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityDuration
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityDuration");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityDuration Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityExecuting
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInExecuting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityExecuting(bool bInExecuting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityExecuting");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityExecuting Parms{};

	Parms.bInExecuting = bInExecuting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityExtraEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInExtraEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityExtraEffect(bool bInExtraEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityExtraEffect");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect Parms{};

	Parms.bInExtraEffect = bInExtraEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityReactivation
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bReactivation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityReactivation(bool bReactivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityReactivation");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityReactivation Parms{};

	Parms.bReactivation = bReactivation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetAbilityUsable
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUsable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetAbilityUsable(bool bUsable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetAbilityUsable");

	Params::HUDAbilitySlotUserWidget_OnSetAbilityUsable Parms{};

	Parms.bUsable = bUsable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetHitStackNum
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   ChargePercentage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetHitStackNum(int32 ChargePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetHitStackNum");

	Params::HUDAbilitySlotUserWidget_OnSetHitStackNum Parms{};

	Parms.ChargePercentage = ChargePercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetRelicChargePercentage
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   RelicChargePercentage                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetRelicChargePercentage(float RelicChargePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetRelicChargePercentage");

	Params::HUDAbilitySlotUserWidget_OnSetRelicChargePercentage Parms{};

	Parms.RelicChargePercentage = RelicChargePercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnSetSetChargeCounter
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InRemainingChargesNum                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnSetSetChargeCounter(int32 InRemainingChargesNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnSetSetChargeCounter");

	Params::HUDAbilitySlotUserWidget_OnSetSetChargeCounter Parms{};

	Parms.InRemainingChargesNum = InRemainingChargesNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDAbilitySlotUserWidget.OnShowFullChargeAnim
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInShowFullChargeAnim                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDAbilitySlotUserWidget::OnShowFullChargeAnim(bool bInShowFullChargeAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAbilitySlotUserWidget", "OnShowFullChargeAnim");

	Params::HUDAbilitySlotUserWidget_OnShowFullChargeAnim Parms{};

	Parms.bInShowFullChargeAnim = bInShowFullChargeAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDKeyItemSlotUserWidget.OnPlayHighlight
// (Event, Public, BlueprintEvent)

void UHUDKeyItemSlotUserWidget::OnPlayHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDKeyItemSlotUserWidget", "OnPlayHighlight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.HUDPopupUserWidget.OnSetData
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FHUDPopupQueue                   InHUDPopupQueue                                        (Parm, NativeAccessSpecifierPublic)

void UHUDPopupUserWidget::OnSetData(const struct FHUDPopupQueue& InHUDPopupQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDPopupUserWidget", "OnSetData");

	Params::HUDPopupUserWidget_OnSetData Parms{};

	Parms.InHUDPopupQueue = std::move(InHUDPopupQueue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDPopupUserWidget.ShowActiveTrackedQuestNotification
// (Final, Native, Protected, BlueprintCallable)

void UHUDPopupUserWidget::ShowActiveTrackedQuestNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDPopupUserWidget", "ShowActiveTrackedQuestNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.HUDQuickUseUserWidget.OnQuickUseChange
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EQuickUseCommand                        InQuickUseCommand                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   InActiveQuickUse                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UInventorySlot*>           InNextQuickUseArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UInventorySlot*>           InPrevQuickUseArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UInventorySlot*                   InUsedItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDQuickUseUserWidget::OnQuickUseChange(EQuickUseCommand InQuickUseCommand, class UInventorySlot* InActiveQuickUse, const TArray<class UInventorySlot*>& InNextQuickUseArray, const TArray<class UInventorySlot*>& InPrevQuickUseArray, class UInventorySlot* InUsedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDQuickUseUserWidget", "OnQuickUseChange");

	Params::HUDQuickUseUserWidget_OnQuickUseChange Parms{};

	Parms.InQuickUseCommand = InQuickUseCommand;
	Parms.InActiveQuickUse = InActiveQuickUse;
	Parms.InNextQuickUseArray = std::move(InNextQuickUseArray);
	Parms.InPrevQuickUseArray = std::move(InPrevQuickUseArray);
	Parms.InUsedItem = InUsedItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.HUDQuickUseUserWidget.OnUseQuickUseItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInventorySlot*                   QuickUseItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDQuickUseUserWidget::OnUseQuickUseItem(class UInventorySlot* QuickUseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDQuickUseUserWidget", "OnUseQuickUseItem");

	Params::HUDQuickUseUserWidget_OnUseQuickUseItem Parms{};

	Parms.QuickUseItem = QuickUseItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.KezkaResurrectScene.ContinueGameplay
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       OlenTransform                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKezkaResurrectScene::ContinueGameplay(const struct FTransform& OlenTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KezkaResurrectScene", "ContinueGameplay");

	Params::KezkaResurrectScene_ContinueGameplay Parms{};

	Parms.OlenTransform = std::move(OlenTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.KezkaResurrectScene.OnAnimEventBase_Target
// (Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UKezkaResurrectScene::OnAnimEventBase_Target(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KezkaResurrectScene", "OnAnimEventBase_Target");

	Params::KezkaResurrectScene_OnAnimEventBase_Target Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.KezkaResurrectScene.OnDeath
// (Final, Native, Public)

void UKezkaResurrectScene::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KezkaResurrectScene", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractTextUserWidget.BPShow
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInteractTextUserWidget::BPShow(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractTextUserWidget", "BPShow");

	Params::InteractTextUserWidget_BPShow Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InteractTextUserWidget.OnShow
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bDoubleInteractBtn                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractTextUserWidget::OnShow(bool bDoubleInteractBtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractTextUserWidget", "OnShow");

	Params::InteractTextUserWidget_OnShow Parms{};

	Parms.bDoubleInteractBtn = bDoubleInteractBtn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.InventoryWindowUserWidget.BPSetFilter
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UVendorFilterSlotUserWidget*      VendorFilterSlotUserWidget                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWindowUserWidget::BPSetFilter(class UVendorFilterSlotUserWidget* VendorFilterSlotUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWindowUserWidget", "BPSetFilter");

	Params::InventoryWindowUserWidget_BPSetFilter Parms{};

	Parms.VendorFilterSlotUserWidget = VendorFilterSlotUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.InventoryWindowUserWidget.EquipItemRequest
// (Final, Native, Protected, BlueprintCallable)

void UInventoryWindowUserWidget::EquipItemRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWindowUserWidget", "EquipItemRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InventoryWindowUserWidget.JumpToNextFilter
// (Final, Native, Protected, BlueprintCallable)

void UInventoryWindowUserWidget::JumpToNextFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWindowUserWidget", "JumpToNextFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.InventoryWindowUserWidget.JumpToPrevFilter
// (Final, Native, Protected, BlueprintCallable)

void UInventoryWindowUserWidget::JumpToPrevFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWindowUserWidget", "JumpToPrevFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemCategoryUserWidget.OnSetText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             CategoryText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemCategoryUserWidget::OnSetText(const class FText& CategoryText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCategoryUserWidget", "OnSetText");

	Params::ItemCategoryUserWidget_OnSetText Parms{};

	Parms.CategoryText = std::move(CategoryText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ItemsHandlerUserWidget.GetItemAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemAbility* UItemsHandlerUserWidget::GetItemAbility(class UManItemSlotBase* ManItemSlotBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "GetItemAbility");

	Params::ItemsHandlerUserWidget_GetItemAbility Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemsHandlerUserWidget.OnAddItem
// (Final, Native, Protected)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnAddItem(class UInventorySlot* InventorySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnAddItem");

	Params::ItemsHandlerUserWidget_OnAddItem Parms{};

	Parms.InventorySlot = InventorySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnApplyEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnApplyEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnApplyEnchant");

	Params::ItemsHandlerUserWidget_OnApplyEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnHideWindow
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnHideWindow(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnHideWindow");

	Params::ItemsHandlerUserWidget_OnHideWindow Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnInventorySlotFocused
// (Final, Native, Public)
// Parameters:
// class UInventorySlotUserWidget*         InventorySlotUserWidget                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnInventorySlotFocused(class UInventorySlotUserWidget* InventorySlotUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnInventorySlotFocused");

	Params::ItemsHandlerUserWidget_OnInventorySlotFocused Parms{};

	Parms.InventorySlotUserWidget = InventorySlotUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnItemSlotChanged
// (Final, Native, Protected)
// Parameters:
// class UInventorySlot*                   SourceSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventorySlot*                   DestinationSlot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnItemSlotChanged(class UInventorySlot* SourceSlot, class UInventorySlot* DestinationSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnItemSlotChanged");

	Params::ItemsHandlerUserWidget_OnItemSlotChanged Parms{};

	Parms.SourceSlot = SourceSlot;
	Parms.DestinationSlot = DestinationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnRemoveEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnRemoveEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnRemoveEnchant");

	Params::ItemsHandlerUserWidget_OnRemoveEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnRemoveItem
// (Final, Native, Protected)
// Parameters:
// class UInventorySlot*                   InventorySlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RemovedItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnRemoveItem(class UInventorySlot* InventorySlot, class UItemAbility* RemovedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnRemoveItem");

	Params::ItemsHandlerUserWidget_OnRemoveItem Parms{};

	Parms.InventorySlot = InventorySlot;
	Parms.RemovedItem = RemovedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnShowWindow
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnShowWindow(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnShowWindow");

	Params::ItemsHandlerUserWidget_OnShowWindow Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ItemsHandlerUserWidget.OnSortChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             SortName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::OnSortChanged(const class FText& SortName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "OnSortChanged");

	Params::ItemsHandlerUserWidget_OnSortChanged Parms{};

	Parms.SortName = std::move(SortName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ItemsHandlerUserWidget.UpdateDetailsPanel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemRequirementText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ComparedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHighlightTooltip                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemsHandlerUserWidget::UpdateDetailsPanel(const class FText& ItemRequirementText, class UItemAbility* Item, class UItemAbility* ComparedItem, bool bEquipped, bool bAnimate, bool bHighlightTooltip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "UpdateDetailsPanel");

	Params::ItemsHandlerUserWidget_UpdateDetailsPanel Parms{};

	Parms.ItemRequirementText = std::move(ItemRequirementText);
	Parms.Item = Item;
	Parms.ComparedItem = ComparedItem;
	Parms.bEquipped = bEquipped;
	Parms.bAnimate = bAnimate;
	Parms.bHighlightTooltip = bHighlightTooltip;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ItemsHandlerUserWidget.GetFilteredItemsNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemsHandlerUserWidget::GetFilteredItemsNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "GetFilteredItemsNum");

	Params::ItemsHandlerUserWidget_GetFilteredItemsNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemsHandlerUserWidget.GetFocusedSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInventorySlotUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventorySlotUserWidget* UItemsHandlerUserWidget::GetFocusedSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "GetFocusedSlot");

	Params::ItemsHandlerUserWidget_GetFocusedSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemsHandlerUserWidget.GetHeroEssenceResource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemsHandlerUserWidget::GetHeroEssenceResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "GetHeroEssenceResource");

	Params::ItemsHandlerUserWidget_GetHeroEssenceResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ItemsHandlerUserWidget.GetHeroGoldResource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemsHandlerUserWidget::GetHeroGoldResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemsHandlerUserWidget", "GetHeroGoldResource");

	Params::ItemsHandlerUserWidget_GetHeroGoldResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LimitedEntropicTearActor.OnSecondsRemainDepleted
// (Event, Public, BlueprintEvent)

void ALimitedEntropicTearActor::OnSecondsRemainDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitedEntropicTearActor", "OnSecondsRemainDepleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.KeyboardHotkeyUserWidget.GetHotkeyNameText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKeyboardHotkeyUserWidget::GetHotkeyNameText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyboardHotkeyUserWidget", "GetHotkeyNameText");

	Params::KeyboardHotkeyUserWidget_GetHotkeyNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.KingPriestVoidEntropicLeap.BPGetExplosionLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidEntropicLeap::BPGetExplosionLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidEntropicLeap", "BPGetExplosionLocation");

	Params::KingPriestVoidEntropicLeap_BPGetExplosionLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.KingPriestVoidEntropicLeap.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKingPriestVoidEntropicLeap::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KingPriestVoidEntropicLeap", "BPGetTeleportLocation");

	Params::KingPriestVoidEntropicLeap_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LadderActorBase.SetTargetLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALadderActorBase::SetTargetLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderActorBase", "SetTargetLocation");

	Params::LadderActorBase_SetTargetLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LadderActorBase.TeleportToLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALadderActorBase::TeleportToLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LadderActorBase", "TeleportToLocation");

	Params::LadderActorBase_TeleportToLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LiftButtonAbility.LiftOnGameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULiftButtonAbility::LiftOnGameplayEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftButtonAbility", "LiftOnGameplayEvent");

	Params::LiftButtonAbility_LiftOnGameplayEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LiftButtonAbility.OnGameplayEvent
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULiftButtonAbility::OnGameplayEvent(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftButtonAbility", "OnGameplayEvent");

	Params::LiftButtonAbility_OnGameplayEvent Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LightningStormAbility.KillStormActor
// (Final, Native, Public)

void ULightningStormAbility::KillStormActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightningStormAbility", "KillStormActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LightningStormAbility.OnStaggerOrStun
// (Final, Native, Private)

void ULightningStormAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightningStormAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameSlotUserWidget.GetSlotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULoadGameSlotUserWidget::GetSlotID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameSlotUserWidget", "GetSlotID");

	Params::LoadGameSlotUserWidget_GetSlotID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LoadGameSlotUserWidget.IsCanLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoadGameSlotUserWidget::IsCanLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameSlotUserWidget", "IsCanLoad");

	Params::LoadGameSlotUserWidget_IsCanLoad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LoadGameSlotUserWidget.IsValidSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoadGameSlotUserWidget::IsValidSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameSlotUserWidget", "IsValidSlot");

	Params::LoadGameSlotUserWidget_IsValidSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LoadGameSlotUserWidget.OnSetSlot
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LevelAndClass                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Location                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             TimeSpent                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LastPlayed                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    InCompatible                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadGameSlotUserWidget::OnSetSlot(const class FText& Name_0, const class FText& LevelAndClass, const class FText& Location, const class FText& TimeSpent, const class FText& LastPlayed, bool InCompatible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameSlotUserWidget", "OnSetSlot");

	Params::LoadGameSlotUserWidget_OnSetSlot Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.LevelAndClass = std::move(LevelAndClass);
	Parms.Location = std::move(Location);
	Parms.TimeSpent = std::move(TimeSpent);
	Parms.LastPlayed = std::move(LastPlayed);
	Parms.InCompatible = InCompatible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VoidWitchNewMoon.BPGetStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoidWitchNewMoon::BPGetStartLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidWitchNewMoon", "BPGetStartLocation");

	Params::VoidWitchNewMoon_BPGetStartLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VoidWitchNewMoon.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoidWitchNewMoon::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidWitchNewMoon", "BPGetTeleportLocation");

	Params::VoidWitchNewMoon_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.LoadGameUserWidget.CloseBtnClicked
// (Final, Native, Public, BlueprintCallable)

void ULoadGameUserWidget::CloseBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "CloseBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameUserWidget.DeleteBtnClicked
// (Final, Native, Public, BlueprintCallable)

void ULoadGameUserWidget::DeleteBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "DeleteBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameUserWidget.LoadBtnClicked
// (Final, Native, Public, BlueprintCallable)

void ULoadGameUserWidget::LoadBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "LoadBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameUserWidget.OnDialogueDeleteSavedGameResult
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadGameUserWidget::OnDialogueDeleteSavedGameResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "OnDialogueDeleteSavedGameResult");

	Params::LoadGameUserWidget_OnDialogueDeleteSavedGameResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadGameUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "OnFocusWidgetChangedEvent");

	Params::LoadGameUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LoadGameUserWidget.OnLoadGameMissingContent
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadGameUserWidget::OnLoadGameMissingContent(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGameUserWidget", "OnLoadGameMissingContent");

	Params::LoadGameUserWidget_OnLoadGameMissingContent Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.StaticElectricity.BPGetTargetEnemyForDamageVfx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UStaticElectricity::BPGetTargetEnemyForDamageVfx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticElectricity", "BPGetTargetEnemyForDamageVfx");

	Params::StaticElectricity_BPGetTargetEnemyForDamageVfx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StaticElectricity.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UStaticElectricity::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticElectricity", "OnPostDamageCaused");

	Params::StaticElectricity_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.StaticElectricity.Reset
// (Final, Native, Protected)

void UStaticElectricity::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticElectricity", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManAchievements.AddFlagToProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   iFlagBit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManAchievements::AddFlagToProgress(const class FName& AchievementID, int32 iFlagBit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAchievements", "AddFlagToProgress");

	Params::ManAchievements_AddFlagToProgress Parms{};

	Parms.AchievementID = AchievementID;
	Parms.iFlagBit = iFlagBit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManAchievements.AddProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   iProgress                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManAchievements::AddProgress(const class FName& AchievementID, int32 iProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAchievements", "AddProgress");

	Params::ManAchievements_AddProgress Parms{};

	Parms.AchievementID = AchievementID;
	Parms.iProgress = iProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManAchievements.GetProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UManAchievements::GetProgress(const class FName& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAchievements", "GetProgress");

	Params::ManAchievements_GetProgress Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManAchievements.IsUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManAchievements::IsUnlocked(const class FName& AchievementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAchievements", "IsUnlocked");

	Params::ManAchievements_IsUnlocked Parms{};

	Parms.AchievementID = AchievementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManAchievements.Unlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceWithStat                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManAchievements::Unlock(const class FName& AchievementID, bool ForceWithStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAchievements", "Unlock");

	Params::ManAchievements_Unlock Parms{};

	Parms.AchievementID = AchievementID;
	Parms.ForceWithStat = ForceWithStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManActivityFunctionLibrary.CompleteQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMandragoraGameMode*              GameMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             questName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManActivityFunctionLibrary::CompleteQuest(class AMandragoraGameMode* GameMode, class FName questName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManActivityFunctionLibrary", "CompleteQuest");

	Params::ManActivityFunctionLibrary_CompleteQuest Parms{};

	Parms.GameMode = GameMode;
	Parms.questName = questName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManActivityFunctionLibrary.EndActivity
// (Final, Native, Static, Public, BlueprintCallable)

void UManActivityFunctionLibrary::EndActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManActivityFunctionLibrary", "EndActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManAudioManager.OnApplicationActivationStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManAudioManager::OnApplicationActivationStateChanged(bool bIsFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManAudioManager", "OnApplicationActivationStateChanged");

	Params::ManAudioManager_OnApplicationActivationStateChanged Parms{};

	Parms.bIsFocused = bIsFocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WargBossAI.OnHeroDie
// (Final, Native, Private)

void UWargBossAI::OnHeroDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WargBossAI", "OnHeroDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManConversationManager.EvaluateConditionWithGlobalDictionary
// (Final, Native, Public)
// Parameters:
// class UPrimalConversationConditionBase* Codition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::EvaluateConditionWithGlobalDictionary(class UPrimalConversationConditionBase* Codition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "EvaluateConditionWithGlobalDictionary");

	Params::ManConversationManager_EvaluateConditionWithGlobalDictionary Parms{};

	Parms.Codition = Codition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.ForceStop
// (Final, Native, Public, BlueprintCallable)

void UManConversationManager::ForceStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "ForceStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManConversationManager.GlobalDictionarySetBool
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionarySetBool(const class FName Name_0, bool InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionarySetBool");

	Params::ManConversationManager_GlobalDictionarySetBool Parms{};

	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionarySetFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionarySetFloat(const class FName Name_0, float InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionarySetFloat");

	Params::ManConversationManager_GlobalDictionarySetFloat Parms{};

	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionarySetInt
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionarySetInt(const class FName Name_0, int32 InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionarySetInt");

	Params::ManConversationManager_GlobalDictionarySetInt Parms{};

	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionarySetString
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValue                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EntryKey)>   OnChanged                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionarySetString(const class FName Name_0, const class FString& InValue, const TDelegate<void(class FName EntryKey)>& OnChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionarySetString");

	Params::ManConversationManager_GlobalDictionarySetString Parms{};

	Parms.Name_0 = Name_0;
	Parms.InValue = std::move(InValue);
	Parms.OnChanged = OnChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalEntryChangedHandler
// (Final, Native, Public)
// Parameters:
// class FName                             EntryKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManConversationManager::GlobalEntryChangedHandler(class FName EntryKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalEntryChangedHandler");

	Params::ManConversationManager_GlobalEntryChangedHandler Parms{};

	Parms.EntryKey = EntryKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManConversationManager.LocalDictionarySetBool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::LocalDictionarySetBool(const class FName Name_0, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "LocalDictionarySetBool");

	Params::ManConversationManager_LocalDictionarySetBool Parms{};

	Parms.Name_0 = Name_0;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.OnPlayerContextGlobalChanged
// (Final, Native, Private)
// Parameters:
// class FName                             GlobalEntryKey                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManConversationManager::OnPlayerContextGlobalChanged(class FName GlobalEntryKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "OnPlayerContextGlobalChanged");

	Params::ManConversationManager_OnPlayerContextGlobalChanged Parms{};

	Parms.GlobalEntryKey = GlobalEntryKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManConversationManager.GlobalDictionaryGetBool
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionaryGetBool(bool* OutValue, const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionaryGetBool");

	Params::ManConversationManager_GlobalDictionaryGetBool Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionaryGetFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionaryGetFloat(float* OutValue, const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionaryGetFloat");

	Params::ManConversationManager_GlobalDictionaryGetFloat Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionaryGetInt
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionaryGetInt(int32* OutValue, const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionaryGetInt");

	Params::ManConversationManager_GlobalDictionaryGetInt Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionaryGetString
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionaryGetString(class FString* OutValue, const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionaryGetString");

	Params::ManConversationManager_GlobalDictionaryGetString Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.GlobalDictionaryIsExists
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::GlobalDictionaryIsExists(const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "GlobalDictionaryIsExists");

	Params::ManConversationManager_GlobalDictionaryIsExists Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManConversationManager.LocalDictionaryGetBool
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManConversationManager::LocalDictionaryGetBool(bool* OutValue, const class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManConversationManager", "LocalDictionaryGetBool");

	Params::ManConversationManager_LocalDictionaryGetBool Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function man.MandragoraTendrilPassive.BPOnWarningEnd
// (Event, Public, BlueprintEvent)

void UMandragoraTendrilPassive::BPOnWarningEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraTendrilPassive", "BPOnWarningEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.MandragoraTendrilPassive.BPOnWarningStart
// (Event, Public, BlueprintEvent)

void UMandragoraTendrilPassive::BPOnWarningStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandragoraTendrilPassive", "BPOnWarningStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.MandrakeFightImplement.OnLootActorPickedUp
// (Final, Native, Private)
// Parameters:
// class AActor*                           LootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMandrakeFightImplement::OnLootActorPickedUp(class AActor* LootActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandrakeFightImplement", "OnLootActorPickedUp");

	Params::MandrakeFightImplement_OnLootActorPickedUp Parms{};

	Parms.LootActor = LootActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandrakeFightImplement.OnLootActorSpawned
// (Final, Native, Private)
// Parameters:
// class AActor*                           LootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMandrakeFightImplement::OnLootActorSpawned(class AActor* LootActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandrakeFightImplement", "OnLootActorSpawned");

	Params::MandrakeFightImplement_OnLootActorSpawned Parms{};

	Parms.LootActor = LootActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandrakeFightImplement.OnTeleportEnded
// (Final, Native, Private)
// Parameters:
// class ADoorActorBase*                   DoorActorBase                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterBase*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMandrakeFightImplement::OnTeleportEnded(class ADoorActorBase* DoorActorBase, class ACharacterBase* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandrakeFightImplement", "OnTeleportEnded");

	Params::MandrakeFightImplement_OnTeleportEnded Parms{};

	Parms.DoorActorBase = DoorActorBase;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MandrakeFightImplement.OnTeleportStarted
// (Final, Native, Private)
// Parameters:
// class ADoorActorBase*                   DoorActorBase                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterBase*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMandrakeFightImplement::OnTeleportStarted(class ADoorActorBase* DoorActorBase, class ACharacterBase* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MandrakeFightImplement", "OnTeleportStarted");

	Params::MandrakeFightImplement_OnTeleportStarted Parms{};

	Parms.DoorActorBase = DoorActorBase;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManEngineEventHandler.OnLevelLoadFadeInBegin
// (Event, Protected, BlueprintEvent)

void UManEngineEventHandler::OnLevelLoadFadeInBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManEngineEventHandler", "OnLevelLoadFadeInBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManEngineEventHandler.OnLevelLoadFadeOutBegin
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bQuick                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManEngineEventHandler::OnLevelLoadFadeOutBegin(bool bQuick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManEngineEventHandler", "OnLevelLoadFadeOutBegin");

	Params::ManEngineEventHandler_OnLevelLoadFadeOutBegin Parms{};

	Parms.bQuick = bQuick;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.ManEngineEventHandler.OnPauseEnd
// (Event, Protected, BlueprintEvent)

void UManEngineEventHandler::OnPauseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManEngineEventHandler", "OnPauseEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManEngineEventHandler.OnPauseStart
// (Event, Protected, BlueprintEvent)

void UManEngineEventHandler::OnPauseStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManEngineEventHandler", "OnPauseStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TwoHandedSettings.GetEditorName
// (Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTwoHandedSettings::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwoHandedSettings", "GetEditorName");

	Params::TwoHandedSettings_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.AddDisableEnemyAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::AddDisableEnemyAI(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "AddDisableEnemyAI");

	Params::ManGameplayLibrary_AddDisableEnemyAI Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.AutomationTestQuitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::AutomationTestQuitGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "AutomationTestQuitGame");

	Params::ManGameplayLibrary_AutomationTestQuitGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.BPDebugMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DebugString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject1                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject2                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject3                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject4                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::BPDebugMessage(const class UObject* WorldContextObject, const class FString& DebugString, class UObject* DebugObject1, class UObject* DebugObject2, class UObject* DebugObject3, class UObject* DebugObject4)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "BPDebugMessage");

	Params::ManGameplayLibrary_BPDebugMessage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DebugString = std::move(DebugString);
	Parms.DebugObject1 = DebugObject1;
	Parms.DebugObject2 = DebugObject2;
	Parms.DebugObject3 = DebugObject3;
	Parms.DebugObject4 = DebugObject4;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.BPGetObjectDebugName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DebugObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UManGameplayLibrary::BPGetObjectDebugName(const class UObject* WorldContextObject, class UObject* DebugObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "BPGetObjectDebugName");

	Params::ManGameplayLibrary_BPGetObjectDebugName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DebugObject = DebugObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.CanCastClassSoft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             SoftPtr                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubclass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::CanCastClassSoft(const class UObject* WorldContextObject, class UClass* Class_0, TSoftClassPtr<class UClass> SoftPtr, bool bSubclass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "CanCastClassSoft");

	Params::ManGameplayLibrary_CanCastClassSoft Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Class_0 = Class_0;
	Parms.SoftPtr = SoftPtr;
	Parms.bSubclass = bSubclass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.CanCastObjectSoft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             SoftPtr                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubclass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::CanCastObjectSoft(const class UObject* WorldContextObject, class UObject* Object, TSoftClassPtr<class UClass> SoftPtr, bool bSubclass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "CanCastObjectSoft");

	Params::ManGameplayLibrary_CanCastObjectSoft Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Object = Object;
	Parms.SoftPtr = SoftPtr;
	Parms.bSubclass = bSubclass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.CanCastSoft
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             SoftPtr                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubclass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::CanCastSoft(const class UObject* WorldContextObject, class UObject* Object, TSoftClassPtr<class UClass> SoftPtr, bool bSubclass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "CanCastSoft");

	Params::ManGameplayLibrary_CanCastSoft Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Object = Object;
	Parms.SoftPtr = SoftPtr;
	Parms.bSubclass = bSubclass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.CanStartCutscene
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::CanStartCutscene(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "CanStartCutscene");

	Params::ManGameplayLibrary_CanStartCutscene Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.DebugCrash
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::DebugCrash(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "DebugCrash");

	Params::ManGameplayLibrary_DebugCrash Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.GetClassName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UManGameplayLibrary::GetClassName(const class UObject* WorldContextObject, class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "GetClassName");

	Params::ManGameplayLibrary_GetClassName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.GetDemoMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDemoMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDemoMode UManGameplayLibrary::GetDemoMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "GetDemoMode");

	Params::ManGameplayLibrary_GetDemoMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.GetManGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UManGameplayLibrary::GetManGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "GetManGameMode");

	Params::ManGameplayLibrary_GetManGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.GetManSurfaceLandingAudioEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESurfaceSamplingID                      SamplingID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UManGameplayLibrary::GetManSurfaceLandingAudioEvent(class AActor* TargetActor, ESurfaceSamplingID SamplingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "GetManSurfaceLandingAudioEvent");

	Params::ManGameplayLibrary_GetManSurfaceLandingAudioEvent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SamplingID = SamplingID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.GetManSurfaceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESurfaceSamplingID                      SamplingID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USurfaceEffectTypeDataAsset*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USurfaceEffectTypeDataAsset* UManGameplayLibrary::GetManSurfaceType(class AActor* TargetActor, ESurfaceSamplingID SamplingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "GetManSurfaceType");

	Params::ManGameplayLibrary_GetManSurfaceType Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SamplingID = SamplingID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.InterruptHero
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEmptyCommandQueue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::InterruptHero(const class UObject* WorldContextObject, bool bEmptyCommandQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "InterruptHero");

	Params::ManGameplayLibrary_InterruptHero Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEmptyCommandQueue = bEmptyCommandQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.IsAbilityUpgradeUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAbilityBase>         AbilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UpgradeID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsAbilityUpgradeUnlocked(const class UObject* WorldContextObject, TSubclassOf<class UAbilityBase> AbilityType, class FName UpgradeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsAbilityUpgradeUnlocked");

	Params::ManGameplayLibrary_IsAbilityUpgradeUnlocked Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AbilityType = AbilityType;
	Parms.UpgradeID = UpgradeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsActorRespawner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsActorRespawner(const class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsActorRespawner");

	Params::ManGameplayLibrary_IsActorRespawner Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsCheatAutoComplete
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsCheatAutoComplete(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsCheatAutoComplete");

	Params::ManGameplayLibrary_IsCheatAutoComplete Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsDebugDisableLevelStartCutscenes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsDebugDisableLevelStartCutscenes(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsDebugDisableLevelStartCutscenes");

	Params::ManGameplayLibrary_IsDebugDisableLevelStartCutscenes Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsInputRestrict
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsInputRestrict(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsInputRestrict");

	Params::ManGameplayLibrary_IsInputRestrict Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsManCheatEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsManCheatEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsManCheatEnabled");

	Params::ManGameplayLibrary_IsManCheatEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.IsManGamePaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::IsManGamePaused(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "IsManGamePaused");

	Params::ManGameplayLibrary_IsManGamePaused Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.LearnDiagram
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemAbility>         Diagram                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManGameplayLibrary::LearnDiagram(const class UObject* WorldContextObject, TSubclassOf<class UItemAbility> Diagram)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "LearnDiagram");

	Params::ManGameplayLibrary_LearnDiagram Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Diagram = Diagram;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.RecallCutsceneInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::RecallCutsceneInventory(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "RecallCutsceneInventory");

	Params::ManGameplayLibrary_RecallCutsceneInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.RejuvenateHero
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::RejuvenateHero(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "RejuvenateHero");

	Params::ManGameplayLibrary_RejuvenateHero Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.RemoveDisableEnemyAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::RemoveDisableEnemyAI(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "RemoveDisableEnemyAI");

	Params::ManGameplayLibrary_RemoveDisableEnemyAI Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.RequestAutoSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::RequestAutoSave(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "RequestAutoSave");

	Params::ManGameplayLibrary_RequestAutoSave Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.SetCheckPointTravelEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCheckpointData*                  CheckpointData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::SetCheckPointTravelEnabled(const class UObject* WorldContextObject, class UCheckpointData* CheckpointData, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "SetCheckPointTravelEnabled");

	Params::ManGameplayLibrary_SetCheckPointTravelEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CheckpointData = CheckpointData;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.SetCutsceneInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDefaultInventory>    NewInventory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::SetCutsceneInventory(const class UObject* WorldContextObject, TSubclassOf<class UDefaultInventory> NewInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "SetCutsceneInventory");

	Params::ManGameplayLibrary_SetCutsceneInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewInventory = NewInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.SetManGamePaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::SetManGamePaused(const class UObject* WorldContextObject, bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "SetManGamePaused");

	Params::ManGameplayLibrary_SetManGamePaused Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.SetShopTableItemVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorShopTable*                 ShopTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemAbility>         Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::SetShopTableItemVisibility(const class UObject* WorldContextObject, class UVendorShopTable* ShopTable, TSubclassOf<class UItemAbility> Item, bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "SetShopTableItemVisibility");

	Params::ManGameplayLibrary_SetShopTableItemVisibility Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ShopTable = ShopTable;
	Parms.Item = Item;
	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.SpawnEnemyCharacter
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AEnemyCharacter>      EnemyClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AVolume*                          AggroVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRespawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeleteUponWorldReset                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UManGameplayLibrary::SpawnEnemyCharacter(const class UObject* WorldContextObject, TSubclassOf<class AEnemyCharacter> EnemyClass, const struct FTransform& SpawnTransform, class AVolume* AggroVolume, bool bRespawn, bool bDeleteUponWorldReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "SpawnEnemyCharacter");

	Params::ManGameplayLibrary_SpawnEnemyCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EnemyClass = EnemyClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.AggroVolume = AggroVolume;
	Parms.bRespawn = bRespawn;
	Parms.bDeleteUponWorldReset = bDeleteUponWorldReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManGameplayLibrary.ToggleInputRestrict
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniqueName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInventory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bItemSetChange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkillSetChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuickUse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToggle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManGameplayLibrary::ToggleInputRestrict(const class UObject* WorldContextObject, class FName UniqueName, bool bAbility, bool bInventory, bool bItemSetChange, bool bSkillSetChange, bool bQuickUse, bool bToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "ToggleInputRestrict");

	Params::ManGameplayLibrary_ToggleInputRestrict Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UniqueName = UniqueName;
	Parms.bAbility = bAbility;
	Parms.bInventory = bInventory;
	Parms.bItemSetChange = bItemSetChange;
	Parms.bSkillSetChange = bSkillSetChange;
	Parms.bQuickUse = bQuickUse;
	Parms.bToggle = bToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManGameplayLibrary.ValidateManDoOnceAutogeneratedName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UManGameplayLibrary::ValidateManDoOnceAutogeneratedName(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManGameplayLibrary", "ValidateManDoOnceAutogeneratedName");

	Params::ManGameplayLibrary_ValidateManDoOnceAutogeneratedName Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WitchLanternUserWidget.AttributeChanged
// (Final, Native, Protected)
// Parameters:
// EAttribute                              AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWitchLanternUserWidget::AttributeChanged(EAttribute AttributeType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternUserWidget", "AttributeChanged");

	Params::WitchLanternUserWidget_AttributeChanged Parms{};

	Parms.AttributeType = AttributeType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternUserWidget.OnPropertyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWitchLanternUserWidget::OnPropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternUserWidget", "OnPropertyChanged");

	Params::WitchLanternUserWidget_OnPropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.WitchLanternUserWidget.OnSetTooltipData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// ESkillTreeNodeState                     SkillTreeNodeState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             CostText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             WarningText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWitchLanternUserWidget::OnSetTooltipData(ESkillTreeNodeState SkillTreeNodeState, const class FText& Name_0, const class FText& Description, const class FText& CostText, const class FText& WarningText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternUserWidget", "OnSetTooltipData");

	Params::WitchLanternUserWidget_OnSetTooltipData Parms{};

	Parms.SkillTreeNodeState = SkillTreeNodeState;
	Parms.Name_0 = std::move(Name_0);
	Parms.Description = std::move(Description);
	Parms.CostText = std::move(CostText);
	Parms.WarningText = std::move(WarningText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.WitchLanternUserWidget.PropertyChanged
// (Final, Native, Protected)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWitchLanternUserWidget::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternUserWidget", "PropertyChanged");

	Params::WitchLanternUserWidget_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLevelScriptActor.BeginPlayFadeOutFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AManLevelScriptActor::BeginPlayFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLevelScriptActor", "BeginPlayFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLevelScriptActor.DebugStuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AManLevelScriptActor*             ManLevelScriptActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManLevelScriptActor::DebugStuff(class AManLevelScriptActor* ManLevelScriptActor, const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLevelScriptActor", "DebugStuff");

	Params::ManLevelScriptActor_DebugStuff Parms{};

	Parms.ManLevelScriptActor = ManLevelScriptActor;
	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLevelScriptActor.ManBeginPlay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AManLevelScriptActor::ManBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLevelScriptActor", "ManBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLevelScriptActor.PostBeginPlay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AManLevelScriptActor::PostBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLevelScriptActor", "PostBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLevelScriptActor.PreBeginPlay
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AManLevelScriptActor::PreBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLevelScriptActor", "PreBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLootActor.InitializeLootActorVFX
// (Event, Protected, BlueprintEvent)

void AManLootActor::InitializeLootActorVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "InitializeLootActorVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManLootActor.Landed
// (Event, Protected, BlueprintEvent)

void AManLootActor::Landed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "Landed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManLootActor.OnHeroPreTravel
// (Native, Protected, HasDefaults)
// Parameters:
// class ALevelVisualVolume*               SourceLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelVisualVolume*               TargetLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManLootActor::OnHeroPreTravel(class ALevelVisualVolume* SourceLevelVisualVolume, class ALevelVisualVolume* TargetLevelVisualVolume, const struct FVector& NewPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "OnHeroPreTravel");

	Params::ManLootActor_OnHeroPreTravel Parms{};

	Parms.SourceLevelVisualVolume = SourceLevelVisualVolume;
	Parms.TargetLevelVisualVolume = TargetLevelVisualVolume;
	Parms.NewPos = std::move(NewPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLootActor.OnLevelLoad
// (Event, Protected, BlueprintEvent)

void AManLootActor::OnLevelLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "OnLevelLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManLootActor.OnStaticObjectPostCollide
// (Native, Protected)
// Parameters:
// TArray<struct FHitResult>               HitResult                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AManLootActor::OnStaticObjectPostCollide(const TArray<struct FHitResult>& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "OnStaticObjectPostCollide");

	Params::ManLootActor_OnStaticObjectPostCollide Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManLootActor.PostLootPickup
// (Event, Protected, BlueprintEvent)

void AManLootActor::PostLootPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "PostLootPickup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.ManLootActor.ToggleInactive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetInactive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManLootActor::ToggleInactive(bool bSetInactive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManLootActor", "ToggleInactive");

	Params::ManLootActor_ToggleInactive Parms{};

	Parms.bSetInactive = bSetInactive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.LootTableList.GetEditorName
// (Final, Native, Protected)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULootTableList::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootTableList", "GetEditorName");

	Params::LootTableList_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EntityLootTable.GetEditorName
// (Final, Native, Protected)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEntityLootTable::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EntityLootTable", "GetEditorName");

	Params::EntityLootTable_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManOutlineVFXSubsystem.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManOutlineVFXSubsystem*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManOutlineVFXSubsystem* UManOutlineVFXSubsystem::Get(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManOutlineVFXSubsystem", "Get");

	Params::ManOutlineVFXSubsystem_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TutorialPromptUserWidget.BPHide
// (Final, Native, Protected, BlueprintCallable)

void UTutorialPromptUserWidget::BPHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptUserWidget", "BPHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptUserWidget.BPShow
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ATutorialPromptActor*             InTutorialPromptActor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialPromptUserWidget::BPShow(class ATutorialPromptActor* InTutorialPromptActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptUserWidget", "BPShow");

	Params::TutorialPromptUserWidget_BPShow Parms{};

	Parms.InTutorialPromptActor = InTutorialPromptActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptUserWidget.CultureChanged
// (Final, Native, Protected)

void UTutorialPromptUserWidget::CultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptUserWidget", "CultureChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptUserWidget.OnAbilityChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialPromptUserWidget::OnAbilityChanged(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptUserWidget", "OnAbilityChanged");

	Params::TutorialPromptUserWidget_OnAbilityChanged Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptUserWidget.OnSticksControlsChanged
// (Final, Native, Protected)

void UTutorialPromptUserWidget::OnSticksControlsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptUserWidget", "OnSticksControlsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManPlayerController.OnApplicationActivationStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManPlayerController::OnApplicationActivationStateChanged(bool bIsFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManPlayerController", "OnApplicationActivationStateChanged");

	Params::ManPlayerController_OnApplicationActivationStateChanged Parms{};

	Parms.bIsFocused = bIsFocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManPlayerController.GetManLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UManLocalPlayer*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManLocalPlayer* AManPlayerController::GetManLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManPlayerController", "GetManLocalPlayer");

	Params::ManPlayerController_GetManLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorDiagram.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UVendorDiagram::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorDiagram", "GetEditorName");

	Params::VendorDiagram_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddAreaReachedObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Story                                                  (Parm, NativeAccessSpecifierPublic)
// struct FTextAndStoryParams              TextAndStoryParams                                     (Parm, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMapSegmentVolumeID*              SegmentUniqueID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               RequiredObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestFinisher                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreObjectiveCompletedEvent                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjectiveReachArea*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjectiveReachArea* UManQuest::AddAreaReachedObjective(class FName Name_0, const class FText& Text, const class FText& Story, const struct FTextAndStoryParams& TextAndStoryParams, const struct FQuestMarker& QuestMarker, class UMapSegmentVolumeID* SegmentUniqueID, class UManQuestObjective* RequiredObjective, int32 RequiredProgress, bool bCriticalObjective, bool bQuestFinisher, bool bPreObjectiveCompletedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddAreaReachedObjective");

	Params::ManQuest_AddAreaReachedObjective Parms{};

	Parms.Name_0 = Name_0;
	Parms.Text = std::move(Text);
	Parms.Story = std::move(Story);
	Parms.TextAndStoryParams = std::move(TextAndStoryParams);
	Parms.QuestMarker = std::move(QuestMarker);
	Parms.SegmentUniqueID = SegmentUniqueID;
	Parms.RequiredObjective = RequiredObjective;
	Parms.RequiredProgress = RequiredProgress;
	Parms.bCriticalObjective = bCriticalObjective;
	Parms.bQuestFinisher = bQuestFinisher;
	Parms.bPreObjectiveCompletedEvent = bPreObjectiveCompletedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddItemAquiredObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    bHideCounter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Story                                                  (Parm, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemAbility>         ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQuantisedItemAbility>    RequiredItems                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UManQuestObjective*               RequiredObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestFinisher                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreObjectiveCompletedEvent                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjectiveAcquireItems*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjectiveAcquireItems* UManQuest::AddItemAquiredObjective(class FName Name_0, const class FText& Text, bool bHideCounter, const class FText& Story, const struct FQuestMarker& QuestMarker, TSubclassOf<class UItemAbility> ItemAbility, const TArray<struct FQuantisedItemAbility>& RequiredItems, class UManQuestObjective* RequiredObjective, int32 RequiredProgress, bool bCriticalObjective, bool bQuestFinisher, bool bPreObjectiveCompletedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddItemAquiredObjective");

	Params::ManQuest_AddItemAquiredObjective Parms{};

	Parms.Name_0 = Name_0;
	Parms.Text = std::move(Text);
	Parms.bHideCounter = bHideCounter;
	Parms.Story = std::move(Story);
	Parms.QuestMarker = std::move(QuestMarker);
	Parms.ItemAbility = ItemAbility;
	Parms.RequiredItems = std::move(RequiredItems);
	Parms.RequiredObjective = RequiredObjective;
	Parms.RequiredProgress = RequiredProgress;
	Parms.bCriticalObjective = bCriticalObjective;
	Parms.bQuestFinisher = bQuestFinisher;
	Parms.bPreObjectiveCompletedEvent = bPreObjectiveCompletedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddItemEquippedObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Story                                                  (Parm, NativeAccessSpecifierPublic)
// struct FTextAndStoryParams              TextAndStoryParams                                     (Parm, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemAbility>         ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               RequiredObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestFinisher                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreObjectiveCompletedEvent                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjectiveEquipItem*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjectiveEquipItem* UManQuest::AddItemEquippedObjective(class FName Name_0, const class FText& Text, const class FText& Story, const struct FTextAndStoryParams& TextAndStoryParams, const struct FQuestMarker& QuestMarker, TSubclassOf<class UItemAbility> ItemAbility, class UManQuestObjective* RequiredObjective, int32 RequiredProgress, bool bCriticalObjective, bool bQuestFinisher, bool bPreObjectiveCompletedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddItemEquippedObjective");

	Params::ManQuest_AddItemEquippedObjective Parms{};

	Parms.Name_0 = Name_0;
	Parms.Text = std::move(Text);
	Parms.Story = std::move(Story);
	Parms.TextAndStoryParams = std::move(TextAndStoryParams);
	Parms.QuestMarker = std::move(QuestMarker);
	Parms.ItemAbility = ItemAbility;
	Parms.RequiredObjective = RequiredObjective;
	Parms.RequiredProgress = RequiredProgress;
	Parms.bCriticalObjective = bCriticalObjective;
	Parms.bQuestFinisher = bQuestFinisher;
	Parms.bPreObjectiveCompletedEvent = bPreObjectiveCompletedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddKillObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Story                                                  (Parm, NativeAccessSpecifierPublic)
// struct FTextAndStoryParams              TextAndStoryParams                                     (Parm, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UClass>>     ActorTypes                                             (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     ActorSoulNames                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UManQuestObjective*               RequiredObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestFinisher                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreObjectiveCompletedEvent                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseActorSouls                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowCounter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjectiveKillEnemies*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjectiveKillEnemies* UManQuest::AddKillObjective(class FName Name_0, const class FText& Text, const class FText& Story, const struct FTextAndStoryParams& TextAndStoryParams, const struct FQuestMarker& QuestMarker, const TArray<TSoftClassPtr<class UClass>>& ActorTypes, TArray<class FName>& ActorSoulNames, class UManQuestObjective* RequiredObjective, int32 RequiredProgress, bool bCriticalObjective, bool bQuestFinisher, bool bPreObjectiveCompletedEvent, bool bUseActorSouls, bool bShowCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddKillObjective");

	Params::ManQuest_AddKillObjective Parms{};

	Parms.Name_0 = Name_0;
	Parms.Text = std::move(Text);
	Parms.Story = std::move(Story);
	Parms.TextAndStoryParams = std::move(TextAndStoryParams);
	Parms.QuestMarker = std::move(QuestMarker);
	Parms.ActorTypes = std::move(ActorTypes);
	Parms.ActorSoulNames = std::move(ActorSoulNames);
	Parms.RequiredObjective = RequiredObjective;
	Parms.RequiredProgress = RequiredProgress;
	Parms.bCriticalObjective = bCriticalObjective;
	Parms.bQuestFinisher = bQuestFinisher;
	Parms.bPreObjectiveCompletedEvent = bPreObjectiveCompletedEvent;
	Parms.bUseActorSouls = bUseActorSouls;
	Parms.bShowCounter = bShowCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ActorSoulNames = std::move(Parms.ActorSoulNames);

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Story                                                  (Parm, NativeAccessSpecifierPublic)
// struct FTextAndStoryParams              TextAndStoryParams                                     (Parm, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UManQuestObjective*               RequiredObjective                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCriticalObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuestFinisher                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreObjectiveCompletedEvent                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurrentVariableName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaxVariableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestObjective*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestObjective* UManQuest::AddObjective(class FName Name_0, const class FText& Text, const class FText& Story, const struct FTextAndStoryParams& TextAndStoryParams, const struct FQuestMarker& QuestMarker, class UManQuestObjective* RequiredObjective, int32 RequiredProgress, bool bCriticalObjective, bool bQuestFinisher, bool bPreObjectiveCompletedEvent, class FName CurrentVariableName, class FName MaxVariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddObjective");

	Params::ManQuest_AddObjective Parms{};

	Parms.Name_0 = Name_0;
	Parms.Text = std::move(Text);
	Parms.Story = std::move(Story);
	Parms.TextAndStoryParams = std::move(TextAndStoryParams);
	Parms.QuestMarker = std::move(QuestMarker);
	Parms.RequiredObjective = RequiredObjective;
	Parms.RequiredProgress = RequiredProgress;
	Parms.bCriticalObjective = bCriticalObjective;
	Parms.bQuestFinisher = bQuestFinisher;
	Parms.bPreObjectiveCompletedEvent = bPreObjectiveCompletedEvent;
	Parms.CurrentVariableName = CurrentVariableName;
	Parms.MaxVariableName = MaxVariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddObjectiveReward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FQuestReward                     RewardToAdd                                            (Parm, NativeAccessSpecifierPublic)
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::AddObjectiveReward(const struct FQuestReward& RewardToAdd, class UManQuestObjective* Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddObjectiveReward");

	Params::ManQuest_AddObjectiveReward Parms{};

	Parms.RewardToAdd = std::move(RewardToAdd);
	Parms.Objective = Objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.AddQuestProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComplete                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CallSource                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuest::AddQuestProgress(class UManQuestObjective* Objective, class FName ObjectiveName, bool bComplete, const class FString& CallSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "AddQuestProgress");

	Params::ManQuest_AddQuestProgress Parms{};

	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;
	Parms.bComplete = bComplete;
	Parms.CallSource = std::move(CallSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.CheckQuestEventData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FQuestEventData                  IncomingData                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FObjectiveCompletionData         CompletionData                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::CheckQuestEventData(const struct FQuestEventData& IncomingData, const struct FObjectiveCompletionData& CompletionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "CheckQuestEventData");

	Params::ManQuest_CheckQuestEventData Parms{};

	Parms.IncomingData = std::move(IncomingData);
	Parms.CompletionData = std::move(CompletionData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.CompleteQuest
// (Final, Native, Public, BlueprintCallable)

void UManQuest::CompleteQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "CompleteQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.ConstructQuestObjectives
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UManQuest::ConstructQuestObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "ConstructQuestObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.ForceQuestDrop
// (Final, Native, Public, BlueprintCallable)

void UManQuest::ForceQuestDrop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "ForceQuestDrop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.GetManGameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UManQuest::GetManGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "GetManGameMode");

	Params::ManQuest_GetManGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.GetObjectiveRewardIcons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIncludeQuestReward                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UTexture2D*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTexture2D*> UManQuest::GetObjectiveRewardIcons(bool bIncludeQuestReward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "GetObjectiveRewardIcons");

	Params::ManQuest_GetObjectiveRewardIcons Parms{};

	Parms.bIncludeQuestReward = bIncludeQuestReward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.GetQuestConclusion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UManQuest::GetQuestConclusion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "GetQuestConclusion");

	Params::ManQuest_GetQuestConclusion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.GetQuestDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UManQuest::GetQuestDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "GetQuestDisplayName");

	Params::ManQuest_GetQuestDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.GetRequiredItemsText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FQuantisedItemAbility>    RequiredItems                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UManQuest::GetRequiredItemsText(const TArray<struct FQuantisedItemAbility>& RequiredItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "GetRequiredItemsText");

	Params::ManQuest_GetRequiredItemsText Parms{};

	Parms.RequiredItems = std::move(RequiredItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.HasFailedObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::HasFailedObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "HasFailedObjective");

	Params::ManQuest_HasFailedObjective Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.IsObjectiveCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::IsObjectiveCompleted(class UManQuestObjective* Objective, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "IsObjectiveCompleted");

	Params::ManQuest_IsObjectiveCompleted Parms{};

	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.IsObjectiveFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::IsObjectiveFailed(class UManQuestObjective* Objective, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "IsObjectiveFailed");

	Params::ManQuest_IsObjectiveFailed Parms{};

	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.IsQuestActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::IsQuestActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "IsQuestActive");

	Params::ManQuest_IsQuestActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.IsQuestCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::IsQuestCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "IsQuestCompleted");

	Params::ManQuest_IsQuestCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.IsQuestObjectiveCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManQuest::IsQuestObjectiveCompleted(class UManQuestObjective* Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "IsQuestObjectiveCompleted");

	Params::ManQuest_IsQuestObjectiveCompleted Parms{};

	Parms.Objective = Objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManQuest.OnGameplayQuestEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FQuestEventData                  Data                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UManQuest::OnGameplayQuestEvent(const struct FQuestEventData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "OnGameplayQuestEvent");

	Params::ManQuest_OnGameplayQuestEvent Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.OnPreQuestObjectiveCompleted
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UManQuestObjective*               CompletedObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowCompletion                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuest::OnPreQuestObjectiveCompleted(class UManQuestObjective* CompletedObjective, bool* AllowCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "OnPreQuestObjectiveCompleted");

	Params::ManQuest_OnPreQuestObjectiveCompleted Parms{};

	Parms.CompletedObjective = CompletedObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AllowCompletion != nullptr)
		*AllowCompletion = Parms.AllowCompletion;
}


// Function man.ManQuest.OnQuestCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UManQuest::OnQuestCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "OnQuestCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.OnQuestObjectiveCompleted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UManQuestObjective*               CompletedObjective                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuest::OnQuestObjectiveCompleted(class UManQuestObjective* CompletedObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "OnQuestObjectiveCompleted");

	Params::ManQuest_OnQuestObjectiveCompleted Parms{};

	Parms.CompletedObjective = CompletedObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.OnQuestObjectiveFailed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UManQuestObjective*               FailedObjective                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuest::OnQuestObjectiveFailed(class UManQuestObjective* FailedObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "OnQuestObjectiveFailed");

	Params::ManQuest_OnQuestObjectiveFailed Parms{};

	Parms.FailedObjective = FailedObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.SetObjectiveFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UManQuest::SetObjectiveFailed(class UManQuestObjective* Objective, class FName ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "SetObjectiveFailed");

	Params::ManQuest_SetObjectiveFailed Parms{};

	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManQuest.SetObjectiveQuestMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManQuestObjective*               Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjectiveName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuestMarker                     QuestMarker                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UManQuest::SetObjectiveQuestMarker(class UManQuestObjective* Objective, class FName ObjectiveName, const struct FQuestMarker& QuestMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManQuest", "SetObjectiveQuestMarker");

	Params::ManQuest_SetObjectiveQuestMarker Parms{};

	Parms.Objective = Objective;
	Parms.ObjectiveName = ObjectiveName;
	Parms.QuestMarker = std::move(QuestMarker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManSaveGameSettings.Load
// (Final, Native, Static, Public)

void UManSaveGameSettings::Load()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ManSaveGameSettings", "Load");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManSaveGameSettings.Save
// (Final, Native, Public)
// Parameters:
// class UManGameUserSettings*             Settings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UManSaveGameSettings::Save(class UManGameUserSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSaveGameSettings", "Save");

	Params::ManSaveGameSettings_Save Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ManSaveManager.OnSaveAchToSlotFinish
// (Final, Native, Private)
// Parameters:
// class FString                           SaveName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FManAchBundle                    pAchBundle                                             (Parm, NativeAccessSpecifierPublic)

void UManSaveManager::OnSaveAchToSlotFinish(const class FString& SaveName, const int32 PlayerIndex, bool bResult, const struct FManAchBundle& pAchBundle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSaveManager", "OnSaveAchToSlotFinish");

	Params::ManSaveManager_OnSaveAchToSlotFinish Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.PlayerIndex = PlayerIndex;
	Parms.bResult = bResult;
	Parms.pAchBundle = std::move(pAchBundle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManSaveManager.OnSaveGamePreviewToSlotFinish
// (Final, Native, Private)
// Parameters:
// class FString                           SaveName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FManSaveBundle                   SaveBundle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UManSaveManager::OnSaveGamePreviewToSlotFinish(const class FString& SaveName, const int32 PlayerIndex, bool bResult, const struct FManSaveBundle& SaveBundle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSaveManager", "OnSaveGamePreviewToSlotFinish");

	Params::ManSaveManager_OnSaveGamePreviewToSlotFinish Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.PlayerIndex = PlayerIndex;
	Parms.bResult = bResult;
	Parms.SaveBundle = std::move(SaveBundle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManSaveManager.OnSaveGameToSlotFinish
// (Final, Native, Private)
// Parameters:
// class FString                           SaveName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FManSaveBundle                   SaveBundle                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UManSaveManager::OnSaveGameToSlotFinish(const class FString& SaveName, const int32 PlayerIndex, bool bResult, const struct FManSaveBundle& SaveBundle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManSaveManager", "OnSaveGameToSlotFinish");

	Params::ManSaveManager_OnSaveGameToSlotFinish Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.PlayerIndex = PlayerIndex;
	Parms.bResult = bResult;
	Parms.SaveBundle = std::move(SaveBundle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VoidBossAttackInhale.BPGetOuterCircleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoidBossAttackInhale::BPGetOuterCircleRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidBossAttackInhale", "BPGetOuterCircleRadius");

	Params::VoidBossAttackInhale_BPGetOuterCircleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VoidBossAttackInhale.IsCollideSignatureEx_Pre
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGroundMovecollideIsCollideSignatureParamParam                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidBossAttackInhale::IsCollideSignatureEx_Pre(struct FGroundMovecollideIsCollideSignatureParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidBossAttackInhale", "IsCollideSignatureEx_Pre");

	Params::VoidBossAttackInhale_IsCollideSignatureEx_Pre Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ManTriggerVolume.OnBeginOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManTriggerVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTriggerVolume", "OnBeginOverlap");

	Params::ManTriggerVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManTriggerVolume.OnEndOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AManTriggerVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManTriggerVolume", "OnEndOverlap");

	Params::ManTriggerVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVisualController.OnVisualBeginOverlap
// (Final, Native, Public)

void UManVisualController::OnVisualBeginOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVisualController", "OnVisualBeginOverlap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManVisualController.OnVisualEndOverlap
// (Final, Native, Public)

void UManVisualController::OnVisualEndOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManVisualController", "OnVisualEndOverlap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VoidRatSummonAbilitiy.GetResurrectTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UVoidRatSummonAbilitiy::GetResurrectTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidRatSummonAbilitiy", "GetResurrectTarget");

	Params::VoidRatSummonAbilitiy_GetResurrectTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MovementSpeedModifierVolume.OnBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovementSpeedModifierVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedModifierVolume", "OnBeginOverlap");

	Params::MovementSpeedModifierVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MovementSpeedModifierVolume.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMovementSpeedModifierVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedModifierVolume", "OnEndOverlap");

	Params::MovementSpeedModifierVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VoidBossEntropyRainAbility.OnProjectileDestroyed
// (Final, Native, Protected)
// Parameters:
// class AActor*                           ProjectileActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidBossEntropyRainAbility::OnProjectileDestroyed(class AActor* ProjectileActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidBossEntropyRainAbility", "OnProjectileDestroyed");

	Params::VoidBossEntropyRainAbility_OnProjectileDestroyed Parms{};

	Parms.ProjectileActor = ProjectileActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VoidBossEntropyRainAbility.OnProjectileShot
// (Final, Native, Protected)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidBossEntropyRainAbility::OnProjectileShot(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidBossEntropyRainAbility", "OnProjectileShot");

	Params::VoidBossEntropyRainAbility_OnProjectileShot Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ManWrapBox.DoItemListCustomNavigation_Down
// (Final, Native, Public)

void UManWrapBox::DoItemListCustomNavigation_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManWrapBox", "DoItemListCustomNavigation_Down");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManWrapBox.DoItemListCustomNavigation_Left
// (Final, Native, Public)

void UManWrapBox::DoItemListCustomNavigation_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManWrapBox", "DoItemListCustomNavigation_Left");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManWrapBox.DoItemListCustomNavigation_Right
// (Final, Native, Public)

void UManWrapBox::DoItemListCustomNavigation_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManWrapBox", "DoItemListCustomNavigation_Right");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ManWrapBox.DoItemListCustomNavigation_Up
// (Final, Native, Public)

void UManWrapBox::DoItemListCustomNavigation_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ManWrapBox", "DoItemListCustomNavigation_Up");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapManager.BPOverrideGlobalTileEdges
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        GlobalTilePos                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LayerIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapExplorationTileEdgeOverride         TopEdge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapExplorationTileEdgeOverride         RightEdge                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapExplorationTileEdgeOverride         BottomEdge                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapExplorationTileEdgeOverride         LeftEdge                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapManager::BPOverrideGlobalTileEdges(const struct FIntPoint& GlobalTilePos, int32 LayerIndex, EMapExplorationTileEdgeOverride TopEdge, EMapExplorationTileEdgeOverride RightEdge, EMapExplorationTileEdgeOverride BottomEdge, EMapExplorationTileEdgeOverride LeftEdge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapManager", "BPOverrideGlobalTileEdges");

	Params::MapManager_BPOverrideGlobalTileEdges Parms{};

	Parms.GlobalTilePos = std::move(GlobalTilePos);
	Parms.LayerIndex = LayerIndex;
	Parms.TopEdge = TopEdge;
	Parms.RightEdge = RightEdge;
	Parms.BottomEdge = BottomEdge;
	Parms.LeftEdge = LeftEdge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MapManager.BPSetAllMapSegmentsUnlocked
// (Final, Native, Public, BlueprintCallable)

void UMapManager::BPSetAllMapSegmentsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapManager", "BPSetAllMapSegmentsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapManager.BPSetCheckPointUnlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCheckpointData*                  Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ObjName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapManager::BPSetCheckPointUnlocked(class UCheckpointData* Data, class FName ObjName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapManager", "BPSetCheckPointUnlocked");

	Params::MapManager_BPSetCheckPointUnlocked Parms{};

	Parms.Data = Data;
	Parms.ObjName = ObjName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MapManager.GetCurrentLevelName
// (Final, Native, Public, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMapManager::GetCurrentLevelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapManager", "GetCurrentLevelName");

	Params::MapManager_GetCurrentLevelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot0Icon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EDialogueType                           DialogueType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVendorAlchemistUserWidget::GetConfirmationWindowSlot0Icon(EDialogueType DialogueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "GetConfirmationWindowSlot0Icon");

	Params::VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon Parms{};

	Parms.DialogueType = DialogueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot0Name
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EDialogueType                           DialogueType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorAlchemistUserWidget::GetConfirmationWindowSlot0Name(EDialogueType DialogueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "GetConfirmationWindowSlot0Name");

	Params::VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name Parms{};

	Parms.DialogueType = DialogueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot1Icon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EDialogueType                           DialogueType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVendorAlchemistUserWidget::GetConfirmationWindowSlot1Icon(EDialogueType DialogueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "GetConfirmationWindowSlot1Icon");

	Params::VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon Parms{};

	Parms.DialogueType = DialogueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot1Name
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EDialogueType                           DialogueType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorAlchemistUserWidget::GetConfirmationWindowSlot1Name(EDialogueType DialogueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "GetConfirmationWindowSlot1Name");

	Params::VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name Parms{};

	Parms.DialogueType = DialogueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.GetItemAbility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UManItemSlotBase*                 ManItemSlotBase                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemAbility* UVendorAlchemistUserWidget::GetItemAbility(class UManItemSlotBase* ManItemSlotBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "GetItemAbility");

	Params::VendorAlchemistUserWidget_GetItemAbility Parms{};

	Parms.ManItemSlotBase = ManItemSlotBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorAlchemistUserWidget.OnEndPlantSeedState
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnEndPlantSeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnEndPlantSeedState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.OnEndRemoveSeedState
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnEndRemoveSeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnEndRemoveSeedState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.OnPlantSeed
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnPlantSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnPlantSeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.OnReplaceSeed
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnReplaceSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnReplaceSeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.OnStartPlantSeedState
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnStartPlantSeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnStartPlantSeedState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.OnStartRemoveSeedState
// (Event, Protected, BlueprintEvent)

void UVendorAlchemistUserWidget::OnStartRemoveSeedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "OnStartRemoveSeedState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorAlchemistUserWidget.PlantSeed
// (Final, Native, Protected, BlueprintCallable)

void UVendorAlchemistUserWidget::PlantSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "PlantSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorAlchemistUserWidget.RemoveSeedRequest
// (Final, Native, Protected, BlueprintCallable)

void UVendorAlchemistUserWidget::RemoveSeedRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorAlchemistUserWidget", "RemoveSeedRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowMarkerUserWidget.OnSetBtnVisiblity
// (Event, Public, BlueprintEvent)
// Parameters:
// ESlateVisibility                        SlateVisibility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowMarkerUserWidget::OnSetBtnVisiblity(ESlateVisibility SlateVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowMarkerUserWidget", "OnSetBtnVisiblity");

	Params::MapWindowMarkerUserWidget_OnSetBtnVisiblity Parms{};

	Parms.SlateVisibility = SlateVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowMarkerUserWidget.OnSetSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowMarkerUserWidget::OnSetSelected(bool bInSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowMarkerUserWidget", "OnSetSelected");

	Params::MapWindowMarkerUserWidget_OnSetSelected Parms{};

	Parms.bInSelected = bInSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.GetMapObjectUserWidgets
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UMapObjectUserWidget*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMapObjectUserWidget*> UMapWindowUserWidget::GetMapObjectUserWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "GetMapObjectUserWidgets");

	Params::MapWindowUserWidget_GetMapObjectUserWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MapWindowUserWidget.GotoCharacterPosition
// (Final, Native, Public, BlueprintCallable)

void UMapWindowUserWidget::GotoCharacterPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "GotoCharacterPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.JumpToNextMarker
// (Final, Native, Protected, BlueprintCallable)

void UMapWindowUserWidget::JumpToNextMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "JumpToNextMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.JumpToPrevMarker
// (Final, Native, Protected, BlueprintCallable)

void UMapWindowUserWidget::JumpToPrevMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "JumpToPrevMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.OnChangeMapSegmentsScale
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InCurrentZoomValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnChangeMapSegmentsScale(float InCurrentZoomValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnChangeMapSegmentsScale");

	Params::MapWindowUserWidget_OnChangeMapSegmentsScale Parms{};

	Parms.InCurrentZoomValue = InCurrentZoomValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnMiniMapElementChange
// (Final, Native, Protected)
// Parameters:
// class UMiniMapActorComponent*           MiniMapActorComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnMiniMapElementChange(class UMiniMapActorComponent* MiniMapActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnMiniMapElementChange");

	Params::MapWindowUserWidget_OnMiniMapElementChange Parms{};

	Parms.MiniMapActorComponent = MiniMapActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.OnPanEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPanEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnPanEnabled(bool bPanEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnPanEnabled");

	Params::MapWindowUserWidget_OnPanEnabled Parms{};

	Parms.bPanEnabled = bPanEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnSetMapName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InMapName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnSetMapName(const class FText& InMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnSetMapName");

	Params::MapWindowUserWidget_OnSetMapName Parms{};

	Parms.InMapName = std::move(InMapName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnSetMarkerNumText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InMarkerNumText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InCurrentMarkerNum                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxMarkerNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnSetMarkerNumText(const class FText& InMarkerNumText, int32 InCurrentMarkerNum, int32 InMaxMarkerNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnSetMarkerNumText");

	Params::MapWindowUserWidget_OnSetMarkerNumText Parms{};

	Parms.InMarkerNumText = std::move(InMarkerNumText);
	Parms.InCurrentMarkerNum = InCurrentMarkerNum;
	Parms.InMaxMarkerNum = InMaxMarkerNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnSetOffscreenQuestIndicator
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InrAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRenderOpacity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnSetOffscreenQuestIndicator(float InrAngle, float InRenderOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnSetOffscreenQuestIndicator");

	Params::MapWindowUserWidget_OnSetOffscreenQuestIndicator Parms{};

	Parms.InrAngle = InrAngle;
	Parms.InRenderOpacity = InRenderOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnSetQuestText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InQuestText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnSetQuestText(const class FText& InQuestText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnSetQuestText");

	Params::MapWindowUserWidget_OnSetQuestText Parms{};

	Parms.InQuestText = std::move(InQuestText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnShowLegend
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnShowLegend(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnShowLegend");

	Params::MapWindowUserWidget_OnShowLegend Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.OnToggleMapLayer
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   MapLayerIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapWindowUserWidget::OnToggleMapLayer(int32 MapLayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnToggleMapLayer");

	Params::MapWindowUserWidget_OnToggleMapLayer Parms{};

	Parms.MapLayerIndex = MapLayerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MapWindowUserWidget.OnTravelFadeOutFinished
// (Final, Native, Protected)

void UMapWindowUserWidget::OnTravelFadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnTravelFadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.OnUnlockAllCheckpoints
// (Final, Native, Protected)

void UMapWindowUserWidget::OnUnlockAllCheckpoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "OnUnlockAllCheckpoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.PlaceOrRemoveMarker
// (Final, Native, Public, BlueprintCallable)

void UMapWindowUserWidget::PlaceOrRemoveMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "PlaceOrRemoveMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.ToggleMapLayer
// (Final, Native, Public, BlueprintCallable)

void UMapWindowUserWidget::ToggleMapLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "ToggleMapLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.MapWindowUserWidget.GetCurrentMapLayerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMapWindowUserWidget::GetCurrentMapLayerIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapWindowUserWidget", "GetCurrentMapLayerIndex");

	Params::MapWindowUserWidget_GetCurrentMapLayerIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VeteranPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVeteranPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VeteranPassive", "DamageDealt");

	Params::VeteranPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MeltdownPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UMeltdownPassive::DamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeltdownPassive", "DamageDealt");

	Params::MeltdownPassive_DamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.MeshSamplingVisualEntity.BPGetNiagaraAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* AMeshSamplingVisualEntity::BPGetNiagaraAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshSamplingVisualEntity", "BPGetNiagaraAsset");

	Params::MeshSamplingVisualEntity_BPGetNiagaraAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MeshSamplingVisualEntity.IsOnHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeshSamplingVisualEntity::IsOnHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshSamplingVisualEntity", "IsOnHero");

	Params::MeshSamplingVisualEntity_IsOnHero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.MeshSamplingVisualEntity.ToggleVFXOnMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeshSamplingVisualEntity::ToggleVFXOnMeshes(bool bActivate, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeshSamplingVisualEntity", "ToggleVFXOnMeshes");

	Params::MeshSamplingVisualEntity_ToggleVFXOnMeshes Parms{};

	Parms.bActivate = bActivate;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MomentumFamiliarAbility.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMomentumFamiliarAbility::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MomentumFamiliarAbility", "PostDamageDealt");

	Params::MomentumFamiliarAbility_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MoveToTargetPointAbility.SetTargetPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoveToTargetPointAbility::SetTargetPoint(const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveToTargetPointAbility", "SetTargetPoint");

	Params::MoveToTargetPointAbility_SetTargetPoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MusicManager.PostEventCallback
// (Final, Native, Public)
// Parameters:
// EAkCallbackType                         in_eType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkCallbackInfo*                  in_pCallbackInfo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManager::PostEventCallback(EAkCallbackType in_eType, class UAkCallbackInfo* in_pCallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicManager", "PostEventCallback");

	Params::MusicManager_PostEventCallback Parms{};

	Parms.in_eType = in_eType;
	Parms.in_pCallbackInfo = in_pCallbackInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NecroRibVolley.OnLanded
// (Final, Native, Public)

void UNecroRibVolley::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NecroRibVolley", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NecroTormentedSoulProjectivePassive.OnProjectileApex
// (Final, Native, Public)
// Parameters:
// float                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNecroTormentedSoulProjectivePassive::OnProjectileApex(float RemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NecroTormentedSoulProjectivePassive", "OnProjectileApex");

	Params::NecroTormentedSoulProjectivePassive_OnProjectileApex Parms{};

	Parms.RemainingTime = RemainingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NecroTormentedSoul.BPPrecursorToggled
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStarted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PrecursorLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNecroTormentedSoul::BPPrecursorToggled(int32 Index_0, bool bStarted, const struct FVector& PrecursorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NecroTormentedSoul", "BPPrecursorToggled");

	Params::NecroTormentedSoul_BPPrecursorToggled Parms{};

	Parms.Index_0 = Index_0;
	Parms.bStarted = bStarted;
	Parms.PrecursorLocation = std::move(PrecursorLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NecroAscendDescend.OnLanded
// (Final, Native, Public)

void UNecroAscendDescend::OnLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NecroAscendDescend", "OnLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NetherBlades.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNetherBlades::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetherBlades", "DamageDealt");

	Params::NetherBlades_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NetherBlades.GetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UNetherBlades::GetTargetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetherBlades", "GetTargetRotation");

	Params::NetherBlades_GetTargetRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.NetherwalkPassive.DamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UNetherwalkPassive::DamageReceived(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetherwalkPassive", "DamageReceived");

	Params::NetherwalkPassive_DamageReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.NewGameUserWidget.CloseBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UNewGameUserWidget::CloseBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewGameUserWidget", "CloseBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NewGameUserWidget.OnDeleteSaveGame
// (Final, Native, Protected)
// Parameters:
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNewGameUserWidget::OnDeleteSaveGame(bool bSucceeded, int32 SlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewGameUserWidget", "OnDeleteSaveGame");

	Params::NewGameUserWidget_OnDeleteSaveGame Parms{};

	Parms.bSucceeded = bSucceeded;
	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NewGameUserWidget.OnDialogueOverwriteSavedGameResult
// (Final, Native, Protected)
// Parameters:
// EDialogueButtonType                     ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNewGameUserWidget::OnDialogueOverwriteSavedGameResult(EDialogueButtonType ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewGameUserWidget", "OnDialogueOverwriteSavedGameResult");

	Params::NewGameUserWidget_OnDialogueOverwriteSavedGameResult Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NewGameUserWidget.SelectBtnClicked
// (Final, Native, Public, BlueprintCallable)

void UNewGameUserWidget::SelectBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NewGameUserWidget", "SelectBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SunderAbility.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USunderAbility::AddIgnoredActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SunderAbility", "AddIgnoredActor");

	Params::SunderAbility_AddIgnoredActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SunderAbility.PostDamageCasued
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USunderAbility::PostDamageCasued(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SunderAbility", "PostDamageCasued");

	Params::SunderAbility_PostDamageCasued Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SunderAbility.PreDamageCasued
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USunderAbility::PreDamageCasued(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SunderAbility", "PreDamageCasued");

	Params::SunderAbility_PreDamageCasued Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.NpcAnimInstance.PickIdle
// (Final, Native, Protected, BlueprintCallable)

void UNpcAnimInstance::PickIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "PickIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NpcAnimInstance.PickIdleBridge
// (Final, Native, Protected, BlueprintCallable)

void UNpcAnimInstance::PickIdleBridge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "PickIdleBridge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NpcAnimInstance.SetLookRange
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LookRangeMin                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookRangeMax                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookRangeHoldMin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookRangeHoldMax                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAnimInstance::SetLookRange(const struct FVector& LookRangeMin, const struct FVector& LookRangeMax, const struct FVector& LookRangeHoldMin, const struct FVector& LookRangeHoldMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "SetLookRange");

	Params::NpcAnimInstance_SetLookRange Parms{};

	Parms.LookRangeMin = std::move(LookRangeMin);
	Parms.LookRangeMax = std::move(LookRangeMax);
	Parms.LookRangeHoldMin = std::move(LookRangeHoldMin);
	Parms.LookRangeHoldMax = std::move(LookRangeHoldMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NpcAnimInstance.StartConversation
// (Final, Native, Public, BlueprintCallable)

void UNpcAnimInstance::StartConversation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "StartConversation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NpcAnimInstance.StopConversation
// (Final, Native, Public, BlueprintCallable)

void UNpcAnimInstance::StopConversation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "StopConversation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryBtnUserWidget.OnSetSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInNewRegistry                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryBtnUserWidget::OnSetSlot(const class FText& InName, bool bInNewRegistry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryBtnUserWidget", "OnSetSlot");

	Params::NPCBestiaryBtnUserWidget_OnSetSlot Parms{};

	Parms.InName = std::move(InName);
	Parms.bInNewRegistry = bInNewRegistry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiarySectionUserWidget.OnSetSlot
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InKillRequirement                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInSectionHidden                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiarySectionUserWidget::OnSetSlot(int32 InKillRequirement, bool bInSectionHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiarySectionUserWidget", "OnSetSlot");

	Params::NPCBestiarySectionUserWidget_OnSetSlot Parms{};

	Parms.InKillRequirement = InKillRequirement;
	Parms.bInSectionHidden = bInSectionHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryUserWidget.BPSetFilter
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EBestiaryCategory                       InBestiaryCategoryFilter                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::BPSetFilter(EBestiaryCategory InBestiaryCategoryFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "BPSetFilter");

	Params::NPCBestiaryUserWidget_BPSetFilter Parms{};

	Parms.InBestiaryCategoryFilter = InBestiaryCategoryFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.GetEntropyTexture
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UNPCBestiaryUserWidget::GetEntropyTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "GetEntropyTexture");

	Params::NPCBestiaryUserWidget_GetEntropyTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.NPCBestiaryUserWidget.JumpToNextFilter
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::JumpToNextFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "JumpToNextFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.JumpToNextPage
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::JumpToNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "JumpToNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.JumpToPrevFilter
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bSelectLastPage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::JumpToPrevFilter(bool bSelectLastPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "JumpToPrevFilter");

	Params::NPCBestiaryUserWidget_JumpToPrevFilter Parms{};

	Parms.bSelectLastPage = bSelectLastPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.JumpToPreviousPage
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::JumpToPreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "JumpToPreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.NavigateDown
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::NavigateDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "NavigateDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.NavigateLeft
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::NavigateLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "NavigateLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.NavigateRight
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::NavigateRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "NavigateRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.NavigateUp
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::NavigateUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "NavigateUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.NPCBestiaryUserWidget.OnSetFilter
// (Event, Protected, BlueprintEvent)
// Parameters:
// EBestiaryCategory                       InBestiaryCategoryFilter                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::OnSetFilter(EBestiaryCategory InBestiaryCategoryFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "OnSetFilter");

	Params::NPCBestiaryUserWidget_OnSetFilter Parms{};

	Parms.InBestiaryCategoryFilter = InBestiaryCategoryFilter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryUserWidget.OnSetNextBtnState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::OnSetNextBtnState(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "OnSetNextBtnState");

	Params::NPCBestiaryUserWidget_OnSetNextBtnState Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryUserWidget.OnSetPrevBtnState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::OnSetPrevBtnState(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "OnSetPrevBtnState");

	Params::NPCBestiaryUserWidget_OnSetPrevBtnState Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryUserWidget.OnUpdateBestiaryPanels
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       InPicture                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InKillNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InKillNumRequestForNextSection                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InPageNumber                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNPCBestiaryUserWidget::OnUpdateBestiaryPanels(const class FText& InName, const class FText& InDescription, const class UTexture2D* InPicture, int32 InKillNum, const class FText& InKillNumRequestForNextSection, const class FText& InPageNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "OnUpdateBestiaryPanels");

	Params::NPCBestiaryUserWidget_OnUpdateBestiaryPanels Parms{};

	Parms.InName = std::move(InName);
	Parms.InDescription = std::move(InDescription);
	Parms.InPicture = InPicture;
	Parms.InKillNum = InKillNum;
	Parms.InKillNumRequestForNextSection = std::move(InKillNumRequestForNextSection);
	Parms.InPageNumber = std::move(InPageNumber);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.NPCBestiaryUserWidget.SelectBtnClicked
// (Final, Native, Protected, BlueprintCallable)

void UNPCBestiaryUserWidget::SelectBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBestiaryUserWidget", "SelectBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorEnchantUserWidget.AddItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorEnchantUserWidget::AddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "AddItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorEnchantUserWidget.OnApplyEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnApplyEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnApplyEnchant");

	Params::VendorEnchantUserWidget_OnApplyEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorEnchantUserWidget.OnDestroyRune
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       DestroyRuneIcon                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnDestroyRune(const class UTexture2D* DestroyRuneIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnDestroyRune");

	Params::VendorEnchantUserWidget_OnDestroyRune Parms{};

	Parms.DestroyRuneIcon = DestroyRuneIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnRemoveEnchant
// (Final, Native, Protected)
// Parameters:
// class UItemAbility*                     TargetItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItemEnchantItemAbility>Enchant                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnRemoveEnchant(class UItemAbility* TargetItem, TSubclassOf<class UItemEnchantItemAbility> Enchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnRemoveEnchant");

	Params::VendorEnchantUserWidget_OnRemoveEnchant Parms{};

	Parms.TargetItem = TargetItem;
	Parms.Enchant = Enchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorEnchantUserWidget.OnSetEnchantText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             EnchantName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             EnchantDescription                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnSetEnchantText(const class FText& EnchantName, const class FText& EnchantDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnSetEnchantText");

	Params::VendorEnchantUserWidget_OnSetEnchantText Parms{};

	Parms.EnchantName = std::move(EnchantName);
	Parms.EnchantDescription = std::move(EnchantDescription);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnSetItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UItemAbility*                     Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnSetItem(class UItemAbility* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnSetItem");

	Params::VendorEnchantUserWidget_OnSetItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnSetRightPanelSlots
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UItemAbility*                     UpgradeItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     RuneStoneItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnSetRightPanelSlots(class UItemAbility* UpgradeItem, class UItemAbility* RuneStoneItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnSetRightPanelSlots");

	Params::VendorEnchantUserWidget_OnSetRightPanelSlots Parms{};

	Parms.UpgradeItem = UpgradeItem;
	Parms.RuneStoneItem = RuneStoneItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnSetRuneStone
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UItemAbility*                     RuneStoneItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnSetRuneStone(class UItemAbility* RuneStoneItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnSetRuneStone");

	Params::VendorEnchantUserWidget_OnSetRuneStone Parms{};

	Parms.RuneStoneItem = RuneStoneItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnUpdateUpgradeItemDetailsPanel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemRequirementText                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InComparedItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InEnchantItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipped                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnUpdateUpgradeItemDetailsPanel(const class FText& ItemRequirementText, class UItemAbility* InItem, class UItemAbility* InComparedItem, class UItemAbility* InEnchantItem, bool bEquipped, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnUpdateUpgradeItemDetailsPanel");

	Params::VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel Parms{};

	Parms.ItemRequirementText = std::move(ItemRequirementText);
	Parms.InItem = InItem;
	Parms.InComparedItem = InComparedItem;
	Parms.InEnchantItem = InEnchantItem;
	Parms.bEquipped = bEquipped;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.OnUpgradeItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       UpgradeItemIcon                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       UpgradeRuneStoneIcon                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorEnchantUserWidget::OnUpgradeItem(const class UTexture2D* UpgradeItemIcon, const class UTexture2D* UpgradeRuneStoneIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "OnUpgradeItem");

	Params::VendorEnchantUserWidget_OnUpgradeItem Parms{};

	Parms.UpgradeItemIcon = UpgradeItemIcon;
	Parms.UpgradeRuneStoneIcon = UpgradeRuneStoneIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorEnchantUserWidget.RemoveItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorEnchantUserWidget::RemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "RemoveItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorEnchantUserWidget.GetEnchantItemCalculatedXPText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorEnchantUserWidget::GetEnchantItemCalculatedXPText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "GetEnchantItemCalculatedXPText");

	Params::VendorEnchantUserWidget_GetEnchantItemCalculatedXPText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorEnchantUserWidget.GetEnchantItemCalculatedXPValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVendorEnchantUserWidget::GetEnchantItemCalculatedXPValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorEnchantUserWidget", "GetEnchantItemCalculatedXPValue");

	Params::VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OpportunistWeakPointPassive.DamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOpportunistWeakPointPassive::DamageReceived(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OpportunistWeakPointPassive", "DamageReceived");

	Params::OpportunistWeakPointPassive_DamageReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.OptionsButtonUserWidget.GetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOptionsButtonUserWidget::GetIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsButtonUserWidget", "GetIndex");

	Params::OptionsButtonUserWidget_GetIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsButtonUserWidget.OnSetDisplayName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InDisplayName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsButtonUserWidget::OnSetDisplayName(const class FText& InDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsButtonUserWidget", "OnSetDisplayName");

	Params::OptionsButtonUserWidget_OnSetDisplayName Parms{};

	Parms.InDisplayName = std::move(InDisplayName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsGeneralUserWidget.SetTextLanguageIndex
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   TextLanguageIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsGeneralUserWidget::SetTextLanguageIndex(int32 TextLanguageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsGeneralUserWidget", "SetTextLanguageIndex");

	Params::OptionsGeneralUserWidget_SetTextLanguageIndex Parms{};

	Parms.TextLanguageIndex = TextLanguageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsKeyBindingsUserWidget.OnFocusedHotkeySelected
// (Event, Protected, BlueprintEvent)

void UOptionsKeyBindingsUserWidget::OnFocusedHotkeySelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsKeyBindingsUserWidget", "OnFocusedHotkeySelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsKeyBindingsUserWidget.OnSetUnboundText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InUnboundText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsKeyBindingsUserWidget::OnSetUnboundText(const class FText& InUnboundText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsKeyBindingsUserWidget", "OnSetUnboundText");

	Params::OptionsKeyBindingsUserWidget_OnSetUnboundText Parms{};

	Parms.InUnboundText = std::move(InUnboundText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsKeyBindingsUserWidget.SelectFocusedHotkey
// (Final, Native, Protected, BlueprintCallable)

void UOptionsKeyBindingsUserWidget::SelectFocusedHotkey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsKeyBindingsUserWidget", "SelectFocusedHotkey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsKeyBindingsUserWidget.SetMainWindowWidgetsZorder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWidgetsZorder                          InMainWindowWidgetsZorder                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsKeyBindingsUserWidget::SetMainWindowWidgetsZorder(EWidgetsZorder InMainWindowWidgetsZorder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsKeyBindingsUserWidget", "SetMainWindowWidgetsZorder");

	Params::OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder Parms{};

	Parms.InMainWindowWidgetsZorder = InMainWindowWidgetsZorder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.JumpToNextOption
// (Final, Native, Public, BlueprintCallable)

void UOptionsSelectorUserWidget::JumpToNextOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "JumpToNextOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.JumpToPrevOption
// (Final, Native, Public, BlueprintCallable)

void UOptionsSelectorUserWidget::JumpToPrevOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "JumpToPrevOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.OnJumpToNextOption
// (Event, Protected, BlueprintEvent)

void UOptionsSelectorUserWidget::OnJumpToNextOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnJumpToNextOption");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsSelectorUserWidget.OnJumpToPrevOption
// (Event, Protected, BlueprintEvent)

void UOptionsSelectorUserWidget::OnJumpToPrevOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnJumpToPrevOption");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.OptionsSelectorUserWidget.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::OnSetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnSetActive");

	Params::OptionsSelectorUserWidget_OnSetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSelectorUserWidget.OnSetDisplayName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InDisplayName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::OnSetDisplayName(const class FText& InDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnSetDisplayName");

	Params::OptionsSelectorUserWidget_OnSetDisplayName Parms{};

	Parms.InDisplayName = std::move(InDisplayName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSelectorUserWidget.OnSetHasChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInHasChanged                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::OnSetHasChanged(bool bInHasChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnSetHasChanged");

	Params::OptionsSelectorUserWidget_OnSetHasChanged Parms{};

	Parms.bInHasChanged = bInHasChanged;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSelectorUserWidget.OnSetSelectedIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InSelectedIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::OnSetSelectedIndex(int32 InSelectedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "OnSetSelectedIndex");

	Params::OptionsSelectorUserWidget_OnSetSelectedIndex Parms{};

	Parms.InSelectedIndex = InSelectedIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSelectorUserWidget.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::SetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "SetActive");

	Params::OptionsSelectorUserWidget_SetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.SetSelectedIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSelectedIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::SetSelectedIndex(int32 InSelectedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "SetSelectedIndex");

	Params::OptionsSelectorUserWidget_SetSelectedIndex Parms{};

	Parms.InSelectedIndex = InSelectedIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.ValueChanged
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSelectorUserWidget::ValueChanged(int32 NewIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "ValueChanged");

	Params::OptionsSelectorUserWidget_ValueChanged Parms{};

	Parms.NewIndex = NewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSelectorUserWidget.GetOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FText>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FText> UOptionsSelectorUserWidget::GetOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "GetOptions");

	Params::OptionsSelectorUserWidget_GetOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSelectorUserWidget.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsSelectorUserWidget::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSelectorUserWidget", "IsActive");

	Params::OptionsSelectorUserWidget_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingObject_Glicko.SetRating
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URatingObject_Glicko::SetRating(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "SetRating");

	Params::RatingObject_Glicko_SetRating Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingObject_Glicko.SetRatingsDeviation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URatingObject_Glicko::SetRatingsDeviation(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "SetRatingsDeviation");

	Params::RatingObject_Glicko_SetRatingsDeviation Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingObject_Glicko.UpdateToTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialRatingsDeviation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeviationChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URatingObject_Glicko::UpdateToTime(float Timestamp, float InitialRatingsDeviation, float DeviationChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "UpdateToTime");

	Params::RatingObject_Glicko_UpdateToTime Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InitialRatingsDeviation = InitialRatingsDeviation;
	Parms.DeviationChange = DeviationChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingObject_Glicko.GetRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingObject_Glicko::GetRating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "GetRating");

	Params::RatingObject_Glicko_GetRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingObject_Glicko.GetRatingsDeviation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingObject_Glicko::GetRatingsDeviation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "GetRatingsDeviation");

	Params::RatingObject_Glicko_GetRatingsDeviation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingObject_Glicko.GetRatingValue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URatingObject_Glicko::GetRatingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObject_Glicko", "GetRatingValue");

	Params::RatingObject_Glicko_GetRatingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSliderUserWidget.Decrease
// (Final, Native, Protected)

void UOptionsSliderUserWidget::Decrease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "Decrease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.GetOptionsType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOptionsType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionsType UOptionsSliderUserWidget::GetOptionsType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "GetOptionsType");

	Params::OptionsSliderUserWidget_GetOptionsType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSliderUserWidget.Increase
// (Final, Native, Protected)

void UOptionsSliderUserWidget::Increase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "Increase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.OnMouseCaptureBegin
// (Final, Native, Protected)

void UOptionsSliderUserWidget::OnMouseCaptureBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "OnMouseCaptureBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.OnMouseCaptureEnd
// (Final, Native, Protected)

void UOptionsSliderUserWidget::OnMouseCaptureEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "OnMouseCaptureEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::OnSetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "OnSetActive");

	Params::OptionsSliderUserWidget_OnSetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSliderUserWidget.OnSetDisplayName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InDisplayName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::OnSetDisplayName(const class FText& InDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "OnSetDisplayName");

	Params::OptionsSliderUserWidget_OnSetDisplayName Parms{};

	Parms.InDisplayName = std::move(InDisplayName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSliderUserWidget.OnSetValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::OnSetValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "OnSetValue");

	Params::OptionsSliderUserWidget_OnSetValue Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OptionsSliderUserWidget.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::SetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "SetActive");

	Params::OptionsSliderUserWidget_SetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayAkEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::SetValue(float InValue, bool bPlayAkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "SetValue");

	Params::OptionsSliderUserWidget_SetValue Parms{};

	Parms.InValue = InValue;
	Parms.bPlayAkEvent = bPlayAkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.ValueChanged
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsSliderUserWidget::ValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "ValueChanged");

	Params::OptionsSliderUserWidget_ValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OptionsSliderUserWidget.GetDisplayValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOptionsSliderUserWidget::GetDisplayValue(float InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "GetDisplayValue");

	Params::OptionsSliderUserWidget_GetDisplayValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSliderUserWidget.GetPercentValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOptionsSliderUserWidget::GetPercentValue(float InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "GetPercentValue");

	Params::OptionsSliderUserWidget_GetPercentValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsSliderUserWidget.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOptionsSliderUserWidget::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsSliderUserWidget", "IsActive");

	Params::OptionsSliderUserWidget_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.OptionsVideoAdvancedUserWidget.OnSetVramText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             VRamText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionsVideoAdvancedUserWidget::OnSetVramText(const class FText& VRamText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsVideoAdvancedUserWidget", "OnSetVramText");

	Params::OptionsVideoAdvancedUserWidget_OnSetVramText Parms{};

	Parms.VRamText = std::move(VRamText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OrbOfDoomAbility.OnProjectileEvent
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrbOfDoomAbility::OnProjectileEvent(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrbOfDoomAbility", "OnProjectileEvent");

	Params::OrbOfDoomAbility_OnProjectileEvent Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OrbOfDoomAbility.PreDamageDealt
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrbOfDoomAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrbOfDoomAbility", "PreDamageDealt");

	Params::OrbOfDoomAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ParryAbility.OnPreDamagedPriority
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UParryAbility::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParryAbility", "OnPreDamagedPriority");

	Params::ParryAbility_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.PauseMenuUserWidget.ContinueBtnClicked
// (Final, Native, Protected, BlueprintCallable)

void UPauseMenuUserWidget::ContinueBtnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "ContinueBtnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PauseMenuUserWidget.ExitToDesktop
// (Final, Native, Protected, BlueprintCallable)

void UPauseMenuUserWidget::ExitToDesktop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "ExitToDesktop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PauseMenuUserWidget.ExitToMainMenu
// (Final, Native, Protected, BlueprintCallable)

void UPauseMenuUserWidget::ExitToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "ExitToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PauseMenuUserWidget.IsControllerSchemeVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPauseMenuUserWidget::IsControllerSchemeVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "IsControllerSchemeVisible");

	Params::PauseMenuUserWidget_IsControllerSchemeVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PauseMenuUserWidget.OnDoubleJumpUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuUserWidget::OnDoubleJumpUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "OnDoubleJumpUnlock");

	Params::PauseMenuUserWidget_OnDoubleJumpUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PauseMenuUserWidget.OnGlideUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuUserWidget::OnGlideUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "OnGlideUnlock");

	Params::PauseMenuUserWidget_OnGlideUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PauseMenuUserWidget.OnGrapplingHookUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuUserWidget::OnGrapplingHookUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "OnGrapplingHookUnlock");

	Params::PauseMenuUserWidget_OnGrapplingHookUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PauseMenuUserWidget.OnGroundSlamUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuUserWidget::OnGroundSlamUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "OnGroundSlamUnlock");

	Params::PauseMenuUserWidget_OnGroundSlamUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PauseMenuUserWidget.OnSetQuickUseDefault
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bQuickUseDefault                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuUserWidget::OnSetQuickUseDefault(bool bQuickUseDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuUserWidget", "OnSetQuickUseDefault");

	Params::PauseMenuUserWidget_OnSetQuickUseDefault Parms{};

	Parms.bQuickUseDefault = bQuickUseDefault;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.MoveAblePlatformActor.OnBeginOverlapInterior
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMoveAblePlatformActor::OnBeginOverlapInterior(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAblePlatformActor", "OnBeginOverlapInterior");

	Params::MoveAblePlatformActor_OnBeginOverlapInterior Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MoveAblePlatformActor.OnEndOverlapInterior
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMoveAblePlatformActor::OnEndOverlapInterior(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAblePlatformActor", "OnEndOverlapInterior");

	Params::MoveAblePlatformActor_OnEndOverlapInterior Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.MoveAblePlatformActor.OnMatchHasStarted
// (Final, Native, Public)

void AMoveAblePlatformActor::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAblePlatformActor", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PlatfromMoverComponent.TriggerBoxActivated
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               InAbilityController                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEventID*                 _GameplayEventID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorSoul*                       paramActorSoul                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatfromMoverComponent::TriggerBoxActivated(class UAbilityController* InAbilityController, class UGameplayEventID* _GameplayEventID, class FName CustomName, class AActorSoul* paramActorSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatfromMoverComponent", "TriggerBoxActivated");

	Params::PlatfromMoverComponent_TriggerBoxActivated Parms{};

	Parms.InAbilityController = InAbilityController;
	Parms._GameplayEventID = _GameplayEventID;
	Parms.CustomName = CustomName;
	Parms.paramActorSoul = paramActorSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PlatformMoverVolume.OnBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlatformMoverVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformMoverVolume", "OnBeginOverlap");

	Params::PlatformMoverVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PlatformMoverVolume.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlatformMoverVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformMoverVolume", "OnEndOverlap");

	Params::PlatformMoverVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PlayerMonologueUserWidget.OnPlayVideo
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           VideoUrl                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMonologueUserWidget::OnPlayVideo(const class FString& VideoUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMonologueUserWidget", "OnPlayVideo");

	Params::PlayerMonologueUserWidget_OnPlayVideo Parms{};

	Parms.VideoUrl = std::move(VideoUrl);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerMonologueUserWidget.OnSetPicture
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Picture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMonologueUserWidget::OnSetPicture(class UTexture2D* Picture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMonologueUserWidget", "OnSetPicture");

	Params::PlayerMonologueUserWidget_OnSetPicture Parms{};

	Parms.Picture = Picture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerMonologueUserWidget.OnShowText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InLineIDText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSubtitleEnable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMonologueUserWidget::OnShowText(const class FText& InText, const class FText& InLineIDText, bool bSubtitleEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMonologueUserWidget", "OnShowText");

	Params::PlayerMonologueUserWidget_OnShowText Parms{};

	Parms.InText = std::move(InText);
	Parms.InLineIDText = std::move(InLineIDText);
	Parms.bSubtitleEnable = bSubtitleEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerStatsStatUserWidget.OnSetCaption
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InCaption                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerStatsStatUserWidget::OnSetCaption(const class FText& InCaption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsStatUserWidget", "OnSetCaption");

	Params::PlayerStatsStatUserWidget_OnSetCaption Parms{};

	Parms.InCaption = std::move(InCaption);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerStatsStatUserWidget.OnSetHidden
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsStatUserWidget::OnSetHidden(bool bInHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsStatUserWidget", "OnSetHidden");

	Params::PlayerStatsStatUserWidget_OnSetHidden Parms{};

	Parms.bInHidden = bInHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PlayerStatsStatUserWidget.OnSetValue
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InValue                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerStatsStatUserWidget::OnSetValue(const class FText& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsStatUserWidget", "OnSetValue");

	Params::PlayerStatsStatUserWidget_OnSetValue Parms{};

	Parms.InValue = std::move(InValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.LevelToModifierElement.GetEditorName
// (Final, Native, Private)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULevelToModifierElement::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelToModifierElement", "GetEditorName");

	Params::LevelToModifierElement_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PoseableMeshActor.BPOnTeleportedBack
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TeleporterActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableMeshActor::BPOnTeleportedBack(class AActor* TeleporterActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableMeshActor", "BPOnTeleportedBack");

	Params::PoseableMeshActor_BPOnTeleportedBack Parms{};

	Parms.TeleporterActor = TeleporterActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PoseableMeshActor.BPTakeFormOf
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToShapeInto                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableMeshActor::BPTakeFormOf(class AActor* ActorToShapeInto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableMeshActor", "BPTakeFormOf");

	Params::PoseableMeshActor_BPTakeFormOf Parms{};

	Parms.ActorToShapeInto = ActorToShapeInto;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.PowerVacuumPassive.EnergyUsed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEntityProperty                         resource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerVacuumPassive::EnergyUsed(EEntityProperty resource, float* amount, class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerVacuumPassive", "EnergyUsed");

	Params::PowerVacuumPassive_EnergyUsed Parms{};

	Parms.resource = resource;
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (amount != nullptr)
		*amount = Parms.amount;
}


// Function man.PowerVacuumPassive.ResetBuff
// (Final, Native, Public)

void UPowerVacuumPassive::ResetBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerVacuumPassive", "ResetBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.ConcentrationPassive.OnPostDamaged_Concentration
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UConcentrationPassive::OnPostDamaged_Concentration(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationPassive", "OnPostDamaged_Concentration");

	Params::ConcentrationPassive_OnPostDamaged_Concentration Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ConcentrationPassive.OnWorldRespawn
// (Final, Native, Public)

void UConcentrationPassive::OnWorldRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConcentrationPassive", "OnWorldRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.QuickChargePassive.PropertyChanged
// (Final, Native, Public)
// Parameters:
// EHeroProperty                           PropertyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RoundedFloatValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoundedIntValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuickChargePassive::PropertyChanged(EHeroProperty PropertyType, float Value, float RoundedFloatValue, int32 RoundedIntValue, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuickChargePassive", "PropertyChanged");

	Params::QuickChargePassive_PropertyChanged Parms{};

	Parms.PropertyType = PropertyType;
	Parms.Value = Value;
	Parms.RoundedFloatValue = RoundedFloatValue;
	Parms.RoundedIntValue = RoundedIntValue;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ThornDanceDamager.ThornTriggered
// (Event, Public, BlueprintEvent)

void AThornDanceDamager::ThornTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThornDanceDamager", "ThornTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.PrimalMath.Compare_CaseNotEqualUClass
// (Final, Native, Static, Public)
// Parameters:
// class UClass*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimalMath::Compare_CaseNotEqualUClass(class UClass* A, class UClass* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "Compare_CaseNotEqualUClass");

	Params::PrimalMath_Compare_CaseNotEqualUClass Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.Compare_CaseNotEqualUObject
// (Final, Native, Static, Public)
// Parameters:
// class UObject*                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimalMath::Compare_CaseNotEqualUObject(class UObject* A, class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "Compare_CaseNotEqualUObject");

	Params::PrimalMath_Compare_CaseNotEqualUObject Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.GetRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::GetRatio(float X, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "GetRatio");

	Params::PrimalMath_GetRatio Parms{};

	Parms.X = X;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.Interpolate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::Interpolate(float Current, float Target, float DeltaTime, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "Interpolate");

	Params::PrimalMath_Interpolate Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.InterpolateBySpeed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::InterpolateBySpeed(float Current, float Target, float DeltaTime, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "InterpolateBySpeed");

	Params::PrimalMath_InterpolateBySpeed Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.SmootherStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::SmootherStep(float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "SmootherStep");

	Params::PrimalMath_SmootherStep Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.SmoothSinStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::SmoothSinStep(float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "SmoothSinStep");

	Params::PrimalMath_SmoothSinStep Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalMath.SmoothStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimalMath::SmoothStep(float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalMath", "SmoothStep");

	Params::PrimalMath_SmoothStep Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalSlotHandler.ActivateSlotItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaterialName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimalSlotHandler::ActivateSlotItem(const class FName& SlotName, const class FName& MaterialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "ActivateSlotItem");

	Params::PrimalSlotHandler_ActivateSlotItem Parms{};

	Parms.SlotName = SlotName;
	Parms.MaterialName = MaterialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PrimalSlotHandler.ActivateSlotItemByMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                MaterialInstance                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimalSlotHandler::ActivateSlotItemByMaterial(const class FName& SlotName, const class UMaterialInstance* MaterialInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "ActivateSlotItemByMaterial");

	Params::PrimalSlotHandler_ActivateSlotItemByMaterial Parms{};

	Parms.SlotName = SlotName;
	Parms.MaterialInstance = MaterialInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PrimalSlotHandler.ActivateSlotItemByMaterialOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                MaterialInstance                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimalSlotHandler::ActivateSlotItemByMaterialOnly(const class UMaterialInstance* MaterialInstance, bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "ActivateSlotItemByMaterialOnly");

	Params::PrimalSlotHandler_ActivateSlotItemByMaterialOnly Parms{};

	Parms.MaterialInstance = MaterialInstance;
	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PrimalSlotHandler.GetSlotIndexByMaterialOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                MaterialInstance                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrimalSlotHandler::GetSlotIndexByMaterialOnly(const class UMaterialInstance* MaterialInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "GetSlotIndexByMaterialOnly");

	Params::PrimalSlotHandler_GetSlotIndexByMaterialOnly Parms{};

	Parms.MaterialInstance = MaterialInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalSlotHandler.GetSlotIndexByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrimalSlotHandler::GetSlotIndexByName(const class FName& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "GetSlotIndexByName");

	Params::PrimalSlotHandler_GetSlotIndexByName Parms{};

	Parms.SlotName = SlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalSlotHandler.GetActiveSlotItemsMaterialName
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// class FName                             SlotName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPrimalSlotHandler::GetActiveSlotItemsMaterialName(const class FName& SlotName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "GetActiveSlotItemsMaterialName");

	Params::PrimalSlotHandler_GetActiveSlotItemsMaterialName Parms{};

	Parms.SlotName = SlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalSlotHandler.GetSlotRules
// (Final, Native, Public, Const)
// Parameters:
// const TArray<struct FPrimalSlotRule>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FPrimalSlotRule> UPrimalSlotHandler::GetSlotRules() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "GetSlotRules");

	Params::PrimalSlotHandler_GetSlotRules Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalSlotHandler.GetSlots
// (Final, Native, Public, Const)
// Parameters:
// const TArray<struct FPrimalSlot>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<struct FPrimalSlot> UPrimalSlotHandler::GetSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrimalSlotHandler", "GetSlots");

	Params::PrimalSlotHandler_GetSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetChangeListVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPrimalVersion::GetChangeListVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetChangeListVersion");

	Params::PrimalVersion_GetChangeListVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetHotfixVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPrimalVersion::GetHotfixVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetHotfixVersion");

	Params::PrimalVersion_GetHotfixVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetMajorVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPrimalVersion::GetMajorVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetMajorVersion");

	Params::PrimalVersion_GetMajorVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetMinorVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UPrimalVersion::GetMinorVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetMinorVersion");

	Params::PrimalVersion_GetMinorVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPrimalVersion::GetTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetTag");

	Params::PrimalVersion_GetTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrimalVersion.GetVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPrimalVersion::GetVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PrimalVersion", "GetVersion");

	Params::PrimalVersion_GetVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkeletonRise.OnDeath
// (Final, Native, Public)

void USkeletonRise::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkeletonRise", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PrismAbility.DamageCaused
// (Final, Native, Public)
// Parameters:
// int32                                   DamageGroupID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDamageValue>             DamageValues                                           (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPrismAbility::DamageCaused(int32 DamageGroupID, class AActor* Source, class AActor* DamageTarget, const TArray<struct FDamageValue>& DamageValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "DamageCaused");

	Params::PrismAbility_DamageCaused Parms{};

	Parms.DamageGroupID = DamageGroupID;
	Parms.Source = Source;
	Parms.DamageTarget = DamageTarget;
	Parms.DamageValues = std::move(DamageValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PrismAbility.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPrismAbility::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "DamageDealt");

	Params::PrismAbility_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PrismAbility.EnableSkillQueue
// (Final, Native, Public)

void UPrismAbility::EnableSkillQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "EnableSkillQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PrismAbility.GetCurrentDamageCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrismAbility::GetCurrentDamageCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "GetCurrentDamageCharge");

	Params::PrismAbility_GetCurrentDamageCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrismAbility.GetCurrentPulseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrismAbility::GetCurrentPulseCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "GetCurrentPulseCount");

	Params::PrismAbility_GetCurrentPulseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrismAbility.GetLastDamagedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UPrismAbility::GetLastDamagedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "GetLastDamagedActor");

	Params::PrismAbility_GetLastDamagedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrismAbility.GetMaxDamageCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrismAbility::GetMaxDamageCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "GetMaxDamageCharge");

	Params::PrismAbility_GetMaxDamageCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrismAbility.IsPrimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrismAbility::IsPrimed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "IsPrimed");

	Params::PrismAbility_IsPrimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PrismAbility.OnStaggerOrStun
// (Final, Native, Public)

void UPrismAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PrismAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PushAbility.BPGetCurrentPushObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UPushAbility::BPGetCurrentPushObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushAbility", "BPGetCurrentPushObject");

	Params::PushAbility_BPGetCurrentPushObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PushAbility.InteractReleased
// (Final, Native, Public)

void UPushAbility::InteractReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushAbility", "InteractReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.PutridGhoulAI.GetStaminaDrainSourceVFX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UPutridGhoulAI::GetStaminaDrainSourceVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PutridGhoulAI", "GetStaminaDrainSourceVFX");

	Params::PutridGhoulAI_GetStaminaDrainSourceVFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.PutridGhoulAI.OnGhoulDamageTaken
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               TargetArg                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPutridGhoulAI::OnGhoulDamageTaken(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* TargetArg, class UAbilityBase* Ability, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PutridGhoulAI", "OnGhoulDamageTaken");

	Params::PutridGhoulAI_OnGhoulDamageTaken Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.TargetArg = TargetArg;
	Parms.Ability = Ability;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestItemUserWidget.OnSetAmount
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestItemUserWidget::OnSetAmount(int32 InAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestItemUserWidget", "OnSetAmount");

	Params::QuestItemUserWidget_OnSetAmount Parms{};

	Parms.InAmount = InAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestItemUserWidget.OnSetEssence
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             EssenceText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestItemUserWidget::OnSetEssence(const class FText& EssenceText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestItemUserWidget", "OnSetEssence");

	Params::QuestItemUserWidget_OnSetEssence Parms{};

	Parms.EssenceText = std::move(EssenceText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestItemUserWidget.OnSetGold
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             GoldText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestItemUserWidget::OnSetGold(const class FText& GoldText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestItemUserWidget", "OnSetGold");

	Params::QuestItemUserWidget_OnSetGold Parms{};

	Parms.GoldText = std::move(GoldText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestItemUserWidget.OnSetItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemAbility*                     InItemAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestItemUserWidget::OnSetItem(class UItemAbility* InItemAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestItemUserWidget", "OnSetItem");

	Params::QuestItemUserWidget_OnSetItem Parms{};

	Parms.InItemAbility = InItemAbility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestListCategoryUserWidget.OnSetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InIsCollapsed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestListCategoryUserWidget::OnSetState(bool InIsCollapsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListCategoryUserWidget", "OnSetState");

	Params::QuestListCategoryUserWidget_OnSetState Parms{};

	Parms.InIsCollapsed = InIsCollapsed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestListCategoryUserWidget.TriggerClicked
// (Final, Native, Protected, BlueprintCallable)

void UQuestListCategoryUserWidget::TriggerClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListCategoryUserWidget", "TriggerClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SmartTextTemplateBase.GetEditorName
// (Final, Native, Protected, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USmartTextTemplateBase::GetEditorName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmartTextTemplateBase", "GetEditorName");

	Params::SmartTextTemplateBase_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.QuestListItemUserWidget.OnSetName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InQuestName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestListItemUserWidget::OnSetName(const class FText& InQuestName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListItemUserWidget", "OnSetName");

	Params::QuestListItemUserWidget_OnSetName Parms{};

	Parms.InQuestName = std::move(InQuestName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestListItemUserWidget.OnSetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// EQuestState                             InQuestState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestListItemUserWidget::OnSetState(EQuestState InQuestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListItemUserWidget", "OnSetState");

	Params::QuestListItemUserWidget_OnSetState Parms{};

	Parms.InQuestState = InQuestState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestListItemUserWidget.OnSetType
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInMainQuest                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestListItemUserWidget::OnSetType(bool bInMainQuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListItemUserWidget", "OnSetType");

	Params::QuestListItemUserWidget_OnSetType Parms{};

	Parms.bInMainQuest = bInMainQuest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestListItemUserWidget.TriggerClicked
// (Final, Native, Protected, BlueprintCallable)

void UQuestListItemUserWidget::TriggerClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListItemUserWidget", "TriggerClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.QuestObjectiveUserWidget.OnSetCounterText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InCounterText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestObjectiveUserWidget::OnSetCounterText(const class FText& InCounterText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveUserWidget", "OnSetCounterText");

	Params::QuestObjectiveUserWidget_OnSetCounterText Parms{};

	Parms.InCounterText = std::move(InCounterText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestObjectiveUserWidget.OnSetObjectiveState
// (Event, Protected, BlueprintEvent)
// Parameters:
// EQuestState                             InObjectiveState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestObjectiveUserWidget::OnSetObjectiveState(EQuestState InObjectiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveUserWidget", "OnSetObjectiveState");

	Params::QuestObjectiveUserWidget_OnSetObjectiveState Parms{};

	Parms.InObjectiveState = InObjectiveState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.QuestObjectiveUserWidget.OnSetObjectiveText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InObjectiveText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestObjectiveUserWidget::OnSetObjectiveText(const class FText& InObjectiveText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveUserWidget", "OnSetObjectiveText");

	Params::QuestObjectiveUserWidget_OnSetObjectiveText Parms{};

	Parms.InObjectiveText = std::move(InObjectiveText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.RapidFireAbility.OnStaggerOrStun
// (Final, Native, Public)

void URapidFireAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RapidFireAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingObjectInterface.GetRatingValue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IRatingObjectInterface::GetRatingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingObjectInterface", "GetRatingValue");

	Params::RatingObjectInterface_GetRatingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystemInterface.AddMatch
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IRatingObjectInterface>Rating1                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class IRatingObjectInterface>Rating2                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRatingSystemInterface::AddMatch(const TScriptInterface<class IRatingObjectInterface>& Rating1, const TScriptInterface<class IRatingObjectInterface>& Rating2, float Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystemInterface", "AddMatch");

	Params::RatingSystemInterface_AddMatch Parms{};

	Parms.Rating1 = Rating1;
	Parms.Rating2 = Rating2;
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingSystemInterface.CreateRatingObject
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TScriptInterface<class IRatingObjectInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class IRatingObjectInterface> IRatingSystemInterface::CreateRatingObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystemInterface", "CreateRatingObject");

	Params::RatingSystemInterface_CreateRatingObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RatingSystemInterface.Update
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IRatingSystemInterface::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RatingSystemInterface", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RatingSystemLibrary.AddRace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class IRatingSystemInterface>RatingSystem                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<struct FRatingResultCategory>    Results                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URatingSystemLibrary::AddRace(TScriptInterface<class IRatingSystemInterface>& RatingSystem, TArray<struct FRatingResultCategory>& Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RatingSystemLibrary", "AddRace");

	Params::RatingSystemLibrary_AddRace Parms{};

	Parms.RatingSystem = RatingSystem;
	Parms.Results = std::move(Results);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RatingSystem = Parms.RatingSystem;
	Results = std::move(Parms.Results);
}


// Function man.ReactiveBlastAbility.ApplyEffectToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReactiveBlastAbility::ApplyEffectToTarget(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactiveBlastAbility", "ApplyEffectToTarget");

	Params::ReactiveBlastAbility_ApplyEffectToTarget Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ReactiveBlastAbility.DoExplosionOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReactiveBlastAbility::DoExplosionOn(class AEnemyCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactiveBlastAbility", "DoExplosionOn");

	Params::ReactiveBlastAbility_DoExplosionOn Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ReactiveBlastAbility.GetVESourceLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UReactiveBlastAbility::GetVESourceLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactiveBlastAbility", "GetVESourceLocation");

	Params::ReactiveBlastAbility_GetVESourceLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ReactiveBlastAbility.GetVETarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UReactiveBlastAbility::GetVETarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactiveBlastAbility", "GetVETarget");

	Params::ReactiveBlastAbility_GetVETarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ReactiveBlastAbility.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UReactiveBlastAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactiveBlastAbility", "PreDamageDealt");

	Params::ReactiveBlastAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.RelicDischargeAbility.GetCurrentRelicCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URelicDischargeAbility::GetCurrentRelicCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RelicDischargeAbility", "GetCurrentRelicCharge");

	Params::RelicDischargeAbility_GetCurrentRelicCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RelicDischargeAbility.GetMaxRelicCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URelicDischargeAbility::GetMaxRelicCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RelicDischargeAbility", "GetMaxRelicCharge");

	Params::RelicDischargeAbility_GetMaxRelicCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RelicDischargePrepare.OnAbilityStarted
// (Final, Native, Private)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URelicDischargePrepare::OnAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RelicDischargePrepare", "OnAbilityStarted");

	Params::RelicDischargePrepare_OnAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RelicDischargePrepare.OnStaggerOrStun
// (Final, Native, Private)

void URelicDischargePrepare::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RelicDischargePrepare", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RetalentUserWidget.GetEssenceRequired
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URetalentUserWidget::GetEssenceRequired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetalentUserWidget", "GetEssenceRequired");

	Params::RetalentUserWidget_GetEssenceRequired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RetalentUserWidget.OnRetalent
// (Event, Protected, BlueprintEvent)

void URetalentUserWidget::OnRetalent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetalentUserWidget", "OnRetalent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.RetalentUserWidget.OnSetRetalentText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             RetalentText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bDefaultTree                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetalentUserWidget::OnSetRetalentText(const class FText& RetalentText, bool bDefaultTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetalentUserWidget", "OnSetRetalentText");

	Params::RetalentUserWidget_OnSetRetalentText Parms{};

	Parms.RetalentText = std::move(RetalentText);
	Parms.bDefaultTree = bDefaultTree;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.RetreatAttackAbility.IsWarningActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URetreatAttackAbility::IsWarningActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatAttackAbility", "IsWarningActive");

	Params::RetreatAttackAbility_IsWarningActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.RetreatAttackAbility.OnReset
// (Final, Native, Public)

void URetreatAttackAbility::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatAttackAbility", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RetreatAttackAbility.OnStaggerOrStun
// (Final, Native, Public)

void URetreatAttackAbility::OnStaggerOrStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatAttackAbility", "OnStaggerOrStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RetreatAttackAbility.OnTravel
// (Final, Native, Public, HasDefaults)
// Parameters:
// class ALevelVisualVolume*               SourceLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelVisualVolume*               TargetLevelVisualVolume                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetreatAttackAbility::OnTravel(class ALevelVisualVolume* SourceLevelVisualVolume, class ALevelVisualVolume* TargetLevelVisualVolume, const struct FVector& NewPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatAttackAbility", "OnTravel");

	Params::RetreatAttackAbility_OnTravel Parms{};

	Parms.SourceLevelVisualVolume = SourceLevelVisualVolume;
	Parms.TargetLevelVisualVolume = TargetLevelVisualVolume;
	Parms.NewPos = std::move(NewPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RetreatAttackAbility.OwnerRemovedFromWorld
// (Final, Native, Public)

void URetreatAttackAbility::OwnerRemovedFromWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RetreatAttackAbility", "OwnerRemovedFromWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RevengePassive.DamageReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URevengePassive::DamageReceived(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevengePassive", "DamageReceived");

	Params::RevengePassive_DamageReceived Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RevengePassive.OnDefend
// (Final, Native, Public)
// Parameters:
// class UAbilityController*               Source                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               Bullet                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               TargetControler                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   effectiveDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageValue                     DamageValue                                            (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URevengePassive::OnDefend(class UAbilityController* Source, class UAbilityController* Bullet, class UAbilityController* TargetControler, class UAbilityBase* Ability, float effectiveDamage, const struct FDamageValue& DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevengePassive", "OnDefend");

	Params::RevengePassive_OnDefend Parms{};

	Parms.Source = Source;
	Parms.Bullet = Bullet;
	Parms.TargetControler = TargetControler;
	Parms.Ability = Ability;
	Parms.effectiveDamage = effectiveDamage;
	Parms.DamageValue = std::move(DamageValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.RevengePassive.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void URevengePassive::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RevengePassive", "PreDamageDealt");

	Params::RevengePassive_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.ReverberatingStrikesPassive.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReverberatingStrikesPassive::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverberatingStrikesPassive", "PostDamageDealt");

	Params::ReverberatingStrikesPassive_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ReverberatingStrikesPassive.Reset
// (Final, Native, Public)

void UReverberatingStrikesPassive::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverberatingStrikesPassive", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.RogueMageAttackZap.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URogueMageAttackZap::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueMageAttackZap", "BPGetTargetLocation");

	Params::RogueMageAttackZap_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeClassUserWidget.GetCharacterClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterClass                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterClass USkillTreeClassUserWidget::GetCharacterClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeClassUserWidget", "GetCharacterClass");

	Params::SkillTreeClassUserWidget_GetCharacterClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SkillTreeSelectorNodeUserWidget.OnPlayUnlockVFX
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeSelectorNodeUserWidget::OnPlayUnlockVFX(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeSelectorNodeUserWidget", "OnPlayUnlockVFX");

	Params::SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeSelectorNodeUserWidget.OnSetSelectorNode
// (Event, Public, BlueprintEvent)
// Parameters:
// ESkillTreeNodeState                     InSkillTreeNodeState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterClass                         InCharacterClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       InNodeIcon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeSelectorNodeUserWidget::OnSetSelectorNode(ESkillTreeNodeState InSkillTreeNodeState, ECharacterClass InCharacterClass, class UTexture2D* InNodeIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeSelectorNodeUserWidget", "OnSetSelectorNode");

	Params::SkillTreeSelectorNodeUserWidget_OnSetSelectorNode Parms{};

	Parms.InSkillTreeNodeState = InSkillTreeNodeState;
	Parms.InCharacterClass = InCharacterClass;
	Parms.InNodeIcon = InNodeIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkillTreeTooltipUserWidget.OnSetup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// ESkillTreeNodeState                     SkillTreeNodeState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             CostText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             WarningText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ECharacterClass                         NodeRegion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillTreeTooltipUserWidget::OnSetup(ESkillTreeNodeState SkillTreeNodeState, const class FText& Name_0, const class FText& Description, const class FText& CostText, const class FText& WarningText, ECharacterClass NodeRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillTreeTooltipUserWidget", "OnSetup");

	Params::SkillTreeTooltipUserWidget_OnSetup Parms{};

	Parms.SkillTreeNodeState = SkillTreeNodeState;
	Parms.Name_0 = std::move(Name_0);
	Parms.Description = std::move(Description);
	Parms.CostText = std::move(CostText);
	Parms.WarningText = std::move(WarningText);
	Parms.NodeRegion = NodeRegion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SkipCutsceneUserWidget.OnConversationModeToggle
// (Final, Native, Protected)
// Parameters:
// class AHeroBase*                        Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkipCutsceneUserWidget::OnConversationModeToggle(class AHeroBase* Hero, class AActor* TargetActor, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkipCutsceneUserWidget", "OnConversationModeToggle");

	Params::SkipCutsceneUserWidget_OnConversationModeToggle Parms{};

	Parms.Hero = Hero;
	Parms.TargetActor = TargetActor;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SkipCutsceneUserWidget.OnCutsceneModeToggle
// (Final, Native, Protected)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkipCutsceneUserWidget::OnCutsceneModeToggle(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkipCutsceneUserWidget", "OnCutsceneModeToggle");

	Params::SkipCutsceneUserWidget_OnCutsceneModeToggle Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SmashPassive.OnPostDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USmashPassive::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmashPassive", "OnPostDamaged");

	Params::SmashPassive_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SmashPassive.OnPreDamagedPriority
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USmashPassive::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmashPassive", "OnPreDamagedPriority");

	Params::SmashPassive_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.SmiteAbility.DoesExecute
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmiteAbility::DoesExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmiteAbility", "DoesExecute");

	Params::SmiteAbility_DoesExecute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SmiteAbility.HasMaxCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USmiteAbility::HasMaxCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmiteAbility", "HasMaxCharge");

	Params::SmiteAbility_HasMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SmiteAbility.Travel
// (Final, Native, Public)

void USmiteAbility::Travel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SmiteAbility", "Travel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoulTear.AbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoulTear::AbilityEnd(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoulTear", "AbilityEnd");

	Params::SoulTear_AbilityEnd Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SoulTear.ChaosRolled
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoulTear::ChaosRolled(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoulTear", "ChaosRolled");

	Params::SoulTear_ChaosRolled Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SoulTear.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USoulTear::DamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoulTear", "DamageDealt");

	Params::SoulTear_DamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.SoundTrackUserWidget.JumpToNextTrack
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::JumpToNextTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "JumpToNextTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.JumpToPreviousTrack
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::JumpToPreviousTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "JumpToPreviousTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.OnSetTrack
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             TrackName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InCurrentTrack                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxTrack                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundTrackUserWidget::OnSetTrack(const class FText& TrackName, int32 InCurrentTrack, int32 InMaxTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "OnSetTrack");

	Params::SoundTrackUserWidget_OnSetTrack Parms{};

	Parms.TrackName = std::move(TrackName);
	Parms.InCurrentTrack = InCurrentTrack;
	Parms.InMaxTrack = InMaxTrack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SoundTrackUserWidget.OnSoundTrackEndReached
// (Final, Native, Private)

void USoundTrackUserWidget::OnSoundTrackEndReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "OnSoundTrackEndReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.PlayCurrentTrack
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::PlayCurrentTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "PlayCurrentTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.SetTrack
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InTrackIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundTrackUserWidget::SetTrack(int32 InTrackIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "SetTrack");

	Params::SoundTrackUserWidget_SetTrack Parms{};

	Parms.InTrackIndex = InTrackIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.StopCurrentTrack
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::StopCurrentTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "StopCurrentTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.VolumeDown
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::VolumeDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "VolumeDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SoundTrackUserWidget.VolumeUp
// (Final, Native, Protected, BlueprintCallable)

void USoundTrackUserWidget::VolumeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundTrackUserWidget", "VolumeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SpeechBubbleUserWidget.OnHide
// (Final, Native, Protected, BlueprintCallable)

void USpeechBubbleUserWidget::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeechBubbleUserWidget", "OnHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SpeechBubbleUserWidget.OnShow
// (Final, Native, Protected, BlueprintCallable)

void USpeechBubbleUserWidget::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeechBubbleUserWidget", "OnShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SpeechBubbleUserWidget.OnShowText
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpeechBubbleUserWidget::OnShowText(bool bInShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeechBubbleUserWidget", "OnShowText");

	Params::SpeechBubbleUserWidget_OnShowText Parms{};

	Parms.bInShow = bInShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.SpeechBubbleUserWidget.OnSubtitleEnable
// (Final, Native, Protected)
// Parameters:
// bool                                    bSubtitleEnable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpeechBubbleUserWidget::OnSubtitleEnable(bool bSubtitleEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeechBubbleUserWidget", "OnSubtitleEnable");

	Params::SpeechBubbleUserWidget_OnSubtitleEnable Parms{};

	Parms.bSubtitleEnable = bSubtitleEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpellbookFamiliar.ExecuteKill
// (Final, Native, Public)

void ASpellbookFamiliar::ExecuteKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellbookFamiliar", "ExecuteKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SpikedWallAbility.OnPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USpikedWallAbility::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpikedWallAbility", "OnPreDamageCaused");

	Params::SpikedWallAbility_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.SpiritCompanionAbility.OnActorKilled
// (Final, Native, Public)
// Parameters:
// class AActor*                           InKilledActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpiritCompanionAbility::OnActorKilled(class AActor* InKilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAbility", "OnActorKilled");

	Params::SpiritCompanionAbility_OnActorKilled Parms{};

	Parms.InKilledActor = InKilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritCompanionAI.OnHeroPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnHeroPostDamageCaused(const struct FPreDamagedEventParam& PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnHeroPostDamageCaused");

	Params::SpiritCompanionAI_OnHeroPostDamageCaused Parms{};

	Parms.PreDamagedEventParam = std::move(PreDamagedEventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritCompanionAI.OnHeroPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnHeroPreDamageCaused(struct FPreDamagedEventParam* PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnHeroPreDamageCaused");

	Params::SpiritCompanionAI_OnHeroPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PreDamagedEventParam != nullptr)
		*PreDamagedEventParam = std::move(Parms.PreDamagedEventParam);
}


// Function man.SpiritCompanionAI.OnOwnerTeleported
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          TeleportPos                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnOwnerTeleported(const struct FVector& TeleportPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnOwnerTeleported");

	Params::SpiritCompanionAI_OnOwnerTeleported Parms{};

	Parms.TeleportPos = std::move(TeleportPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritCompanionAI.OnSpiritCompanionKilled
// (Final, Native, Public)
// Parameters:
// class UObject*                          Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               KillerAbilityController                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnSpiritCompanionKilled(class UObject* Killer, class UAbilityController* KillerAbilityController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnSpiritCompanionKilled");

	Params::SpiritCompanionAI_OnSpiritCompanionKilled Parms{};

	Parms.Killer = Killer;
	Parms.KillerAbilityController = KillerAbilityController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritCompanionAI.OnSpiritPostDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnSpiritPostDamageCaused(const struct FPreDamagedEventParam& PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnSpiritPostDamageCaused");

	Params::SpiritCompanionAI_OnSpiritPostDamageCaused Parms{};

	Parms.PreDamagedEventParam = std::move(PreDamagedEventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritCompanionAI.OnSpiritPreDamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            PreDamagedEventParam                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void USpiritCompanionAI::OnSpiritPreDamageCaused(struct FPreDamagedEventParam* PreDamagedEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritCompanionAI", "OnSpiritPreDamageCaused");

	Params::SpiritCompanionAI_OnSpiritPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PreDamagedEventParam != nullptr)
		*PreDamagedEventParam = std::move(Parms.PreDamagedEventParam);
}


// Function man.SprintAbility.BPOverburdenedStart
// (Event, Public, BlueprintEvent)

void USprintAbility::BPOverburdenedStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprintAbility", "BPOverburdenedStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.StatusTypeController.BPGetStatusEffectStackNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStatusTypeController::BPGetStatusEffectStackNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTypeController", "BPGetStatusEffectStackNum");

	Params::StatusTypeController_BPGetStatusEffectStackNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StatusTypeController.GetLastSECauserDamageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FStatusEffectCauserDamage        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStatusEffectCauserDamage UStatusTypeController::GetLastSECauserDamageData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTypeController", "GetLastSECauserDamageData");

	Params::StatusTypeController_GetLastSECauserDamageData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StatusEffectPassive.BPGetSourceActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UStatusEffectPassive::BPGetSourceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectPassive", "BPGetSourceActor");

	Params::StatusEffectPassive_BPGetSourceActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.StatusEffectPassive.BPGetSourceSourceAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityBase* UStatusEffectPassive::BPGetSourceSourceAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectPassive", "BPGetSourceSourceAbility");

	Params::StatusEffectPassive_BPGetSourceSourceAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.EnemyModifiersNode.GetEditorName
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEnemyModifiersNode::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyModifiersNode", "GetEditorName");

	Params::EnemyModifiersNode_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.SummonImpAbility.AbilityModifierChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bAddedModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGeneralAbilityModifier                 GeneralID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CustomID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USummonImpAbility::AbilityModifierChanged(bool bAddedModifier, EGeneralAbilityModifier GeneralID, class FName CustomID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonImpAbility", "AbilityModifierChanged");

	Params::SummonImpAbility_AbilityModifierChanged Parms{};

	Parms.bAddedModifier = bAddedModifier;
	Parms.GeneralID = GeneralID;
	Parms.CustomID = CustomID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SummonImpAbility.FamiliarAnimEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void USummonImpAbility::FamiliarAnimEvent(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonImpAbility", "FamiliarAnimEvent");

	Params::SummonImpAbility_FamiliarAnimEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.SummonImpAbility.FamiliarKilled
// (Final, Native, Public)

void USummonImpAbility::FamiliarKilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonImpAbility", "FamiliarKilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SummonImpAbility.KillFamiliar
// (Final, Native, Public)

void USummonImpAbility::KillFamiliar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonImpAbility", "KillFamiliar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SummonImpAbility.PreDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void USummonImpAbility::PreDamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SummonImpAbility", "PreDamageDealt");

	Params::SummonImpAbility_PreDamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.SurfaceTypeVolume.ChangeDataAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USurfaceEffectTypeDataAsset*      InDataAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurfaceTypeVolume::ChangeDataAsset(class USurfaceEffectTypeDataAsset* InDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceTypeVolume", "ChangeDataAsset");

	Params::SurfaceTypeVolume_ChangeDataAsset Parms{};

	Parms.InDataAsset = InDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SurfaceTypeVolume.UpdateTextRenderer
// (Final, Native, Public, BlueprintCallable)

void ASurfaceTypeVolume::UpdateTextRenderer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceTypeVolume", "UpdateTextRenderer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SurfaceEffectComponent.OnSurfaceVolBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USurfaceEffectComponent::OnSurfaceVolBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceEffectComponent", "OnSurfaceVolBeginOverlap");

	Params::SurfaceEffectComponent_OnSurfaceVolBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SurfaceEffectComponent.OnSurfaceVolEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurfaceEffectComponent::OnSurfaceVolEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurfaceEffectComponent", "OnSurfaceVolEndOverlap");

	Params::SurfaceEffectComponent_OnSurfaceVolEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TabButtonUserWidget.OnSetActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabButtonUserWidget::OnSetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabButtonUserWidget", "OnSetActive");

	Params::TabButtonUserWidget_OnSetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TabButtonUserWidget.OnSetEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabButtonUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabButtonUserWidget", "OnSetEnabled");

	Params::TabButtonUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TabButtonUserWidget.OnSetText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTabButtonUserWidget::OnSetText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabButtonUserWidget", "OnSetText");

	Params::TabButtonUserWidget_OnSetText Parms{};

	Parms.Text = std::move(Text);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TabButtonUserWidget.OnToggleNewItemWarning
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTabButtonUserWidget::OnToggleNewItemWarning(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TabButtonUserWidget", "OnToggleNewItemWarning");

	Params::TabButtonUserWidget_OnToggleNewItemWarning Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TeleportHelperAbility.FadeInFinished
// (Final, Native, Public)

void UTeleportHelperAbility::FadeInFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportHelperAbility", "FadeInFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportHelperAbility.FadeOutFinished
// (Final, Native, Public)

void UTeleportHelperAbility::FadeOutFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportHelperAbility", "FadeOutFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportHelperAbility.OnUserInput
// (Final, Native, Public)
// Parameters:
// int32                                   InputCommandNum                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeleportHelperAbility::OnUserInput(int32 InputCommandNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportHelperAbility", "OnUserInput");

	Params::TeleportHelperAbility_OnUserInput Parms{};

	Parms.InputCommandNum = InputCommandNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportTarget.BPPlayPortalVfxAfterTeleport
// (Event, Public, BlueprintEvent)

void ATeleportTarget::BPPlayPortalVfxAfterTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportTarget", "BPPlayPortalVfxAfterTeleport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TeleportTriggerVolume.IsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATeleportTriggerVolume::IsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportTriggerVolume", "IsEnabled");

	Params::TeleportTriggerVolume_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TeleportTriggerVolume.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATeleportTriggerVolume::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportTriggerVolume", "OnBeginOverlap");

	Params::TeleportTriggerVolume_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportTriggerVolume.OnCinematicFinished
// (Final, Native, Protected)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeleportTriggerVolume::OnCinematicFinished(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportTriggerVolume", "OnCinematicFinished");

	Params::TeleportTriggerVolume_OnCinematicFinished Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TeleportTriggerVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeleportTriggerVolume::SetEnabled(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeleportTriggerVolume", "SetEnabled");

	Params::TeleportTriggerVolume_SetEnabled Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TextBubbleWidgetComponent.BPAddDialogue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          addOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitforOtherVO                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBubbleWidgetComponent::BPAddDialogue(class UDialogueDataAsset* DialogueDataAsset, class UObject* addOnce, bool bWaitforOtherVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBubbleWidgetComponent", "BPAddDialogue");

	Params::TextBubbleWidgetComponent_BPAddDialogue Parms{};

	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.addOnce = addOnce;
	Parms.bWaitforOtherVO = bWaitforOtherVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TextBubbleWidgetComponent.BPAddDialogueInstant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          addOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBubbleWidgetComponent::BPAddDialogueInstant(class UDialogueDataAsset* DialogueDataAsset, class UObject* addOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBubbleWidgetComponent", "BPAddDialogueInstant");

	Params::TextBubbleWidgetComponent_BPAddDialogueInstant Parms{};

	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.addOnce = addOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TextBubbleWidgetComponent.BPFadeIn
// (Native, Event, Public, BlueprintEvent)

void UTextBubbleWidgetComponent::BPFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBubbleWidgetComponent", "BPFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TextBubbleWidgetComponent.BPFadeOut
// (Native, Event, Public, BlueprintEvent)

void UTextBubbleWidgetComponent::BPFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBubbleWidgetComponent", "BPFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TextBubbleWidgetComponent.BPInit
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             LineIDText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EDialogueBubbleType                     DialogueBubbleType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBubbleWidgetComponent::BPInit(const class FText& Text, const class FText& LineIDText, EDialogueBubbleType DialogueBubbleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBubbleWidgetComponent", "BPInit");

	Params::TextBubbleWidgetComponent_BPInit Parms{};

	Parms.Text = std::move(Text);
	Parms.LineIDText = std::move(LineIDText);
	Parms.DialogueBubbleType = DialogueBubbleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ToxicCutsPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UToxicCutsPassive::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToxicCutsPassive", "DamageDealt");

	Params::ToxicCutsPassive_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ToxicPool.PostDamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UToxicPool::PostDamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToxicPool", "PostDamageDealt");

	Params::ToxicPool_PostDamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TrapActorBase.BPStopTrap
// (Final, Native, Public, BlueprintCallable)

void ATrapActorBase::BPStopTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapActorBase", "BPStopTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TrapActorBase.IsOperational
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATrapActorBase::IsOperational()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapActorBase", "IsOperational");

	Params::TrapActorBase_IsOperational Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TrapActorBase.ToggleTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBringOnline                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrapActorBase::ToggleTrap(bool bBringOnline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapActorBase", "ToggleTrap");

	Params::TrapActorBase_ToggleTrap Parms{};

	Parms.bBringOnline = bBringOnline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ProjectileTrap.ProjectileShot
// (Final, Native, Protected)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileTrap::ProjectileShot(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileTrap", "ProjectileShot");

	Params::ProjectileTrap_ProjectileShot Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.PeriodicStakes.BPStopTrap
// (Final, Native, Public, BlueprintCallable)

void APeriodicStakes::BPStopTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PeriodicStakes", "BPStopTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TreasureGoblinAI.Damaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTreasureGoblinAI::Damaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureGoblinAI", "Damaged");

	Params::TreasureGoblinAI_Damaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TreasureGoblinAI.KillStateChanged
// (Final, Native, Public)

void UTreasureGoblinAI::KillStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureGoblinAI", "KillStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TriggerBoxComponent.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTriggerBoxComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerBoxComponent", "OnBeginOverlap");

	Params::TriggerBoxComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TriggerBoxComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerBoxComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerBoxComponent", "OnEndOverlap");

	Params::TriggerBoxComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.OnGPEventToggleAbility_Trigger.OnSpawned
// (Final, Native, Public)
// Parameters:
// class AActorSoul*                       ActorSoul                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           BondActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityController*               AbilityController                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnGPEventToggleAbility_Trigger::OnSpawned(class AActorSoul* ActorSoul, class AActor* BondActor, class UAbilityController* AbilityController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnGPEventToggleAbility_Trigger", "OnSpawned");

	Params::OnGPEventToggleAbility_Trigger_OnSpawned Parms{};

	Parms.ActorSoul = ActorSoul;
	Parms.BondActor = BondActor;
	Parms.AbilityController = AbilityController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TrinityAbility.GetVASphereSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTrinityAbility::GetVASphereSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrinityAbility", "GetVASphereSize");

	Params::TrinityAbility_GetVASphereSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.TutorialPromptActor.DataChanged
// (Event, Public, BlueprintEvent)

void ATutorialPromptActor::DataChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptActor", "DataChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptActor.EventFulfilled
// (Event, Public, BlueprintEvent)

void ATutorialPromptActor::EventFulfilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptActor", "EventFulfilled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptActor.HidePrompt
// (Event, Public, BlueprintEvent)

void ATutorialPromptActor::HidePrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptActor", "HidePrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptActor.ShowPrompt
// (Event, Public, BlueprintEvent)

void ATutorialPromptActor::ShowPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptActor", "ShowPrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.TutorialPromptVolume_DestroyCeramic.DamageCaused
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_DestroyCeramic::DamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_DestroyCeramic", "DamageCaused");

	Params::TutorialPromptVolume_DestroyCeramic_DamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume_AbilityTrigger.AbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     pAbility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_AbilityTrigger::AbilityStarted(class UAbilityBase* pAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_AbilityTrigger", "AbilityStarted");

	Params::TutorialPromptVolume_AbilityTrigger_AbilityStarted Parms{};

	Parms.pAbility = pAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume_UseQuickItem.AbilityStarted
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     pAbility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_UseQuickItem::AbilityStarted(class UAbilityBase* pAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_UseQuickItem", "AbilityStarted");

	Params::TutorialPromptVolume_UseQuickItem_AbilityStarted Parms{};

	Parms.pAbility = pAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume_LookUpDown.OnLookVAxisInput
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_LookUpDown::OnLookVAxisInput(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_LookUpDown", "OnLookVAxisInput");

	Params::TutorialPromptVolume_LookUpDown_OnLookVAxisInput Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialPromptVolume_OpenStartMenu.OnStartMenuHide
// (Final, Native, Public)
// Parameters:
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialPromptVolume_OpenStartMenu::OnStartMenuHide(class UManUserWidgetBase* ManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPromptVolume_OpenStartMenu", "OnStartMenuHide");

	Params::TutorialPromptVolume_OpenStartMenu_OnStartMenuHide Parms{};

	Parms.ManUserWidgetBase = ManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialScreenUserWidget.JumpToNextPage
// (Final, Native, Protected, BlueprintCallable)

void UTutorialScreenUserWidget::JumpToNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "JumpToNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialScreenUserWidget.JumpToNextScreen
// (Final, Native, Protected, BlueprintCallable)

void UTutorialScreenUserWidget::JumpToNextScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "JumpToNextScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialScreenUserWidget.JumpToPreviousPage
// (Final, Native, Protected, BlueprintCallable)

void UTutorialScreenUserWidget::JumpToPreviousPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "JumpToPreviousPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialScreenUserWidget.JumpToPreviousScreen
// (Final, Native, Protected, BlueprintCallable)

void UTutorialScreenUserWidget::JumpToPreviousScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "JumpToPreviousScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.TutorialScreenUserWidget.OnSetDescription
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTutorialScreenUserWidget::OnSetDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "OnSetDescription");

	Params::TutorialScreenUserWidget_OnSetDescription Parms{};

	Parms.Description = std::move(Description);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TutorialScreenUserWidget.OnSetPage
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InPageNumber                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   CurrentPage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFade                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialScreenUserWidget::OnSetPage(const class FText& Title, const class FText& InPageNumber, int32 CurrentPage, int32 MaxPage, bool bFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "OnSetPage");

	Params::TutorialScreenUserWidget_OnSetPage Parms{};

	Parms.Title = std::move(Title);
	Parms.InPageNumber = std::move(InPageNumber);
	Parms.CurrentPage = CurrentPage;
	Parms.MaxPage = MaxPage;
	Parms.bFade = bFade;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TutorialScreenUserWidget.OnSetReplayBtnsState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUpEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDownEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialScreenUserWidget::OnSetReplayBtnsState(bool bUpEnabled, bool bDownEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialScreenUserWidget", "OnSetReplayBtnsState");

	Params::TutorialScreenUserWidget_OnSetReplayBtnsState Parms{};

	Parms.bUpEnabled = bUpEnabled;
	Parms.bDownEnabled = bDownEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.TypeWriterTextUserWidget.SetText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTypeWriterTextUserWidget::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypeWriterTextUserWidget", "SetText");

	Params::TypeWriterTextUserWidget_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.BPAddDialogueBrawler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          addOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitforOtherVO                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::BPAddDialogueBrawler(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset, class UObject* addOnce, bool bWaitforOtherVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "BPAddDialogueBrawler");

	Params::UIFunctionLibrary_BPAddDialogueBrawler Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.addOnce = addOnce;
	Parms.bWaitforOtherVO = bWaitforOtherVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.BPAddGlobalOneTimeDialogueBrawler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitforOtherVO                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::BPAddGlobalOneTimeDialogueBrawler(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset, bool bWaitforOtherVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "BPAddGlobalOneTimeDialogueBrawler");

	Params::UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.bWaitforOtherVO = bWaitforOtherVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.BPAddRandomDialogueBrawler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          addOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitforOtherVO                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::BPAddRandomDialogueBrawler(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset, class UObject* addOnce, bool bWaitforOtherVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "BPAddRandomDialogueBrawler");

	Params::UIFunctionLibrary_BPAddRandomDialogueBrawler Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.addOnce = addOnce;
	Parms.bWaitforOtherVO = bWaitforOtherVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.BPAddRepeatableDialogueLineBrawler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          addOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitforOtherVO                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::BPAddRepeatableDialogueLineBrawler(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset, class UObject* addOnce, bool bWaitforOtherVO)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "BPAddRepeatableDialogueLineBrawler");

	Params::UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.addOnce = addOnce;
	Parms.bWaitforOtherVO = bWaitforOtherVO;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.BPSetFade
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFadeOutFinished                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFadeInFinished                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlayerInvulnerableDuringFade                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayerMoveInputDuringFadeOut                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerLockAtFadeOutFinished                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::BPSetFade(class UObject* WorldContextObject, float FadeOutTime, float FadeDuration, float FadeInTime, const TDelegate<void()>& OnFadeOutFinished, const TDelegate<void()>& OnFadeInFinished, bool bPlayerInvulnerableDuringFade, float PlayerMoveInputDuringFadeOut, bool bPlayerLockAtFadeOutFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "BPSetFade");

	Params::UIFunctionLibrary_BPSetFade Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FadeOutTime = FadeOutTime;
	Parms.FadeDuration = FadeDuration;
	Parms.FadeInTime = FadeInTime;
	Parms.OnFadeOutFinished = OnFadeOutFinished;
	Parms.OnFadeInFinished = OnFadeInFinished;
	Parms.bPlayerInvulnerableDuringFade = bPlayerInvulnerableDuringFade;
	Parms.PlayerMoveInputDuringFadeOut = PlayerMoveInputDuringFadeOut;
	Parms.bPlayerLockAtFadeOutFinished = bPlayerLockAtFadeOutFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ChangeHotkey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             OldKey                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             NewKey                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrimary                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ChangeHotkey(class UObject* WorldContextObject, class FName ActionName, class FName AxisName, float AxisScale, const struct FKey& OldKey, const struct FKey& NewKey, bool bPrimary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ChangeHotkey");

	Params::UIFunctionLibrary_ChangeHotkey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActionName = ActionName;
	Parms.AxisName = AxisName;
	Parms.AxisScale = AxisScale;
	Parms.OldKey = std::move(OldKey);
	Parms.NewKey = std::move(NewKey);
	Parms.bPrimary = bPrimary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ClearTutorialSign
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ClearTutorialSign(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ClearTutorialSign");

	Params::UIFunctionLibrary_ClearTutorialSign Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.FloatToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoundingMode                           RoundingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::FloatToText(float Value, ERoundingMode RoundingMode, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, bool bAsPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "FloatToText");

	Params::UIFunctionLibrary_FloatToText Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.bAsPercent = bAsPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetActiveAbilitiesWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActiveAbilitiesWindowUserWidget* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActiveAbilitiesWindowUserWidget* UUIFunctionLibrary::GetActiveAbilitiesWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetActiveAbilitiesWindowUserWidget");

	Params::UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetAttributeIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAttribute                              attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUIFunctionLibrary::GetAttributeIcon(EAttribute attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetAttributeIcon");

	Params::UIFunctionLibrary_GetAttributeIcon Parms{};

	Parms.attribute = attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetBountyBoardItems
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBountyBoardItem>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBountyBoardItem> UUIFunctionLibrary::GetBountyBoardItems(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetBountyBoardItems");

	Params::UIFunctionLibrary_GetBountyBoardItems Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetCharacterNameUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterNameUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterNameUserWidget* UUIFunctionLibrary::GetCharacterNameUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetCharacterNameUserWidget");

	Params::UIFunctionLibrary_GetCharacterNameUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetCharacterWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterWindowUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterWindowUserWidget* UUIFunctionLibrary::GetCharacterWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetCharacterWindowUserWidget");

	Params::UIFunctionLibrary_GetCharacterWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetControlDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputDisplay UUIFunctionLibrary::GetControlDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetControlDisplay");

	Params::UIFunctionLibrary_GetControlDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetConversationManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManConversationManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManConversationManager* UUIFunctionLibrary::GetConversationManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetConversationManager");

	Params::UIFunctionLibrary_GetConversationManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetConversationUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationUserWidget*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConversationUserWidget* UUIFunctionLibrary::GetConversationUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetConversationUserWidget");

	Params::UIFunctionLibrary_GetConversationUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetCreateCharacterUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCreateCharacterUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCreateCharacterUserWidget* UUIFunctionLibrary::GetCreateCharacterUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetCreateCharacterUserWidget");

	Params::UIFunctionLibrary_GetCreateCharacterUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetCreditsUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCreditsUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCreditsUserWidget* UUIFunctionLibrary::GetCreditsUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetCreditsUserWidget");

	Params::UIFunctionLibrary_GetCreditsUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetDialogueNodeVisibleTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDialogueDataAsset*               DialogueDataAsset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DialogueIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIFunctionLibrary::GetDialogueNodeVisibleTime(const class UDialogueDataAsset* DialogueDataAsset, int32 DialogueIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetDialogueNodeVisibleTime");

	Params::UIFunctionLibrary_GetDialogueNodeVisibleTime Parms{};

	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.DialogueIndex = DialogueIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetEmptyLoreText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::GetEmptyLoreText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetEmptyLoreText");

	Params::UIFunctionLibrary_GetEmptyLoreText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetEquipLoadIndicatorColor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEquipLoadIndicator                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEquipLoadIndicator UUIFunctionLibrary::GetEquipLoadIndicatorColor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetEquipLoadIndicatorColor");

	Params::UIFunctionLibrary_GetEquipLoadIndicatorColor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetFormattedSubtitleText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InSpeakerName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseDefault                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::GetFormattedSubtitleText(const class FText& InSpeakerName, const class FText& InText, bool bUseDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetFormattedSubtitleText");

	Params::UIFunctionLibrary_GetFormattedSubtitleText Parms{};

	Parms.InSpeakerName = std::move(InSpeakerName);
	Parms.InText = std::move(InText);
	Parms.bUseDefault = bUseDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManGameInstance*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManGameInstance* UUIFunctionLibrary::GetGameInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetGameInstance");

	Params::UIFunctionLibrary_GetGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMandragoraGameMode*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMandragoraGameMode* UUIFunctionLibrary::GetGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetGameMode");

	Params::UIFunctionLibrary_GetGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroAbilitiesData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHeroAbilitiesData*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHeroAbilitiesData* UUIFunctionLibrary::GetHeroAbilitiesData(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroAbilitiesData");

	Params::UIFunctionLibrary_GetHeroAbilitiesData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroComboPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroComboPoint(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroComboPoint");

	Params::UIFunctionLibrary_GetHeroComboPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroComboPointFraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroComboPointFraction(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroComboPointFraction");

	Params::UIFunctionLibrary_GetHeroComboPointFraction Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroCurrentItemSetIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroCurrentItemSetIndex(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroCurrentItemSetIndex");

	Params::UIFunctionLibrary_GetHeroCurrentItemSetIndex Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroDefaultCharacterClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterClass                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterClass UUIFunctionLibrary::GetHeroDefaultCharacterClass(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroDefaultCharacterClass");

	Params::UIFunctionLibrary_GetHeroDefaultCharacterClass Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::GetHeroDescription(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroDescription");

	Params::UIFunctionLibrary_GetHeroDescription Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroEntropicEssence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroEntropicEssence(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroEntropicEssence");

	Params::UIFunctionLibrary_GetHeroEntropicEssence Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroEssence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroEssence(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroEssence");

	Params::UIFunctionLibrary_GetHeroEssence Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroGold
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroGold(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroGold");

	Params::UIFunctionLibrary_GetHeroGold Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroIsInCombat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::GetHeroIsInCombat(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroIsInCombat");

	Params::UIFunctionLibrary_GetHeroIsInCombat Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroMaxComboPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroMaxComboPoint(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroMaxComboPoint");

	Params::UIFunctionLibrary_GetHeroMaxComboPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUIFunctionLibrary::GetHeroName(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroName");

	Params::UIFunctionLibrary_GetHeroName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHeroSkillPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetHeroSkillPoint(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHeroSkillPoint");

	Params::UIFunctionLibrary_GetHeroSkillPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHotkeyDataAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHotkeyDataAsset*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHotkeyDataAsset* UUIFunctionLibrary::GetHotkeyDataAsset(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHotkeyDataAsset");

	Params::UIFunctionLibrary_GetHotkeyDataAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHotkeyKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> UUIFunctionLibrary::GetHotkeyKeys(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHotkeyKeys");

	Params::UIFunctionLibrary_GetHotkeyKeys Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetHUDWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHUDUserWidget*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHUDUserWidget* UUIFunctionLibrary::GetHUDWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetHUDWidget");

	Params::UIFunctionLibrary_GetHUDWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetInputDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputDisplay                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputDisplay UUIFunctionLibrary::GetInputDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetInputDisplay");

	Params::UIFunctionLibrary_GetInputDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetInventory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventory* UUIFunctionLibrary::GetInventory(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetInventory");

	Params::UIFunctionLibrary_GetInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetInventoryWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInventoryWindowUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryWindowUserWidget* UUIFunctionLibrary::GetInventoryWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetInventoryWindowUserWidget");

	Params::UIFunctionLibrary_GetInventoryWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetItemsTooltipDataAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemsTooltipDataAsset*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemsTooltipDataAsset* UUIFunctionLibrary::GetItemsTooltipDataAsset(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetItemsTooltipDataAsset");

	Params::UIFunctionLibrary_GetItemsTooltipDataAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetLevelText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::GetLevelText(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetLevelText");

	Params::UIFunctionLibrary_GetLevelText Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetLevelUpWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelUpWindowUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelUpWindowUserWidget* UUIFunctionLibrary::GetLevelUpWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetLevelUpWindowUserWidget");

	Params::UIFunctionLibrary_GetLevelUpWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetLoadGameUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULoadGameUserWidget*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULoadGameUserWidget* UUIFunctionLibrary::GetLoadGameUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetLoadGameUserWidget");

	Params::UIFunctionLibrary_GetLoadGameUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetMainParent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ChildWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::GetMainParent(class UObject* WorldContextObject, class UWidget* ChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMainParent");

	Params::UIFunctionLibrary_GetMainParent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ChildWidget = ChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetManLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManLocalPlayer*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManLocalPlayer* UUIFunctionLibrary::GetManLocalPlayer(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetManLocalPlayer");

	Params::UIFunctionLibrary_GetManLocalPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetManPlayerInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManPlayerInput*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManPlayerInput* UUIFunctionLibrary::GetManPlayerInput(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetManPlayerInput");

	Params::UIFunctionLibrary_GetManPlayerInput Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetManUserWidgetBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetsZorder                          WidgetsZorder                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::GetManUserWidgetBase(class UObject* WorldContextObject, EWidgetsZorder WidgetsZorder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetManUserWidgetBase");

	Params::UIFunctionLibrary_GetManUserWidgetBase Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetsZorder = WidgetsZorder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetMapManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMapManager*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapManager* UUIFunctionLibrary::GetMapManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMapManager");

	Params::UIFunctionLibrary_GetMapManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetMapWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMapWindowUserWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapWindowUserWidget* UUIFunctionLibrary::GetMapWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMapWindowUserWidget");

	Params::UIFunctionLibrary_GetMapWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetMaxSaveGameSlotNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetMaxSaveGameSlotNum(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetMaxSaveGameSlotNum");

	Params::UIFunctionLibrary_GetMaxSaveGameSlotNum Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetNewGameUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNewGameUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNewGameUserWidget* UUIFunctionLibrary::GetNewGameUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetNewGameUserWidget");

	Params::UIFunctionLibrary_GetNewGameUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetNPCBestiaryUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNPCBestiaryUserWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNPCBestiaryUserWidget* UUIFunctionLibrary::GetNPCBestiaryUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetNPCBestiaryUserWidget");

	Params::UIFunctionLibrary_GetNPCBestiaryUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetPauseMenuUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPauseMenuUserWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPauseMenuUserWidget* UUIFunctionLibrary::GetPauseMenuUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetPauseMenuUserWidget");

	Params::UIFunctionLibrary_GetPauseMenuUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetQuestManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManQuestManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManQuestManager* UUIFunctionLibrary::GetQuestManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetQuestManager");

	Params::UIFunctionLibrary_GetQuestManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetQuestWindowUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UQuestWindowUserWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UQuestWindowUserWidget* UUIFunctionLibrary::GetQuestWindowUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetQuestWindowUserWidget");

	Params::UIFunctionLibrary_GetQuestWindowUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetShortLevelText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::GetShortLevelText(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetShortLevelText");

	Params::UIFunctionLibrary_GetShortLevelText Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetSkillTreeManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkillTreeManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkillTreeManager* UUIFunctionLibrary::GetSkillTreeManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetSkillTreeManager");

	Params::UIFunctionLibrary_GetSkillTreeManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetSkillTreeUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkillTreeUserWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkillTreeUserWidget* UUIFunctionLibrary::GetSkillTreeUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetSkillTreeUserWidget");

	Params::UIFunctionLibrary_GetSkillTreeUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetSmallScreenMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESmallScreenMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESmallScreenMode UUIFunctionLibrary::GetSmallScreenMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetSmallScreenMode");

	Params::UIFunctionLibrary_GetSmallScreenMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetSubLevelActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SubLevelName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UUIFunctionLibrary::GetSubLevelActors(class UObject* WorldContextObject, const class FString& SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetSubLevelActors");

	Params::UIFunctionLibrary_GetSubLevelActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SubLevelName = std::move(SubLevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetSwappedKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UUIFunctionLibrary::GetSwappedKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetSwappedKey");

	Params::UIFunctionLibrary_GetSwappedKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetTopMostManUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::GetTopMostManUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetTopMostManUserWidget");

	Params::UIFunctionLibrary_GetTopMostManUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetUIScale
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUIFunctionLibrary::GetUIScale(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetUIScale");

	Params::UIFunctionLibrary_GetUIScale Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorAlchemistUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorAlchemistUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorAlchemistUserWidget* UUIFunctionLibrary::GetVendorAlchemistUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorAlchemistUserWidget");

	Params::UIFunctionLibrary_GetVendorAlchemistUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorBuyUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorBuyUserWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorBuyUserWidget* UUIFunctionLibrary::GetVendorBuyUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorBuyUserWidget");

	Params::UIFunctionLibrary_GetVendorBuyUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorCraftUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorCraftUserWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorCraftUserWidget* UUIFunctionLibrary::GetVendorCraftUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorCraftUserWidget");

	Params::UIFunctionLibrary_GetVendorCraftUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorCurrentExperience
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIFunctionLibrary::GetVendorCurrentExperience(class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorCurrentExperience");

	Params::UIFunctionLibrary_GetVendorCurrentExperience Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorCurrentLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetVendorCurrentLevel(class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorCurrentLevel");

	Params::UIFunctionLibrary_GetVendorCurrentLevel Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorEnchantUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorEnchantUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorEnchantUserWidget* UUIFunctionLibrary::GetVendorEnchantUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorEnchantUserWidget");

	Params::UIFunctionLibrary_GetVendorEnchantUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorExperienceForCurrentLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIFunctionLibrary::GetVendorExperienceForCurrentLevel(class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorExperienceForCurrentLevel");

	Params::UIFunctionLibrary_GetVendorExperienceForCurrentLevel Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorExperienceForNextLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIFunctionLibrary::GetVendorExperienceForNextLevel(class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorExperienceForNextLevel");

	Params::UIFunctionLibrary_GetVendorExperienceForNextLevel Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorMapFragmentUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorMapFragmentUserWidget*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorMapFragmentUserWidget* UUIFunctionLibrary::GetVendorMapFragmentUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorMapFragmentUserWidget");

	Params::UIFunctionLibrary_GetVendorMapFragmentUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorNextLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIFunctionLibrary::GetVendorNextLevel(class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorNextLevel");

	Params::UIFunctionLibrary_GetVendorNextLevel Parms{};

	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorPortraitsUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorPortraitsUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorPortraitsUserWidget* UUIFunctionLibrary::GetVendorPortraitsUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorPortraitsUserWidget");

	Params::UIFunctionLibrary_GetVendorPortraitsUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorSellUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorSellUserWidget*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorSellUserWidget* UUIFunctionLibrary::GetVendorSellUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorSellUserWidget");

	Params::UIFunctionLibrary_GetVendorSellUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorTransmogUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorTransmogUserWidget*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorTransmogUserWidget* UUIFunctionLibrary::GetVendorTransmogUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorTransmogUserWidget");

	Params::UIFunctionLibrary_GetVendorTransmogUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.GetVendorUpgradeUserWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorUpgradeUserWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorUpgradeUserWidget* UUIFunctionLibrary::GetVendorUpgradeUserWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "GetVendorUpgradeUserWidget");

	Params::UIFunctionLibrary_GetVendorUpgradeUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.HideAllWindows
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetInputModeGameOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideAllWindows(class UObject* WorldContextObject, float AnimDuration, bool bSetInputModeGameOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideAllWindows");

	Params::UIFunctionLibrary_HideAllWindows Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.bSetInputModeGameOnly = bSetInputModeGameOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.HideAllWindowsWithKeepArray
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EWidgetsZorder>                  KeepWindowsArray                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetInputModeGameOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideAllWindowsWithKeepArray(class UObject* WorldContextObject, const TArray<EWidgetsZorder>& KeepWindowsArray, float AnimDuration, bool bSetInputModeGameOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideAllWindowsWithKeepArray");

	Params::UIFunctionLibrary_HideAllWindowsWithKeepArray Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KeepWindowsArray = std::move(KeepWindowsArray);
	Parms.AnimDuration = AnimDuration;
	Parms.bSetInputModeGameOnly = bSetInputModeGameOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.HideHUD
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideHUD(class UObject* WorldContextObject, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideHUD");

	Params::UIFunctionLibrary_HideHUD Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.HideSubtitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideSubtitle(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideSubtitle");

	Params::UIFunctionLibrary_HideSubtitle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.HideWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UManUserWidgetBase*               InManUserWidgetBase                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetInputModeGameOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideWindow(class UManUserWidgetBase* InManUserWidgetBase, float AnimDuration, bool bSetInputModeGameOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideWindow");

	Params::UIFunctionLibrary_HideWindow Parms{};

	Parms.InManUserWidgetBase = InManUserWidgetBase;
	Parms.AnimDuration = AnimDuration;
	Parms.bSetInputModeGameOnly = bSetInputModeGameOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.HideWindowByZorder
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetsZorder                          WidgetsZorder                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetInputModeGameOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::HideWindowByZorder(class UObject* WorldContextObject, EWidgetsZorder WidgetsZorder, float AnimDuration, bool bSetInputModeGameOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "HideWindowByZorder");

	Params::UIFunctionLibrary_HideWindowByZorder Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetsZorder = WidgetsZorder;
	Parms.AnimDuration = AnimDuration;
	Parms.bSetInputModeGameOnly = bSetInputModeGameOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.IntToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::IntToText(int32 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IntToText");

	Params::UIFunctionLibrary_IntToText Parms{};

	Parms.Value = Value;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsAltarActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsAltarActive(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsAltarActive");

	Params::UIFunctionLibrary_IsAltarActive Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsCheckPointActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsCheckPointActive(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsCheckPointActive");

	Params::UIFunctionLibrary_IsCheckPointActive Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsConversationActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsConversationActive(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsConversationActive");

	Params::UIFunctionLibrary_IsConversationActive Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsCutsceneCinematicRuning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsCutsceneCinematicRuning(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsCutsceneCinematicRuning");

	Params::UIFunctionLibrary_IsCutsceneCinematicRuning Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsCutsceneRuning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsCutsceneRuning(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsCutsceneRuning");

	Params::UIFunctionLibrary_IsCutsceneRuning Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsDefaultGamepadHotkey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsDefaultGamepadHotkey(class UObject* WorldContextObject, class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsDefaultGamepadHotkey");

	Params::UIFunctionLibrary_IsDefaultGamepadHotkey Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsGeneratingShader
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsGeneratingShader(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsGeneratingShader");

	Params::UIFunctionLibrary_IsGeneratingShader Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsGodModeActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsGodModeActive(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsGodModeActive");

	Params::UIFunctionLibrary_IsGodModeActive Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsHotkeyKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsHotkeyKey(class FName ActionName, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsHotkeyKey");

	Params::UIFunctionLibrary_IsHotkeyKey Parms{};

	Parms.ActionName = ActionName;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsInputModeUIOnly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsInputModeUIOnly(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsInputModeUIOnly");

	Params::UIFunctionLibrary_IsInputModeUIOnly Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsKeyboardEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsKeyboardEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsKeyboardEnabled");

	Params::UIFunctionLibrary_IsKeyboardEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsKeyboardInputDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsKeyboardInputDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsKeyboardInputDisplay");

	Params::UIFunctionLibrary_IsKeyboardInputDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsKeyPressed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsKeyPressed(class UObject* WorldContextObject, class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsKeyPressed");

	Params::UIFunctionLibrary_IsKeyPressed Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsLeftAndRightSticksSwapped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsLeftAndRightSticksSwapped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsLeftAndRightSticksSwapped");

	Params::UIFunctionLibrary_IsLeftAndRightSticksSwapped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsLeftClickToBuySellSelectedItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsLeftClickToBuySellSelectedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsLeftClickToBuySellSelectedItem");

	Params::UIFunctionLibrary_IsLeftClickToBuySellSelectedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsMouseInputDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsMouseInputDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsMouseInputDisplay");

	Params::UIFunctionLibrary_IsMouseInputDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsPauseMenuAllowed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsPauseMenuAllowed(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsPauseMenuAllowed");

	Params::UIFunctionLibrary_IsPauseMenuAllowed Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsReachedTheCaravan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsReachedTheCaravan(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsReachedTheCaravan");

	Params::UIFunctionLibrary_IsReachedTheCaravan Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsSmallScreenMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsSmallScreenMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsSmallScreenMode");

	Params::UIFunctionLibrary_IsSmallScreenMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsSprintToggleMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsSprintToggleMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsSprintToggleMode");

	Params::UIFunctionLibrary_IsSprintToggleMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsSubtitleVisible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsSubtitleVisible(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsSubtitleVisible");

	Params::UIFunctionLibrary_IsSubtitleVisible Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsTopMostWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               InManUserWidgetBase                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsTopMostWidget(class UObject* WorldContextObject, class UManUserWidgetBase* InManUserWidgetBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsTopMostWidget");

	Params::UIFunctionLibrary_IsTopMostWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InManUserWidgetBase = InManUserWidgetBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsXAxisInverted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsXAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsXAxisInverted");

	Params::UIFunctionLibrary_IsXAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.IsYAxisInverted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::IsYAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "IsYAxisInverted");

	Params::UIFunctionLibrary_IsYAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.OpenSteamPage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::OpenSteamPage(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "OpenSteamPage");

	Params::UIFunctionLibrary_OpenSteamPage Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.OpenStore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::OpenStore(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "OpenStore");

	Params::UIFunctionLibrary_OpenStore Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.OverrideNavigationRule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UManUserWidgetBase*               MainWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUINavigationRule                       Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WidgetToFocus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::OverrideNavigationRule(class UManUserWidgetBase* MainWidget, class UWidget* Widget, EUINavigation Direction, EUINavigationRule Rule, class FName WidgetToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "OverrideNavigationRule");

	Params::UIFunctionLibrary_OverrideNavigationRule Parms{};

	Parms.MainWidget = MainWidget;
	Parms.Widget = Widget;
	Parms.Direction = Direction;
	Parms.Rule = Rule;
	Parms.WidgetToFocus = WidgetToFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.PlayAkAudioEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AkEventActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::PlayAkAudioEvent(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, class AActor* AkEventActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "PlayAkAudioEvent");

	Params::UIFunctionLibrary_PlayAkAudioEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AkEvent = AkEvent;
	Parms.AkEventActor = AkEventActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.SetConversationOpacity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::SetConversationOpacity(class UObject* WorldContextObject, float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetConversationOpacity");

	Params::UIFunctionLibrary_SetConversationOpacity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Opacity = Opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.SetLungeActionName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractButtonUserWidget*        InteractButtonUserWidget                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFunctionLibrary::SetLungeActionName(class UObject* WorldContextObject, class UInteractButtonUserWidget* InteractButtonUserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetLungeActionName");

	Params::UIFunctionLibrary_SetLungeActionName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InteractButtonUserWidget = InteractButtonUserWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.SetTabButtonNewItemWarningInAllWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETabButtonType                          TabButtonType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewItemWarning                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::SetTabButtonNewItemWarningInAllWidget(class UObject* WorldContextObject, ETabButtonType TabButtonType, bool bNewItemWarning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetTabButtonNewItemWarningInAllWidget");

	Params::UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TabButtonType = TabButtonType;
	Parms.bNewItemWarning = bNewItemWarning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.SetTabButtonsStateInAllWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETabButtonType                          TabButtonType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::SetTabButtonsStateInAllWidget(class UObject* WorldContextObject, ETabButtonType TabButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetTabButtonsStateInAllWidget");

	Params::UIFunctionLibrary_SetTabButtonsStateInAllWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TabButtonType = TabButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.SetTextFormatByHeroGender
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIFunctionLibrary::SetTextFormatByHeroGender(class UObject* WorldContextObject, const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SetTextFormatByHeroGender");

	Params::UIFunctionLibrary_SetTextFormatByHeroGender Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowBossScreenWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAttributeContainer*              BossAttributeContainer                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowBossScreenWindow(class UObject* WorldContextObject, float AnimDuration, class UAttributeContainer* BossAttributeContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowBossScreenWindow");

	Params::UIFunctionLibrary_ShowBossScreenWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.BossAttributeContainer = BossAttributeContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowBountyBoardWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowBountyBoardWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowBountyBoardWindow");

	Params::UIFunctionLibrary_ShowBountyBoardWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowCharacterWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowCharacterWindow(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowCharacterWindow");

	Params::UIFunctionLibrary_ShowCharacterWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowConversationWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowConversationWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowConversationWindow");

	Params::UIFunctionLibrary_ShowConversationWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowCreateCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowCreateCharacter(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowCreateCharacter");

	Params::UIFunctionLibrary_ShowCreateCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowCredits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>OnCompleted                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UCreditsUserWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCreditsUserWidget* UUIFunctionLibrary::ShowCredits(class UObject* WorldContextObject, const TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>& OnCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowCredits");

	Params::UIFunctionLibrary_ShowCredits Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OnCompleted = OnCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowCutsceneCinematic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCutsceneCinematicDataAsset*      CutsceneCinematicDataAsset                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>OnCompleted                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAlwaysResumeToGame                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCutsceneCinematicUserWidget*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCutsceneCinematicUserWidget* UUIFunctionLibrary::ShowCutsceneCinematic(class UObject* WorldContextObject, class UCutsceneCinematicDataAsset* CutsceneCinematicDataAsset, const TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>& OnCompleted, bool bAlwaysResumeToGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowCutsceneCinematic");

	Params::UIFunctionLibrary_ShowCutsceneCinematic Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CutsceneCinematicDataAsset = CutsceneCinematicDataAsset;
	Parms.OnCompleted = OnCompleted;
	Parms.bAlwaysResumeToGame = bAlwaysResumeToGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowDeathScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowDeathScreen(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowDeathScreen");

	Params::UIFunctionLibrary_ShowDeathScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowHUD
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowHUD(class UObject* WorldContextObject, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowHUD");

	Params::UIFunctionLibrary_ShowHUD Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bAnimate = bAnimate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowInfoScreenWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInfoScreentDataAsset*            InfoScreenData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowInfoScreenWindow(class UObject* WorldContextObject, class UInfoScreentDataAsset* InfoScreenData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowInfoScreenWindow");

	Params::UIFunctionLibrary_ShowInfoScreenWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InfoScreenData = InfoScreenData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowLevelUpWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowLevelUpWindow(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowLevelUpWindow");

	Params::UIFunctionLibrary_ShowLevelUpWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowLoadGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowLoadGame(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowLoadGame");

	Params::UIFunctionLibrary_ShowLoadGame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowMainMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowMainMenu(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowMainMenu");

	Params::UIFunctionLibrary_ShowMainMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowManUserWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ManUserWidgetBase                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HideHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowManUserWidget(class UObject* WorldContextObject, float AnimDuration, class UManUserWidgetBase* ManUserWidgetBase, bool HideHUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowManUserWidget");

	Params::UIFunctionLibrary_ShowManUserWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.ManUserWidgetBase = ManUserWidgetBase;
	Parms.HideHUD = HideHUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowManUserWidgetByZorder
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetsZorder                          WidgetsZorder                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HideHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowManUserWidgetByZorder(class UObject* WorldContextObject, float AnimDuration, EWidgetsZorder WidgetsZorder, bool HideHUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowManUserWidgetByZorder");

	Params::UIFunctionLibrary_ShowManUserWidgetByZorder Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.WidgetsZorder = WidgetsZorder;
	Parms.HideHUD = HideHUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowMapWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMapWindowUserWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapWindowUserWidget* UUIFunctionLibrary::ShowMapWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowMapWindow");

	Params::UIFunctionLibrary_ShowMapWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowMouseCursor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowMouseCursor(class UObject* WorldContextObject, bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowMouseCursor");

	Params::UIFunctionLibrary_ShowMouseCursor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowNPCBestiaryWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowNPCBestiaryWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowNPCBestiaryWindow");

	Params::UIFunctionLibrary_ShowNPCBestiaryWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowOptions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowOptions(class UObject* WorldContextObject, float AnimDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowOptions");

	Params::UIFunctionLibrary_ShowOptions Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowOptionsSubtitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowOptionsSubtitle(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowOptionsSubtitle");

	Params::UIFunctionLibrary_ShowOptionsSubtitle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowPauseMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOpenAkEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowPauseMenu(class UObject* WorldContextObject, float AnimDuration, bool bOpenAkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowPauseMenu");

	Params::UIFunctionLibrary_ShowPauseMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.bOpenAkEvent = bOpenAkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowPlayerMonologue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueDataAsset*               DialogueDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>OnCompleted                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UPlayerMonologueUserWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerMonologueUserWidget* UUIFunctionLibrary::ShowPlayerMonologue(class UObject* WorldContextObject, class UDialogueDataAsset* DialogueDataAsset, const TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>& OnCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowPlayerMonologue");

	Params::UIFunctionLibrary_ShowPlayerMonologue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueDataAsset = DialogueDataAsset;
	Parms.OnCompleted = OnCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowSubtitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueNode                    DialogueNode                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   SubtitleDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowSubtitle(class UObject* WorldContextObject, const struct FDialogueNode& DialogueNode, float SubtitleDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowSubtitle");

	Params::UIFunctionLibrary_ShowSubtitle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DialogueNode = std::move(DialogueNode);
	Parms.SubtitleDuration = SubtitleDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowTutorialReplayScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialScreenDataAsset*         TutorialScreenDataAsset                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialScreenUserWidget*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialScreenUserWidget* UUIFunctionLibrary::ShowTutorialReplayScreen(class UObject* WorldContextObject, class UTutorialScreenDataAsset* TutorialScreenDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowTutorialReplayScreen");

	Params::UIFunctionLibrary_ShowTutorialReplayScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TutorialScreenDataAsset = TutorialScreenDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowTutorialScreen
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialScreenDataAsset*         TutorialScreenDataAsset                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>OnCompleted                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UTutorialScreenUserWidget*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialScreenUserWidget* UUIFunctionLibrary::ShowTutorialScreen(class UObject* WorldContextObject, class UTutorialScreenDataAsset* TutorialScreenDataAsset, const TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)>& OnCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowTutorialScreen");

	Params::UIFunctionLibrary_ShowTutorialScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TutorialScreenDataAsset = TutorialScreenDataAsset;
	Parms.OnCompleted = OnCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowTutorialSign
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTutorialPrompt                  PromptStruct                                           (Parm, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowTutorialSign(class UObject* WorldContextObject, const struct FTutorialPrompt& PromptStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowTutorialSign");

	Params::UIFunctionLibrary_ShowTutorialSign Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PromptStruct = std::move(PromptStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.ShowVendorAlchemistWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExclusiveGardenMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorAlchemistWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor, bool bExclusiveGardenMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorAlchemistWindow");

	Params::UIFunctionLibrary_ShowVendorAlchemistWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;
	Parms.bExclusiveGardenMode = bExclusiveGardenMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorBuyWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorBuyWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorBuyWindow");

	Params::UIFunctionLibrary_ShowVendorBuyWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorCraftWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorCraftWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorCraftWindow");

	Params::UIFunctionLibrary_ShowVendorCraftWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorEnchantWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorEnchantWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorEnchantWindow");

	Params::UIFunctionLibrary_ShowVendorEnchantWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorMapFragmentWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorMapFragmentWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorMapFragmentWindow");

	Params::UIFunctionLibrary_ShowVendorMapFragmentWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorSellWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorSellWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorSellWindow");

	Params::UIFunctionLibrary_ShowVendorSellWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorTransmogWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorTransmogWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorTransmogWindow");

	Params::UIFunctionLibrary_ShowVendorTransmogWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowVendorUpgradeWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManUserWidgetBase*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManUserWidgetBase* UUIFunctionLibrary::ShowVendorUpgradeWindow(class UObject* WorldContextObject, float AnimDuration, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowVendorUpgradeWindow");

	Params::UIFunctionLibrary_ShowVendorUpgradeWindow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimDuration = AnimDuration;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UIFunctionLibrary.ShowWindowByTabButtonType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETabButtonType                          TabButtonType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::ShowWindowByTabButtonType(class UObject* WorldContextObject, ETabButtonType TabButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "ShowWindowByTabButtonType");

	Params::UIFunctionLibrary_ShowWindowByTabButtonType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TabButtonType = TabButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.SimulateInputKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::SimulateInputKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "SimulateInputKey");

	Params::UIFunctionLibrary_SimulateInputKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.StopAkAudioEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TransitionDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AkEventActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::StopAkAudioEvent(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, int32 TransitionDuration, class AActor* AkEventActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "StopAkAudioEvent");

	Params::UIFunctionLibrary_StopAkAudioEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AkEvent = AkEvent;
	Parms.TransitionDuration = TransitionDuration;
	Parms.AkEventActor = AkEventActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.TriggerHudCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHudCommand                             HUDCommand                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActorBase*                       InteractedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::TriggerHudCommand(class UObject* WorldContextObject, EHudCommand HUDCommand, class AActorBase* InteractedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "TriggerHudCommand");

	Params::UIFunctionLibrary_TriggerHudCommand Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HUDCommand = HUDCommand;
	Parms.InteractedActor = InteractedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UIFunctionLibrary.TriggerHudMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHudMessage                             Msg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFunctionLibrary::TriggerHudMessage(class UObject* WorldContextObject, EHudMessage Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFunctionLibrary", "TriggerHudMessage");

	Params::UIFunctionLibrary_TriggerHudMessage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableBurst.StatusEffectApplied
// (Final, Native, Public)
// Parameters:
// class AActor*                           effecttarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnstableBurst::StatusEffectApplied(class AActor* effecttarget, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableBurst", "StatusEffectApplied");

	Params::UnstableBurst_StatusEffectApplied Parms{};

	Parms.effecttarget = effecttarget;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableTrailActor.Explode
// (Final, Native, Public, BlueprintCallable)

void AUnstableTrailActor::Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableTrailActor", "Explode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableTrailActor.IsValidDetonator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AUnstableTrailActor::IsValidDetonator(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableTrailActor", "IsValidDetonator");

	Params::UnstableTrailActor_IsValidDetonator Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UseInventoryAbility.OnRecoveryEnded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     RecoveryAbility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUseInventoryAbility::OnRecoveryEnded(class UAbilityBase* RecoveryAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UseInventoryAbility", "OnRecoveryEnded");

	Params::UseInventoryAbility_OnRecoveryEnded Parms{};

	Parms.RecoveryAbility = RecoveryAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VampireBeastAI.EventOnAbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVampireBeastAI::EventOnAbilityEnd(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireBeastAI", "EventOnAbilityEnd");

	Params::VampireBeastAI_EventOnAbilityEnd Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VampireBeastAI.EventOnAbilityStarting
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVampireBeastAI::EventOnAbilityStarting(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireBeastAI", "EventOnAbilityStarting");

	Params::VampireBeastAI_EventOnAbilityStarting Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VampireLordAI.BPStartAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInSkipRoomEnter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSerialize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVampireLordAI::BPStartAggro(bool bInSkipRoomEnter, bool bSerialize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireLordAI", "BPStartAggro");

	Params::VampireLordAI_BPStartAggro Parms{};

	Parms.bInSkipRoomEnter = bInSkipRoomEnter;
	Parms.bSerialize = bSerialize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VampireLordAI.EventOnAbilityEnd
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVampireLordAI::EventOnAbilityEnd(class UAbilityBase* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VampireLordAI", "EventOnAbilityEnd");

	Params::VampireLordAI_EventOnAbilityEnd Parms{};

	Parms.InAbility = InAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Varlist.BPFindVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVarlist::BPFindVariable(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Varlist", "BPFindVariable");

	Params::Varlist_BPFindVariable Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Varlist.BPGetValue_Text
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVarlist::BPGetValue_Text(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Varlist", "BPGetValue_Text");

	Params::Varlist_BPGetValue_Text Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.Varlist.BPGetVariable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVarlistValue*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVarlistValue* UVarlist::BPGetVariable(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Varlist", "BPGetVariable");

	Params::Varlist_BPGetVariable Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VarlistValueFloat.GetEditorName
// (Final, Native, Private)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UVarlistValueFloat::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VarlistValueFloat", "GetEditorName");

	Params::VarlistValueFloat_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.ApplyCartUpgrade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::ApplyCartUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "ApplyCartUpgrade");

	Params::VendorActor_ApplyCartUpgrade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.BPAddXP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Xp                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::BPAddXP(float Xp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "BPAddXP");

	Params::VendorActor_BPAddXP Parms{};

	Parms.Xp = Xp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.BPShowMiniMapIcon
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::BPShowMiniMapIcon(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "BPShowMiniMapIcon");

	Params::VendorActor_BPShowMiniMapIcon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function man.VendorActor.BuyItemFromVendor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorItemSlot*                  ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::BuyItemFromVendor(class UVendorItemSlot* ItemSlot, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "BuyItemFromVendor");

	Params::VendorActor_BuyItemFromVendor Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.CanUseCartUpgrade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::CanUseCartUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "CanUseCartUpgrade");

	Params::VendorActor_CanUseCartUpgrade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.CraftItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorItemSlot*                  CraftItem_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemAbility* AVendorActor::CraftItem(class UVendorItemSlot* CraftItem_0, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "CraftItem");

	Params::VendorActor_CraftItem Parms{};

	Parms.CraftItem_0 = CraftItem_0;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.DisenchantItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemEnchantItemAbility>EnchantType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 ItemToDisenchant                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetEnchantment                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::DisenchantItem(TSubclassOf<class UItemEnchantItemAbility> EnchantType, class UManItemSlotBase* ItemToDisenchant, bool bGetEnchantment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "DisenchantItem");

	Params::VendorActor_DisenchantItem Parms{};

	Parms.EnchantType = EnchantType;
	Parms.ItemToDisenchant = ItemToDisenchant;
	Parms.bGetEnchantment = bGetEnchantment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.EnchantItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 EnchantItem_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 ItemToEnchant                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::EnchantItem(class UManItemSlotBase* EnchantItem_0, class UManItemSlotBase* ItemToEnchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "EnchantItem");

	Params::VendorActor_EnchantItem Parms{};

	Parms.EnchantItem_0 = EnchantItem_0;
	Parms.ItemToEnchant = ItemToEnchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.GetCraftItemCalculatedXP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorItemSlot*                  CraftItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetCraftItemCalculatedXP(class UVendorItemSlot* CraftItem, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetCraftItemCalculatedXP");

	Params::VendorActor_GetCraftItemCalculatedXP Parms{};

	Parms.CraftItem = CraftItem;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetCurrentExperience
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetCurrentExperience()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetCurrentExperience");

	Params::VendorActor_GetCurrentExperience Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetEnchantItemCalculatedXP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetEnchantItemCalculatedXP(class UManItemSlotBase* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetEnchantItemCalculatedXP");

	Params::VendorActor_GetEnchantItemCalculatedXP Parms{};

	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetExperienceForLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetExperienceForLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetExperienceForLevel");

	Params::VendorActor_GetExperienceForLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetExperienceForNextLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetExperienceForNextLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetExperienceForNextLevel");

	Params::VendorActor_GetExperienceForNextLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetHerbGarden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorHerbGarden*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorHerbGarden* AVendorActor::GetHerbGarden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetHerbGarden");

	Params::VendorActor_GetHerbGarden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetItemEnchantments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetItemEnchantments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetItemEnchantments");

	Params::VendorActor_GetItemEnchantments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetItemPrice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVendorActionQueryMode                  QueryMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVendorPriceData>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVendorPriceData> AVendorActor::GetItemPrice(class UManItemSlotBase* ItemSlot, EVendorActionQueryMode QueryMode, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetItemPrice");

	Params::VendorActor_GetItemPrice Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.QueryMode = QueryMode;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetLearnableDiagrams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetLearnableDiagrams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetLearnableDiagrams");

	Params::VendorActor_GetLearnableDiagrams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetLearnableMapFragments
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetLearnableMapFragments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetLearnableMapFragments");

	Params::VendorActor_GetLearnableMapFragments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetModifiedCraftingCost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCraftRecipe                     Recipe                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVendorActor::GetModifiedCraftingCost(const struct FCraftRecipe& Recipe, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetModifiedCraftingCost");

	Params::VendorActor_GetModifiedCraftingCost Parms{};

	Parms.Recipe = std::move(Recipe);
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetSoldPlayerItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetSoldPlayerItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetSoldPlayerItems");

	Params::VendorActor_GetSoldPlayerItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetVendorCraftableItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetVendorCraftableItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetVendorCraftableItems");

	Params::VendorActor_GetVendorCraftableItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetVendorLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AVendorActor::GetVendorLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetVendorLevel");

	Params::VendorActor_GetVendorLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetVendorTypeText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AVendorActor::GetVendorTypeText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetVendorTypeText");

	Params::VendorActor_GetVendorTypeText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.GetVendorWares
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UManItemSlotBase*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UManItemSlotBase*> AVendorActor::GetVendorWares()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "GetVendorWares");

	Params::VendorActor_GetVendorWares Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsDiagramLearnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDiagramItemAbility*              Diagram                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsDiagramLearnable(class UDiagramItemAbility* Diagram)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsDiagramLearnable");

	Params::VendorActor_IsDiagramLearnable Parms{};

	Parms.Diagram = Diagram;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsIEnchantOnItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItemEnchantItemAbility>EnchantType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsIEnchantOnItem(TSubclassOf<class UItemEnchantItemAbility> EnchantType, class UManItemSlotBase* ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsIEnchantOnItem");

	Params::VendorActor_IsIEnchantOnItem Parms{};

	Parms.EnchantType = EnchantType;
	Parms.ItemSlot = ItemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsInCaravan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsInCaravan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsInCaravan");

	Params::VendorActor_IsInCaravan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsInvalidEnchantTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 ItemToEnchant                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsInvalidEnchantTarget(class UManItemSlotBase* ItemToEnchant, class UManItemSlotBase* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsInvalidEnchantTarget");

	Params::VendorActor_IsInvalidEnchantTarget Parms{};

	Parms.ItemToEnchant = ItemToEnchant;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsItemCraftable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVendorItemSlot*                  CraftItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsItemCraftable(class UVendorItemSlot* CraftItem, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsItemCraftable");

	Params::VendorActor_IsItemCraftable Parms{};

	Parms.CraftItem = CraftItem;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsItemEnchantable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 ItemToEnchant                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 EnchantItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsItemEnchantable(class UManItemSlotBase* ItemToEnchant, class UManItemSlotBase* EnchantItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsItemEnchantable");

	Params::VendorActor_IsItemEnchantable Parms{};

	Parms.ItemToEnchant = ItemToEnchant;
	Parms.EnchantItem = EnchantItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsItemEnchanted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsItemEnchanted(class UManItemSlotBase* ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsItemEnchanted");

	Params::VendorActor_IsItemEnchanted Parms{};

	Parms.ItemSlot = ItemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.IsMaxLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::IsMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "IsMaxLevel");

	Params::VendorActor_IsMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.LearnAllDiagram
// (Final, Native, Public, BlueprintCallable)

void AVendorActor::LearnAllDiagram()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "LearnAllDiagram");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.LearnAllMapFragment
// (Final, Native, Public, BlueprintCallable)

void AVendorActor::LearnAllMapFragment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "LearnAllMapFragment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.LearnDiagram
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDiagramItemAbility*              Diagram                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGainXPForLearning                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitializeDiagram                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::LearnDiagram(class UDiagramItemAbility* Diagram, bool bGainXPForLearning, bool bInitializeDiagram)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "LearnDiagram");

	Params::VendorActor_LearnDiagram Parms{};

	Parms.Diagram = Diagram;
	Parms.bGainXPForLearning = bGainXPForLearning;
	Parms.bInitializeDiagram = bInitializeDiagram;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.LearnMapFragment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapFragmentItemAbility*          MapFragmentItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGainXPForLearning                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::LearnMapFragment(class UMapFragmentItemAbility* MapFragmentItem, bool bGainXPForLearning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "LearnMapFragment");

	Params::VendorActor_LearnMapFragment Parms{};

	Parms.MapFragmentItem = MapFragmentItem;
	Parms.bGainXPForLearning = bGainXPForLearning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.SellItemToVendor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInventorySlot*                   ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVendorActor::SellItemToVendor(class UInventorySlot* ItemSlot, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "SellItemToVendor");

	Params::VendorActor_SellItemToVendor Parms{};

	Parms.ItemSlot = ItemSlot;
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorActor.SlotQuery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 SlotToQuery                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVendorActionQueryMode                  QueryMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManItemSlotBase*                 ItemToEnchant                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EVendorActionQuery>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EVendorActionQuery> AVendorActor::SlotQuery(class UManItemSlotBase* SlotToQuery, EVendorActionQueryMode QueryMode, int32 amount, class UManItemSlotBase* ItemToEnchant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "SlotQuery");

	Params::VendorActor_SlotQuery Parms{};

	Parms.SlotToQuery = SlotToQuery;
	Parms.QueryMode = QueryMode;
	Parms.amount = amount;
	Parms.ItemToEnchant = ItemToEnchant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorActor.TransmogrifyItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemAbility*                     ItemAbility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemSlot                               ItemSlotType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVendorActor::TransmogrifyItem(class UItemAbility* ItemAbility, EItemSlot ItemSlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorActor", "TransmogrifyItem");

	Params::VendorActor_TransmogrifyItem Parms{};

	Parms.ItemAbility = ItemAbility;
	Parms.ItemSlotType = ItemSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorManager.GetVendorData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AVendorActor>         VendorClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVendorStateData*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorStateData* UVendorManager::GetVendorData(TSubclassOf<class AVendorActor> VendorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorManager", "GetVendorData");

	Params::VendorManager_GetVendorData Parms{};

	Parms.VendorClass = VendorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorBuyUserWidget.BPBuyItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorBuyUserWidget::BPBuyItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "BPBuyItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorBuyUserWidget.BPBuyMaxItem
// (Final, Native, Protected, BlueprintCallable)

void UVendorBuyUserWidget::BPBuyMaxItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "BPBuyMaxItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorBuyUserWidget.OnBuyItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorBuyUserWidget::OnBuyItem(class UTexture2D* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "OnBuyItem");

	Params::VendorBuyUserWidget_OnBuyItem Parms{};

	Parms.Icon = Icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorBuyUserWidget.OnDiagramLearned
// (Final, Native, Protected)

void UVendorBuyUserWidget::OnDiagramLearned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "OnDiagramLearned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorBuyUserWidget.OnFocusWidgetChangedEvent
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          OldFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewFocusedWidget                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorBuyUserWidget::OnFocusWidgetChangedEvent(class UWidget* OldFocusedWidget, class UWidget* NewFocusedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "OnFocusWidgetChangedEvent");

	Params::VendorBuyUserWidget_OnFocusWidgetChangedEvent Parms{};

	Parms.OldFocusedWidget = OldFocusedWidget;
	Parms.NewFocusedWidget = NewFocusedWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorBuyUserWidget.IsItemBtnsVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorBuyUserWidget::IsItemBtnsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorBuyUserWidget", "IsItemBtnsVisible");

	Params::VendorBuyUserWidget_IsItemBtnsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorConfirmationUserWidget.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UManItemSlotBase*                 InManItemSlotBase                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemAbility*                     InItemAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInBuyMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHeroProperty                           InPropertyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSelectedCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAllCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPricePerItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorConfirmationUserWidget::Init(class UManItemSlotBase* InManItemSlotBase, class UItemAbility* InItemAbility, bool bInBuyMode, EHeroProperty InPropertyType, int32 InSelectedCount, int32 InAllCount, int32 InPricePerItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorConfirmationUserWidget", "Init");

	Params::VendorConfirmationUserWidget_Init Parms{};

	Parms.InManItemSlotBase = InManItemSlotBase;
	Parms.InItemAbility = InItemAbility;
	Parms.bInBuyMode = bInBuyMode;
	Parms.InPropertyType = InPropertyType;
	Parms.InSelectedCount = InSelectedCount;
	Parms.InAllCount = InAllCount;
	Parms.InPricePerItem = InPricePerItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorConfirmationUserWidget.OnSetSelectedCount
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InSelectedCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorConfirmationUserWidget::OnSetSelectedCount(int32 InSelectedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorConfirmationUserWidget", "OnSetSelectedCount");

	Params::VendorConfirmationUserWidget_OnSetSelectedCount Parms{};

	Parms.InSelectedCount = InSelectedCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorConfirmationUserWidget.SetSelectedCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSelectedCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorConfirmationUserWidget::SetSelectedCount(int32 InSelectedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorConfirmationUserWidget", "SetSelectedCount");

	Params::VendorConfirmationUserWidget_SetSelectedCount Parms{};

	Parms.InSelectedCount = InSelectedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorCraftSlotUserWidget.OnSetItemRequirements
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InItemRequirements                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorCraftSlotUserWidget::OnSetItemRequirements(const class FText& InItemRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftSlotUserWidget", "OnSetItemRequirements");

	Params::VendorCraftSlotUserWidget_OnSetItemRequirements Parms{};

	Parms.InItemRequirements = std::move(InItemRequirements);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorCraftSlotUserWidget.OnSetItemType
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InItemType                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorCraftSlotUserWidget::OnSetItemType(const class FText& InItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftSlotUserWidget", "OnSetItemType");

	Params::VendorCraftSlotUserWidget_OnSetItemType Parms{};

	Parms.InItemType = std::move(InItemType);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorCraftSlotUserWidget.OnSetMaxCraftableNum
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InMaxCraftableNum                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInIsUnavailable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorCraftSlotUserWidget::OnSetMaxCraftableNum(const class FText& InMaxCraftableNum, bool bInIsUnavailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorCraftSlotUserWidget", "OnSetMaxCraftableNum");

	Params::VendorCraftSlotUserWidget_OnSetMaxCraftableNum Parms{};

	Parms.InMaxCraftableNum = std::move(InMaxCraftableNum);
	Parms.bInIsUnavailable = bInIsUnavailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.OnSetEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorFilterSlotUserWidget::OnSetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "OnSetEnabled");

	Params::VendorFilterSlotUserWidget_OnSetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.OnSetItemIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ItemIcon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorFilterSlotUserWidget::OnSetItemIcon(class UTexture2D* ItemIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "OnSetItemIcon");

	Params::VendorFilterSlotUserWidget_OnSetItemIcon Parms{};

	Parms.ItemIcon = ItemIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.OnSetSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorFilterSlotUserWidget::OnSetSelected(bool bInSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "OnSetSelected");

	Params::VendorFilterSlotUserWidget_OnSetSelected Parms{};

	Parms.bInSelected = bInSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.OnSetVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorFilterSlotUserWidget::OnSetVisible(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "OnSetVisible");

	Params::VendorFilterSlotUserWidget_OnSetVisible Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.OnToggleNewItemWarning
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorFilterSlotUserWidget::OnToggleNewItemWarning(bool bInVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "OnToggleNewItemWarning");

	Params::VendorFilterSlotUserWidget_OnToggleNewItemWarning Parms{};

	Parms.bInVisible = bInVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorFilterSlotUserWidget.GetSlotName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVendorFilterSlotUserWidget::GetSlotName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "GetSlotName");

	Params::VendorFilterSlotUserWidget_GetSlotName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorFilterSlotUserWidget.IsFilterEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorFilterSlotUserWidget::IsFilterEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorFilterSlotUserWidget", "IsFilterEnabled");

	Params::VendorFilterSlotUserWidget_IsFilterEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorMapFragmentLabelUserWidget.OnUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentLabelUserWidget::OnUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentLabelUserWidget", "OnUnlock");

	Params::VendorMapFragmentLabelUserWidget_OnUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorMapFragmentSlotUserWidget.GetTexture
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVendorMapFragmentSlotUserWidget::GetTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentSlotUserWidget", "GetTexture");

	Params::VendorMapFragmentSlotUserWidget_GetTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorMapFragmentSlotUserWidget.OnSetTexture
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentSlotUserWidget::OnSetTexture(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentSlotUserWidget", "OnSetTexture");

	Params::VendorMapFragmentSlotUserWidget_OnSetTexture Parms{};

	Parms.bSet = bSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorMapFragmentSlotUserWidget.OnUnlock
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentSlotUserWidget::OnUnlock(bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentSlotUserWidget", "OnUnlock");

	Params::VendorMapFragmentSlotUserWidget_OnUnlock Parms{};

	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorMapFragmentUserWidget.GetVendorLevelByMapFragments
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVendorMapFragmentUserWidget::GetVendorLevelByMapFragments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentUserWidget", "GetVendorLevelByMapFragments");

	Params::VendorMapFragmentUserWidget_GetVendorLevelByMapFragments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorMapFragmentUserWidget.OnLearnMapFragment
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    LevelUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentUserWidget::OnLearnMapFragment(bool LevelUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentUserWidget", "OnLearnMapFragment");

	Params::VendorMapFragmentUserWidget_OnLearnMapFragment Parms{};

	Parms.LevelUp = LevelUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorMapFragmentUserWidget.OnMiniMapSegmentUnlocked
// (Final, Native, Protected)
// Parameters:
// class UMapSegmentVolumeID*              SegmentID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentUserWidget::OnMiniMapSegmentUnlocked(class UMapSegmentVolumeID* SegmentID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentUserWidget", "OnMiniMapSegmentUnlocked");

	Params::VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked Parms{};

	Parms.SegmentID = SegmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorMapFragmentUserWidget.OnSetMapFragmentParams
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             MapFragmentsNum                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             MapFragmentsXpText                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MapFragmentsXpValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMapFragmentsAvailable                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorMapFragmentUserWidget::OnSetMapFragmentParams(const class FText& MapFragmentsNum, const class FText& MapFragmentsXpText, float MapFragmentsXpValue, bool bMapFragmentsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorMapFragmentUserWidget", "OnSetMapFragmentParams");

	Params::VendorMapFragmentUserWidget_OnSetMapFragmentParams Parms{};

	Parms.MapFragmentsNum = std::move(MapFragmentsNum);
	Parms.MapFragmentsXpText = std::move(MapFragmentsXpText);
	Parms.MapFragmentsXpValue = MapFragmentsXpValue;
	Parms.bMapFragmentsAvailable = bMapFragmentsAvailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorTransmogRowUserWidget.OnSetData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InEquippedItemIcon                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       InTransmogItemIcon                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InTransmogItemName                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInUnavailable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorTransmogRowUserWidget::OnSetData(class UTexture2D* InEquippedItemIcon, class UTexture2D* InTransmogItemIcon, const class FText& InTransmogItemName, bool bInUnavailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogRowUserWidget", "OnSetData");

	Params::VendorTransmogRowUserWidget_OnSetData Parms{};

	Parms.InEquippedItemIcon = InEquippedItemIcon;
	Parms.InTransmogItemIcon = InTransmogItemIcon;
	Parms.InTransmogItemName = std::move(InTransmogItemName);
	Parms.bInUnavailable = bInUnavailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorTransmogUserWidget.BtnHotkeyAClickedRequest
// (Final, Native, Protected, BlueprintCallable)

void UVendorTransmogUserWidget::BtnHotkeyAClickedRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "BtnHotkeyAClickedRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorTransmogUserWidget.DoItemListCustomNavigation_Down
// (Final, Native, Protected)

void UVendorTransmogUserWidget::DoItemListCustomNavigation_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "DoItemListCustomNavigation_Down");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorTransmogUserWidget.DoItemListCustomNavigation_Up
// (Final, Native, Protected)

void UVendorTransmogUserWidget::DoItemListCustomNavigation_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "DoItemListCustomNavigation_Up");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VendorTransmogUserWidget.GetSelectedVendorTransmogRowUserWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UVendorTransmogRowUserWidget*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVendorTransmogRowUserWidget* UVendorTransmogUserWidget::GetSelectedVendorTransmogRowUserWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "GetSelectedVendorTransmogRowUserWidget");

	Params::VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorTransmogUserWidget.OnAddTransmogItem
// (Event, Protected, BlueprintEvent)

void UVendorTransmogUserWidget::OnAddTransmogItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "OnAddTransmogItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorTransmogUserWidget.OnRemoveTransmogItem
// (Event, Protected, BlueprintEvent)

void UVendorTransmogUserWidget::OnRemoveTransmogItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "OnRemoveTransmogItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorTransmogUserWidget.OnSetTransmogMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInTransmogMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorTransmogUserWidget::OnSetTransmogMode(bool bInTransmogMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "OnSetTransmogMode");

	Params::VendorTransmogUserWidget_OnSetTransmogMode Parms{};

	Parms.bInTransmogMode = bInTransmogMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorTransmogUserWidget.IsTransmogMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVendorTransmogUserWidget::IsTransmogMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorTransmogUserWidget", "IsTransmogMode");

	Params::VendorTransmogUserWidget_IsTransmogMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorUpgradeUserWidget.GetVendorLevelByDiagrams
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVendorUpgradeUserWidget::GetVendorLevelByDiagrams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "GetVendorLevelByDiagrams");

	Params::VendorUpgradeUserWidget_GetVendorLevelByDiagrams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VendorUpgradeUserWidget.OnLearnDiagram
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    LevelUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUpgradeUserWidget::OnLearnDiagram(bool LevelUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnLearnDiagram");

	Params::VendorUpgradeUserWidget_OnLearnDiagram Parms{};

	Parms.LevelUp = LevelUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUpgradeUserWidget.OnSetDiagramParams
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             DiagramsNum                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             DiagramsXpText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DiagramsXpValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDiagramsAvailable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUpgradeUserWidget::OnSetDiagramParams(const class FText& DiagramsNum, const class FText& DiagramsXpText, float DiagramsXpValue, bool bDiagramsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnSetDiagramParams");

	Params::VendorUpgradeUserWidget_OnSetDiagramParams Parms{};

	Parms.DiagramsNum = std::move(DiagramsNum);
	Parms.DiagramsXpText = std::move(DiagramsXpText);
	Parms.DiagramsXpValue = DiagramsXpValue;
	Parms.bDiagramsAvailable = bDiagramsAvailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUpgradeUserWidget.OnSetUpgradeCost
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShowUpgradeCost                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UpgradeCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorUpgradeUserWidget::OnSetUpgradeCost(bool bShowUpgradeCost, int32 UpgradeCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnSetUpgradeCost");

	Params::VendorUpgradeUserWidget_OnSetUpgradeCost Parms{};

	Parms.bShowUpgradeCost = bShowUpgradeCost;
	Parms.UpgradeCost = UpgradeCost;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUpgradeUserWidget.OnSetUpgradeTitle
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             UpgradeTitle                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVendorUpgradeUserWidget::OnSetUpgradeTitle(const class FText& UpgradeTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnSetUpgradeTitle");

	Params::VendorUpgradeUserWidget_OnSetUpgradeTitle Parms{};

	Parms.UpgradeTitle = std::move(UpgradeTitle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.VendorUpgradeUserWidget.OnUpgradeCart
// (Event, Protected, BlueprintEvent)

void UVendorUpgradeUserWidget::OnUpgradeCart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnUpgradeCart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function man.VendorUpgradeUserWidget.OnUpgradeCartAnimFinished
// (Final, Native, Public, BlueprintCallable)

void UVendorUpgradeUserWidget::OnUpgradeCartAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorUpgradeUserWidget", "OnUpgradeCartAnimFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VfxComponentBase.BPForceKill
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UVfxComponentBase::BPForceKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "BPForceKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VfxComponentBase.BPPlayDamageBloodSplashVfx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVfxComponentBase::BPPlayDamageBloodSplashVfx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "BPPlayDamageBloodSplashVfx");

	Params::VfxComponentBase_BPPlayDamageBloodSplashVfx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VfxComponentBase.BPPlayDamageVfx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVfxComponentBase::BPPlayDamageVfx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "BPPlayDamageVfx");

	Params::VfxComponentBase_BPPlayDamageVfx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VfxComponentBase.BPStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UVfxComponentBase::BPStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "BPStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VfxComponentBase.BPTick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVfxComponentBase::BPTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "BPTick");

	Params::VfxComponentBase_BPTick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VfxComponentBase.GetAbilityController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilityController*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityController* UVfxComponentBase::GetAbilityController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "GetAbilityController");

	Params::VfxComponentBase_GetAbilityController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VfxComponentBase.GetAttributeContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAttributeContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttributeContainer* UVfxComponentBase::GetAttributeContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "GetAttributeContainer");

	Params::VfxComponentBase_GetAttributeContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VfxComponentBase.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UVfxComponentBase::GetSkeletalMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "GetSkeletalMesh");

	Params::VfxComponentBase_GetSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VfxComponentBase.OnSystemFinishedHandler
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         PSystem                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVfxComponentBase::OnSystemFinishedHandler(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VfxComponentBase", "OnSystemFinishedHandler");

	Params::VfxComponentBase_OnSystemFinishedHandler Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.VLB_JumpAttackAbility.BPGetChandelierLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVLB_JumpAttackAbility::BPGetChandelierLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VLB_JumpAttackAbility", "BPGetChandelierLocation");

	Params::VLB_JumpAttackAbility_BPGetChandelierLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VLB_JumpAttackAbility.BPGetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVLB_JumpAttackAbility::BPGetTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VLB_JumpAttackAbility", "BPGetTargetLocation");

	Params::VLB_JumpAttackAbility_BPGetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VLB_JumpAttackAbility.Chandelier_OnAnimEventBase
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAnimEventParam                  AnimEventParam                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UVLB_JumpAttackAbility::Chandelier_OnAnimEventBase(struct FAnimEventParam* AnimEventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VLB_JumpAttackAbility", "Chandelier_OnAnimEventBase");

	Params::VLB_JumpAttackAbility_Chandelier_OnAnimEventBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimEventParam != nullptr)
		*AnimEventParam = std::move(Parms.AnimEventParam);
}


// Function man.VWAnamorphosis.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVWAnamorphosis::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VWAnamorphosis", "BPGetTeleportLocation");

	Params::VWAnamorphosis_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VoidWitchTeleport.BPGetStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoidWitchTeleport::BPGetStartLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidWitchTeleport", "BPGetStartLocation");

	Params::VoidWitchTeleport_BPGetStartLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VoidWitchTeleport.BPGetTeleportLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoidWitchTeleport::BPGetTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidWitchTeleport", "BPGetTeleportLocation");

	Params::VoidWitchTeleport_BPGetTeleportLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.VolatileConduit.OnAbilityAdded
// (Final, Native, Public)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolatileConduit::OnAbilityAdded(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VolatileConduit", "OnAbilityAdded");

	Params::VolatileConduit_OnAbilityAdded Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WallClimb.OnAnimToggled
// (Final, Native, Public)
// Parameters:
// class UAnimID*                          AnimID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWallClimb::OnAnimToggled(class UAnimID* AnimID, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallClimb", "OnAnimToggled");

	Params::WallClimb_OnAnimToggled Parms{};

	Parms.AnimID = AnimID;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WallClimb.OnTeleport
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWallClimb::OnTeleport(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallClimb", "OnTeleport");

	Params::WallClimb_OnTeleport Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.EnergyAttunement.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnergyAttunement::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyAttunement", "OnPostDamageCaused");

	Params::EnergyAttunement_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Grounding.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGrounding::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grounding", "OnPostDamageCaused");

	Params::Grounding_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.UnstableElements.BPGetTargetEnemyForDamageVfx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnemyCharacter* UUnstableElements::BPGetTargetEnemyForDamageVfx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableElements", "BPGetTargetEnemyForDamageVfx");

	Params::UnstableElements_BPGetTargetEnemyForDamageVfx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.UnstableElements.OnPreDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UUnstableElements::OnPreDamageCaused(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableElements", "OnPreDamageCaused");

	Params::UnstableElements_OnPreDamageCaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.CycleOfLife.OnEntityKilled
// (Final, Native, Protected)
// Parameters:
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCycleOfLife::OnEntityKilled(class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CycleOfLife", "OnEntityKilled");

	Params::CycleOfLife_OnEntityKilled Parms{};

	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CycleOfLife.OnLootActorPickedUp
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCycleOfLife::OnLootActorPickedUp(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CycleOfLife", "OnLootActorPickedUp");

	Params::CycleOfLife_OnLootActorPickedUp Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.CycleOfLife.Reset
// (Final, Native, Protected)

void UCycleOfLife::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CycleOfLife", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Rejuvenation.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URejuvenation::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rejuvenation", "OnPostDamageCaused");

	Params::Rejuvenation_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Rejuvenation.Reset
// (Final, Native, Protected)

void URejuvenation::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rejuvenation", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.Thornskin.OnPostDamaged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UThornskin::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Thornskin", "OnPostDamaged");

	Params::Thornskin_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.Thornskin.OnPreDamagedPriority
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UThornskin::OnPreDamagedPriority(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Thornskin", "OnPreDamagedPriority");

	Params::Thornskin_OnPreDamagedPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.Thornskin.Reset
// (Final, Native, Protected)

void UThornskin::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Thornskin", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.SicEm.OnPostDamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USicEm::OnPostDamageCaused(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SicEm", "OnPostDamageCaused");

	Params::SicEm_OnPostDamageCaused Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SicEm.OnProjectileShot
// (Final, Native, Protected)
// Parameters:
// class AManProjectile*                   Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USicEm::OnProjectileShot(class AManProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SicEm", "OnProjectileShot");

	Params::SicEm_OnProjectileShot Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WyldEcho.BPGetDelayInSec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWyldEcho::BPGetDelayInSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WyldEcho", "BPGetDelayInSec");

	Params::WyldEcho_BPGetDelayInSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WyldEcho.BPGetDelayTimerCurrentValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWyldEcho::BPGetDelayTimerCurrentValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WyldEcho", "BPGetDelayTimerCurrentValue");

	Params::WyldEcho_BPGetDelayTimerCurrentValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WyldEcho.OnAbilityAdded
// (Final, Native, Protected)
// Parameters:
// class UAbilityBase*                     Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWyldEcho::OnAbilityAdded(class UAbilityBase* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WyldEcho", "OnAbilityAdded");

	Params::WyldEcho_OnAbilityAdded Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WyldEcho.OnPostAbilityStarted
// (Final, Native, Protected)
// Parameters:
// class UAbilityBase*                     StartedAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDesired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWyldEcho::OnPostAbilityStarted(class UAbilityBase* StartedAbility, bool bDesired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WyldEcho", "OnPostAbilityStarted");

	Params::WyldEcho_OnPostAbilityStarted Parms{};

	Parms.StartedAbility = StartedAbility;
	Parms.bDesired = bDesired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WyldEcho.Reset
// (Final, Native, Protected)

void UWyldEcho::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WyldEcho", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.VenomousThorns.OnStatusEffectCaused
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVenomousThorns::OnStatusEffectCaused(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VenomousThorns", "OnStatusEffectCaused");

	Params::VenomousThorns_OnStatusEffectCaused Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.ExplosiveDecomposition.BPGetBurstDamageRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UExplosiveDecomposition::BPGetBurstDamageRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosiveDecomposition", "BPGetBurstDamageRadius");

	Params::ExplosiveDecomposition_BPGetBurstDamageRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.ExplosiveDecomposition.OnStatusEffectCaused
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffectInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExplosiveDecomposition::OnStatusEffectCaused(class AActor* TargetActor, EStatusEffectType Type, bool IsNewEffect, class UStatusEffectInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplosiveDecomposition", "OnStatusEffectCaused");

	Params::ExplosiveDecomposition_OnStatusEffectCaused Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;
	Parms.IsNewEffect = IsNewEffect;
	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.SpiritualFocus.OnAttributeChanged
// (Final, Native, Protected)
// Parameters:
// EAttribute                              AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpiritualFocus::OnAttributeChanged(EAttribute AttributeType, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritualFocus", "OnAttributeChanged");

	Params::SpiritualFocus_OnAttributeChanged Parms{};

	Parms.AttributeType = AttributeType;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WeaponExpertPassive.RageChanged
// (Final, Native, Public)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponExpertPassive::RageChanged(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponExpertPassive", "RageChanged");

	Params::WeaponExpertPassive_RageChanged Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WeaponModelActor.BPPostWeaponAttachToggle
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bAttached                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponModelActor::BPPostWeaponAttachToggle(bool bAttached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponModelActor", "BPPostWeaponAttachToggle");

	Params::WeaponModelActor_BPPostWeaponAttachToggle Parms{};

	Parms.bAttached = bAttached;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.OneHandedSettings.GetEditorName
// (Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOneHandedSettings::GetEditorName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OneHandedSettings", "GetEditorName");

	Params::OneHandedSettings_GetEditorName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WindowWarningUserWidget.OnSetWarningText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bInShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             WarningText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EHasInventoryResourceResult>     InventoryResourceResults                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWindowWarningUserWidget::OnSetWarningText(bool bInShow, const class FText& WarningText, const TArray<EHasInventoryResourceResult>& InventoryResourceResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindowWarningUserWidget", "OnSetWarningText");

	Params::WindowWarningUserWidget_OnSetWarningText Parms{};

	Parms.bInShow = bInShow;
	Parms.WarningText = std::move(WarningText);
	Parms.InventoryResourceResults = std::move(InventoryResourceResults);

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.WitchLanternPassiveLifesteal.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWitchLanternPassiveLifesteal::DamageDealt(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternPassiveLifesteal", "DamageDealt");

	Params::WitchLanternPassiveLifesteal_DamageDealt Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternPassiveSpiritBond.LifeAuraDepleted
// (Final, Native, Public)

void UWitchLanternPassiveSpiritBond::LifeAuraDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternPassiveSpiritBond", "LifeAuraDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternPassiveSpiritBond.Prime
// (Final, Native, Public)

void UWitchLanternPassiveSpiritBond::Prime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternPassiveSpiritBond", "Prime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternPassiveSpiritBond.RespawnPrime
// (Final, Native, Public)
// Parameters:
// class AHeroBase*                        Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWitchLanternPassiveSpiritBond::RespawnPrime(class AHeroBase* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternPassiveSpiritBond", "RespawnPrime");

	Params::WitchLanternPassiveSpiritBond_RespawnPrime Parms{};

	Parms.Hero = Hero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function man.WitchLanternResourceUserWidget.OnSetValueColors
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   EssenceCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWitchLanternResourceUserWidget::OnSetValueColors(int32 EssenceCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternResourceUserWidget", "OnSetValueColors");

	Params::WitchLanternResourceUserWidget_OnSetValueColors Parms{};

	Parms.EssenceCost = EssenceCost;

	UObject::ProcessEvent(Func, &Parms);
}


// Function man.WitchLanternResourceUserWidget.GetCost
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWitchLanternResourceUserWidget::GetCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitchLanternResourceUserWidget", "GetCost");

	Params::WitchLanternResourceUserWidget_GetCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function man.WitherPassive.DamageDealt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UWitherPassive::DamageDealt(struct FPreDamagedEventParam* Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WitherPassive", "DamageDealt");

	Params::WitherPassive_DamageDealt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param != nullptr)
		*Param = std::move(Parms.Param);
}


// Function man.WraithAI.IsCollideSignature
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverride                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCollide                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWraithAI::IsCollideSignature(class AActor* Actor, bool* bOverride, bool* bCollide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WraithAI", "IsCollideSignature");

	Params::WraithAI_IsCollideSignature Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOverride != nullptr)
		*bOverride = Parms.bOverride;

	if (bCollide != nullptr)
		*bCollide = Parms.bCollide;
}


// Function man.BodyPartsAbility.OnPostDamaged
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPreDamagedEventParam            Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBodyPartsAbility::OnPostDamaged(const struct FPreDamagedEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BodyPartsAbility", "OnPostDamaged");

	Params::BodyPartsAbility_OnPostDamaged Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

