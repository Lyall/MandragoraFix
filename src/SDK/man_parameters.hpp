#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: man

#include "Basic.hpp"

#include "InputCore_structs.hpp"
#include "man_structs.hpp"
#include "MovieScene_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "PrimalConversation_structs.hpp"
#include "SlateCore_structs.hpp"
#include "AkAudio_structs.hpp"
#include "UMG_structs.hpp"


namespace SDK::Params
{

// Function man.AbilityBase.AbilityStartedEvent
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_AbilityStartedEvent final
{
public:
	class UAbilityBase*                           pStartedAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityBase_AbilityStartedEvent) == 0x000008, "Wrong alignment on AbilityBase_AbilityStartedEvent");
static_assert(sizeof(AbilityBase_AbilityStartedEvent) == 0x000010, "Wrong size on AbilityBase_AbilityStartedEvent");
static_assert(offsetof(AbilityBase_AbilityStartedEvent, pStartedAbility) == 0x000000, "Member 'AbilityBase_AbilityStartedEvent::pStartedAbility' has a wrong offset!");
static_assert(offsetof(AbilityBase_AbilityStartedEvent, bDesired) == 0x000008, "Member 'AbilityBase_AbilityStartedEvent::bDesired' has a wrong offset!");

// Function man.AbilityBase.BPAbilityCustomEvent
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPAbilityCustomEvent final
{
public:
	class FName                                   CustomName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPAbilityCustomEvent) == 0x000004, "Wrong alignment on AbilityBase_BPAbilityCustomEvent");
static_assert(sizeof(AbilityBase_BPAbilityCustomEvent) == 0x000008, "Wrong size on AbilityBase_BPAbilityCustomEvent");
static_assert(offsetof(AbilityBase_BPAbilityCustomEvent, CustomName) == 0x000000, "Member 'AbilityBase_BPAbilityCustomEvent::CustomName' has a wrong offset!");

// Function man.AbilityBase.BPCustomEvent
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPCustomEvent final
{
public:
	class FName                                   CustomName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPCustomEvent) == 0x000004, "Wrong alignment on AbilityBase_BPCustomEvent");
static_assert(sizeof(AbilityBase_BPCustomEvent) == 0x000008, "Wrong size on AbilityBase_BPCustomEvent");
static_assert(offsetof(AbilityBase_BPCustomEvent, CustomName) == 0x000000, "Member 'AbilityBase_BPCustomEvent::CustomName' has a wrong offset!");

// Function man.AbilityBase.BPGetCaster
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPGetCaster final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetCaster) == 0x000008, "Wrong alignment on AbilityBase_BPGetCaster");
static_assert(sizeof(AbilityBase_BPGetCaster) == 0x000008, "Wrong size on AbilityBase_BPGetCaster");
static_assert(offsetof(AbilityBase_BPGetCaster, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetCaster::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetComponentByClass
// 0x0018 (0x0018 - 0x0000)
struct AbilityBase_BPGetComponentByClass final
{
public:
	class UClass*                                 ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSub;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityComponent*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetComponentByClass) == 0x000008, "Wrong alignment on AbilityBase_BPGetComponentByClass");
static_assert(sizeof(AbilityBase_BPGetComponentByClass) == 0x000018, "Wrong size on AbilityBase_BPGetComponentByClass");
static_assert(offsetof(AbilityBase_BPGetComponentByClass, ComponentClass) == 0x000000, "Member 'AbilityBase_BPGetComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(AbilityBase_BPGetComponentByClass, bSub) == 0x000008, "Member 'AbilityBase_BPGetComponentByClass::bSub' has a wrong offset!");
static_assert(offsetof(AbilityBase_BPGetComponentByClass, ReturnValue) == 0x000010, "Member 'AbilityBase_BPGetComponentByClass::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetComponentByName
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_BPGetComponentByName final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityComponent*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetComponentByName) == 0x000008, "Wrong alignment on AbilityBase_BPGetComponentByName");
static_assert(sizeof(AbilityBase_BPGetComponentByName) == 0x000010, "Wrong size on AbilityBase_BPGetComponentByName");
static_assert(offsetof(AbilityBase_BPGetComponentByName, ComponentName) == 0x000000, "Member 'AbilityBase_BPGetComponentByName::ComponentName' has a wrong offset!");
static_assert(offsetof(AbilityBase_BPGetComponentByName, ReturnValue) == 0x000008, "Member 'AbilityBase_BPGetComponentByName::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetDuration
// 0x0004 (0x0004 - 0x0000)
struct AbilityBase_BPGetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetDuration) == 0x000004, "Wrong alignment on AbilityBase_BPGetDuration");
static_assert(sizeof(AbilityBase_BPGetDuration) == 0x000004, "Wrong size on AbilityBase_BPGetDuration");
static_assert(offsetof(AbilityBase_BPGetDuration, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetDuration::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetHitPosition
// 0x000C (0x000C - 0x0000)
struct AbilityBase_BPGetHitPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetHitPosition) == 0x000004, "Wrong alignment on AbilityBase_BPGetHitPosition");
static_assert(sizeof(AbilityBase_BPGetHitPosition) == 0x00000C, "Wrong size on AbilityBase_BPGetHitPosition");
static_assert(offsetof(AbilityBase_BPGetHitPosition, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetHitPosition::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetInstigatorAbility
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_BPGetInstigatorAbility final
{
public:
	bool                                          bAcrossEntities;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetInstigatorAbility) == 0x000008, "Wrong alignment on AbilityBase_BPGetInstigatorAbility");
static_assert(sizeof(AbilityBase_BPGetInstigatorAbility) == 0x000010, "Wrong size on AbilityBase_BPGetInstigatorAbility");
static_assert(offsetof(AbilityBase_BPGetInstigatorAbility, bAcrossEntities) == 0x000000, "Member 'AbilityBase_BPGetInstigatorAbility::bAcrossEntities' has a wrong offset!");
static_assert(offsetof(AbilityBase_BPGetInstigatorAbility, ReturnValue) == 0x000008, "Member 'AbilityBase_BPGetInstigatorAbility::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct AbilityBase_BPGetRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetRemainingTime) == 0x000004, "Wrong alignment on AbilityBase_BPGetRemainingTime");
static_assert(sizeof(AbilityBase_BPGetRemainingTime) == 0x000004, "Wrong size on AbilityBase_BPGetRemainingTime");
static_assert(offsetof(AbilityBase_BPGetRemainingTime, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetRemainingTime::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetSummoner
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPGetSummoner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetSummoner) == 0x000008, "Wrong alignment on AbilityBase_BPGetSummoner");
static_assert(sizeof(AbilityBase_BPGetSummoner) == 0x000008, "Wrong size on AbilityBase_BPGetSummoner");
static_assert(offsetof(AbilityBase_BPGetSummoner, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetSummoner::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetTarget
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPGetTarget final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetTarget) == 0x000008, "Wrong alignment on AbilityBase_BPGetTarget");
static_assert(sizeof(AbilityBase_BPGetTarget) == 0x000008, "Wrong size on AbilityBase_BPGetTarget");
static_assert(offsetof(AbilityBase_BPGetTarget, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetTarget::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPIsRuning
// 0x0001 (0x0001 - 0x0000)
struct AbilityBase_BPIsRuning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPIsRuning) == 0x000001, "Wrong alignment on AbilityBase_BPIsRuning");
static_assert(sizeof(AbilityBase_BPIsRuning) == 0x000001, "Wrong size on AbilityBase_BPIsRuning");
static_assert(offsetof(AbilityBase_BPIsRuning, ReturnValue) == 0x000000, "Member 'AbilityBase_BPIsRuning::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPOnTick
// 0x0004 (0x0004 - 0x0000)
struct AbilityBase_BPOnTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPOnTick) == 0x000004, "Wrong alignment on AbilityBase_BPOnTick");
static_assert(sizeof(AbilityBase_BPOnTick) == 0x000004, "Wrong size on AbilityBase_BPOnTick");
static_assert(offsetof(AbilityBase_BPOnTick, DeltaTime) == 0x000000, "Member 'AbilityBase_BPOnTick::DeltaTime' has a wrong offset!");

// Function man.AbilityBase.BPSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct AbilityBase_BPSetEnabled final
{
public:
	bool                                          inEnabled;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPSetEnabled) == 0x000001, "Wrong alignment on AbilityBase_BPSetEnabled");
static_assert(sizeof(AbilityBase_BPSetEnabled) == 0x000001, "Wrong size on AbilityBase_BPSetEnabled");
static_assert(offsetof(AbilityBase_BPSetEnabled, inEnabled) == 0x000000, "Member 'AbilityBase_BPSetEnabled::inEnabled' has a wrong offset!");

// Function man.AbilityBase.BPStartCondition
// 0x0001 (0x0001 - 0x0000)
struct AbilityBase_BPStartCondition final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPStartCondition) == 0x000001, "Wrong alignment on AbilityBase_BPStartCondition");
static_assert(sizeof(AbilityBase_BPStartCondition) == 0x000001, "Wrong size on AbilityBase_BPStartCondition");
static_assert(offsetof(AbilityBase_BPStartCondition, Result) == 0x000000, "Member 'AbilityBase_BPStartCondition::Result' has a wrong offset!");

// Function man.AbilityBase.GetAbilityController
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetAbilityController) == 0x000008, "Wrong alignment on AbilityBase_GetAbilityController");
static_assert(sizeof(AbilityBase_GetAbilityController) == 0x000008, "Wrong size on AbilityBase_GetAbilityController");
static_assert(offsetof(AbilityBase_GetAbilityController, ReturnValue) == 0x000000, "Member 'AbilityBase_GetAbilityController::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetActor
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetActor) == 0x000008, "Wrong alignment on AbilityBase_GetActor");
static_assert(sizeof(AbilityBase_GetActor) == 0x000008, "Wrong size on AbilityBase_GetActor");
static_assert(offsetof(AbilityBase_GetActor, ReturnValue) == 0x000000, "Member 'AbilityBase_GetActor::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetActorBase
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetActorBase final
{
public:
	class AActorBase*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetActorBase) == 0x000008, "Wrong alignment on AbilityBase_GetActorBase");
static_assert(sizeof(AbilityBase_GetActorBase) == 0x000008, "Wrong size on AbilityBase_GetActorBase");
static_assert(offsetof(AbilityBase_GetActorBase, ReturnValue) == 0x000000, "Member 'AbilityBase_GetActorBase::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetAttributeContainer) == 0x000008, "Wrong alignment on AbilityBase_GetAttributeContainer");
static_assert(sizeof(AbilityBase_GetAttributeContainer) == 0x000008, "Wrong size on AbilityBase_GetAttributeContainer");
static_assert(offsetof(AbilityBase_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'AbilityBase_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetCharacter final
{
public:
	class ACharacterBase*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetCharacter) == 0x000008, "Wrong alignment on AbilityBase_GetCharacter");
static_assert(sizeof(AbilityBase_GetCharacter) == 0x000008, "Wrong size on AbilityBase_GetCharacter");
static_assert(offsetof(AbilityBase_GetCharacter, ReturnValue) == 0x000000, "Member 'AbilityBase_GetCharacter::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetEditorName) == 0x000008, "Wrong alignment on AbilityBase_GetEditorName");
static_assert(sizeof(AbilityBase_GetEditorName) == 0x000010, "Wrong size on AbilityBase_GetEditorName");
static_assert(offsetof(AbilityBase_GetEditorName, ReturnValue) == 0x000000, "Member 'AbilityBase_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetEnemyCharacter
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetEnemyCharacter final
{
public:
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetEnemyCharacter) == 0x000008, "Wrong alignment on AbilityBase_GetEnemyCharacter");
static_assert(sizeof(AbilityBase_GetEnemyCharacter) == 0x000008, "Wrong size on AbilityBase_GetEnemyCharacter");
static_assert(offsetof(AbilityBase_GetEnemyCharacter, ReturnValue) == 0x000000, "Member 'AbilityBase_GetEnemyCharacter::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetGameMode
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetGameMode final
{
public:
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetGameMode) == 0x000008, "Wrong alignment on AbilityBase_GetGameMode");
static_assert(sizeof(AbilityBase_GetGameMode) == 0x000008, "Wrong size on AbilityBase_GetGameMode");
static_assert(offsetof(AbilityBase_GetGameMode, ReturnValue) == 0x000000, "Member 'AbilityBase_GetGameMode::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetHero
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_GetHero final
{
public:
	class AHeroBase*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetHero) == 0x000008, "Wrong alignment on AbilityBase_GetHero");
static_assert(sizeof(AbilityBase_GetHero) == 0x000008, "Wrong size on AbilityBase_GetHero");
static_assert(offsetof(AbilityBase_GetHero, ReturnValue) == 0x000000, "Member 'AbilityBase_GetHero::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.GetRemainingChaosEffectTime
// 0x0004 (0x0004 - 0x0000)
struct AbilityBase_GetRemainingChaosEffectTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_GetRemainingChaosEffectTime) == 0x000004, "Wrong alignment on AbilityBase_GetRemainingChaosEffectTime");
static_assert(sizeof(AbilityBase_GetRemainingChaosEffectTime) == 0x000004, "Wrong size on AbilityBase_GetRemainingChaosEffectTime");
static_assert(offsetof(AbilityBase_GetRemainingChaosEffectTime, ReturnValue) == 0x000000, "Member 'AbilityBase_GetRemainingChaosEffectTime::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.IsInterrupted
// 0x0001 (0x0001 - 0x0000)
struct AbilityBase_IsInterrupted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_IsInterrupted) == 0x000001, "Wrong alignment on AbilityBase_IsInterrupted");
static_assert(sizeof(AbilityBase_IsInterrupted) == 0x000001, "Wrong size on AbilityBase_IsInterrupted");
static_assert(offsetof(AbilityBase_IsInterrupted, ReturnValue) == 0x000000, "Member 'AbilityBase_IsInterrupted::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.OnAbilityAnimReplacedBase
// 0x0018 (0x0018 - 0x0000)
struct AbilityBase_OnAbilityAnimReplacedBase final
{
public:
	class UAnimID*                                SrcAnimId;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                DestAnimId;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReplacerObject;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_OnAbilityAnimReplacedBase) == 0x000008, "Wrong alignment on AbilityBase_OnAbilityAnimReplacedBase");
static_assert(sizeof(AbilityBase_OnAbilityAnimReplacedBase) == 0x000018, "Wrong size on AbilityBase_OnAbilityAnimReplacedBase");
static_assert(offsetof(AbilityBase_OnAbilityAnimReplacedBase, SrcAnimId) == 0x000000, "Member 'AbilityBase_OnAbilityAnimReplacedBase::SrcAnimId' has a wrong offset!");
static_assert(offsetof(AbilityBase_OnAbilityAnimReplacedBase, DestAnimId) == 0x000008, "Member 'AbilityBase_OnAbilityAnimReplacedBase::DestAnimId' has a wrong offset!");
static_assert(offsetof(AbilityBase_OnAbilityAnimReplacedBase, ReplacerObject) == 0x000010, "Member 'AbilityBase_OnAbilityAnimReplacedBase::ReplacerObject' has a wrong offset!");

// Function man.AbilityBase.OnAnimEventBase
// 0x0030 (0x0030 - 0x0000)
struct AbilityBase_OnAnimEventBase final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_OnAnimEventBase) == 0x000008, "Wrong alignment on AbilityBase_OnAnimEventBase");
static_assert(sizeof(AbilityBase_OnAnimEventBase) == 0x000030, "Wrong size on AbilityBase_OnAnimEventBase");
static_assert(offsetof(AbilityBase_OnAnimEventBase, AnimEventParam) == 0x000000, "Member 'AbilityBase_OnAnimEventBase::AnimEventParam' has a wrong offset!");

// Function man.AbilityBase.OnAttackSpeedChanged
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_OnAttackSpeedChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_OnAttackSpeedChanged) == 0x000008, "Wrong alignment on AbilityBase_OnAttackSpeedChanged");
static_assert(sizeof(AbilityBase_OnAttackSpeedChanged) == 0x000010, "Wrong size on AbilityBase_OnAttackSpeedChanged");
static_assert(offsetof(AbilityBase_OnAttackSpeedChanged, attribute) == 0x000000, "Member 'AbilityBase_OnAttackSpeedChanged::attribute' has a wrong offset!");
static_assert(offsetof(AbilityBase_OnAttackSpeedChanged, preValue) == 0x000008, "Member 'AbilityBase_OnAttackSpeedChanged::preValue' has a wrong offset!");

// Function man.AbilityBase.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct AbilityBase_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_OnPreDamaged) == 0x000008, "Wrong alignment on AbilityBase_OnPreDamaged");
static_assert(sizeof(AbilityBase_OnPreDamaged) == 0x0002D8, "Wrong size on AbilityBase_OnPreDamaged");
static_assert(offsetof(AbilityBase_OnPreDamaged, Param) == 0x000000, "Member 'AbilityBase_OnPreDamaged::Param' has a wrong offset!");

// Function man.AbilityBase.OnVisualEntitySpawned
// 0x0010 (0x0010 - 0x0000)
struct AbilityBase_OnVisualEntitySpawned final
{
public:
	class AVisualEntity*                          VisualEntity;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_OnVisualEntitySpawned) == 0x000008, "Wrong alignment on AbilityBase_OnVisualEntitySpawned");
static_assert(sizeof(AbilityBase_OnVisualEntitySpawned) == 0x000010, "Wrong size on AbilityBase_OnVisualEntitySpawned");
static_assert(offsetof(AbilityBase_OnVisualEntitySpawned, VisualEntity) == 0x000000, "Member 'AbilityBase_OnVisualEntitySpawned::VisualEntity' has a wrong offset!");
static_assert(offsetof(AbilityBase_OnVisualEntitySpawned, TargetActor) == 0x000008, "Member 'AbilityBase_OnVisualEntitySpawned::TargetActor' has a wrong offset!");

// Function man.AbilityBase.BPGetHudWidget
// 0x0008 (0x0008 - 0x0000)
struct AbilityBase_BPGetHudWidget final
{
public:
	class UHUDUserWidget*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetHudWidget) == 0x000008, "Wrong alignment on AbilityBase_BPGetHudWidget");
static_assert(sizeof(AbilityBase_BPGetHudWidget) == 0x000008, "Wrong size on AbilityBase_BPGetHudWidget");
static_assert(offsetof(AbilityBase_BPGetHudWidget, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetHudWidget::ReturnValue' has a wrong offset!");

// Function man.AbilityBase.BPGetMaxStackNum
// 0x0004 (0x0004 - 0x0000)
struct AbilityBase_BPGetMaxStackNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityBase_BPGetMaxStackNum) == 0x000004, "Wrong alignment on AbilityBase_BPGetMaxStackNum");
static_assert(sizeof(AbilityBase_BPGetMaxStackNum) == 0x000004, "Wrong size on AbilityBase_BPGetMaxStackNum");
static_assert(offsetof(AbilityBase_BPGetMaxStackNum, ReturnValue) == 0x000000, "Member 'AbilityBase_BPGetMaxStackNum::ReturnValue' has a wrong offset!");

// Function man.AIBase.OnAbilityEndingBase
// 0x0008 (0x0008 - 0x0000)
struct AIBase_OnAbilityEndingBase final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIBase_OnAbilityEndingBase) == 0x000008, "Wrong alignment on AIBase_OnAbilityEndingBase");
static_assert(sizeof(AIBase_OnAbilityEndingBase) == 0x000008, "Wrong size on AIBase_OnAbilityEndingBase");
static_assert(offsetof(AIBase_OnAbilityEndingBase, InAbility) == 0x000000, "Member 'AIBase_OnAbilityEndingBase::InAbility' has a wrong offset!");

// Function man.AIBase.OnAbilityStarting
// 0x0008 (0x0008 - 0x0000)
struct AIBase_OnAbilityStarting final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIBase_OnAbilityStarting) == 0x000008, "Wrong alignment on AIBase_OnAbilityStarting");
static_assert(sizeof(AIBase_OnAbilityStarting) == 0x000008, "Wrong size on AIBase_OnAbilityStarting");
static_assert(offsetof(AIBase_OnAbilityStarting, InAbility) == 0x000000, "Member 'AIBase_OnAbilityStarting::InAbility' has a wrong offset!");

// Function man.AIBase.OnAbilityStartingBase
// 0x0010 (0x0010 - 0x0000)
struct AIBase_OnAbilityStartingBase final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesire;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIBase_OnAbilityStartingBase) == 0x000008, "Wrong alignment on AIBase_OnAbilityStartingBase");
static_assert(sizeof(AIBase_OnAbilityStartingBase) == 0x000010, "Wrong size on AIBase_OnAbilityStartingBase");
static_assert(offsetof(AIBase_OnAbilityStartingBase, InAbility) == 0x000000, "Member 'AIBase_OnAbilityStartingBase::InAbility' has a wrong offset!");
static_assert(offsetof(AIBase_OnAbilityStartingBase, bDesire) == 0x000008, "Member 'AIBase_OnAbilityStartingBase::bDesire' has a wrong offset!");

// Function man.AIBase.OnAggroVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct AIBase_OnAggroVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIBase_OnAggroVolumeOverlap) == 0x000008, "Wrong alignment on AIBase_OnAggroVolumeOverlap");
static_assert(sizeof(AIBase_OnAggroVolumeOverlap) == 0x000010, "Wrong size on AIBase_OnAggroVolumeOverlap");
static_assert(offsetof(AIBase_OnAggroVolumeOverlap, OverlappedActor) == 0x000000, "Member 'AIBase_OnAggroVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(AIBase_OnAggroVolumeOverlap, OtherActor) == 0x000008, "Member 'AIBase_OnAggroVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.AIBase.OnRoomenterAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct AIBase_OnRoomenterAbilityEnded final
{
public:
	class UAbilityBase*                           AbilityEnded;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIBase_OnRoomenterAbilityEnded) == 0x000008, "Wrong alignment on AIBase_OnRoomenterAbilityEnded");
static_assert(sizeof(AIBase_OnRoomenterAbilityEnded) == 0x000008, "Wrong size on AIBase_OnRoomenterAbilityEnded");
static_assert(offsetof(AIBase_OnRoomenterAbilityEnded, AbilityEnded) == 0x000000, "Member 'AIBase_OnRoomenterAbilityEnded::AbilityEnded' has a wrong offset!");

// Function man.AIBase.OnRoomenterAnimEvent
// 0x0030 (0x0030 - 0x0000)
struct AIBase_OnRoomenterAnimEvent final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIBase_OnRoomenterAnimEvent) == 0x000008, "Wrong alignment on AIBase_OnRoomenterAnimEvent");
static_assert(sizeof(AIBase_OnRoomenterAnimEvent) == 0x000030, "Wrong size on AIBase_OnRoomenterAnimEvent");
static_assert(offsetof(AIBase_OnRoomenterAnimEvent, AnimEventParam) == 0x000000, "Member 'AIBase_OnRoomenterAnimEvent::AnimEventParam' has a wrong offset!");

// Function man.BasicAI.BasicAI_IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct BasicAI_BasicAI_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BasicAI_BasicAI_IsCollideSignature) == 0x000008, "Wrong alignment on BasicAI_BasicAI_IsCollideSignature");
static_assert(sizeof(BasicAI_BasicAI_IsCollideSignature) == 0x000010, "Wrong size on BasicAI_BasicAI_IsCollideSignature");
static_assert(offsetof(BasicAI_BasicAI_IsCollideSignature, Actor) == 0x000000, "Member 'BasicAI_BasicAI_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(BasicAI_BasicAI_IsCollideSignature, bOverride) == 0x000008, "Member 'BasicAI_BasicAI_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(BasicAI_BasicAI_IsCollideSignature, bCollide) == 0x000009, "Member 'BasicAI_BasicAI_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.BasicAI.BasicAI_IsCollideSignatureEx
// 0x0030 (0x0030 - 0x0000)
struct BasicAI_BasicAI_IsCollideSignatureEx final
{
public:
	struct FGroundMovecollideIsCollideSignatureParam Param;                                             // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasicAI_BasicAI_IsCollideSignatureEx) == 0x000008, "Wrong alignment on BasicAI_BasicAI_IsCollideSignatureEx");
static_assert(sizeof(BasicAI_BasicAI_IsCollideSignatureEx) == 0x000030, "Wrong size on BasicAI_BasicAI_IsCollideSignatureEx");
static_assert(offsetof(BasicAI_BasicAI_IsCollideSignatureEx, Param) == 0x000000, "Member 'BasicAI_BasicAI_IsCollideSignatureEx::Param' has a wrong offset!");

// Function man.BasicAI.BPStartAggro
// 0x0002 (0x0002 - 0x0000)
struct BasicAI_BPStartAggro final
{
public:
	bool                                          bInSkipRoomEnter;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSerialize;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasicAI_BPStartAggro) == 0x000001, "Wrong alignment on BasicAI_BPStartAggro");
static_assert(sizeof(BasicAI_BPStartAggro) == 0x000002, "Wrong size on BasicAI_BPStartAggro");
static_assert(offsetof(BasicAI_BPStartAggro, bInSkipRoomEnter) == 0x000000, "Member 'BasicAI_BPStartAggro::bInSkipRoomEnter' has a wrong offset!");
static_assert(offsetof(BasicAI_BPStartAggro, bSerialize) == 0x000001, "Member 'BasicAI_BPStartAggro::bSerialize' has a wrong offset!");

// Function man.BasicAI.OnActorRespawned
// 0x0008 (0x0008 - 0x0000)
struct BasicAI_OnActorRespawned final
{
public:
	class AActor*                                 RespawnedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasicAI_OnActorRespawned) == 0x000008, "Wrong alignment on BasicAI_OnActorRespawned");
static_assert(sizeof(BasicAI_OnActorRespawned) == 0x000008, "Wrong size on BasicAI_OnActorRespawned");
static_assert(offsetof(BasicAI_OnActorRespawned, RespawnedActor) == 0x000000, "Member 'BasicAI_OnActorRespawned::RespawnedActor' has a wrong offset!");

// Function man.BasicAI.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct BasicAI_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasicAI_OnPostDamaged) == 0x000008, "Wrong alignment on BasicAI_OnPostDamaged");
static_assert(sizeof(BasicAI_OnPostDamaged) == 0x0002D8, "Wrong size on BasicAI_OnPostDamaged");
static_assert(offsetof(BasicAI_OnPostDamaged, Param) == 0x000000, "Member 'BasicAI_OnPostDamaged::Param' has a wrong offset!");

// Function man.ManUserWidgetBase.CloseRequest
// 0x0002 (0x0002 - 0x0000)
struct ManUserWidgetBase_CloseRequest final
{
public:
	bool                                          bOpenPauseMenu;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyClose;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_CloseRequest) == 0x000001, "Wrong alignment on ManUserWidgetBase_CloseRequest");
static_assert(sizeof(ManUserWidgetBase_CloseRequest) == 0x000002, "Wrong size on ManUserWidgetBase_CloseRequest");
static_assert(offsetof(ManUserWidgetBase_CloseRequest, bOpenPauseMenu) == 0x000000, "Member 'ManUserWidgetBase_CloseRequest::bOpenPauseMenu' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_CloseRequest, bOnlyClose) == 0x000001, "Member 'ManUserWidgetBase_CloseRequest::bOnlyClose' has a wrong offset!");

// Function man.ManUserWidgetBase.OnAnalogValueChangedEvent
// 0x0020 (0x0020 - 0x0000)
struct ManUserWidgetBase_OnAnalogValueChangedEvent final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnalogValue;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManUserWidgetBase_OnAnalogValueChangedEvent) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnAnalogValueChangedEvent");
static_assert(sizeof(ManUserWidgetBase_OnAnalogValueChangedEvent) == 0x000020, "Wrong size on ManUserWidgetBase_OnAnalogValueChangedEvent");
static_assert(offsetof(ManUserWidgetBase_OnAnalogValueChangedEvent, Key) == 0x000000, "Member 'ManUserWidgetBase_OnAnalogValueChangedEvent::Key' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnAnalogValueChangedEvent, AnalogValue) == 0x000018, "Member 'ManUserWidgetBase_OnAnalogValueChangedEvent::AnalogValue' has a wrong offset!");

// Function man.ManUserWidgetBase.OnErrorHiglight
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_OnErrorHiglight final
{
public:
	class UInteractButtonUserWidget*              InteractButtonUserWidget;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnErrorHiglight) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnErrorHiglight");
static_assert(sizeof(ManUserWidgetBase_OnErrorHiglight) == 0x000008, "Wrong size on ManUserWidgetBase_OnErrorHiglight");
static_assert(offsetof(ManUserWidgetBase_OnErrorHiglight, InteractButtonUserWidget) == 0x000000, "Member 'ManUserWidgetBase_OnErrorHiglight::InteractButtonUserWidget' has a wrong offset!");

// Function man.ManUserWidgetBase.OnHide
// 0x0004 (0x0004 - 0x0000)
struct ManUserWidgetBase_OnHide final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnHide) == 0x000004, "Wrong alignment on ManUserWidgetBase_OnHide");
static_assert(sizeof(ManUserWidgetBase_OnHide) == 0x000004, "Wrong size on ManUserWidgetBase_OnHide");
static_assert(offsetof(ManUserWidgetBase_OnHide, AnimDuration) == 0x000000, "Member 'ManUserWidgetBase_OnHide::AnimDuration' has a wrong offset!");

// Function man.ManUserWidgetBase.OnHoldCanceled
// 0x0010 (0x0010 - 0x0000)
struct ManUserWidgetBase_OnHoldCanceled final
{
public:
	class UInteractButtonUserWidget*              InteractButtonUserWidget;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMinTimeCancel;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManUserWidgetBase_OnHoldCanceled) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnHoldCanceled");
static_assert(sizeof(ManUserWidgetBase_OnHoldCanceled) == 0x000010, "Wrong size on ManUserWidgetBase_OnHoldCanceled");
static_assert(offsetof(ManUserWidgetBase_OnHoldCanceled, InteractButtonUserWidget) == 0x000000, "Member 'ManUserWidgetBase_OnHoldCanceled::InteractButtonUserWidget' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnHoldCanceled, bMinTimeCancel) == 0x000008, "Member 'ManUserWidgetBase_OnHoldCanceled::bMinTimeCancel' has a wrong offset!");

// Function man.ManUserWidgetBase.OnHoldFinished
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_OnHoldFinished final
{
public:
	class UInteractButtonUserWidget*              InteractButtonUserWidget;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnHoldFinished) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnHoldFinished");
static_assert(sizeof(ManUserWidgetBase_OnHoldFinished) == 0x000008, "Wrong size on ManUserWidgetBase_OnHoldFinished");
static_assert(offsetof(ManUserWidgetBase_OnHoldFinished, InteractButtonUserWidget) == 0x000000, "Member 'ManUserWidgetBase_OnHoldFinished::InteractButtonUserWidget' has a wrong offset!");

// Function man.ManUserWidgetBase.OnHoldStarted
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_OnHoldStarted final
{
public:
	class UInteractButtonUserWidget*              InteractButtonUserWidget;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnHoldStarted) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnHoldStarted");
static_assert(sizeof(ManUserWidgetBase_OnHoldStarted) == 0x000008, "Wrong size on ManUserWidgetBase_OnHoldStarted");
static_assert(offsetof(ManUserWidgetBase_OnHoldStarted, InteractButtonUserWidget) == 0x000000, "Member 'ManUserWidgetBase_OnHoldStarted::InteractButtonUserWidget' has a wrong offset!");

// Function man.ManUserWidgetBase.OnInputDisplayChanged
// 0x0002 (0x0002 - 0x0000)
struct ManUserWidgetBase_OnInputDisplayChanged final
{
public:
	EInputDisplay                                 InInputDisplay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 InControlDisplay;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnInputDisplayChanged) == 0x000001, "Wrong alignment on ManUserWidgetBase_OnInputDisplayChanged");
static_assert(sizeof(ManUserWidgetBase_OnInputDisplayChanged) == 0x000002, "Wrong size on ManUserWidgetBase_OnInputDisplayChanged");
static_assert(offsetof(ManUserWidgetBase_OnInputDisplayChanged, InInputDisplay) == 0x000000, "Member 'ManUserWidgetBase_OnInputDisplayChanged::InInputDisplay' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnInputDisplayChanged, InControlDisplay) == 0x000001, "Member 'ManUserWidgetBase_OnInputDisplayChanged::InControlDisplay' has a wrong offset!");

// Function man.ManUserWidgetBase.OnRotateCharacterLeft
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_OnRotateCharacterLeft final
{
public:
	bool                                          bRotate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnRotateCharacterLeft) == 0x000001, "Wrong alignment on ManUserWidgetBase_OnRotateCharacterLeft");
static_assert(sizeof(ManUserWidgetBase_OnRotateCharacterLeft) == 0x000001, "Wrong size on ManUserWidgetBase_OnRotateCharacterLeft");
static_assert(offsetof(ManUserWidgetBase_OnRotateCharacterLeft, bRotate) == 0x000000, "Member 'ManUserWidgetBase_OnRotateCharacterLeft::bRotate' has a wrong offset!");

// Function man.ManUserWidgetBase.OnRotateCharacterRight
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_OnRotateCharacterRight final
{
public:
	bool                                          bRotate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnRotateCharacterRight) == 0x000001, "Wrong alignment on ManUserWidgetBase_OnRotateCharacterRight");
static_assert(sizeof(ManUserWidgetBase_OnRotateCharacterRight) == 0x000001, "Wrong size on ManUserWidgetBase_OnRotateCharacterRight");
static_assert(offsetof(ManUserWidgetBase_OnRotateCharacterRight, bRotate) == 0x000000, "Member 'ManUserWidgetBase_OnRotateCharacterRight::bRotate' has a wrong offset!");

// Function man.ManUserWidgetBase.OnSetFocusedWidget
// 0x0018 (0x0018 - 0x0000)
struct ManUserWidgetBase_OnSetFocusedWidget final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeFocusByUser;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeFocusByMouse;                               // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManUserWidgetBase_OnSetFocusedWidget) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnSetFocusedWidget");
static_assert(sizeof(ManUserWidgetBase_OnSetFocusedWidget) == 0x000018, "Wrong size on ManUserWidgetBase_OnSetFocusedWidget");
static_assert(offsetof(ManUserWidgetBase_OnSetFocusedWidget, OldFocusedWidget) == 0x000000, "Member 'ManUserWidgetBase_OnSetFocusedWidget::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnSetFocusedWidget, NewFocusedWidget) == 0x000008, "Member 'ManUserWidgetBase_OnSetFocusedWidget::NewFocusedWidget' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnSetFocusedWidget, bChangeFocusByUser) == 0x000010, "Member 'ManUserWidgetBase_OnSetFocusedWidget::bChangeFocusByUser' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnSetFocusedWidget, bChangeFocusByMouse) == 0x000011, "Member 'ManUserWidgetBase_OnSetFocusedWidget::bChangeFocusByMouse' has a wrong offset!");

// Function man.ManUserWidgetBase.OnSetInputDisplay
// 0x0002 (0x0002 - 0x0000)
struct ManUserWidgetBase_OnSetInputDisplay final
{
public:
	EInputDisplay                                 InInputDisplay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 InControlDisplay;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnSetInputDisplay) == 0x000001, "Wrong alignment on ManUserWidgetBase_OnSetInputDisplay");
static_assert(sizeof(ManUserWidgetBase_OnSetInputDisplay) == 0x000002, "Wrong size on ManUserWidgetBase_OnSetInputDisplay");
static_assert(offsetof(ManUserWidgetBase_OnSetInputDisplay, InInputDisplay) == 0x000000, "Member 'ManUserWidgetBase_OnSetInputDisplay::InInputDisplay' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_OnSetInputDisplay, InControlDisplay) == 0x000001, "Member 'ManUserWidgetBase_OnSetInputDisplay::InControlDisplay' has a wrong offset!");

// Function man.ManUserWidgetBase.OnSetTabButtonsVisbility
// 0x0004 (0x0004 - 0x0000)
struct ManUserWidgetBase_OnSetTabButtonsVisbility final
{
public:
	int32                                         InVisibleTabButtonNum;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnSetTabButtonsVisbility) == 0x000004, "Wrong alignment on ManUserWidgetBase_OnSetTabButtonsVisbility");
static_assert(sizeof(ManUserWidgetBase_OnSetTabButtonsVisbility) == 0x000004, "Wrong size on ManUserWidgetBase_OnSetTabButtonsVisbility");
static_assert(offsetof(ManUserWidgetBase_OnSetTabButtonsVisbility, InVisibleTabButtonNum) == 0x000000, "Member 'ManUserWidgetBase_OnSetTabButtonsVisbility::InVisibleTabButtonNum' has a wrong offset!");

// Function man.ManUserWidgetBase.OnShow
// 0x0004 (0x0004 - 0x0000)
struct ManUserWidgetBase_OnShow final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnShow) == 0x000004, "Wrong alignment on ManUserWidgetBase_OnShow");
static_assert(sizeof(ManUserWidgetBase_OnShow) == 0x000004, "Wrong size on ManUserWidgetBase_OnShow");
static_assert(offsetof(ManUserWidgetBase_OnShow, AnimDuration) == 0x000000, "Member 'ManUserWidgetBase_OnShow::AnimDuration' has a wrong offset!");

// Function man.ManUserWidgetBase.OnSortChanged
// 0x0018 (0x0018 - 0x0000)
struct ManUserWidgetBase_OnSortChanged final
{
public:
	class FText                                   SortName;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnSortChanged) == 0x000008, "Wrong alignment on ManUserWidgetBase_OnSortChanged");
static_assert(sizeof(ManUserWidgetBase_OnSortChanged) == 0x000018, "Wrong size on ManUserWidgetBase_OnSortChanged");
static_assert(offsetof(ManUserWidgetBase_OnSortChanged, SortName) == 0x000000, "Member 'ManUserWidgetBase_OnSortChanged::SortName' has a wrong offset!");

// Function man.ManUserWidgetBase.OnUserScrolled
// 0x0004 (0x0004 - 0x0000)
struct ManUserWidgetBase_OnUserScrolled final
{
public:
	float                                         CurrentOffset;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_OnUserScrolled) == 0x000004, "Wrong alignment on ManUserWidgetBase_OnUserScrolled");
static_assert(sizeof(ManUserWidgetBase_OnUserScrolled) == 0x000004, "Wrong size on ManUserWidgetBase_OnUserScrolled");
static_assert(offsetof(ManUserWidgetBase_OnUserScrolled, CurrentOffset) == 0x000000, "Member 'ManUserWidgetBase_OnUserScrolled::CurrentOffset' has a wrong offset!");

// Function man.ManUserWidgetBase.SetFocusedWidget
// 0x0010 (0x0010 - 0x0000)
struct ManUserWidgetBase_SetFocusedWidget final
{
public:
	class UWidget*                                InFocusedWidget;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeFocusByUser;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeFocusByMouse;                               // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSetLastValidFocusedWidget;                   // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManUserWidgetBase_SetFocusedWidget) == 0x000008, "Wrong alignment on ManUserWidgetBase_SetFocusedWidget");
static_assert(sizeof(ManUserWidgetBase_SetFocusedWidget) == 0x000010, "Wrong size on ManUserWidgetBase_SetFocusedWidget");
static_assert(offsetof(ManUserWidgetBase_SetFocusedWidget, InFocusedWidget) == 0x000000, "Member 'ManUserWidgetBase_SetFocusedWidget::InFocusedWidget' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_SetFocusedWidget, bAnimate) == 0x000008, "Member 'ManUserWidgetBase_SetFocusedWidget::bAnimate' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_SetFocusedWidget, bChangeFocusByUser) == 0x000009, "Member 'ManUserWidgetBase_SetFocusedWidget::bChangeFocusByUser' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_SetFocusedWidget, bChangeFocusByMouse) == 0x00000A, "Member 'ManUserWidgetBase_SetFocusedWidget::bChangeFocusByMouse' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_SetFocusedWidget, bForceSetLastValidFocusedWidget) == 0x00000B, "Member 'ManUserWidgetBase_SetFocusedWidget::bForceSetLastValidFocusedWidget' has a wrong offset!");

// Function man.ManUserWidgetBase.SetInteractedActor
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_SetInteractedActor final
{
public:
	class AActorBase*                             InInteractedActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_SetInteractedActor) == 0x000008, "Wrong alignment on ManUserWidgetBase_SetInteractedActor");
static_assert(sizeof(ManUserWidgetBase_SetInteractedActor) == 0x000008, "Wrong size on ManUserWidgetBase_SetInteractedActor");
static_assert(offsetof(ManUserWidgetBase_SetInteractedActor, InInteractedActor) == 0x000000, "Member 'ManUserWidgetBase_SetInteractedActor::InInteractedActor' has a wrong offset!");

// Function man.ManUserWidgetBase.SetTab
// 0x0002 (0x0002 - 0x0000)
struct ManUserWidgetBase_SetTab final
{
public:
	ETabButtonType                                TabButtonType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWindow;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_SetTab) == 0x000001, "Wrong alignment on ManUserWidgetBase_SetTab");
static_assert(sizeof(ManUserWidgetBase_SetTab) == 0x000002, "Wrong size on ManUserWidgetBase_SetTab");
static_assert(offsetof(ManUserWidgetBase_SetTab, TabButtonType) == 0x000000, "Member 'ManUserWidgetBase_SetTab::TabButtonType' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_SetTab, bShowWindow) == 0x000001, "Member 'ManUserWidgetBase_SetTab::bShowWindow' has a wrong offset!");

// Function man.ManUserWidgetBase.BPIsVisible
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_BPIsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_BPIsVisible) == 0x000001, "Wrong alignment on ManUserWidgetBase_BPIsVisible");
static_assert(sizeof(ManUserWidgetBase_BPIsVisible) == 0x000001, "Wrong size on ManUserWidgetBase_BPIsVisible");
static_assert(offsetof(ManUserWidgetBase_BPIsVisible, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_BPIsVisible::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.GetAnimPlaybackSpeed
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_GetAnimPlaybackSpeed final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_GetAnimPlaybackSpeed) == 0x000004, "Wrong alignment on ManUserWidgetBase_GetAnimPlaybackSpeed");
static_assert(sizeof(ManUserWidgetBase_GetAnimPlaybackSpeed) == 0x000008, "Wrong size on ManUserWidgetBase_GetAnimPlaybackSpeed");
static_assert(offsetof(ManUserWidgetBase_GetAnimPlaybackSpeed, AnimDuration) == 0x000000, "Member 'ManUserWidgetBase_GetAnimPlaybackSpeed::AnimDuration' has a wrong offset!");
static_assert(offsetof(ManUserWidgetBase_GetAnimPlaybackSpeed, ReturnValue) == 0x000004, "Member 'ManUserWidgetBase_GetAnimPlaybackSpeed::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.GetFilterType
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_GetFilterType final
{
public:
	EItemSlot                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_GetFilterType) == 0x000001, "Wrong alignment on ManUserWidgetBase_GetFilterType");
static_assert(sizeof(ManUserWidgetBase_GetFilterType) == 0x000001, "Wrong size on ManUserWidgetBase_GetFilterType");
static_assert(offsetof(ManUserWidgetBase_GetFilterType, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_GetFilterType::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.GetFocusedWidget
// 0x0008 (0x0008 - 0x0000)
struct ManUserWidgetBase_GetFocusedWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_GetFocusedWidget) == 0x000008, "Wrong alignment on ManUserWidgetBase_GetFocusedWidget");
static_assert(sizeof(ManUserWidgetBase_GetFocusedWidget) == 0x000008, "Wrong size on ManUserWidgetBase_GetFocusedWidget");
static_assert(offsetof(ManUserWidgetBase_GetFocusedWidget, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_GetFocusedWidget::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.GetNextTab
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_GetNextTab final
{
public:
	ETabButtonType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_GetNextTab) == 0x000001, "Wrong alignment on ManUserWidgetBase_GetNextTab");
static_assert(sizeof(ManUserWidgetBase_GetNextTab) == 0x000001, "Wrong size on ManUserWidgetBase_GetNextTab");
static_assert(offsetof(ManUserWidgetBase_GetNextTab, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_GetNextTab::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.GetPreviousTab
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_GetPreviousTab final
{
public:
	ETabButtonType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_GetPreviousTab) == 0x000001, "Wrong alignment on ManUserWidgetBase_GetPreviousTab");
static_assert(sizeof(ManUserWidgetBase_GetPreviousTab) == 0x000001, "Wrong size on ManUserWidgetBase_GetPreviousTab");
static_assert(offsetof(ManUserWidgetBase_GetPreviousTab, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_GetPreviousTab::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.IsHoldProgress
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_IsHoldProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_IsHoldProgress) == 0x000001, "Wrong alignment on ManUserWidgetBase_IsHoldProgress");
static_assert(sizeof(ManUserWidgetBase_IsHoldProgress) == 0x000001, "Wrong size on ManUserWidgetBase_IsHoldProgress");
static_assert(offsetof(ManUserWidgetBase_IsHoldProgress, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_IsHoldProgress::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.IsLeftMouseButtonDown
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_IsLeftMouseButtonDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_IsLeftMouseButtonDown) == 0x000001, "Wrong alignment on ManUserWidgetBase_IsLeftMouseButtonDown");
static_assert(sizeof(ManUserWidgetBase_IsLeftMouseButtonDown) == 0x000001, "Wrong size on ManUserWidgetBase_IsLeftMouseButtonDown");
static_assert(offsetof(ManUserWidgetBase_IsLeftMouseButtonDown, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_IsLeftMouseButtonDown::ReturnValue' has a wrong offset!");

// Function man.ManUserWidgetBase.IsRotateCharacter
// 0x0001 (0x0001 - 0x0000)
struct ManUserWidgetBase_IsRotateCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManUserWidgetBase_IsRotateCharacter) == 0x000001, "Wrong alignment on ManUserWidgetBase_IsRotateCharacter");
static_assert(sizeof(ManUserWidgetBase_IsRotateCharacter) == 0x000001, "Wrong size on ManUserWidgetBase_IsRotateCharacter");
static_assert(offsetof(ManUserWidgetBase_IsRotateCharacter, ReturnValue) == 0x000000, "Member 'ManUserWidgetBase_IsRotateCharacter::ReturnValue' has a wrong offset!");

// Function man.LevelVisualVolume.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct LevelVisualVolume_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelVisualVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on LevelVisualVolume_OnBeginOverlap");
static_assert(sizeof(LevelVisualVolume_OnBeginOverlap) == 0x000010, "Wrong size on LevelVisualVolume_OnBeginOverlap");
static_assert(offsetof(LevelVisualVolume_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'LevelVisualVolume_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(LevelVisualVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'LevelVisualVolume_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.LevelVisualVolume.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct LevelVisualVolume_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelVisualVolume_OnEndOverlap) == 0x000008, "Wrong alignment on LevelVisualVolume_OnEndOverlap");
static_assert(sizeof(LevelVisualVolume_OnEndOverlap) == 0x000010, "Wrong size on LevelVisualVolume_OnEndOverlap");
static_assert(offsetof(LevelVisualVolume_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'LevelVisualVolume_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(LevelVisualVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'LevelVisualVolume_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.AbilityComponent.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct AbilityComponent_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityComponent_GetEditorName) == 0x000008, "Wrong alignment on AbilityComponent_GetEditorName");
static_assert(sizeof(AbilityComponent_GetEditorName) == 0x000010, "Wrong size on AbilityComponent_GetEditorName");
static_assert(offsetof(AbilityComponent_GetEditorName, ReturnValue) == 0x000000, "Member 'AbilityComponent_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.AbilityEventComponent.GameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct AbilityEventComponent_GameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_GameplayEvent) == 0x000008, "Wrong alignment on AbilityEventComponent_GameplayEvent");
static_assert(sizeof(AbilityEventComponent_GameplayEvent) == 0x000020, "Wrong size on AbilityEventComponent_GameplayEvent");
static_assert(offsetof(AbilityEventComponent_GameplayEvent, AbilityController) == 0x000000, "Member 'AbilityEventComponent_GameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_GameplayEvent, _GameplayEventID) == 0x000008, "Member 'AbilityEventComponent_GameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_GameplayEvent, CustomName) == 0x000010, "Member 'AbilityEventComponent_GameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_GameplayEvent, paramActorSoul) == 0x000018, "Member 'AbilityEventComponent_GameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.AbilityEventComponent.OnAnimEventBase
// 0x0030 (0x0030 - 0x0000)
struct AbilityEventComponent_OnAnimEventBase final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_OnAnimEventBase) == 0x000008, "Wrong alignment on AbilityEventComponent_OnAnimEventBase");
static_assert(sizeof(AbilityEventComponent_OnAnimEventBase) == 0x000030, "Wrong size on AbilityEventComponent_OnAnimEventBase");
static_assert(offsetof(AbilityEventComponent_OnAnimEventBase, AnimEventParam) == 0x000000, "Member 'AbilityEventComponent_OnAnimEventBase::AnimEventParam' has a wrong offset!");

// Function man.AbilityEventComponent.OnDamageCaused
// 0x0160 (0x0160 - 0x0000)
struct AbilityEventComponent_OnDamageCaused final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbility;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_OnDamageCaused) == 0x000008, "Wrong alignment on AbilityEventComponent_OnDamageCaused");
static_assert(sizeof(AbilityEventComponent_OnDamageCaused) == 0x000160, "Wrong size on AbilityEventComponent_OnDamageCaused");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, Source) == 0x000000, "Member 'AbilityEventComponent_OnDamageCaused::Source' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, Bullet) == 0x000008, "Member 'AbilityEventComponent_OnDamageCaused::Bullet' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, Target) == 0x000010, "Member 'AbilityEventComponent_OnDamageCaused::Target' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, InAbility) == 0x000018, "Member 'AbilityEventComponent_OnDamageCaused::InAbility' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, effectiveDamage) == 0x000020, "Member 'AbilityEventComponent_OnDamageCaused::effectiveDamage' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageCaused, DamageValue) == 0x000028, "Member 'AbilityEventComponent_OnDamageCaused::DamageValue' has a wrong offset!");

// Function man.AbilityEventComponent.OnDamageTaken
// 0x0160 (0x0160 - 0x0000)
struct AbilityEventComponent_OnDamageTaken final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     TargetArg;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbility;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_OnDamageTaken) == 0x000008, "Wrong alignment on AbilityEventComponent_OnDamageTaken");
static_assert(sizeof(AbilityEventComponent_OnDamageTaken) == 0x000160, "Wrong size on AbilityEventComponent_OnDamageTaken");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, Source) == 0x000000, "Member 'AbilityEventComponent_OnDamageTaken::Source' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, Bullet) == 0x000008, "Member 'AbilityEventComponent_OnDamageTaken::Bullet' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, TargetArg) == 0x000010, "Member 'AbilityEventComponent_OnDamageTaken::TargetArg' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, InAbility) == 0x000018, "Member 'AbilityEventComponent_OnDamageTaken::InAbility' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, effectiveDamage) == 0x000020, "Member 'AbilityEventComponent_OnDamageTaken::effectiveDamage' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnDamageTaken, DamageValue) == 0x000028, "Member 'AbilityEventComponent_OnDamageTaken::DamageValue' has a wrong offset!");

// Function man.AbilityEventComponent.OnEntityTeleportPost
// 0x000C (0x000C - 0x0000)
struct AbilityEventComponent_OnEntityTeleportPost final
{
public:
	struct FVector                                NewPosition;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_OnEntityTeleportPost) == 0x000004, "Wrong alignment on AbilityEventComponent_OnEntityTeleportPost");
static_assert(sizeof(AbilityEventComponent_OnEntityTeleportPost) == 0x00000C, "Wrong size on AbilityEventComponent_OnEntityTeleportPost");
static_assert(offsetof(AbilityEventComponent_OnEntityTeleportPost, NewPosition) == 0x000000, "Member 'AbilityEventComponent_OnEntityTeleportPost::NewPosition' has a wrong offset!");

// Function man.AbilityEventComponent.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct AbilityEventComponent_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityEventComponent_OnPostDamageCaused) == 0x000008, "Wrong alignment on AbilityEventComponent_OnPostDamageCaused");
static_assert(sizeof(AbilityEventComponent_OnPostDamageCaused) == 0x0002D8, "Wrong size on AbilityEventComponent_OnPostDamageCaused");
static_assert(offsetof(AbilityEventComponent_OnPostDamageCaused, Param) == 0x000000, "Member 'AbilityEventComponent_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.AbilityEventComponent.OnStatusEffectChange
// 0x0018 (0x0018 - 0x0000)
struct AbilityEventComponent_OnStatusEffectChange final
{
public:
	EStatusEffectChange                           Change;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackNum;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityEventComponent_OnStatusEffectChange) == 0x000008, "Wrong alignment on AbilityEventComponent_OnStatusEffectChange");
static_assert(sizeof(AbilityEventComponent_OnStatusEffectChange) == 0x000018, "Wrong size on AbilityEventComponent_OnStatusEffectChange");
static_assert(offsetof(AbilityEventComponent_OnStatusEffectChange, Change) == 0x000000, "Member 'AbilityEventComponent_OnStatusEffectChange::Change' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnStatusEffectChange, StatusType) == 0x000001, "Member 'AbilityEventComponent_OnStatusEffectChange::StatusType' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnStatusEffectChange, Source) == 0x000008, "Member 'AbilityEventComponent_OnStatusEffectChange::Source' has a wrong offset!");
static_assert(offsetof(AbilityEventComponent_OnStatusEffectChange, StackNum) == 0x000010, "Member 'AbilityEventComponent_OnStatusEffectChange::StackNum' has a wrong offset!");

// Function man.RestoreEnergyAbilityComponent.OnAbilityResourceConsumed
// 0x0008 (0x0008 - 0x0000)
struct RestoreEnergyAbilityComponent_OnAbilityResourceConsumed final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RestoreEnergyAbilityComponent_OnAbilityResourceConsumed) == 0x000008, "Wrong alignment on RestoreEnergyAbilityComponent_OnAbilityResourceConsumed");
static_assert(sizeof(RestoreEnergyAbilityComponent_OnAbilityResourceConsumed) == 0x000008, "Wrong size on RestoreEnergyAbilityComponent_OnAbilityResourceConsumed");
static_assert(offsetof(RestoreEnergyAbilityComponent_OnAbilityResourceConsumed, StartedAbility) == 0x000000, "Member 'RestoreEnergyAbilityComponent_OnAbilityResourceConsumed::StartedAbility' has a wrong offset!");

// Function man.ManQuestObjective.AddRequiredObjective
// 0x0010 (0x0010 - 0x0000)
struct ManQuestObjective_AddRequiredObjective final
{
public:
	class UManQuestObjective*                     PreObjective;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestObjective_AddRequiredObjective) == 0x000008, "Wrong alignment on ManQuestObjective_AddRequiredObjective");
static_assert(sizeof(ManQuestObjective_AddRequiredObjective) == 0x000010, "Wrong size on ManQuestObjective_AddRequiredObjective");
static_assert(offsetof(ManQuestObjective_AddRequiredObjective, PreObjective) == 0x000000, "Member 'ManQuestObjective_AddRequiredObjective::PreObjective' has a wrong offset!");
static_assert(offsetof(ManQuestObjective_AddRequiredObjective, ReturnValue) == 0x000008, "Member 'ManQuestObjective_AddRequiredObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuestObjective.BPGetObjectiveText
// 0x0020 (0x0020 - 0x0000)
struct ManQuestObjective_BPGetObjectiveText final
{
public:
	bool                                          bShowCounterText;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestObjective_BPGetObjectiveText) == 0x000008, "Wrong alignment on ManQuestObjective_BPGetObjectiveText");
static_assert(sizeof(ManQuestObjective_BPGetObjectiveText) == 0x000020, "Wrong size on ManQuestObjective_BPGetObjectiveText");
static_assert(offsetof(ManQuestObjective_BPGetObjectiveText, bShowCounterText) == 0x000000, "Member 'ManQuestObjective_BPGetObjectiveText::bShowCounterText' has a wrong offset!");
static_assert(offsetof(ManQuestObjective_BPGetObjectiveText, ReturnValue) == 0x000008, "Member 'ManQuestObjective_BPGetObjectiveText::ReturnValue' has a wrong offset!");

// Function man.AbilitiesUserWidgetBase.OnSetFilterName
// 0x0020 (0x0020 - 0x0000)
struct AbilitiesUserWidgetBase_OnSetFilterName final
{
public:
	class FText                                   FilterName;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EWeaponType                                   InWeaponTypeFilter;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayChangeFilterSound;                            // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilitiesUserWidgetBase_OnSetFilterName) == 0x000008, "Wrong alignment on AbilitiesUserWidgetBase_OnSetFilterName");
static_assert(sizeof(AbilitiesUserWidgetBase_OnSetFilterName) == 0x000020, "Wrong size on AbilitiesUserWidgetBase_OnSetFilterName");
static_assert(offsetof(AbilitiesUserWidgetBase_OnSetFilterName, FilterName) == 0x000000, "Member 'AbilitiesUserWidgetBase_OnSetFilterName::FilterName' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnSetFilterName, InWeaponTypeFilter) == 0x000018, "Member 'AbilitiesUserWidgetBase_OnSetFilterName::InWeaponTypeFilter' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnSetFilterName, bPlayChangeFilterSound) == 0x000019, "Member 'AbilitiesUserWidgetBase_OnSetFilterName::bPlayChangeFilterSound' has a wrong offset!");

// Function man.AbilitiesUserWidgetBase.OnSetUpgrades
// 0x0008 (0x0008 - 0x0000)
struct AbilitiesUserWidgetBase_OnSetUpgrades final
{
public:
	int32                                         MaxUpgrades;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearnedUpgrades;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitiesUserWidgetBase_OnSetUpgrades) == 0x000004, "Wrong alignment on AbilitiesUserWidgetBase_OnSetUpgrades");
static_assert(sizeof(AbilitiesUserWidgetBase_OnSetUpgrades) == 0x000008, "Wrong size on AbilitiesUserWidgetBase_OnSetUpgrades");
static_assert(offsetof(AbilitiesUserWidgetBase_OnSetUpgrades, MaxUpgrades) == 0x000000, "Member 'AbilitiesUserWidgetBase_OnSetUpgrades::MaxUpgrades' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnSetUpgrades, LearnedUpgrades) == 0x000004, "Member 'AbilitiesUserWidgetBase_OnSetUpgrades::LearnedUpgrades' has a wrong offset!");

// Function man.AbilitiesUserWidgetBase.OnUpdateDetailsPanel
// 0x0090 (0x0090 - 0x0000)
struct AbilitiesUserWidgetBase_OnUpdateDetailsPanel final
{
public:
	class FText                                   Name_0;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   CostText;                                          // 0x0048(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Requirements;                                      // 0x0060(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UTexture2D*                       Icon;                                              // 0x0078(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUpgrades;                                       // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearnedUpgrades;                                   // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel) == 0x000008, "Wrong alignment on AbilitiesUserWidgetBase_OnUpdateDetailsPanel");
static_assert(sizeof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel) == 0x000090, "Wrong size on AbilitiesUserWidgetBase_OnUpdateDetailsPanel");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, Name_0) == 0x000000, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::Name_0' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, Description) == 0x000018, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::Description' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, FlavorText) == 0x000030, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::FlavorText' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, CostText) == 0x000048, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::CostText' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, Requirements) == 0x000060, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::Requirements' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, Icon) == 0x000078, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::Icon' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, AbilityClass) == 0x000080, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::AbilityClass' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, MaxUpgrades) == 0x000088, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::MaxUpgrades' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateDetailsPanel, LearnedUpgrades) == 0x00008C, "Member 'AbilitiesUserWidgetBase_OnUpdateDetailsPanel::LearnedUpgrades' has a wrong offset!");

// Function man.AbilitiesUserWidgetBase.OnUpdateUpgradesPanel
// 0x0028 (0x0028 - 0x0000)
struct AbilitiesUserWidgetBase_OnUpdateUpgradesPanel final
{
public:
	TArray<class FText>                           Upgrades;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Requirements;                                      // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitiesUserWidgetBase_OnUpdateUpgradesPanel) == 0x000008, "Wrong alignment on AbilitiesUserWidgetBase_OnUpdateUpgradesPanel");
static_assert(sizeof(AbilitiesUserWidgetBase_OnUpdateUpgradesPanel) == 0x000028, "Wrong size on AbilitiesUserWidgetBase_OnUpdateUpgradesPanel");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateUpgradesPanel, Upgrades) == 0x000000, "Member 'AbilitiesUserWidgetBase_OnUpdateUpgradesPanel::Upgrades' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_OnUpdateUpgradesPanel, Requirements) == 0x000010, "Member 'AbilitiesUserWidgetBase_OnUpdateUpgradesPanel::Requirements' has a wrong offset!");

// Function man.AbilitiesUserWidgetBase.SetFilter
// 0x0003 (0x0003 - 0x0000)
struct AbilitiesUserWidgetBase_SetFilter final
{
public:
	EWeaponType                                   InWeaponTypeFilter;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilterSlotAnimate;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayChangeFilterSound;                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitiesUserWidgetBase_SetFilter) == 0x000001, "Wrong alignment on AbilitiesUserWidgetBase_SetFilter");
static_assert(sizeof(AbilitiesUserWidgetBase_SetFilter) == 0x000003, "Wrong size on AbilitiesUserWidgetBase_SetFilter");
static_assert(offsetof(AbilitiesUserWidgetBase_SetFilter, InWeaponTypeFilter) == 0x000000, "Member 'AbilitiesUserWidgetBase_SetFilter::InWeaponTypeFilter' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_SetFilter, bFilterSlotAnimate) == 0x000001, "Member 'AbilitiesUserWidgetBase_SetFilter::bFilterSlotAnimate' has a wrong offset!");
static_assert(offsetof(AbilitiesUserWidgetBase_SetFilter, bPlayChangeFilterSound) == 0x000002, "Member 'AbilitiesUserWidgetBase_SetFilter::bPlayChangeFilterSound' has a wrong offset!");

// Function man.AbilityToggleComponent.GameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct AbilityToggleComponent_GameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityToggleComponent_GameplayEvent) == 0x000008, "Wrong alignment on AbilityToggleComponent_GameplayEvent");
static_assert(sizeof(AbilityToggleComponent_GameplayEvent) == 0x000020, "Wrong size on AbilityToggleComponent_GameplayEvent");
static_assert(offsetof(AbilityToggleComponent_GameplayEvent, AbilityController) == 0x000000, "Member 'AbilityToggleComponent_GameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_GameplayEvent, _GameplayEventID) == 0x000008, "Member 'AbilityToggleComponent_GameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_GameplayEvent, CustomName) == 0x000010, "Member 'AbilityToggleComponent_GameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_GameplayEvent, paramActorSoul) == 0x000018, "Member 'AbilityToggleComponent_GameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.AbilityToggleComponent.OnDamageCaused
// 0x0160 (0x0160 - 0x0000)
struct AbilityToggleComponent_OnDamageCaused final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbility;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityToggleComponent_OnDamageCaused) == 0x000008, "Wrong alignment on AbilityToggleComponent_OnDamageCaused");
static_assert(sizeof(AbilityToggleComponent_OnDamageCaused) == 0x000160, "Wrong size on AbilityToggleComponent_OnDamageCaused");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, Source) == 0x000000, "Member 'AbilityToggleComponent_OnDamageCaused::Source' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, Bullet) == 0x000008, "Member 'AbilityToggleComponent_OnDamageCaused::Bullet' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, Target) == 0x000010, "Member 'AbilityToggleComponent_OnDamageCaused::Target' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, InAbility) == 0x000018, "Member 'AbilityToggleComponent_OnDamageCaused::InAbility' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, effectiveDamage) == 0x000020, "Member 'AbilityToggleComponent_OnDamageCaused::effectiveDamage' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageCaused, DamageValue) == 0x000028, "Member 'AbilityToggleComponent_OnDamageCaused::DamageValue' has a wrong offset!");

// Function man.AbilityToggleComponent.OnDamageTaken
// 0x0160 (0x0160 - 0x0000)
struct AbilityToggleComponent_OnDamageTaken final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     TargetArg;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbility;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityToggleComponent_OnDamageTaken) == 0x000008, "Wrong alignment on AbilityToggleComponent_OnDamageTaken");
static_assert(sizeof(AbilityToggleComponent_OnDamageTaken) == 0x000160, "Wrong size on AbilityToggleComponent_OnDamageTaken");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, Source) == 0x000000, "Member 'AbilityToggleComponent_OnDamageTaken::Source' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, Bullet) == 0x000008, "Member 'AbilityToggleComponent_OnDamageTaken::Bullet' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, TargetArg) == 0x000010, "Member 'AbilityToggleComponent_OnDamageTaken::TargetArg' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, InAbility) == 0x000018, "Member 'AbilityToggleComponent_OnDamageTaken::InAbility' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, effectiveDamage) == 0x000020, "Member 'AbilityToggleComponent_OnDamageTaken::effectiveDamage' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnDamageTaken, DamageValue) == 0x000028, "Member 'AbilityToggleComponent_OnDamageTaken::DamageValue' has a wrong offset!");

// Function man.AbilityToggleComponent.OnEntityTeleportPost
// 0x000C (0x000C - 0x0000)
struct AbilityToggleComponent_OnEntityTeleportPost final
{
public:
	struct FVector                                NewPosition;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityToggleComponent_OnEntityTeleportPost) == 0x000004, "Wrong alignment on AbilityToggleComponent_OnEntityTeleportPost");
static_assert(sizeof(AbilityToggleComponent_OnEntityTeleportPost) == 0x00000C, "Wrong size on AbilityToggleComponent_OnEntityTeleportPost");
static_assert(offsetof(AbilityToggleComponent_OnEntityTeleportPost, NewPosition) == 0x000000, "Member 'AbilityToggleComponent_OnEntityTeleportPost::NewPosition' has a wrong offset!");

// Function man.AbilityToggleComponent.OnGuardedAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct AbilityToggleComponent_OnGuardedAbilityEnded final
{
public:
	class UAbilityBase*                           AbilityEnded;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityToggleComponent_OnGuardedAbilityEnded) == 0x000008, "Wrong alignment on AbilityToggleComponent_OnGuardedAbilityEnded");
static_assert(sizeof(AbilityToggleComponent_OnGuardedAbilityEnded) == 0x000008, "Wrong size on AbilityToggleComponent_OnGuardedAbilityEnded");
static_assert(offsetof(AbilityToggleComponent_OnGuardedAbilityEnded, AbilityEnded) == 0x000000, "Member 'AbilityToggleComponent_OnGuardedAbilityEnded::AbilityEnded' has a wrong offset!");

// Function man.AbilityToggleComponent.OnStatusEffectChange
// 0x0018 (0x0018 - 0x0000)
struct AbilityToggleComponent_OnStatusEffectChange final
{
public:
	EStatusEffectChange                           Change;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackNum;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityToggleComponent_OnStatusEffectChange) == 0x000008, "Wrong alignment on AbilityToggleComponent_OnStatusEffectChange");
static_assert(sizeof(AbilityToggleComponent_OnStatusEffectChange) == 0x000018, "Wrong size on AbilityToggleComponent_OnStatusEffectChange");
static_assert(offsetof(AbilityToggleComponent_OnStatusEffectChange, Change) == 0x000000, "Member 'AbilityToggleComponent_OnStatusEffectChange::Change' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnStatusEffectChange, StatusType) == 0x000001, "Member 'AbilityToggleComponent_OnStatusEffectChange::StatusType' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnStatusEffectChange, Source) == 0x000008, "Member 'AbilityToggleComponent_OnStatusEffectChange::Source' has a wrong offset!");
static_assert(offsetof(AbilityToggleComponent_OnStatusEffectChange, StackNum) == 0x000010, "Member 'AbilityToggleComponent_OnStatusEffectChange::StackNum' has a wrong offset!");

// Function man.Timer_AbilityComponent.BPGetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct Timer_AbilityComponent_BPGetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Timer_AbilityComponent_BPGetElapsedTime) == 0x000004, "Wrong alignment on Timer_AbilityComponent_BPGetElapsedTime");
static_assert(sizeof(Timer_AbilityComponent_BPGetElapsedTime) == 0x000004, "Wrong size on Timer_AbilityComponent_BPGetElapsedTime");
static_assert(offsetof(Timer_AbilityComponent_BPGetElapsedTime, ReturnValue) == 0x000000, "Member 'Timer_AbilityComponent_BPGetElapsedTime::ReturnValue' has a wrong offset!");

// Function man.Timer_AbilityComponent.BPGetOriginalTime
// 0x0004 (0x0004 - 0x0000)
struct Timer_AbilityComponent_BPGetOriginalTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Timer_AbilityComponent_BPGetOriginalTime) == 0x000004, "Wrong alignment on Timer_AbilityComponent_BPGetOriginalTime");
static_assert(sizeof(Timer_AbilityComponent_BPGetOriginalTime) == 0x000004, "Wrong size on Timer_AbilityComponent_BPGetOriginalTime");
static_assert(offsetof(Timer_AbilityComponent_BPGetOriginalTime, ReturnValue) == 0x000000, "Member 'Timer_AbilityComponent_BPGetOriginalTime::ReturnValue' has a wrong offset!");

// Function man.ChaoticEnergiesComponent.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct ChaoticEnergiesComponent_OnAbilityEnded final
{
public:
	class UAbilityBase*                           EndedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticEnergiesComponent_OnAbilityEnded) == 0x000008, "Wrong alignment on ChaoticEnergiesComponent_OnAbilityEnded");
static_assert(sizeof(ChaoticEnergiesComponent_OnAbilityEnded) == 0x000008, "Wrong size on ChaoticEnergiesComponent_OnAbilityEnded");
static_assert(offsetof(ChaoticEnergiesComponent_OnAbilityEnded, EndedAbility) == 0x000000, "Member 'ChaoticEnergiesComponent_OnAbilityEnded::EndedAbility' has a wrong offset!");

// Function man.ChaoticEnergiesComponent.OnAbilityResourcesConsumed
// 0x0008 (0x0008 - 0x0000)
struct ChaoticEnergiesComponent_OnAbilityResourcesConsumed final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticEnergiesComponent_OnAbilityResourcesConsumed) == 0x000008, "Wrong alignment on ChaoticEnergiesComponent_OnAbilityResourcesConsumed");
static_assert(sizeof(ChaoticEnergiesComponent_OnAbilityResourcesConsumed) == 0x000008, "Wrong size on ChaoticEnergiesComponent_OnAbilityResourcesConsumed");
static_assert(offsetof(ChaoticEnergiesComponent_OnAbilityResourcesConsumed, StartedAbility) == 0x000000, "Member 'ChaoticEnergiesComponent_OnAbilityResourcesConsumed::StartedAbility' has a wrong offset!");

// Function man.ChaoticEnergiesComponent.OwnerPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct ChaoticEnergiesComponent_OwnerPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticEnergiesComponent_OwnerPostDamageCaused) == 0x000008, "Wrong alignment on ChaoticEnergiesComponent_OwnerPostDamageCaused");
static_assert(sizeof(ChaoticEnergiesComponent_OwnerPostDamageCaused) == 0x0002D8, "Wrong size on ChaoticEnergiesComponent_OwnerPostDamageCaused");
static_assert(offsetof(ChaoticEnergiesComponent_OwnerPostDamageCaused, Param) == 0x000000, "Member 'ChaoticEnergiesComponent_OwnerPostDamageCaused::Param' has a wrong offset!");

// Function man.KingPriestVoidDarkWall.BPGetExplosionLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidDarkWall_BPGetExplosionLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidDarkWall_BPGetExplosionLocation) == 0x000004, "Wrong alignment on KingPriestVoidDarkWall_BPGetExplosionLocation");
static_assert(sizeof(KingPriestVoidDarkWall_BPGetExplosionLocation) == 0x00000C, "Wrong size on KingPriestVoidDarkWall_BPGetExplosionLocation");
static_assert(offsetof(KingPriestVoidDarkWall_BPGetExplosionLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidDarkWall_BPGetExplosionLocation::ReturnValue' has a wrong offset!");

// Function man.KingPriestVoidDarkWall.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidDarkWall_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidDarkWall_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestVoidDarkWall_BPGetTeleportLocation");
static_assert(sizeof(KingPriestVoidDarkWall_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestVoidDarkWall_BPGetTeleportLocation");
static_assert(offsetof(KingPriestVoidDarkWall_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidDarkWall_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.KingPriestVoidDarkWall.BPIsDarkWallStartedOnLeftSide
// 0x0001 (0x0001 - 0x0000)
struct KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide) == 0x000001, "Wrong alignment on KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide");
static_assert(sizeof(KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide) == 0x000001, "Wrong size on KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide");
static_assert(offsetof(KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide, ReturnValue) == 0x000000, "Member 'KingPriestVoidDarkWall_BPIsDarkWallStartedOnLeftSide::ReturnValue' has a wrong offset!");

// Function man.LongPressIndicatorUserWidget.OnSetIndicatorRatio
// 0x0004 (0x0004 - 0x0000)
struct LongPressIndicatorUserWidget_OnSetIndicatorRatio final
{
public:
	float                                         InIndicatorRatio;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LongPressIndicatorUserWidget_OnSetIndicatorRatio) == 0x000004, "Wrong alignment on LongPressIndicatorUserWidget_OnSetIndicatorRatio");
static_assert(sizeof(LongPressIndicatorUserWidget_OnSetIndicatorRatio) == 0x000004, "Wrong size on LongPressIndicatorUserWidget_OnSetIndicatorRatio");
static_assert(offsetof(LongPressIndicatorUserWidget_OnSetIndicatorRatio, InIndicatorRatio) == 0x000000, "Member 'LongPressIndicatorUserWidget_OnSetIndicatorRatio::InIndicatorRatio' has a wrong offset!");

// Function man.ForcedChaosEffectAbilityComponent.OnPreAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct ForcedChaosEffectAbilityComponent_OnPreAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ForcedChaosEffectAbilityComponent_OnPreAbilityStarted) == 0x000008, "Wrong alignment on ForcedChaosEffectAbilityComponent_OnPreAbilityStarted");
static_assert(sizeof(ForcedChaosEffectAbilityComponent_OnPreAbilityStarted) == 0x000010, "Wrong size on ForcedChaosEffectAbilityComponent_OnPreAbilityStarted");
static_assert(offsetof(ForcedChaosEffectAbilityComponent_OnPreAbilityStarted, StartedAbility) == 0x000000, "Member 'ForcedChaosEffectAbilityComponent_OnPreAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(ForcedChaosEffectAbilityComponent_OnPreAbilityStarted, bDesired) == 0x000008, "Member 'ForcedChaosEffectAbilityComponent_OnPreAbilityStarted::bDesired' has a wrong offset!");

// Function man.ActorBase.BPGetFacing
// 0x0004 (0x0004 - 0x0000)
struct ActorBase_BPGetFacing final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_BPGetFacing) == 0x000004, "Wrong alignment on ActorBase_BPGetFacing");
static_assert(sizeof(ActorBase_BPGetFacing) == 0x000004, "Wrong size on ActorBase_BPGetFacing");
static_assert(offsetof(ActorBase_BPGetFacing, ReturnValue) == 0x000000, "Member 'ActorBase_BPGetFacing::ReturnValue' has a wrong offset!");

// Function man.ActorBase.BPGetForwardVector
// 0x000C (0x000C - 0x0000)
struct ActorBase_BPGetForwardVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_BPGetForwardVector) == 0x000004, "Wrong alignment on ActorBase_BPGetForwardVector");
static_assert(sizeof(ActorBase_BPGetForwardVector) == 0x00000C, "Wrong size on ActorBase_BPGetForwardVector");
static_assert(offsetof(ActorBase_BPGetForwardVector, ReturnValue) == 0x000000, "Member 'ActorBase_BPGetForwardVector::ReturnValue' has a wrong offset!");

// Function man.ActorBase.BPGetInteractText
// 0x0030 (0x0030 - 0x0000)
struct ActorBase_BPGetInteractText final
{
public:
	class FText                                   DefaultText;                                       // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_BPGetInteractText) == 0x000008, "Wrong alignment on ActorBase_BPGetInteractText");
static_assert(sizeof(ActorBase_BPGetInteractText) == 0x000030, "Wrong size on ActorBase_BPGetInteractText");
static_assert(offsetof(ActorBase_BPGetInteractText, DefaultText) == 0x000000, "Member 'ActorBase_BPGetInteractText::DefaultText' has a wrong offset!");
static_assert(offsetof(ActorBase_BPGetInteractText, ReturnValue) == 0x000018, "Member 'ActorBase_BPGetInteractText::ReturnValue' has a wrong offset!");

// Function man.ActorBase.BPStartAnim
// 0x0010 (0x0010 - 0x0000)
struct ActorBase_BPStartAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBase_BPStartAnim) == 0x000008, "Wrong alignment on ActorBase_BPStartAnim");
static_assert(sizeof(ActorBase_BPStartAnim) == 0x000010, "Wrong size on ActorBase_BPStartAnim");
static_assert(offsetof(ActorBase_BPStartAnim, AnimID) == 0x000000, "Member 'ActorBase_BPStartAnim::AnimID' has a wrong offset!");
static_assert(offsetof(ActorBase_BPStartAnim, ReturnValue) == 0x000008, "Member 'ActorBase_BPStartAnim::ReturnValue' has a wrong offset!");

// Function man.ActorBase.BPStopAnim
// 0x0010 (0x0010 - 0x0000)
struct ActorBase_BPStopAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorBase_BPStopAnim) == 0x000008, "Wrong alignment on ActorBase_BPStopAnim");
static_assert(sizeof(ActorBase_BPStopAnim) == 0x000010, "Wrong size on ActorBase_BPStopAnim");
static_assert(offsetof(ActorBase_BPStopAnim, AnimID) == 0x000000, "Member 'ActorBase_BPStopAnim::AnimID' has a wrong offset!");
static_assert(offsetof(ActorBase_BPStopAnim, ReturnValue) == 0x000008, "Member 'ActorBase_BPStopAnim::ReturnValue' has a wrong offset!");

// Function man.ActorBase.GetAbilityController
// 0x0008 (0x0008 - 0x0000)
struct ActorBase_GetAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_GetAbilityController) == 0x000008, "Wrong alignment on ActorBase_GetAbilityController");
static_assert(sizeof(ActorBase_GetAbilityController) == 0x000008, "Wrong size on ActorBase_GetAbilityController");
static_assert(offsetof(ActorBase_GetAbilityController, ReturnValue) == 0x000000, "Member 'ActorBase_GetAbilityController::ReturnValue' has a wrong offset!");

// Function man.ActorBase.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct ActorBase_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_GetAttributeContainer) == 0x000008, "Wrong alignment on ActorBase_GetAttributeContainer");
static_assert(sizeof(ActorBase_GetAttributeContainer) == 0x000008, "Wrong size on ActorBase_GetAttributeContainer");
static_assert(offsetof(ActorBase_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'ActorBase_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.ActorBase.IsInteractable
// 0x0001 (0x0001 - 0x0000)
struct ActorBase_IsInteractable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_IsInteractable) == 0x000001, "Wrong alignment on ActorBase_IsInteractable");
static_assert(sizeof(ActorBase_IsInteractable) == 0x000001, "Wrong size on ActorBase_IsInteractable");
static_assert(offsetof(ActorBase_IsInteractable, ReturnValue) == 0x000000, "Member 'ActorBase_IsInteractable::ReturnValue' has a wrong offset!");

// Function man.ActorBase.MAN_SetActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct ActorBase_MAN_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_MAN_SetActorHiddenInGame) == 0x000001, "Wrong alignment on ActorBase_MAN_SetActorHiddenInGame");
static_assert(sizeof(ActorBase_MAN_SetActorHiddenInGame) == 0x000001, "Wrong size on ActorBase_MAN_SetActorHiddenInGame");
static_assert(offsetof(ActorBase_MAN_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'ActorBase_MAN_SetActorHiddenInGame::bNewHidden' has a wrong offset!");

// Function man.ActorBase.OnVfxEvent
// 0x0008 (0x0008 - 0x0000)
struct ActorBase_OnVfxEvent final
{
public:
	class FName                                   VfxEventType;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_OnVfxEvent) == 0x000004, "Wrong alignment on ActorBase_OnVfxEvent");
static_assert(sizeof(ActorBase_OnVfxEvent) == 0x000008, "Wrong size on ActorBase_OnVfxEvent");
static_assert(offsetof(ActorBase_OnVfxEvent, VfxEventType) == 0x000000, "Member 'ActorBase_OnVfxEvent::VfxEventType' has a wrong offset!");

// Function man.ActorBase.SetLevelSequenceConversationAnimID
// 0x0008 (0x0008 - 0x0000)
struct ActorBase_SetLevelSequenceConversationAnimID final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong alignment on ActorBase_SetLevelSequenceConversationAnimID");
static_assert(sizeof(ActorBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong size on ActorBase_SetLevelSequenceConversationAnimID");
static_assert(offsetof(ActorBase_SetLevelSequenceConversationAnimID, AnimID) == 0x000000, "Member 'ActorBase_SetLevelSequenceConversationAnimID::AnimID' has a wrong offset!");

// Function man.ActorBase.SetLevelSequenceMirrored
// 0x0001 (0x0001 - 0x0000)
struct ActorBase_SetLevelSequenceMirrored final
{
public:
	bool                                          bMirrored;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_SetLevelSequenceMirrored) == 0x000001, "Wrong alignment on ActorBase_SetLevelSequenceMirrored");
static_assert(sizeof(ActorBase_SetLevelSequenceMirrored) == 0x000001, "Wrong size on ActorBase_SetLevelSequenceMirrored");
static_assert(offsetof(ActorBase_SetLevelSequenceMirrored, bMirrored) == 0x000000, "Member 'ActorBase_SetLevelSequenceMirrored::bMirrored' has a wrong offset!");

// Function man.ActorBase.ToggleIneractability
// 0x0001 (0x0001 - 0x0000)
struct ActorBase_ToggleIneractability final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_ToggleIneractability) == 0x000001, "Wrong alignment on ActorBase_ToggleIneractability");
static_assert(sizeof(ActorBase_ToggleIneractability) == 0x000001, "Wrong size on ActorBase_ToggleIneractability");
static_assert(offsetof(ActorBase_ToggleIneractability, bActivate) == 0x000000, "Member 'ActorBase_ToggleIneractability::bActivate' has a wrong offset!");

// Function man.ActorBase.ToggleInteractability
// 0x0001 (0x0001 - 0x0000)
struct ActorBase_ToggleInteractability final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBase_ToggleInteractability) == 0x000001, "Wrong alignment on ActorBase_ToggleInteractability");
static_assert(sizeof(ActorBase_ToggleInteractability) == 0x000001, "Wrong size on ActorBase_ToggleInteractability");
static_assert(offsetof(ActorBase_ToggleInteractability, bActivate) == 0x000000, "Member 'ActorBase_ToggleInteractability::bActivate' has a wrong offset!");

// Function man.CoverTerrainWithActors.BasicAttackHitCounterUpdated
// 0x0008 (0x0008 - 0x0000)
struct CoverTerrainWithActors_BasicAttackHitCounterUpdated final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverTerrainWithActors_BasicAttackHitCounterUpdated) == 0x000008, "Wrong alignment on CoverTerrainWithActors_BasicAttackHitCounterUpdated");
static_assert(sizeof(CoverTerrainWithActors_BasicAttackHitCounterUpdated) == 0x000008, "Wrong size on CoverTerrainWithActors_BasicAttackHitCounterUpdated");
static_assert(offsetof(CoverTerrainWithActors_BasicAttackHitCounterUpdated, HitActor) == 0x000000, "Member 'CoverTerrainWithActors_BasicAttackHitCounterUpdated::HitActor' has a wrong offset!");

// Function man.CoverTerrainWithActors.GetPresumedLength
// 0x0004 (0x0004 - 0x0000)
struct CoverTerrainWithActors_GetPresumedLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverTerrainWithActors_GetPresumedLength) == 0x000004, "Wrong alignment on CoverTerrainWithActors_GetPresumedLength");
static_assert(sizeof(CoverTerrainWithActors_GetPresumedLength) == 0x000004, "Wrong size on CoverTerrainWithActors_GetPresumedLength");
static_assert(offsetof(CoverTerrainWithActors_GetPresumedLength, ReturnValue) == 0x000000, "Member 'CoverTerrainWithActors_GetPresumedLength::ReturnValue' has a wrong offset!");

// Function man.DeadlyDancePassive.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DeadlyDancePassive_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeadlyDancePassive_PostDamageDealt) == 0x000008, "Wrong alignment on DeadlyDancePassive_PostDamageDealt");
static_assert(sizeof(DeadlyDancePassive_PostDamageDealt) == 0x0002D8, "Wrong size on DeadlyDancePassive_PostDamageDealt");
static_assert(offsetof(DeadlyDancePassive_PostDamageDealt, Param) == 0x000000, "Member 'DeadlyDancePassive_PostDamageDealt::Param' has a wrong offset!");

// Function man.ComboPointsManagementComponent.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct ComboPointsManagementComponent_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboPointsManagementComponent_OnPostDamageDone) == 0x000008, "Wrong alignment on ComboPointsManagementComponent_OnPostDamageDone");
static_assert(sizeof(ComboPointsManagementComponent_OnPostDamageDone) == 0x0002D8, "Wrong size on ComboPointsManagementComponent_OnPostDamageDone");
static_assert(offsetof(ComboPointsManagementComponent_OnPostDamageDone, DamageParams) == 0x000000, "Member 'ComboPointsManagementComponent_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.BloodMagicAbilityComponent.PreResourceChecked
// 0x0010 (0x0010 - 0x0000)
struct BloodMagicAbilityComponent_PreResourceChecked final
{
public:
	EEntityProperty                               Property;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceValue;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodMagicAbilityComponent_PreResourceChecked) == 0x000008, "Wrong alignment on BloodMagicAbilityComponent_PreResourceChecked");
static_assert(sizeof(BloodMagicAbilityComponent_PreResourceChecked) == 0x000010, "Wrong size on BloodMagicAbilityComponent_PreResourceChecked");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceChecked, Property) == 0x000000, "Member 'BloodMagicAbilityComponent_PreResourceChecked::Property' has a wrong offset!");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceChecked, ResourceValue) == 0x000004, "Member 'BloodMagicAbilityComponent_PreResourceChecked::ResourceValue' has a wrong offset!");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceChecked, SourceAbility) == 0x000008, "Member 'BloodMagicAbilityComponent_PreResourceChecked::SourceAbility' has a wrong offset!");

// Function man.BloodMagicAbilityComponent.PreResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct BloodMagicAbilityComponent_PreResourceUsed final
{
public:
	EEntityProperty                               Property;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceValue;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodMagicAbilityComponent_PreResourceUsed) == 0x000008, "Wrong alignment on BloodMagicAbilityComponent_PreResourceUsed");
static_assert(sizeof(BloodMagicAbilityComponent_PreResourceUsed) == 0x000010, "Wrong size on BloodMagicAbilityComponent_PreResourceUsed");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceUsed, Property) == 0x000000, "Member 'BloodMagicAbilityComponent_PreResourceUsed::Property' has a wrong offset!");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceUsed, ResourceValue) == 0x000004, "Member 'BloodMagicAbilityComponent_PreResourceUsed::ResourceValue' has a wrong offset!");
static_assert(offsetof(BloodMagicAbilityComponent_PreResourceUsed, SourceAbility) == 0x000008, "Member 'BloodMagicAbilityComponent_PreResourceUsed::SourceAbility' has a wrong offset!");

// Function man.ManTelemetry.GetManTelemetry
// 0x0008 (0x0008 - 0x0000)
struct ManTelemetry_GetManTelemetry final
{
public:
	class UManTelemetry*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManTelemetry_GetManTelemetry) == 0x000008, "Wrong alignment on ManTelemetry_GetManTelemetry");
static_assert(sizeof(ManTelemetry_GetManTelemetry) == 0x000008, "Wrong size on ManTelemetry_GetManTelemetry");
static_assert(offsetof(ManTelemetry_GetManTelemetry, ReturnValue) == 0x000000, "Member 'ManTelemetry_GetManTelemetry::ReturnValue' has a wrong offset!");

// Function man.ManTelemetry.SendTelemetry
// 0x0020 (0x0020 - 0x0000)
struct ManTelemetry_SendTelemetry final
{
public:
	class FString                                 MetricCode;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectId;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManTelemetry_SendTelemetry) == 0x000008, "Wrong alignment on ManTelemetry_SendTelemetry");
static_assert(sizeof(ManTelemetry_SendTelemetry) == 0x000020, "Wrong size on ManTelemetry_SendTelemetry");
static_assert(offsetof(ManTelemetry_SendTelemetry, MetricCode) == 0x000000, "Member 'ManTelemetry_SendTelemetry::MetricCode' has a wrong offset!");
static_assert(offsetof(ManTelemetry_SendTelemetry, Value) == 0x000010, "Member 'ManTelemetry_SendTelemetry::Value' has a wrong offset!");
static_assert(offsetof(ManTelemetry_SendTelemetry, Level) == 0x000014, "Member 'ManTelemetry_SendTelemetry::Level' has a wrong offset!");
static_assert(offsetof(ManTelemetry_SendTelemetry, ObjectId) == 0x000018, "Member 'ManTelemetry_SendTelemetry::ObjectId' has a wrong offset!");

// Function man.CustomEventOnAbilityModifierChange.OnAbilityModifierChanged
// 0x000C (0x000C - 0x0000)
struct CustomEventOnAbilityModifierChange_OnAbilityModifierChanged final
{
public:
	bool                                          bAdded;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGeneralAbilityModifier                       GeneralID;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomID;                                          // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnAbilityModifierChange_OnAbilityModifierChanged) == 0x000004, "Wrong alignment on CustomEventOnAbilityModifierChange_OnAbilityModifierChanged");
static_assert(sizeof(CustomEventOnAbilityModifierChange_OnAbilityModifierChanged) == 0x00000C, "Wrong size on CustomEventOnAbilityModifierChange_OnAbilityModifierChanged");
static_assert(offsetof(CustomEventOnAbilityModifierChange_OnAbilityModifierChanged, bAdded) == 0x000000, "Member 'CustomEventOnAbilityModifierChange_OnAbilityModifierChanged::bAdded' has a wrong offset!");
static_assert(offsetof(CustomEventOnAbilityModifierChange_OnAbilityModifierChanged, GeneralID) == 0x000001, "Member 'CustomEventOnAbilityModifierChange_OnAbilityModifierChanged::GeneralID' has a wrong offset!");
static_assert(offsetof(CustomEventOnAbilityModifierChange_OnAbilityModifierChanged, CustomID) == 0x000004, "Member 'CustomEventOnAbilityModifierChange_OnAbilityModifierChanged::CustomID' has a wrong offset!");

// Function man.TrappedSoulsBase.TriggerOnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct TrappedSoulsBase_TriggerOnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrappedSoulsBase_TriggerOnComponentBeginOverlap) == 0x000008, "Wrong alignment on TrappedSoulsBase_TriggerOnComponentBeginOverlap");
static_assert(sizeof(TrappedSoulsBase_TriggerOnComponentBeginOverlap) == 0x0000A8, "Wrong size on TrappedSoulsBase_TriggerOnComponentBeginOverlap");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'TrappedSoulsBase_TriggerOnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function man.TrappedSoulsBase.TriggerOnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct TrappedSoulsBase_TriggerOnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TrappedSoulsBase_TriggerOnComponentEndOverlap) == 0x000008, "Wrong alignment on TrappedSoulsBase_TriggerOnComponentEndOverlap");
static_assert(sizeof(TrappedSoulsBase_TriggerOnComponentEndOverlap) == 0x000020, "Wrong size on TrappedSoulsBase_TriggerOnComponentEndOverlap");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'TrappedSoulsBase_TriggerOnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentEndOverlap, OtherActor) == 0x000008, "Member 'TrappedSoulsBase_TriggerOnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentEndOverlap, OtherComp) == 0x000010, "Member 'TrappedSoulsBase_TriggerOnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(TrappedSoulsBase_TriggerOnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'TrappedSoulsBase_TriggerOnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.GreenEyePoisonActor.OnPreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct GreenEyePoisonActor_OnPreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GreenEyePoisonActor_OnPreDamageDealt) == 0x000008, "Wrong alignment on GreenEyePoisonActor_OnPreDamageDealt");
static_assert(sizeof(GreenEyePoisonActor_OnPreDamageDealt) == 0x0002D8, "Wrong size on GreenEyePoisonActor_OnPreDamageDealt");
static_assert(offsetof(GreenEyePoisonActor_OnPreDamageDealt, Param) == 0x000000, "Member 'GreenEyePoisonActor_OnPreDamageDealt::Param' has a wrong offset!");

// Function man.AdditionalStatusEffectOnStatusEffectComponent.OnStatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused) == 0x000008, "Wrong alignment on AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused");
static_assert(sizeof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused) == 0x000018, "Wrong size on AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused");
static_assert(offsetof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused, TargetActor) == 0x000000, "Member 'AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused::TargetActor' has a wrong offset!");
static_assert(offsetof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused, Type) == 0x000008, "Member 'AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused, IsNewEffect) == 0x000009, "Member 'AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused, Instance) == 0x000010, "Member 'AdditionalStatusEffectOnStatusEffectComponent_OnStatusEffectCaused::Instance' has a wrong offset!");

// Function man.AdditionalEffectDuringStatusEffectComponent.StatusEffectApplied
// 0x0018 (0x0018 - 0x0000)
struct AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied) == 0x000008, "Wrong alignment on AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied");
static_assert(sizeof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied) == 0x000018, "Wrong size on AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied");
static_assert(offsetof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied, TargetActor) == 0x000000, "Member 'AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied::TargetActor' has a wrong offset!");
static_assert(offsetof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied, Type) == 0x000008, "Member 'AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied::Type' has a wrong offset!");
static_assert(offsetof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied, IsNewEffect) == 0x000009, "Member 'AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied::IsNewEffect' has a wrong offset!");
static_assert(offsetof(AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied, Instance) == 0x000010, "Member 'AdditionalEffectDuringStatusEffectComponent_StatusEffectApplied::Instance' has a wrong offset!");

// Function man.ConsumeResourceForStatusEffect.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct ConsumeResourceForStatusEffect_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsumeResourceForStatusEffect_OnPostDamageCaused) == 0x000008, "Wrong alignment on ConsumeResourceForStatusEffect_OnPostDamageCaused");
static_assert(sizeof(ConsumeResourceForStatusEffect_OnPostDamageCaused) == 0x0002D8, "Wrong size on ConsumeResourceForStatusEffect_OnPostDamageCaused");
static_assert(offsetof(ConsumeResourceForStatusEffect_OnPostDamageCaused, Param) == 0x000000, "Member 'ConsumeResourceForStatusEffect_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.GatheringLight.OnPreDamaged_GatheringLight
// 0x02D8 (0x02D8 - 0x0000)
struct GatheringLight_OnPreDamaged_GatheringLight final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GatheringLight_OnPreDamaged_GatheringLight) == 0x000008, "Wrong alignment on GatheringLight_OnPreDamaged_GatheringLight");
static_assert(sizeof(GatheringLight_OnPreDamaged_GatheringLight) == 0x0002D8, "Wrong size on GatheringLight_OnPreDamaged_GatheringLight");
static_assert(offsetof(GatheringLight_OnPreDamaged_GatheringLight, Param) == 0x000000, "Member 'GatheringLight_OnPreDamaged_GatheringLight::Param' has a wrong offset!");

// Function man.PortalMirrorImplement.TriggerOnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct PortalMirrorImplement_TriggerOnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PortalMirrorImplement_TriggerOnComponentBeginOverlap) == 0x000008, "Wrong alignment on PortalMirrorImplement_TriggerOnComponentBeginOverlap");
static_assert(sizeof(PortalMirrorImplement_TriggerOnComponentBeginOverlap) == 0x0000A8, "Wrong size on PortalMirrorImplement_TriggerOnComponentBeginOverlap");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(PortalMirrorImplement_TriggerOnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'PortalMirrorImplement_TriggerOnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function man.PriestLightBarrierPassive.GetAbsorbComponent
// 0x0008 (0x0008 - 0x0000)
struct PriestLightBarrierPassive_GetAbsorbComponent final
{
public:
	class UAbsorbDamageAbilityComponent*          ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PriestLightBarrierPassive_GetAbsorbComponent) == 0x000008, "Wrong alignment on PriestLightBarrierPassive_GetAbsorbComponent");
static_assert(sizeof(PriestLightBarrierPassive_GetAbsorbComponent) == 0x000008, "Wrong size on PriestLightBarrierPassive_GetAbsorbComponent");
static_assert(offsetof(PriestLightBarrierPassive_GetAbsorbComponent, ReturnValue) == 0x000000, "Member 'PriestLightBarrierPassive_GetAbsorbComponent::ReturnValue' has a wrong offset!");

// Function man.PriestLightBarrierPassive.OnAbilityModifierChanged
// 0x000C (0x000C - 0x0000)
struct PriestLightBarrierPassive_OnAbilityModifierChanged final
{
public:
	bool                                          bInAdded;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGeneralAbilityModifier                       GeneralID;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomID;                                          // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PriestLightBarrierPassive_OnAbilityModifierChanged) == 0x000004, "Wrong alignment on PriestLightBarrierPassive_OnAbilityModifierChanged");
static_assert(sizeof(PriestLightBarrierPassive_OnAbilityModifierChanged) == 0x00000C, "Wrong size on PriestLightBarrierPassive_OnAbilityModifierChanged");
static_assert(offsetof(PriestLightBarrierPassive_OnAbilityModifierChanged, bInAdded) == 0x000000, "Member 'PriestLightBarrierPassive_OnAbilityModifierChanged::bInAdded' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_OnAbilityModifierChanged, GeneralID) == 0x000001, "Member 'PriestLightBarrierPassive_OnAbilityModifierChanged::GeneralID' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_OnAbilityModifierChanged, CustomID) == 0x000004, "Member 'PriestLightBarrierPassive_OnAbilityModifierChanged::CustomID' has a wrong offset!");

// Function man.PriestLightBarrierPassive.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct PriestLightBarrierPassive_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PriestLightBarrierPassive_PropertyChanged) == 0x000004, "Wrong alignment on PriestLightBarrierPassive_PropertyChanged");
static_assert(sizeof(PriestLightBarrierPassive_PropertyChanged) == 0x000014, "Wrong size on PriestLightBarrierPassive_PropertyChanged");
static_assert(offsetof(PriestLightBarrierPassive_PropertyChanged, PropertyType) == 0x000000, "Member 'PriestLightBarrierPassive_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_PropertyChanged, Value) == 0x000004, "Member 'PriestLightBarrierPassive_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'PriestLightBarrierPassive_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'PriestLightBarrierPassive_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(PriestLightBarrierPassive_PropertyChanged, bAnimate) == 0x000010, "Member 'PriestLightBarrierPassive_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.CustomEventOnAbility.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnAbility_OnAbilityEnded final
{
public:
	class UAbilityBase*                           EndedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnAbility_OnAbilityEnded) == 0x000008, "Wrong alignment on CustomEventOnAbility_OnAbilityEnded");
static_assert(sizeof(CustomEventOnAbility_OnAbilityEnded) == 0x000008, "Wrong size on CustomEventOnAbility_OnAbilityEnded");
static_assert(offsetof(CustomEventOnAbility_OnAbilityEnded, EndedAbility) == 0x000000, "Member 'CustomEventOnAbility_OnAbilityEnded::EndedAbility' has a wrong offset!");

// Function man.CustomEventOnAbility.OnAbilityResourceConsumed
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnAbility_OnAbilityResourceConsumed final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnAbility_OnAbilityResourceConsumed) == 0x000008, "Wrong alignment on CustomEventOnAbility_OnAbilityResourceConsumed");
static_assert(sizeof(CustomEventOnAbility_OnAbilityResourceConsumed) == 0x000008, "Wrong size on CustomEventOnAbility_OnAbilityResourceConsumed");
static_assert(offsetof(CustomEventOnAbility_OnAbilityResourceConsumed, StartedAbility) == 0x000000, "Member 'CustomEventOnAbility_OnAbilityResourceConsumed::StartedAbility' has a wrong offset!");

// Function man.CustomEventOnAbility.OnAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct CustomEventOnAbility_OnAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CustomEventOnAbility_OnAbilityStarted) == 0x000008, "Wrong alignment on CustomEventOnAbility_OnAbilityStarted");
static_assert(sizeof(CustomEventOnAbility_OnAbilityStarted) == 0x000010, "Wrong size on CustomEventOnAbility_OnAbilityStarted");
static_assert(offsetof(CustomEventOnAbility_OnAbilityStarted, StartedAbility) == 0x000000, "Member 'CustomEventOnAbility_OnAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(CustomEventOnAbility_OnAbilityStarted, bDesired) == 0x000008, "Member 'CustomEventOnAbility_OnAbilityStarted::bDesired' has a wrong offset!");

// Function man.CustomEventOnAbility.OnPostAddAbility
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnAbility_OnPostAddAbility final
{
public:
	class UAbilityBase*                           AddedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnAbility_OnPostAddAbility) == 0x000008, "Wrong alignment on CustomEventOnAbility_OnPostAddAbility");
static_assert(sizeof(CustomEventOnAbility_OnPostAddAbility) == 0x000008, "Wrong size on CustomEventOnAbility_OnPostAddAbility");
static_assert(offsetof(CustomEventOnAbility_OnPostAddAbility, AddedAbility) == 0x000000, "Member 'CustomEventOnAbility_OnPostAddAbility::AddedAbility' has a wrong offset!");

// Function man.CustomEventOnAbility.OnPostRemoveAbility
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnAbility_OnPostRemoveAbility final
{
public:
	class UAbilityBase*                           RemovedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnAbility_OnPostRemoveAbility) == 0x000008, "Wrong alignment on CustomEventOnAbility_OnPostRemoveAbility");
static_assert(sizeof(CustomEventOnAbility_OnPostRemoveAbility) == 0x000008, "Wrong size on CustomEventOnAbility_OnPostRemoveAbility");
static_assert(offsetof(CustomEventOnAbility_OnPostRemoveAbility, RemovedAbility) == 0x000000, "Member 'CustomEventOnAbility_OnPostRemoveAbility::RemovedAbility' has a wrong offset!");

// Function man.ManVolumeBase.BPEncompassesPoint
// 0x0010 (0x0010 - 0x0000)
struct ManVolumeBase_BPEncompassesPoint final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManVolumeBase_BPEncompassesPoint) == 0x000004, "Wrong alignment on ManVolumeBase_BPEncompassesPoint");
static_assert(sizeof(ManVolumeBase_BPEncompassesPoint) == 0x000010, "Wrong size on ManVolumeBase_BPEncompassesPoint");
static_assert(offsetof(ManVolumeBase_BPEncompassesPoint, Point) == 0x000000, "Member 'ManVolumeBase_BPEncompassesPoint::Point' has a wrong offset!");
static_assert(offsetof(ManVolumeBase_BPEncompassesPoint, ReturnValue) == 0x00000C, "Member 'ManVolumeBase_BPEncompassesPoint::ReturnValue' has a wrong offset!");

// Function man.DarkFocus.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DarkFocus_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFocus_DamageDealt) == 0x000008, "Wrong alignment on DarkFocus_DamageDealt");
static_assert(sizeof(DarkFocus_DamageDealt) == 0x0002D8, "Wrong size on DarkFocus_DamageDealt");
static_assert(offsetof(DarkFocus_DamageDealt, Param) == 0x000000, "Member 'DarkFocus_DamageDealt::Param' has a wrong offset!");

// Function man.Execute.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct Execute_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Execute_OnPostDamageCaused) == 0x000008, "Wrong alignment on Execute_OnPostDamageCaused");
static_assert(sizeof(Execute_OnPostDamageCaused) == 0x0002D8, "Wrong size on Execute_OnPostDamageCaused");
static_assert(offsetof(Execute_OnPostDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'Execute_OnPostDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.TimedAbilityManager.OnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct TimedAbilityManager_OnGameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimedAbilityManager_OnGameplayEvent) == 0x000008, "Wrong alignment on TimedAbilityManager_OnGameplayEvent");
static_assert(sizeof(TimedAbilityManager_OnGameplayEvent) == 0x000020, "Wrong size on TimedAbilityManager_OnGameplayEvent");
static_assert(offsetof(TimedAbilityManager_OnGameplayEvent, AbilityController) == 0x000000, "Member 'TimedAbilityManager_OnGameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(TimedAbilityManager_OnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'TimedAbilityManager_OnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(TimedAbilityManager_OnGameplayEvent, CustomName) == 0x000010, "Member 'TimedAbilityManager_OnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(TimedAbilityManager_OnGameplayEvent, paramActorSoul) == 0x000018, "Member 'TimedAbilityManager_OnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.OnDamaged_AbilityComponent.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct OnDamaged_AbilityComponent_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnDamaged_AbilityComponent_OnPostDamaged) == 0x000008, "Wrong alignment on OnDamaged_AbilityComponent_OnPostDamaged");
static_assert(sizeof(OnDamaged_AbilityComponent_OnPostDamaged) == 0x0002D8, "Wrong size on OnDamaged_AbilityComponent_OnPostDamaged");
static_assert(offsetof(OnDamaged_AbilityComponent_OnPostDamaged, Param) == 0x000000, "Member 'OnDamaged_AbilityComponent_OnPostDamaged::Param' has a wrong offset!");

// Function man.CharacterBase.AddTextBubble
// 0x0020 (0x0020 - 0x0000)
struct CharacterBase_AddTextBubble final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogueBubbleType                           DialogueBubbleType;                                // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_AddTextBubble) == 0x000008, "Wrong alignment on CharacterBase_AddTextBubble");
static_assert(sizeof(CharacterBase_AddTextBubble) == 0x000020, "Wrong size on CharacterBase_AddTextBubble");
static_assert(offsetof(CharacterBase_AddTextBubble, Text) == 0x000000, "Member 'CharacterBase_AddTextBubble::Text' has a wrong offset!");
static_assert(offsetof(CharacterBase_AddTextBubble, Delay) == 0x000018, "Member 'CharacterBase_AddTextBubble::Delay' has a wrong offset!");
static_assert(offsetof(CharacterBase_AddTextBubble, DialogueBubbleType) == 0x00001C, "Member 'CharacterBase_AddTextBubble::DialogueBubbleType' has a wrong offset!");

// Function man.CharacterBase.BPExecuteCommand
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_BPExecuteCommand final
{
public:
	class FName                                   commandName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPExecuteCommand) == 0x000004, "Wrong alignment on CharacterBase_BPExecuteCommand");
static_assert(sizeof(CharacterBase_BPExecuteCommand) == 0x000008, "Wrong size on CharacterBase_BPExecuteCommand");
static_assert(offsetof(CharacterBase_BPExecuteCommand, commandName) == 0x000000, "Member 'CharacterBase_BPExecuteCommand::commandName' has a wrong offset!");

// Function man.CharacterBase.BPGetAIPhaseIndex
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_BPGetAIPhaseIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPGetAIPhaseIndex) == 0x000004, "Wrong alignment on CharacterBase_BPGetAIPhaseIndex");
static_assert(sizeof(CharacterBase_BPGetAIPhaseIndex) == 0x000004, "Wrong size on CharacterBase_BPGetAIPhaseIndex");
static_assert(offsetof(CharacterBase_BPGetAIPhaseIndex, ReturnValue) == 0x000000, "Member 'CharacterBase_BPGetAIPhaseIndex::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPGetAnimPlayRate
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_BPGetAnimPlayRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPGetAnimPlayRate) == 0x000004, "Wrong alignment on CharacterBase_BPGetAnimPlayRate");
static_assert(sizeof(CharacterBase_BPGetAnimPlayRate) == 0x000004, "Wrong size on CharacterBase_BPGetAnimPlayRate");
static_assert(offsetof(CharacterBase_BPGetAnimPlayRate, ReturnValue) == 0x000000, "Member 'CharacterBase_BPGetAnimPlayRate::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPGetAxisXFacing
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_BPGetAxisXFacing final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPGetAxisXFacing) == 0x000004, "Wrong alignment on CharacterBase_BPGetAxisXFacing");
static_assert(sizeof(CharacterBase_BPGetAxisXFacing) == 0x000004, "Wrong size on CharacterBase_BPGetAxisXFacing");
static_assert(offsetof(CharacterBase_BPGetAxisXFacing, ReturnValue) == 0x000000, "Member 'CharacterBase_BPGetAxisXFacing::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPHasEntityTag
// 0x000C (0x000C - 0x0000)
struct CharacterBase_BPHasEntityTag final
{
public:
	class FName                                   DeathTag;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_BPHasEntityTag) == 0x000004, "Wrong alignment on CharacterBase_BPHasEntityTag");
static_assert(sizeof(CharacterBase_BPHasEntityTag) == 0x00000C, "Wrong size on CharacterBase_BPHasEntityTag");
static_assert(offsetof(CharacterBase_BPHasEntityTag, DeathTag) == 0x000000, "Member 'CharacterBase_BPHasEntityTag::DeathTag' has a wrong offset!");
static_assert(offsetof(CharacterBase_BPHasEntityTag, ReturnValue) == 0x000008, "Member 'CharacterBase_BPHasEntityTag::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPIsBoss
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_BPIsBoss final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPIsBoss) == 0x000001, "Wrong alignment on CharacterBase_BPIsBoss");
static_assert(sizeof(CharacterBase_BPIsBoss) == 0x000001, "Wrong size on CharacterBase_BPIsBoss");
static_assert(offsetof(CharacterBase_BPIsBoss, ReturnValue) == 0x000000, "Member 'CharacterBase_BPIsBoss::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPIsFalling
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_BPIsFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPIsFalling) == 0x000001, "Wrong alignment on CharacterBase_BPIsFalling");
static_assert(sizeof(CharacterBase_BPIsFalling) == 0x000001, "Wrong size on CharacterBase_BPIsFalling");
static_assert(offsetof(CharacterBase_BPIsFalling, ReturnValue) == 0x000000, "Member 'CharacterBase_BPIsFalling::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPIsRespawnFinished
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_BPIsRespawnFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPIsRespawnFinished) == 0x000001, "Wrong alignment on CharacterBase_BPIsRespawnFinished");
static_assert(sizeof(CharacterBase_BPIsRespawnFinished) == 0x000001, "Wrong size on CharacterBase_BPIsRespawnFinished");
static_assert(offsetof(CharacterBase_BPIsRespawnFinished, ReturnValue) == 0x000000, "Member 'CharacterBase_BPIsRespawnFinished::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPKill
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_BPKill final
{
public:
	class UAnimID*                                CustomAnim;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInterruptAll;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestInvulnerable;                                 // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_BPKill) == 0x000008, "Wrong alignment on CharacterBase_BPKill");
static_assert(sizeof(CharacterBase_BPKill) == 0x000010, "Wrong size on CharacterBase_BPKill");
static_assert(offsetof(CharacterBase_BPKill, CustomAnim) == 0x000000, "Member 'CharacterBase_BPKill::CustomAnim' has a wrong offset!");
static_assert(offsetof(CharacterBase_BPKill, bForceInterruptAll) == 0x000008, "Member 'CharacterBase_BPKill::bForceInterruptAll' has a wrong offset!");
static_assert(offsetof(CharacterBase_BPKill, bTestInvulnerable) == 0x000009, "Member 'CharacterBase_BPKill::bTestInvulnerable' has a wrong offset!");
static_assert(offsetof(CharacterBase_BPKill, ReturnValue) == 0x00000A, "Member 'CharacterBase_BPKill::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.BPLootDropCondition
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_BPLootDropCondition final
{
public:
	class UItemAbility*                           Loot;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_BPLootDropCondition) == 0x000008, "Wrong alignment on CharacterBase_BPLootDropCondition");
static_assert(sizeof(CharacterBase_BPLootDropCondition) == 0x000010, "Wrong size on CharacterBase_BPLootDropCondition");
static_assert(offsetof(CharacterBase_BPLootDropCondition, Loot) == 0x000000, "Member 'CharacterBase_BPLootDropCondition::Loot' has a wrong offset!");
static_assert(offsetof(CharacterBase_BPLootDropCondition, Result) == 0x000008, "Member 'CharacterBase_BPLootDropCondition::Result' has a wrong offset!");

// Function man.CharacterBase.BPMoveHorizontal
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_BPMoveHorizontal final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPMoveHorizontal) == 0x000004, "Wrong alignment on CharacterBase_BPMoveHorizontal");
static_assert(sizeof(CharacterBase_BPMoveHorizontal) == 0x000004, "Wrong size on CharacterBase_BPMoveHorizontal");
static_assert(offsetof(CharacterBase_BPMoveHorizontal, Value) == 0x000000, "Member 'CharacterBase_BPMoveHorizontal::Value' has a wrong offset!");

// Function man.CharacterBase.BPMoveVertical
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_BPMoveVertical final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPMoveVertical) == 0x000004, "Wrong alignment on CharacterBase_BPMoveVertical");
static_assert(sizeof(CharacterBase_BPMoveVertical) == 0x000004, "Wrong size on CharacterBase_BPMoveVertical");
static_assert(offsetof(CharacterBase_BPMoveVertical, Value) == 0x000000, "Member 'CharacterBase_BPMoveVertical::Value' has a wrong offset!");

// Function man.CharacterBase.BPOverrideLootSpawnTransform
// 0x0030 (0x0030 - 0x0000)
struct CharacterBase_BPOverrideLootSpawnTransform final
{
public:
	struct FTransform                             InTransform;                                       // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPOverrideLootSpawnTransform) == 0x000010, "Wrong alignment on CharacterBase_BPOverrideLootSpawnTransform");
static_assert(sizeof(CharacterBase_BPOverrideLootSpawnTransform) == 0x000030, "Wrong size on CharacterBase_BPOverrideLootSpawnTransform");
static_assert(offsetof(CharacterBase_BPOverrideLootSpawnTransform, InTransform) == 0x000000, "Member 'CharacterBase_BPOverrideLootSpawnTransform::InTransform' has a wrong offset!");

// Function man.CharacterBase.BPSetFacing
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_BPSetFacing final
{
public:
	class AActor*                                 FacingTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPSetFacing) == 0x000008, "Wrong alignment on CharacterBase_BPSetFacing");
static_assert(sizeof(CharacterBase_BPSetFacing) == 0x000008, "Wrong size on CharacterBase_BPSetFacing");
static_assert(offsetof(CharacterBase_BPSetFacing, FacingTarget) == 0x000000, "Member 'CharacterBase_BPSetFacing::FacingTarget' has a wrong offset!");

// Function man.CharacterBase.BPTeleportToTransform
// 0x0030 (0x0030 - 0x0000)
struct CharacterBase_BPTeleportToTransform final
{
public:
	struct FTransform                             InTransform;                                       // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPTeleportToTransform) == 0x000010, "Wrong alignment on CharacterBase_BPTeleportToTransform");
static_assert(sizeof(CharacterBase_BPTeleportToTransform) == 0x000030, "Wrong size on CharacterBase_BPTeleportToTransform");
static_assert(offsetof(CharacterBase_BPTeleportToTransform, InTransform) == 0x000000, "Member 'CharacterBase_BPTeleportToTransform::InTransform' has a wrong offset!");

// Function man.CharacterBase.BPToggleDelayedLoot
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_BPToggleDelayedLoot final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPToggleDelayedLoot) == 0x000001, "Wrong alignment on CharacterBase_BPToggleDelayedLoot");
static_assert(sizeof(CharacterBase_BPToggleDelayedLoot) == 0x000001, "Wrong size on CharacterBase_BPToggleDelayedLoot");
static_assert(offsetof(CharacterBase_BPToggleDelayedLoot, bToggle) == 0x000000, "Member 'CharacterBase_BPToggleDelayedLoot::bToggle' has a wrong offset!");

// Function man.CharacterBase.CanPlayFallingAnim
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_CanPlayFallingAnim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_CanPlayFallingAnim) == 0x000001, "Wrong alignment on CharacterBase_CanPlayFallingAnim");
static_assert(sizeof(CharacterBase_CanPlayFallingAnim) == 0x000001, "Wrong size on CharacterBase_CanPlayFallingAnim");
static_assert(offsetof(CharacterBase_CanPlayFallingAnim, ReturnValue) == 0x000000, "Member 'CharacterBase_CanPlayFallingAnim::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.EnableLevelSequenceAnimationOverlay
// 0x0018 (0x0018 - 0x0000)
struct CharacterBase_EnableLevelSequenceAnimationOverlay final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_EnableLevelSequenceAnimationOverlay) == 0x000008, "Wrong alignment on CharacterBase_EnableLevelSequenceAnimationOverlay");
static_assert(sizeof(CharacterBase_EnableLevelSequenceAnimationOverlay) == 0x000018, "Wrong size on CharacterBase_EnableLevelSequenceAnimationOverlay");
static_assert(offsetof(CharacterBase_EnableLevelSequenceAnimationOverlay, Actors) == 0x000000, "Member 'CharacterBase_EnableLevelSequenceAnimationOverlay::Actors' has a wrong offset!");
static_assert(offsetof(CharacterBase_EnableLevelSequenceAnimationOverlay, bEnable) == 0x000010, "Member 'CharacterBase_EnableLevelSequenceAnimationOverlay::bEnable' has a wrong offset!");

// Function man.CharacterBase.ForceMirrorRate
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_ForceMirrorRate final
{
public:
	float                                         MirrorRate;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_ForceMirrorRate) == 0x000004, "Wrong alignment on CharacterBase_ForceMirrorRate");
static_assert(sizeof(CharacterBase_ForceMirrorRate) == 0x000008, "Wrong size on CharacterBase_ForceMirrorRate");
static_assert(offsetof(CharacterBase_ForceMirrorRate, MirrorRate) == 0x000000, "Member 'CharacterBase_ForceMirrorRate::MirrorRate' has a wrong offset!");
static_assert(offsetof(CharacterBase_ForceMirrorRate, bEnable) == 0x000004, "Member 'CharacterBase_ForceMirrorRate::bEnable' has a wrong offset!");

// Function man.CharacterBase.GetAbilityController
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_GetAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetAbilityController) == 0x000008, "Wrong alignment on CharacterBase_GetAbilityController");
static_assert(sizeof(CharacterBase_GetAbilityController) == 0x000008, "Wrong size on CharacterBase_GetAbilityController");
static_assert(offsetof(CharacterBase_GetAbilityController, ReturnValue) == 0x000000, "Member 'CharacterBase_GetAbilityController::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetAttributeContainer) == 0x000008, "Wrong alignment on CharacterBase_GetAttributeContainer");
static_assert(sizeof(CharacterBase_GetAttributeContainer) == 0x000008, "Wrong size on CharacterBase_GetAttributeContainer");
static_assert(offsetof(CharacterBase_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'CharacterBase_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetGameCamera
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_GetGameCamera final
{
public:
	class AGameCamera*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetGameCamera) == 0x000008, "Wrong alignment on CharacterBase_GetGameCamera");
static_assert(sizeof(CharacterBase_GetGameCamera) == 0x000008, "Wrong size on CharacterBase_GetGameCamera");
static_assert(offsetof(CharacterBase_GetGameCamera, ReturnValue) == 0x000000, "Member 'CharacterBase_GetGameCamera::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetHeroDistance
// 0x000C (0x000C - 0x0000)
struct CharacterBase_GetHeroDistance final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetHeroDistance) == 0x000004, "Wrong alignment on CharacterBase_GetHeroDistance");
static_assert(sizeof(CharacterBase_GetHeroDistance) == 0x00000C, "Wrong size on CharacterBase_GetHeroDistance");
static_assert(offsetof(CharacterBase_GetHeroDistance, ReturnValue) == 0x000000, "Member 'CharacterBase_GetHeroDistance::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetHeroLookAngle
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_GetHeroLookAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetHeroLookAngle) == 0x000004, "Wrong alignment on CharacterBase_GetHeroLookAngle");
static_assert(sizeof(CharacterBase_GetHeroLookAngle) == 0x000004, "Wrong size on CharacterBase_GetHeroLookAngle");
static_assert(offsetof(CharacterBase_GetHeroLookAngle, ReturnValue) == 0x000000, "Member 'CharacterBase_GetHeroLookAngle::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetStatusEffectController
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_GetStatusEffectController final
{
public:
	class UStatusEffectController*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetStatusEffectController) == 0x000008, "Wrong alignment on CharacterBase_GetStatusEffectController");
static_assert(sizeof(CharacterBase_GetStatusEffectController) == 0x000008, "Wrong size on CharacterBase_GetStatusEffectController");
static_assert(offsetof(CharacterBase_GetStatusEffectController, ReturnValue) == 0x000000, "Member 'CharacterBase_GetStatusEffectController::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.IsRooted
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_IsRooted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_IsRooted) == 0x000001, "Wrong alignment on CharacterBase_IsRooted");
static_assert(sizeof(CharacterBase_IsRooted) == 0x000001, "Wrong size on CharacterBase_IsRooted");
static_assert(offsetof(CharacterBase_IsRooted, ReturnValue) == 0x000000, "Member 'CharacterBase_IsRooted::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.IsWeaknessed
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_IsWeaknessed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_IsWeaknessed) == 0x000001, "Wrong alignment on CharacterBase_IsWeaknessed");
static_assert(sizeof(CharacterBase_IsWeaknessed) == 0x000001, "Wrong size on CharacterBase_IsWeaknessed");
static_assert(offsetof(CharacterBase_IsWeaknessed, ReturnValue) == 0x000000, "Member 'CharacterBase_IsWeaknessed::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.LookHAxisBind
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_LookHAxisBind final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_LookHAxisBind) == 0x000004, "Wrong alignment on CharacterBase_LookHAxisBind");
static_assert(sizeof(CharacterBase_LookHAxisBind) == 0x000004, "Wrong size on CharacterBase_LookHAxisBind");
static_assert(offsetof(CharacterBase_LookHAxisBind, Value) == 0x000000, "Member 'CharacterBase_LookHAxisBind::Value' has a wrong offset!");

// Function man.CharacterBase.LookVAxisBind
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_LookVAxisBind final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_LookVAxisBind) == 0x000004, "Wrong alignment on CharacterBase_LookVAxisBind");
static_assert(sizeof(CharacterBase_LookVAxisBind) == 0x000004, "Wrong size on CharacterBase_LookVAxisBind");
static_assert(offsetof(CharacterBase_LookVAxisBind, Value) == 0x000000, "Member 'CharacterBase_LookVAxisBind::Value' has a wrong offset!");

// Function man.CharacterBase.LookVAxisBindMouseWheel
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_LookVAxisBindMouseWheel final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_LookVAxisBindMouseWheel) == 0x000004, "Wrong alignment on CharacterBase_LookVAxisBindMouseWheel");
static_assert(sizeof(CharacterBase_LookVAxisBindMouseWheel) == 0x000004, "Wrong size on CharacterBase_LookVAxisBindMouseWheel");
static_assert(offsetof(CharacterBase_LookVAxisBindMouseWheel, Value) == 0x000000, "Member 'CharacterBase_LookVAxisBindMouseWheel::Value' has a wrong offset!");

// Function man.CharacterBase.MAN_SetActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_MAN_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_MAN_SetActorHiddenInGame) == 0x000001, "Wrong alignment on CharacterBase_MAN_SetActorHiddenInGame");
static_assert(sizeof(CharacterBase_MAN_SetActorHiddenInGame) == 0x000001, "Wrong size on CharacterBase_MAN_SetActorHiddenInGame");
static_assert(offsetof(CharacterBase_MAN_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'CharacterBase_MAN_SetActorHiddenInGame::bNewHidden' has a wrong offset!");

// Function man.CharacterBase.MoveHorizontal
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_MoveHorizontal final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_MoveHorizontal) == 0x000004, "Wrong alignment on CharacterBase_MoveHorizontal");
static_assert(sizeof(CharacterBase_MoveHorizontal) == 0x000004, "Wrong size on CharacterBase_MoveHorizontal");
static_assert(offsetof(CharacterBase_MoveHorizontal, Value) == 0x000000, "Member 'CharacterBase_MoveHorizontal::Value' has a wrong offset!");

// Function man.CharacterBase.MoveHorizontalJoystick
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_MoveHorizontalJoystick final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_MoveHorizontalJoystick) == 0x000004, "Wrong alignment on CharacterBase_MoveHorizontalJoystick");
static_assert(sizeof(CharacterBase_MoveHorizontalJoystick) == 0x000004, "Wrong size on CharacterBase_MoveHorizontalJoystick");
static_assert(offsetof(CharacterBase_MoveHorizontalJoystick, Value) == 0x000000, "Member 'CharacterBase_MoveHorizontalJoystick::Value' has a wrong offset!");

// Function man.CharacterBase.MoveVertical
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_MoveVertical final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_MoveVertical) == 0x000004, "Wrong alignment on CharacterBase_MoveVertical");
static_assert(sizeof(CharacterBase_MoveVertical) == 0x000004, "Wrong size on CharacterBase_MoveVertical");
static_assert(offsetof(CharacterBase_MoveVertical, Value) == 0x000000, "Member 'CharacterBase_MoveVertical::Value' has a wrong offset!");

// Function man.CharacterBase.MoveVerticalJoystick
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_MoveVerticalJoystick final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_MoveVerticalJoystick) == 0x000004, "Wrong alignment on CharacterBase_MoveVerticalJoystick");
static_assert(sizeof(CharacterBase_MoveVerticalJoystick) == 0x000004, "Wrong size on CharacterBase_MoveVerticalJoystick");
static_assert(offsetof(CharacterBase_MoveVerticalJoystick, Value) == 0x000000, "Member 'CharacterBase_MoveVerticalJoystick::Value' has a wrong offset!");

// Function man.CharacterBase.OnBodyPartDissolved
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_OnBodyPartDissolved final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnBodyPartDissolved) == 0x000004, "Wrong alignment on CharacterBase_OnBodyPartDissolved");
static_assert(sizeof(CharacterBase_OnBodyPartDissolved) == 0x000008, "Wrong size on CharacterBase_OnBodyPartDissolved");
static_assert(offsetof(CharacterBase_OnBodyPartDissolved, MaterialSlotName) == 0x000000, "Member 'CharacterBase_OnBodyPartDissolved::MaterialSlotName' has a wrong offset!");

// Function man.CharacterBase.OnHitCameraShake
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_OnHitCameraShake final
{
public:
	TSubclassOf<class UGameCameraShake>           CameraShake;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnHitCameraShake) == 0x000008, "Wrong alignment on CharacterBase_OnHitCameraShake");
static_assert(sizeof(CharacterBase_OnHitCameraShake) == 0x000008, "Wrong size on CharacterBase_OnHitCameraShake");
static_assert(offsetof(CharacterBase_OnHitCameraShake, CameraShake) == 0x000000, "Member 'CharacterBase_OnHitCameraShake::CameraShake' has a wrong offset!");

// Function man.CharacterBase.OnLevelSequence
// 0x0050 (0x0050 - 0x0000)
struct CharacterBase_OnLevelSequence final
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendInDuration;                                   // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_OnLevelSequence) == 0x000010, "Wrong alignment on CharacterBase_OnLevelSequence");
static_assert(sizeof(CharacterBase_OnLevelSequence) == 0x000050, "Wrong size on CharacterBase_OnLevelSequence");
static_assert(offsetof(CharacterBase_OnLevelSequence, LevelSequence) == 0x000000, "Member 'CharacterBase_OnLevelSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnLevelSequence, WorldTransform) == 0x000010, "Member 'CharacterBase_OnLevelSequence::WorldTransform' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnLevelSequence, BlendInDuration) == 0x000040, "Member 'CharacterBase_OnLevelSequence::BlendInDuration' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnLevelSequence, BlendOutDuration) == 0x000044, "Member 'CharacterBase_OnLevelSequence::BlendOutDuration' has a wrong offset!");

// Function man.CharacterBase.OnPlayLevelSequence
// 0x0030 (0x0030 - 0x0000)
struct CharacterBase_OnPlayLevelSequence final
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FMovieSceneObjectBindingID>     Bindings;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         BlendInDuration;                                   // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnPlayLevelSequence) == 0x000008, "Wrong alignment on CharacterBase_OnPlayLevelSequence");
static_assert(sizeof(CharacterBase_OnPlayLevelSequence) == 0x000030, "Wrong size on CharacterBase_OnPlayLevelSequence");
static_assert(offsetof(CharacterBase_OnPlayLevelSequence, LevelSequence) == 0x000000, "Member 'CharacterBase_OnPlayLevelSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnPlayLevelSequence, Actors) == 0x000008, "Member 'CharacterBase_OnPlayLevelSequence::Actors' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnPlayLevelSequence, Bindings) == 0x000018, "Member 'CharacterBase_OnPlayLevelSequence::Bindings' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnPlayLevelSequence, BlendInDuration) == 0x000028, "Member 'CharacterBase_OnPlayLevelSequence::BlendInDuration' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnPlayLevelSequence, BlendOutDuration) == 0x00002C, "Member 'CharacterBase_OnPlayLevelSequence::BlendOutDuration' has a wrong offset!");

// Function man.CharacterBase.OnVfxAnimEvent
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_OnVfxAnimEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_OnVfxAnimEvent) == 0x000008, "Wrong alignment on CharacterBase_OnVfxAnimEvent");
static_assert(sizeof(CharacterBase_OnVfxAnimEvent) == 0x000010, "Wrong size on CharacterBase_OnVfxAnimEvent");
static_assert(offsetof(CharacterBase_OnVfxAnimEvent, AnimID) == 0x000000, "Member 'CharacterBase_OnVfxAnimEvent::AnimID' has a wrong offset!");
static_assert(offsetof(CharacterBase_OnVfxAnimEvent, AnimEventType) == 0x000008, "Member 'CharacterBase_OnVfxAnimEvent::AnimEventType' has a wrong offset!");

// Function man.CharacterBase.OnVfxAnimStarted
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_OnVfxAnimStarted final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnVfxAnimStarted) == 0x000008, "Wrong alignment on CharacterBase_OnVfxAnimStarted");
static_assert(sizeof(CharacterBase_OnVfxAnimStarted) == 0x000008, "Wrong size on CharacterBase_OnVfxAnimStarted");
static_assert(offsetof(CharacterBase_OnVfxAnimStarted, AnimID) == 0x000000, "Member 'CharacterBase_OnVfxAnimStarted::AnimID' has a wrong offset!");

// Function man.CharacterBase.OnVfxAnimStopped
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_OnVfxAnimStopped final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnVfxAnimStopped) == 0x000008, "Wrong alignment on CharacterBase_OnVfxAnimStopped");
static_assert(sizeof(CharacterBase_OnVfxAnimStopped) == 0x000008, "Wrong size on CharacterBase_OnVfxAnimStopped");
static_assert(offsetof(CharacterBase_OnVfxAnimStopped, AnimID) == 0x000000, "Member 'CharacterBase_OnVfxAnimStopped::AnimID' has a wrong offset!");

// Function man.CharacterBase.OnVfxEvent
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_OnVfxEvent final
{
public:
	class FName                                   VfxEventType;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_OnVfxEvent) == 0x000004, "Wrong alignment on CharacterBase_OnVfxEvent");
static_assert(sizeof(CharacterBase_OnVfxEvent) == 0x000008, "Wrong size on CharacterBase_OnVfxEvent");
static_assert(offsetof(CharacterBase_OnVfxEvent, VfxEventType) == 0x000000, "Member 'CharacterBase_OnVfxEvent::VfxEventType' has a wrong offset!");

// Function man.CharacterBase.SetConversationLookTarget
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetConversationLookTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetConversationLookTarget) == 0x000008, "Wrong alignment on CharacterBase_SetConversationLookTarget");
static_assert(sizeof(CharacterBase_SetConversationLookTarget) == 0x000008, "Wrong size on CharacterBase_SetConversationLookTarget");
static_assert(offsetof(CharacterBase_SetConversationLookTarget, TargetActor) == 0x000000, "Member 'CharacterBase_SetConversationLookTarget::TargetActor' has a wrong offset!");

// Function man.CharacterBase.SetCustomFace
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetCustomFace final
{
public:
	class UCustomCharacterSlot*                   Face;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetCustomFace) == 0x000008, "Wrong alignment on CharacterBase_SetCustomFace");
static_assert(sizeof(CharacterBase_SetCustomFace) == 0x000008, "Wrong size on CharacterBase_SetCustomFace");
static_assert(offsetof(CharacterBase_SetCustomFace, Face) == 0x000000, "Member 'CharacterBase_SetCustomFace::Face' has a wrong offset!");

// Function man.CharacterBase.SetCustomHairColor
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetCustomHairColor final
{
public:
	class UCustomCharacterHairColor*              HairColor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetCustomHairColor) == 0x000008, "Wrong alignment on CharacterBase_SetCustomHairColor");
static_assert(sizeof(CharacterBase_SetCustomHairColor) == 0x000008, "Wrong size on CharacterBase_SetCustomHairColor");
static_assert(offsetof(CharacterBase_SetCustomHairColor, HairColor) == 0x000000, "Member 'CharacterBase_SetCustomHairColor::HairColor' has a wrong offset!");

// Function man.CharacterBase.SetCustomHairStyle
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetCustomHairStyle final
{
public:
	class UCustomCharacterSlot*                   HairStyle;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetCustomHairStyle) == 0x000008, "Wrong alignment on CharacterBase_SetCustomHairStyle");
static_assert(sizeof(CharacterBase_SetCustomHairStyle) == 0x000008, "Wrong size on CharacterBase_SetCustomHairStyle");
static_assert(offsetof(CharacterBase_SetCustomHairStyle, HairStyle) == 0x000000, "Member 'CharacterBase_SetCustomHairStyle::HairStyle' has a wrong offset!");

// Function man.CharacterBase.SetCustomSkinColor
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetCustomSkinColor final
{
public:
	class UCustomCharacterSkinColor*              SkinColor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetCustomSkinColor) == 0x000008, "Wrong alignment on CharacterBase_SetCustomSkinColor");
static_assert(sizeof(CharacterBase_SetCustomSkinColor) == 0x000008, "Wrong size on CharacterBase_SetCustomSkinColor");
static_assert(offsetof(CharacterBase_SetCustomSkinColor, SkinColor) == 0x000000, "Member 'CharacterBase_SetCustomSkinColor::SkinColor' has a wrong offset!");

// Function man.CharacterBase.SetCustomTattoo
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetCustomTattoo final
{
public:
	class UCustomCharacterTattoo*                 Tattoo;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetCustomTattoo) == 0x000008, "Wrong alignment on CharacterBase_SetCustomTattoo");
static_assert(sizeof(CharacterBase_SetCustomTattoo) == 0x000008, "Wrong size on CharacterBase_SetCustomTattoo");
static_assert(offsetof(CharacterBase_SetCustomTattoo, Tattoo) == 0x000000, "Member 'CharacterBase_SetCustomTattoo::Tattoo' has a wrong offset!");

// Function man.CharacterBase.SetLevelSequenceCombatMode
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_SetLevelSequenceCombatMode final
{
public:
	bool                                          bCombatMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetLevelSequenceCombatMode) == 0x000001, "Wrong alignment on CharacterBase_SetLevelSequenceCombatMode");
static_assert(sizeof(CharacterBase_SetLevelSequenceCombatMode) == 0x000001, "Wrong size on CharacterBase_SetLevelSequenceCombatMode");
static_assert(offsetof(CharacterBase_SetLevelSequenceCombatMode, bCombatMode) == 0x000000, "Member 'CharacterBase_SetLevelSequenceCombatMode::bCombatMode' has a wrong offset!");

// Function man.CharacterBase.SetLevelSequenceConversationAnimID
// 0x0008 (0x0008 - 0x0000)
struct CharacterBase_SetLevelSequenceConversationAnimID final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong alignment on CharacterBase_SetLevelSequenceConversationAnimID");
static_assert(sizeof(CharacterBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong size on CharacterBase_SetLevelSequenceConversationAnimID");
static_assert(offsetof(CharacterBase_SetLevelSequenceConversationAnimID, AnimID) == 0x000000, "Member 'CharacterBase_SetLevelSequenceConversationAnimID::AnimID' has a wrong offset!");

// Function man.CharacterBase.SetLevelSequenceFacing
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_SetLevelSequenceFacing final
{
public:
	float                                         CharacterFacing;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetLevelSequenceFacing) == 0x000004, "Wrong alignment on CharacterBase_SetLevelSequenceFacing");
static_assert(sizeof(CharacterBase_SetLevelSequenceFacing) == 0x000004, "Wrong size on CharacterBase_SetLevelSequenceFacing");
static_assert(offsetof(CharacterBase_SetLevelSequenceFacing, CharacterFacing) == 0x000000, "Member 'CharacterBase_SetLevelSequenceFacing::CharacterFacing' has a wrong offset!");

// Function man.CharacterBase.SetLevelSequenceMirrored
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_SetLevelSequenceMirrored final
{
public:
	bool                                          bMirrored;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetLevelSequenceMirrored) == 0x000001, "Wrong alignment on CharacterBase_SetLevelSequenceMirrored");
static_assert(sizeof(CharacterBase_SetLevelSequenceMirrored) == 0x000001, "Wrong size on CharacterBase_SetLevelSequenceMirrored");
static_assert(offsetof(CharacterBase_SetLevelSequenceMirrored, bMirrored) == 0x000000, "Member 'CharacterBase_SetLevelSequenceMirrored::bMirrored' has a wrong offset!");

// Function man.CharacterBase.SetLevelSequenceMirrorRate
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_SetLevelSequenceMirrorRate final
{
public:
	float                                         CharacterMirrorRate;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetLevelSequenceMirrorRate) == 0x000004, "Wrong alignment on CharacterBase_SetLevelSequenceMirrorRate");
static_assert(sizeof(CharacterBase_SetLevelSequenceMirrorRate) == 0x000004, "Wrong size on CharacterBase_SetLevelSequenceMirrorRate");
static_assert(offsetof(CharacterBase_SetLevelSequenceMirrorRate, CharacterMirrorRate) == 0x000000, "Member 'CharacterBase_SetLevelSequenceMirrorRate::CharacterMirrorRate' has a wrong offset!");

// Function man.CharacterBase.SetVisualSlotsLocked
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_SetVisualSlotsLocked final
{
public:
	bool                                          bLock;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_SetVisualSlotsLocked) == 0x000001, "Wrong alignment on CharacterBase_SetVisualSlotsLocked");
static_assert(sizeof(CharacterBase_SetVisualSlotsLocked) == 0x000001, "Wrong size on CharacterBase_SetVisualSlotsLocked");
static_assert(offsetof(CharacterBase_SetVisualSlotsLocked, bLock) == 0x000000, "Member 'CharacterBase_SetVisualSlotsLocked::bLock' has a wrong offset!");

// Function man.CharacterBase.SetVisualSlotVisible
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_SetVisualSlotVisible final
{
public:
	class UCharacterVisualSlotInfo*               VisualSlots;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_SetVisualSlotVisible) == 0x000008, "Wrong alignment on CharacterBase_SetVisualSlotVisible");
static_assert(sizeof(CharacterBase_SetVisualSlotVisible) == 0x000010, "Wrong size on CharacterBase_SetVisualSlotVisible");
static_assert(offsetof(CharacterBase_SetVisualSlotVisible, VisualSlots) == 0x000000, "Member 'CharacterBase_SetVisualSlotVisible::VisualSlots' has a wrong offset!");
static_assert(offsetof(CharacterBase_SetVisualSlotVisible, bVisible) == 0x000008, "Member 'CharacterBase_SetVisualSlotVisible::bVisible' has a wrong offset!");

// Function man.CharacterBase.StartRiseRagdoll
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_StartRiseRagdoll final
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_StartRiseRagdoll) == 0x000008, "Wrong alignment on CharacterBase_StartRiseRagdoll");
static_assert(sizeof(CharacterBase_StartRiseRagdoll) == 0x000010, "Wrong size on CharacterBase_StartRiseRagdoll");
static_assert(offsetof(CharacterBase_StartRiseRagdoll, BoneNames) == 0x000000, "Member 'CharacterBase_StartRiseRagdoll::BoneNames' has a wrong offset!");

// Function man.CharacterBase.StopRiseRagdoll
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_StopRiseRagdoll final
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_StopRiseRagdoll) == 0x000008, "Wrong alignment on CharacterBase_StopRiseRagdoll");
static_assert(sizeof(CharacterBase_StopRiseRagdoll) == 0x000010, "Wrong size on CharacterBase_StopRiseRagdoll");
static_assert(offsetof(CharacterBase_StopRiseRagdoll, BoneNames) == 0x000000, "Member 'CharacterBase_StopRiseRagdoll::BoneNames' has a wrong offset!");

// Function man.CharacterBase.ToggleAnim
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_ToggleAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_ToggleAnim) == 0x000008, "Wrong alignment on CharacterBase_ToggleAnim");
static_assert(sizeof(CharacterBase_ToggleAnim) == 0x000010, "Wrong size on CharacterBase_ToggleAnim");
static_assert(offsetof(CharacterBase_ToggleAnim, AnimID) == 0x000000, "Member 'CharacterBase_ToggleAnim::AnimID' has a wrong offset!");
static_assert(offsetof(CharacterBase_ToggleAnim, bStart) == 0x000008, "Member 'CharacterBase_ToggleAnim::bStart' has a wrong offset!");
static_assert(offsetof(CharacterBase_ToggleAnim, ReturnValue) == 0x000009, "Member 'CharacterBase_ToggleAnim::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.ToggleLevelSequence
// 0x0018 (0x0018 - 0x0000)
struct CharacterBase_ToggleLevelSequence final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterBase_ToggleLevelSequence) == 0x000008, "Wrong alignment on CharacterBase_ToggleLevelSequence");
static_assert(sizeof(CharacterBase_ToggleLevelSequence) == 0x000018, "Wrong size on CharacterBase_ToggleLevelSequence");
static_assert(offsetof(CharacterBase_ToggleLevelSequence, Actors) == 0x000000, "Member 'CharacterBase_ToggleLevelSequence::Actors' has a wrong offset!");
static_assert(offsetof(CharacterBase_ToggleLevelSequence, bStart) == 0x000010, "Member 'CharacterBase_ToggleLevelSequence::bStart' has a wrong offset!");

// Function man.CharacterBase.UseCharacterCreationBody
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_UseCharacterCreationBody final
{
public:
	bool                                          bCharacterCreationBody;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_UseCharacterCreationBody) == 0x000001, "Wrong alignment on CharacterBase_UseCharacterCreationBody");
static_assert(sizeof(CharacterBase_UseCharacterCreationBody) == 0x000001, "Wrong size on CharacterBase_UseCharacterCreationBody");
static_assert(offsetof(CharacterBase_UseCharacterCreationBody, bCharacterCreationBody) == 0x000000, "Member 'CharacterBase_UseCharacterCreationBody::bCharacterCreationBody' has a wrong offset!");

// Function man.CharacterBase.UseFemaleSlots
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_UseFemaleSlots final
{
public:
	bool                                          bFemaleSlots;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_UseFemaleSlots) == 0x000001, "Wrong alignment on CharacterBase_UseFemaleSlots");
static_assert(sizeof(CharacterBase_UseFemaleSlots) == 0x000001, "Wrong size on CharacterBase_UseFemaleSlots");
static_assert(offsetof(CharacterBase_UseFemaleSlots, bFemaleSlots) == 0x000000, "Member 'CharacterBase_UseFemaleSlots::bFemaleSlots' has a wrong offset!");

// Function man.CharacterBase.BPIsAlive
// 0x0001 (0x0001 - 0x0000)
struct CharacterBase_BPIsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_BPIsAlive) == 0x000001, "Wrong alignment on CharacterBase_BPIsAlive");
static_assert(sizeof(CharacterBase_BPIsAlive) == 0x000001, "Wrong size on CharacterBase_BPIsAlive");
static_assert(offsetof(CharacterBase_BPIsAlive, ReturnValue) == 0x000000, "Member 'CharacterBase_BPIsAlive::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetLedgeCatchVelocity
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_GetLedgeCatchVelocity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetLedgeCatchVelocity) == 0x000004, "Wrong alignment on CharacterBase_GetLedgeCatchVelocity");
static_assert(sizeof(CharacterBase_GetLedgeCatchVelocity) == 0x000004, "Wrong size on CharacterBase_GetLedgeCatchVelocity");
static_assert(offsetof(CharacterBase_GetLedgeCatchVelocity, ReturnValue) == 0x000000, "Member 'CharacterBase_GetLedgeCatchVelocity::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetNumSlotMeshComponents
// 0x0004 (0x0004 - 0x0000)
struct CharacterBase_GetNumSlotMeshComponents final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetNumSlotMeshComponents) == 0x000004, "Wrong alignment on CharacterBase_GetNumSlotMeshComponents");
static_assert(sizeof(CharacterBase_GetNumSlotMeshComponents) == 0x000004, "Wrong size on CharacterBase_GetNumSlotMeshComponents");
static_assert(offsetof(CharacterBase_GetNumSlotMeshComponents, ReturnValue) == 0x000000, "Member 'CharacterBase_GetNumSlotMeshComponents::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetSlotMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_GetSlotMeshComponent final
{
public:
	int32                                         SlotMeshComponentIndex;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetSlotMeshComponent) == 0x000008, "Wrong alignment on CharacterBase_GetSlotMeshComponent");
static_assert(sizeof(CharacterBase_GetSlotMeshComponent) == 0x000010, "Wrong size on CharacterBase_GetSlotMeshComponent");
static_assert(offsetof(CharacterBase_GetSlotMeshComponent, SlotMeshComponentIndex) == 0x000000, "Member 'CharacterBase_GetSlotMeshComponent::SlotMeshComponentIndex' has a wrong offset!");
static_assert(offsetof(CharacterBase_GetSlotMeshComponent, ReturnValue) == 0x000008, "Member 'CharacterBase_GetSlotMeshComponent::ReturnValue' has a wrong offset!");

// Function man.CharacterBase.GetSlotMeshComponents
// 0x0010 (0x0010 - 0x0000)
struct CharacterBase_GetSlotMeshComponents final
{
public:
	TArray<class USkeletalMeshComponent*>         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterBase_GetSlotMeshComponents) == 0x000008, "Wrong alignment on CharacterBase_GetSlotMeshComponents");
static_assert(sizeof(CharacterBase_GetSlotMeshComponents) == 0x000010, "Wrong size on CharacterBase_GetSlotMeshComponents");
static_assert(offsetof(CharacterBase_GetSlotMeshComponents, ReturnValue) == 0x000000, "Member 'CharacterBase_GetSlotMeshComponents::ReturnValue' has a wrong offset!");

// Function man.OnKillCaused_AbilityComponent.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct OnKillCaused_AbilityComponent_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnKillCaused_AbilityComponent_OnPostDamageCaused) == 0x000008, "Wrong alignment on OnKillCaused_AbilityComponent_OnPostDamageCaused");
static_assert(sizeof(OnKillCaused_AbilityComponent_OnPostDamageCaused) == 0x0002D8, "Wrong size on OnKillCaused_AbilityComponent_OnPostDamageCaused");
static_assert(offsetof(OnKillCaused_AbilityComponent_OnPostDamageCaused, Param) == 0x000000, "Member 'OnKillCaused_AbilityComponent_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.OnDamageCaused_AbilityComponent.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct OnDamageCaused_AbilityComponent_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnDamageCaused_AbilityComponent_OnPreDamageCaused) == 0x000008, "Wrong alignment on OnDamageCaused_AbilityComponent_OnPreDamageCaused");
static_assert(sizeof(OnDamageCaused_AbilityComponent_OnPreDamageCaused) == 0x0002D8, "Wrong size on OnDamageCaused_AbilityComponent_OnPreDamageCaused");
static_assert(offsetof(OnDamageCaused_AbilityComponent_OnPreDamageCaused, Param) == 0x000000, "Member 'OnDamageCaused_AbilityComponent_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.LootTableListDropAmount.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct LootTableListDropAmount_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootTableListDropAmount_GetEditorName) == 0x000008, "Wrong alignment on LootTableListDropAmount_GetEditorName");
static_assert(sizeof(LootTableListDropAmount_GetEditorName) == 0x000010, "Wrong size on LootTableListDropAmount_GetEditorName");
static_assert(offsetof(LootTableListDropAmount_GetEditorName, ReturnValue) == 0x000000, "Member 'LootTableListDropAmount_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.GrabPoint.BPOnGrabbed
// 0x0008 (0x0008 - 0x0000)
struct GrabPoint_BPOnGrabbed final
{
public:
	class AHeroBase*                              Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrabPoint_BPOnGrabbed) == 0x000008, "Wrong alignment on GrabPoint_BPOnGrabbed");
static_assert(sizeof(GrabPoint_BPOnGrabbed) == 0x000008, "Wrong size on GrabPoint_BPOnGrabbed");
static_assert(offsetof(GrabPoint_BPOnGrabbed, Hero) == 0x000000, "Member 'GrabPoint_BPOnGrabbed::Hero' has a wrong offset!");

// Function man.TriggerableAbility.BPGetAimAngle
// 0x0004 (0x0004 - 0x0000)
struct TriggerableAbility_BPGetAimAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TriggerableAbility_BPGetAimAngle) == 0x000004, "Wrong alignment on TriggerableAbility_BPGetAimAngle");
static_assert(sizeof(TriggerableAbility_BPGetAimAngle) == 0x000004, "Wrong size on TriggerableAbility_BPGetAimAngle");
static_assert(offsetof(TriggerableAbility_BPGetAimAngle, ReturnValue) == 0x000000, "Member 'TriggerableAbility_BPGetAimAngle::ReturnValue' has a wrong offset!");

// Function man.DivineHammersAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DivineHammersAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineHammersAbility_PostDamageDealt) == 0x000008, "Wrong alignment on DivineHammersAbility_PostDamageDealt");
static_assert(sizeof(DivineHammersAbility_PostDamageDealt) == 0x0002D8, "Wrong size on DivineHammersAbility_PostDamageDealt");
static_assert(offsetof(DivineHammersAbility_PostDamageDealt, Param) == 0x000000, "Member 'DivineHammersAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.PeriodicBulletTrapManager.ProjectileShot
// 0x0008 (0x0008 - 0x0000)
struct PeriodicBulletTrapManager_ProjectileShot final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PeriodicBulletTrapManager_ProjectileShot) == 0x000008, "Wrong alignment on PeriodicBulletTrapManager_ProjectileShot");
static_assert(sizeof(PeriodicBulletTrapManager_ProjectileShot) == 0x000008, "Wrong size on PeriodicBulletTrapManager_ProjectileShot");
static_assert(offsetof(PeriodicBulletTrapManager_ProjectileShot, Projectile) == 0x000000, "Member 'PeriodicBulletTrapManager_ProjectileShot::Projectile' has a wrong offset!");

// Function man.ShiftingPlatform.BPOnWarning
// 0x000C (0x000C - 0x0000)
struct ShiftingPlatform_BPOnWarning final
{
public:
	float                                         TimeRemain;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullWarningTime;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDownState;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ShiftingPlatform_BPOnWarning) == 0x000004, "Wrong alignment on ShiftingPlatform_BPOnWarning");
static_assert(sizeof(ShiftingPlatform_BPOnWarning) == 0x00000C, "Wrong size on ShiftingPlatform_BPOnWarning");
static_assert(offsetof(ShiftingPlatform_BPOnWarning, TimeRemain) == 0x000000, "Member 'ShiftingPlatform_BPOnWarning::TimeRemain' has a wrong offset!");
static_assert(offsetof(ShiftingPlatform_BPOnWarning, FullWarningTime) == 0x000004, "Member 'ShiftingPlatform_BPOnWarning::FullWarningTime' has a wrong offset!");
static_assert(offsetof(ShiftingPlatform_BPOnWarning, bUpState) == 0x000008, "Member 'ShiftingPlatform_BPOnWarning::bUpState' has a wrong offset!");
static_assert(offsetof(ShiftingPlatform_BPOnWarning, bDownState) == 0x000009, "Member 'ShiftingPlatform_BPOnWarning::bDownState' has a wrong offset!");

// Function man.ModifyAttributeWithAttribute.OnAttributeChanged
// 0x0010 (0x0010 - 0x0000)
struct ModifyAttributeWithAttribute_OnAttributeChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyAttributeWithAttribute_OnAttributeChanged) == 0x000008, "Wrong alignment on ModifyAttributeWithAttribute_OnAttributeChanged");
static_assert(sizeof(ModifyAttributeWithAttribute_OnAttributeChanged) == 0x000010, "Wrong size on ModifyAttributeWithAttribute_OnAttributeChanged");
static_assert(offsetof(ModifyAttributeWithAttribute_OnAttributeChanged, attribute) == 0x000000, "Member 'ModifyAttributeWithAttribute_OnAttributeChanged::attribute' has a wrong offset!");
static_assert(offsetof(ModifyAttributeWithAttribute_OnAttributeChanged, preValue) == 0x000008, "Member 'ModifyAttributeWithAttribute_OnAttributeChanged::preValue' has a wrong offset!");

// Function man.ModifyAttributeAbilityComponent.OnAttributeChanged
// 0x0010 (0x0010 - 0x0000)
struct ModifyAttributeAbilityComponent_OnAttributeChanged final
{
public:
	EAttribute                                    attribute_0;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyAttributeAbilityComponent_OnAttributeChanged) == 0x000008, "Wrong alignment on ModifyAttributeAbilityComponent_OnAttributeChanged");
static_assert(sizeof(ModifyAttributeAbilityComponent_OnAttributeChanged) == 0x000010, "Wrong size on ModifyAttributeAbilityComponent_OnAttributeChanged");
static_assert(offsetof(ModifyAttributeAbilityComponent_OnAttributeChanged, attribute_0) == 0x000000, "Member 'ModifyAttributeAbilityComponent_OnAttributeChanged::attribute_0' has a wrong offset!");
static_assert(offsetof(ModifyAttributeAbilityComponent_OnAttributeChanged, preValue) == 0x000008, "Member 'ModifyAttributeAbilityComponent_OnAttributeChanged::preValue' has a wrong offset!");

// Function man.ModifyAttributeAbilityComponent.OnStackNumChanged
// 0x0010 (0x0010 - 0x0000)
struct ModifyAttributeAbilityComponent_OnStackNumChanged final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         preValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ModifyAttributeAbilityComponent_OnStackNumChanged) == 0x000008, "Wrong alignment on ModifyAttributeAbilityComponent_OnStackNumChanged");
static_assert(sizeof(ModifyAttributeAbilityComponent_OnStackNumChanged) == 0x000010, "Wrong size on ModifyAttributeAbilityComponent_OnStackNumChanged");
static_assert(offsetof(ModifyAttributeAbilityComponent_OnStackNumChanged, InAbility) == 0x000000, "Member 'ModifyAttributeAbilityComponent_OnStackNumChanged::InAbility' has a wrong offset!");
static_assert(offsetof(ModifyAttributeAbilityComponent_OnStackNumChanged, preValue) == 0x000008, "Member 'ModifyAttributeAbilityComponent_OnStackNumChanged::preValue' has a wrong offset!");

// Function man.ModifyAttributeAbilityComponent.SetModifierAdd
// 0x0004 (0x0004 - 0x0000)
struct ModifyAttributeAbilityComponent_SetModifierAdd final
{
public:
	float                                         NewMod;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyAttributeAbilityComponent_SetModifierAdd) == 0x000004, "Wrong alignment on ModifyAttributeAbilityComponent_SetModifierAdd");
static_assert(sizeof(ModifyAttributeAbilityComponent_SetModifierAdd) == 0x000004, "Wrong size on ModifyAttributeAbilityComponent_SetModifierAdd");
static_assert(offsetof(ModifyAttributeAbilityComponent_SetModifierAdd, NewMod) == 0x000000, "Member 'ModifyAttributeAbilityComponent_SetModifierAdd::NewMod' has a wrong offset!");

// Function man.ModifyAttributeAbilityComponent.SetModifierMult
// 0x0004 (0x0004 - 0x0000)
struct ModifyAttributeAbilityComponent_SetModifierMult final
{
public:
	float                                         NewMod;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyAttributeAbilityComponent_SetModifierMult) == 0x000004, "Wrong alignment on ModifyAttributeAbilityComponent_SetModifierMult");
static_assert(sizeof(ModifyAttributeAbilityComponent_SetModifierMult) == 0x000004, "Wrong size on ModifyAttributeAbilityComponent_SetModifierMult");
static_assert(offsetof(ModifyAttributeAbilityComponent_SetModifierMult, NewMod) == 0x000000, "Member 'ModifyAttributeAbilityComponent_SetModifierMult::NewMod' has a wrong offset!");

// Function man.ToggleBasicAttackHitSequence.OnItemsChanged
// 0x0010 (0x0010 - 0x0000)
struct ToggleBasicAttackHitSequence_OnItemsChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToggleBasicAttackHitSequence_OnItemsChanged) == 0x000008, "Wrong alignment on ToggleBasicAttackHitSequence_OnItemsChanged");
static_assert(sizeof(ToggleBasicAttackHitSequence_OnItemsChanged) == 0x000010, "Wrong size on ToggleBasicAttackHitSequence_OnItemsChanged");
static_assert(offsetof(ToggleBasicAttackHitSequence_OnItemsChanged, SourceSlot) == 0x000000, "Member 'ToggleBasicAttackHitSequence_OnItemsChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(ToggleBasicAttackHitSequence_OnItemsChanged, DestinationSlot) == 0x000008, "Member 'ToggleBasicAttackHitSequence_OnItemsChanged::DestinationSlot' has a wrong offset!");

// Function man.ToggleBasicAttackHitSequence.OnPostAddAbility
// 0x0008 (0x0008 - 0x0000)
struct ToggleBasicAttackHitSequence_OnPostAddAbility final
{
public:
	class UAbilityBase*                           AddedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToggleBasicAttackHitSequence_OnPostAddAbility) == 0x000008, "Wrong alignment on ToggleBasicAttackHitSequence_OnPostAddAbility");
static_assert(sizeof(ToggleBasicAttackHitSequence_OnPostAddAbility) == 0x000008, "Wrong size on ToggleBasicAttackHitSequence_OnPostAddAbility");
static_assert(offsetof(ToggleBasicAttackHitSequence_OnPostAddAbility, AddedAbility) == 0x000000, "Member 'ToggleBasicAttackHitSequence_OnPostAddAbility::AddedAbility' has a wrong offset!");

// Function man.ToggleBasicAttackHitSequence.OnPostRemoveAbility
// 0x0008 (0x0008 - 0x0000)
struct ToggleBasicAttackHitSequence_OnPostRemoveAbility final
{
public:
	class UAbilityBase*                           RemovedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToggleBasicAttackHitSequence_OnPostRemoveAbility) == 0x000008, "Wrong alignment on ToggleBasicAttackHitSequence_OnPostRemoveAbility");
static_assert(sizeof(ToggleBasicAttackHitSequence_OnPostRemoveAbility) == 0x000008, "Wrong size on ToggleBasicAttackHitSequence_OnPostRemoveAbility");
static_assert(offsetof(ToggleBasicAttackHitSequence_OnPostRemoveAbility, RemovedAbility) == 0x000000, "Member 'ToggleBasicAttackHitSequence_OnPostRemoveAbility::RemovedAbility' has a wrong offset!");

// Function man.MarionetteDollsAI.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct MarionetteDollsAI_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarionetteDollsAI_OnPostDamageCaused) == 0x000008, "Wrong alignment on MarionetteDollsAI_OnPostDamageCaused");
static_assert(sizeof(MarionetteDollsAI_OnPostDamageCaused) == 0x0002D8, "Wrong size on MarionetteDollsAI_OnPostDamageCaused");
static_assert(offsetof(MarionetteDollsAI_OnPostDamageCaused, DamageParams) == 0x000000, "Member 'MarionetteDollsAI_OnPostDamageCaused::DamageParams' has a wrong offset!");

// Function man.MarionetteDollsAI.OnPostDamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct MarionetteDollsAI_OnPostDamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarionetteDollsAI_OnPostDamageTaken) == 0x000008, "Wrong alignment on MarionetteDollsAI_OnPostDamageTaken");
static_assert(sizeof(MarionetteDollsAI_OnPostDamageTaken) == 0x0002D8, "Wrong size on MarionetteDollsAI_OnPostDamageTaken");
static_assert(offsetof(MarionetteDollsAI_OnPostDamageTaken, DamageParams) == 0x000000, "Member 'MarionetteDollsAI_OnPostDamageTaken::DamageParams' has a wrong offset!");

// Function man.MarionetteDollsAI.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct MarionetteDollsAI_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarionetteDollsAI_OnPreDamagedPriority) == 0x000008, "Wrong alignment on MarionetteDollsAI_OnPreDamagedPriority");
static_assert(sizeof(MarionetteDollsAI_OnPreDamagedPriority) == 0x0002D8, "Wrong size on MarionetteDollsAI_OnPreDamagedPriority");
static_assert(offsetof(MarionetteDollsAI_OnPreDamagedPriority, Param) == 0x000000, "Member 'MarionetteDollsAI_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.ConversationStarter.StartConversationBP
// 0x000C (0x000C - 0x0000)
struct ConversationStarter_StartConversationBP final
{
public:
	bool                                          bKeepCutsceneMode;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConversationName;                                  // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationStarter_StartConversationBP) == 0x000004, "Wrong alignment on ConversationStarter_StartConversationBP");
static_assert(sizeof(ConversationStarter_StartConversationBP) == 0x00000C, "Wrong size on ConversationStarter_StartConversationBP");
static_assert(offsetof(ConversationStarter_StartConversationBP, bKeepCutsceneMode) == 0x000000, "Member 'ConversationStarter_StartConversationBP::bKeepCutsceneMode' has a wrong offset!");
static_assert(offsetof(ConversationStarter_StartConversationBP, ConversationName) == 0x000004, "Member 'ConversationStarter_StartConversationBP::ConversationName' has a wrong offset!");

// Function man.ManGameInstance.GetAchievements
// 0x0008 (0x0008 - 0x0000)
struct ManGameInstance_GetAchievements final
{
public:
	class UManAchievements*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_GetAchievements) == 0x000008, "Wrong alignment on ManGameInstance_GetAchievements");
static_assert(sizeof(ManGameInstance_GetAchievements) == 0x000008, "Wrong size on ManGameInstance_GetAchievements");
static_assert(offsetof(ManGameInstance_GetAchievements, ReturnValue) == 0x000000, "Member 'ManGameInstance_GetAchievements::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.GetFadeManager
// 0x0008 (0x0008 - 0x0000)
struct ManGameInstance_GetFadeManager final
{
public:
	class UFadeManager*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_GetFadeManager) == 0x000008, "Wrong alignment on ManGameInstance_GetFadeManager");
static_assert(sizeof(ManGameInstance_GetFadeManager) == 0x000008, "Wrong size on ManGameInstance_GetFadeManager");
static_assert(offsetof(ManGameInstance_GetFadeManager, ReturnValue) == 0x000000, "Member 'ManGameInstance_GetFadeManager::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.OnExitToDesktopSaveInProgress
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_OnExitToDesktopSaveInProgress final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_OnExitToDesktopSaveInProgress) == 0x000001, "Wrong alignment on ManGameInstance_OnExitToDesktopSaveInProgress");
static_assert(sizeof(ManGameInstance_OnExitToDesktopSaveInProgress) == 0x000001, "Wrong size on ManGameInstance_OnExitToDesktopSaveInProgress");
static_assert(offsetof(ManGameInstance_OnExitToDesktopSaveInProgress, bStart) == 0x000000, "Member 'ManGameInstance_OnExitToDesktopSaveInProgress::bStart' has a wrong offset!");

// Function man.ManGameInstance.OnExitToMainMenuSaveInProgress
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_OnExitToMainMenuSaveInProgress final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_OnExitToMainMenuSaveInProgress) == 0x000001, "Wrong alignment on ManGameInstance_OnExitToMainMenuSaveInProgress");
static_assert(sizeof(ManGameInstance_OnExitToMainMenuSaveInProgress) == 0x000001, "Wrong size on ManGameInstance_OnExitToMainMenuSaveInProgress");
static_assert(offsetof(ManGameInstance_OnExitToMainMenuSaveInProgress, bStart) == 0x000000, "Member 'ManGameInstance_OnExitToMainMenuSaveInProgress::bStart' has a wrong offset!");

// Function man.ManGameInstance.GetInputDisplay
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_GetInputDisplay final
{
public:
	EInputDisplay                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_GetInputDisplay) == 0x000001, "Wrong alignment on ManGameInstance_GetInputDisplay");
static_assert(sizeof(ManGameInstance_GetInputDisplay) == 0x000001, "Wrong size on ManGameInstance_GetInputDisplay");
static_assert(offsetof(ManGameInstance_GetInputDisplay, ReturnValue) == 0x000000, "Member 'ManGameInstance_GetInputDisplay::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.IsConsoleActive
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_IsConsoleActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_IsConsoleActive) == 0x000001, "Wrong alignment on ManGameInstance_IsConsoleActive");
static_assert(sizeof(ManGameInstance_IsConsoleActive) == 0x000001, "Wrong size on ManGameInstance_IsConsoleActive");
static_assert(offsetof(ManGameInstance_IsConsoleActive, ReturnValue) == 0x000000, "Member 'ManGameInstance_IsConsoleActive::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.IsFadeManagerActive
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_IsFadeManagerActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_IsFadeManagerActive) == 0x000001, "Wrong alignment on ManGameInstance_IsFadeManagerActive");
static_assert(sizeof(ManGameInstance_IsFadeManagerActive) == 0x000001, "Wrong size on ManGameInstance_IsFadeManagerActive");
static_assert(offsetof(ManGameInstance_IsFadeManagerActive, ReturnValue) == 0x000000, "Member 'ManGameInstance_IsFadeManagerActive::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.IsKeyboardInputDisplay
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_IsKeyboardInputDisplay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_IsKeyboardInputDisplay) == 0x000001, "Wrong alignment on ManGameInstance_IsKeyboardInputDisplay");
static_assert(sizeof(ManGameInstance_IsKeyboardInputDisplay) == 0x000001, "Wrong size on ManGameInstance_IsKeyboardInputDisplay");
static_assert(offsetof(ManGameInstance_IsKeyboardInputDisplay, ReturnValue) == 0x000000, "Member 'ManGameInstance_IsKeyboardInputDisplay::ReturnValue' has a wrong offset!");

// Function man.ManGameInstance.IsMouseInputDisplay
// 0x0001 (0x0001 - 0x0000)
struct ManGameInstance_IsMouseInputDisplay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameInstance_IsMouseInputDisplay) == 0x000001, "Wrong alignment on ManGameInstance_IsMouseInputDisplay");
static_assert(sizeof(ManGameInstance_IsMouseInputDisplay) == 0x000001, "Wrong size on ManGameInstance_IsMouseInputDisplay");
static_assert(offsetof(ManGameInstance_IsMouseInputDisplay, ReturnValue) == 0x000000, "Member 'ManGameInstance_IsMouseInputDisplay::ReturnValue' has a wrong offset!");

// Function man.BanditBruteBossAttackBomb.BPGetSmokeBombImpactLocation
// 0x000C (0x000C - 0x0000)
struct BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation) == 0x000004, "Wrong alignment on BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation");
static_assert(sizeof(BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation) == 0x00000C, "Wrong size on BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation");
static_assert(offsetof(BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation, ReturnValue) == 0x000000, "Member 'BanditBruteBossAttackBomb_BPGetSmokeBombImpactLocation::ReturnValue' has a wrong offset!");

// Function man.SkillTreeUserWidget.HideAttributeSelector
// 0x0003 (0x0003 - 0x0000)
struct SkillTreeUserWidget_HideAttributeSelector final
{
public:
	bool                                          bPlayAkEvent;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnim;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideByUnlockVFX;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_HideAttributeSelector) == 0x000001, "Wrong alignment on SkillTreeUserWidget_HideAttributeSelector");
static_assert(sizeof(SkillTreeUserWidget_HideAttributeSelector) == 0x000003, "Wrong size on SkillTreeUserWidget_HideAttributeSelector");
static_assert(offsetof(SkillTreeUserWidget_HideAttributeSelector, bPlayAkEvent) == 0x000000, "Member 'SkillTreeUserWidget_HideAttributeSelector::bPlayAkEvent' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_HideAttributeSelector, bPlayAnim) == 0x000001, "Member 'SkillTreeUserWidget_HideAttributeSelector::bPlayAnim' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_HideAttributeSelector, bHideByUnlockVFX) == 0x000002, "Member 'SkillTreeUserWidget_HideAttributeSelector::bHideByUnlockVFX' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnHideAttributeSelector
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeUserWidget_OnHideAttributeSelector final
{
public:
	bool                                          bPlayAnim;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_OnHideAttributeSelector) == 0x000001, "Wrong alignment on SkillTreeUserWidget_OnHideAttributeSelector");
static_assert(sizeof(SkillTreeUserWidget_OnHideAttributeSelector) == 0x000001, "Wrong size on SkillTreeUserWidget_OnHideAttributeSelector");
static_assert(offsetof(SkillTreeUserWidget_OnHideAttributeSelector, bPlayAnim) == 0x000000, "Member 'SkillTreeUserWidget_OnHideAttributeSelector::bPlayAnim' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct SkillTreeUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on SkillTreeUserWidget_OnPropertyChanged");
static_assert(sizeof(SkillTreeUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on SkillTreeUserWidget_OnPropertyChanged");
static_assert(offsetof(SkillTreeUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'SkillTreeUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'SkillTreeUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'SkillTreeUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'SkillTreeUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'SkillTreeUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnSetAttributeSelector
// 0x0020 (0x0020 - 0x0000)
struct SkillTreeUserWidget_OnSetAttributeSelector final
{
public:
	class FText                                   BonusText;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bPlayBonusUnlockedAnim;                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllUnlocked;                                      // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeUserWidget_OnSetAttributeSelector) == 0x000008, "Wrong alignment on SkillTreeUserWidget_OnSetAttributeSelector");
static_assert(sizeof(SkillTreeUserWidget_OnSetAttributeSelector) == 0x000020, "Wrong size on SkillTreeUserWidget_OnSetAttributeSelector");
static_assert(offsetof(SkillTreeUserWidget_OnSetAttributeSelector, BonusText) == 0x000000, "Member 'SkillTreeUserWidget_OnSetAttributeSelector::BonusText' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnSetAttributeSelector, bPlayBonusUnlockedAnim) == 0x000018, "Member 'SkillTreeUserWidget_OnSetAttributeSelector::bPlayBonusUnlockedAnim' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnSetAttributeSelector, bAllUnlocked) == 0x000019, "Member 'SkillTreeUserWidget_OnSetAttributeSelector::bAllUnlocked' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnSetCharacterClassName
// 0x0018 (0x0018 - 0x0000)
struct SkillTreeUserWidget_OnSetCharacterClassName final
{
public:
	class FText                                   CharacterClassName;                                // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_OnSetCharacterClassName) == 0x000008, "Wrong alignment on SkillTreeUserWidget_OnSetCharacterClassName");
static_assert(sizeof(SkillTreeUserWidget_OnSetCharacterClassName) == 0x000018, "Wrong size on SkillTreeUserWidget_OnSetCharacterClassName");
static_assert(offsetof(SkillTreeUserWidget_OnSetCharacterClassName, CharacterClassName) == 0x000000, "Member 'SkillTreeUserWidget_OnSetCharacterClassName::CharacterClassName' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnSetTooltipPosition
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeUserWidget_OnSetTooltipPosition final
{
public:
	ESkillTreeTooltipPosition                     TooltipPosition;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_OnSetTooltipPosition) == 0x000001, "Wrong alignment on SkillTreeUserWidget_OnSetTooltipPosition");
static_assert(sizeof(SkillTreeUserWidget_OnSetTooltipPosition) == 0x000001, "Wrong size on SkillTreeUserWidget_OnSetTooltipPosition");
static_assert(offsetof(SkillTreeUserWidget_OnSetTooltipPosition, TooltipPosition) == 0x000000, "Member 'SkillTreeUserWidget_OnSetTooltipPosition::TooltipPosition' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnShowAttributeSelector
// 0x0004 (0x0004 - 0x0000)
struct SkillTreeUserWidget_OnShowAttributeSelector final
{
public:
	int32                                         NodeNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_OnShowAttributeSelector) == 0x000004, "Wrong alignment on SkillTreeUserWidget_OnShowAttributeSelector");
static_assert(sizeof(SkillTreeUserWidget_OnShowAttributeSelector) == 0x000004, "Wrong size on SkillTreeUserWidget_OnShowAttributeSelector");
static_assert(offsetof(SkillTreeUserWidget_OnShowAttributeSelector, NodeNum) == 0x000000, "Member 'SkillTreeUserWidget_OnShowAttributeSelector::NodeNum' has a wrong offset!");

// Function man.SkillTreeUserWidget.OnShowPanel
// 0x0038 (0x0038 - 0x0000)
struct SkillTreeUserWidget_OnShowPanel final
{
public:
	float                                         InAnimDuration;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharacterClassName;                                // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class USkillTreeClassUserWidget*              InCurrentSkillTreeClass;                           // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkillTreeClassUserWidget*              InNextSkillTreeClass;                              // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkillTreeClassUserWidget*              InPrevSkillTreeClass;                              // 0x0030(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_OnShowPanel) == 0x000008, "Wrong alignment on SkillTreeUserWidget_OnShowPanel");
static_assert(sizeof(SkillTreeUserWidget_OnShowPanel) == 0x000038, "Wrong size on SkillTreeUserWidget_OnShowPanel");
static_assert(offsetof(SkillTreeUserWidget_OnShowPanel, InAnimDuration) == 0x000000, "Member 'SkillTreeUserWidget_OnShowPanel::InAnimDuration' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnShowPanel, CharacterClassName) == 0x000008, "Member 'SkillTreeUserWidget_OnShowPanel::CharacterClassName' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnShowPanel, InCurrentSkillTreeClass) == 0x000020, "Member 'SkillTreeUserWidget_OnShowPanel::InCurrentSkillTreeClass' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnShowPanel, InNextSkillTreeClass) == 0x000028, "Member 'SkillTreeUserWidget_OnShowPanel::InNextSkillTreeClass' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_OnShowPanel, InPrevSkillTreeClass) == 0x000030, "Member 'SkillTreeUserWidget_OnShowPanel::InPrevSkillTreeClass' has a wrong offset!");

// Function man.SkillTreeUserWidget.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct SkillTreeUserWidget_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeUserWidget_PropertyChanged) == 0x000004, "Wrong alignment on SkillTreeUserWidget_PropertyChanged");
static_assert(sizeof(SkillTreeUserWidget_PropertyChanged) == 0x000014, "Wrong size on SkillTreeUserWidget_PropertyChanged");
static_assert(offsetof(SkillTreeUserWidget_PropertyChanged, PropertyType) == 0x000000, "Member 'SkillTreeUserWidget_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_PropertyChanged, Value) == 0x000004, "Member 'SkillTreeUserWidget_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'SkillTreeUserWidget_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'SkillTreeUserWidget_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_PropertyChanged, bAnimate) == 0x000010, "Member 'SkillTreeUserWidget_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.SkillTreeUserWidget.ShowPanel
// 0x0008 (0x0008 - 0x0000)
struct SkillTreeUserWidget_ShowPanel final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterClass                               CharacterClass;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedFocusOnClassStart;                            // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeUserWidget_ShowPanel) == 0x000004, "Wrong alignment on SkillTreeUserWidget_ShowPanel");
static_assert(sizeof(SkillTreeUserWidget_ShowPanel) == 0x000008, "Wrong size on SkillTreeUserWidget_ShowPanel");
static_assert(offsetof(SkillTreeUserWidget_ShowPanel, AnimDuration) == 0x000000, "Member 'SkillTreeUserWidget_ShowPanel::AnimDuration' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_ShowPanel, CharacterClass) == 0x000004, "Member 'SkillTreeUserWidget_ShowPanel::CharacterClass' has a wrong offset!");
static_assert(offsetof(SkillTreeUserWidget_ShowPanel, bNeedFocusOnClassStart) == 0x000005, "Member 'SkillTreeUserWidget_ShowPanel::bNeedFocusOnClassStart' has a wrong offset!");

// Function man.SkillTreeUserWidget.IsAttributeSelectorVisible
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeUserWidget_IsAttributeSelectorVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_IsAttributeSelectorVisible) == 0x000001, "Wrong alignment on SkillTreeUserWidget_IsAttributeSelectorVisible");
static_assert(sizeof(SkillTreeUserWidget_IsAttributeSelectorVisible) == 0x000001, "Wrong size on SkillTreeUserWidget_IsAttributeSelectorVisible");
static_assert(offsetof(SkillTreeUserWidget_IsAttributeSelectorVisible, ReturnValue) == 0x000000, "Member 'SkillTreeUserWidget_IsAttributeSelectorVisible::ReturnValue' has a wrong offset!");

// Function man.SkillTreeUserWidget.IsPlayingUnlockVFX
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeUserWidget_IsPlayingUnlockVFX final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeUserWidget_IsPlayingUnlockVFX) == 0x000001, "Wrong alignment on SkillTreeUserWidget_IsPlayingUnlockVFX");
static_assert(sizeof(SkillTreeUserWidget_IsPlayingUnlockVFX) == 0x000001, "Wrong size on SkillTreeUserWidget_IsPlayingUnlockVFX");
static_assert(offsetof(SkillTreeUserWidget_IsPlayingUnlockVFX, ReturnValue) == 0x000000, "Member 'SkillTreeUserWidget_IsPlayingUnlockVFX::ReturnValue' has a wrong offset!");

// Function man.StackingDamageComponent.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct StackingDamageComponent_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StackingDamageComponent_OnPreDamageCaused) == 0x000008, "Wrong alignment on StackingDamageComponent_OnPreDamageCaused");
static_assert(sizeof(StackingDamageComponent_OnPreDamageCaused) == 0x0002D8, "Wrong size on StackingDamageComponent_OnPreDamageCaused");
static_assert(offsetof(StackingDamageComponent_OnPreDamageCaused, Param) == 0x000000, "Member 'StackingDamageComponent_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.LyMaCallCultistsAbility.OnCultistKilled
// 0x0010 (0x0010 - 0x0000)
struct LyMaCallCultistsAbility_OnCultistKilled final
{
public:
	class UObject*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     KillerAbilityController;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LyMaCallCultistsAbility_OnCultistKilled) == 0x000008, "Wrong alignment on LyMaCallCultistsAbility_OnCultistKilled");
static_assert(sizeof(LyMaCallCultistsAbility_OnCultistKilled) == 0x000010, "Wrong size on LyMaCallCultistsAbility_OnCultistKilled");
static_assert(offsetof(LyMaCallCultistsAbility_OnCultistKilled, Killer) == 0x000000, "Member 'LyMaCallCultistsAbility_OnCultistKilled::Killer' has a wrong offset!");
static_assert(offsetof(LyMaCallCultistsAbility_OnCultistKilled, KillerAbilityController) == 0x000008, "Member 'LyMaCallCultistsAbility_OnCultistKilled::KillerAbilityController' has a wrong offset!");

// Function man.DamageIncreaseByNearbyEnemies.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct DamageIncreaseByNearbyEnemies_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageIncreaseByNearbyEnemies_OnPreDamageCaused) == 0x000008, "Wrong alignment on DamageIncreaseByNearbyEnemies_OnPreDamageCaused");
static_assert(sizeof(DamageIncreaseByNearbyEnemies_OnPreDamageCaused) == 0x0002D8, "Wrong size on DamageIncreaseByNearbyEnemies_OnPreDamageCaused");
static_assert(offsetof(DamageIncreaseByNearbyEnemies_OnPreDamageCaused, Param) == 0x000000, "Member 'DamageIncreaseByNearbyEnemies_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.WeaponExpertComponent.OnItemsChanged
// 0x0010 (0x0010 - 0x0000)
struct WeaponExpertComponent_OnItemsChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponExpertComponent_OnItemsChanged) == 0x000008, "Wrong alignment on WeaponExpertComponent_OnItemsChanged");
static_assert(sizeof(WeaponExpertComponent_OnItemsChanged) == 0x000010, "Wrong size on WeaponExpertComponent_OnItemsChanged");
static_assert(offsetof(WeaponExpertComponent_OnItemsChanged, SourceSlot) == 0x000000, "Member 'WeaponExpertComponent_OnItemsChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(WeaponExpertComponent_OnItemsChanged, DestinationSlot) == 0x000008, "Member 'WeaponExpertComponent_OnItemsChanged::DestinationSlot' has a wrong offset!");

// Function man.ManHUD.DrawDebugLine
// 0x0024 (0x0024 - 0x0000)
struct ManHUD_DrawDebugLine final
{
public:
	float                                         StartScreenX;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartScreenY;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScreenX;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScreenY;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManHUD_DrawDebugLine) == 0x000004, "Wrong alignment on ManHUD_DrawDebugLine");
static_assert(sizeof(ManHUD_DrawDebugLine) == 0x000024, "Wrong size on ManHUD_DrawDebugLine");
static_assert(offsetof(ManHUD_DrawDebugLine, StartScreenX) == 0x000000, "Member 'ManHUD_DrawDebugLine::StartScreenX' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugLine, StartScreenY) == 0x000004, "Member 'ManHUD_DrawDebugLine::StartScreenY' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugLine, EndScreenX) == 0x000008, "Member 'ManHUD_DrawDebugLine::EndScreenX' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugLine, EndScreenY) == 0x00000C, "Member 'ManHUD_DrawDebugLine::EndScreenY' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugLine, LineColor) == 0x000010, "Member 'ManHUD_DrawDebugLine::LineColor' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugLine, LineThickness) == 0x000020, "Member 'ManHUD_DrawDebugLine::LineThickness' has a wrong offset!");

// Function man.ManHUD.DrawDebugRect
// 0x0020 (0x0020 - 0x0000)
struct ManHUD_DrawDebugRect final
{
public:
	struct FLinearColor                           RectColor;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenW;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenH;                                           // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManHUD_DrawDebugRect) == 0x000004, "Wrong alignment on ManHUD_DrawDebugRect");
static_assert(sizeof(ManHUD_DrawDebugRect) == 0x000020, "Wrong size on ManHUD_DrawDebugRect");
static_assert(offsetof(ManHUD_DrawDebugRect, RectColor) == 0x000000, "Member 'ManHUD_DrawDebugRect::RectColor' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugRect, ScreenX) == 0x000010, "Member 'ManHUD_DrawDebugRect::ScreenX' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugRect, ScreenY) == 0x000014, "Member 'ManHUD_DrawDebugRect::ScreenY' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugRect, ScreenW) == 0x000018, "Member 'ManHUD_DrawDebugRect::ScreenW' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugRect, ScreenH) == 0x00001C, "Member 'ManHUD_DrawDebugRect::ScreenH' has a wrong offset!");

// Function man.ManHUD.DrawDebugText
// 0x0038 (0x0038 - 0x0000)
struct ManHUD_DrawDebugText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManHUD_DrawDebugText) == 0x000008, "Wrong alignment on ManHUD_DrawDebugText");
static_assert(sizeof(ManHUD_DrawDebugText) == 0x000038, "Wrong size on ManHUD_DrawDebugText");
static_assert(offsetof(ManHUD_DrawDebugText, Text) == 0x000000, "Member 'ManHUD_DrawDebugText::Text' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, TextColor) == 0x000010, "Member 'ManHUD_DrawDebugText::TextColor' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, ScreenX) == 0x000020, "Member 'ManHUD_DrawDebugText::ScreenX' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, ScreenY) == 0x000024, "Member 'ManHUD_DrawDebugText::ScreenY' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, Font) == 0x000028, "Member 'ManHUD_DrawDebugText::Font' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, Scale) == 0x000030, "Member 'ManHUD_DrawDebugText::Scale' has a wrong offset!");
static_assert(offsetof(ManHUD_DrawDebugText, bScalePosition) == 0x000034, "Member 'ManHUD_DrawDebugText::bScalePosition' has a wrong offset!");

// Function man.EnchantItemsComponent.OnItemsChanged
// 0x0010 (0x0010 - 0x0000)
struct EnchantItemsComponent_OnItemsChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnchantItemsComponent_OnItemsChanged) == 0x000008, "Wrong alignment on EnchantItemsComponent_OnItemsChanged");
static_assert(sizeof(EnchantItemsComponent_OnItemsChanged) == 0x000010, "Wrong size on EnchantItemsComponent_OnItemsChanged");
static_assert(offsetof(EnchantItemsComponent_OnItemsChanged, SourceSlot) == 0x000000, "Member 'EnchantItemsComponent_OnItemsChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(EnchantItemsComponent_OnItemsChanged, DestinationSlot) == 0x000008, "Member 'EnchantItemsComponent_OnItemsChanged::DestinationSlot' has a wrong offset!");

// Function man.EnchantItemsComponent.OnRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct EnchantItemsComponent_OnRemoveItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RemovedItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnchantItemsComponent_OnRemoveItem) == 0x000008, "Wrong alignment on EnchantItemsComponent_OnRemoveItem");
static_assert(sizeof(EnchantItemsComponent_OnRemoveItem) == 0x000010, "Wrong size on EnchantItemsComponent_OnRemoveItem");
static_assert(offsetof(EnchantItemsComponent_OnRemoveItem, InventorySlot) == 0x000000, "Member 'EnchantItemsComponent_OnRemoveItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(EnchantItemsComponent_OnRemoveItem, RemovedItem) == 0x000008, "Member 'EnchantItemsComponent_OnRemoveItem::RemovedItem' has a wrong offset!");

// Function man.FangExecutionerBloodVial.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct FangExecutionerBloodVial_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FangExecutionerBloodVial_OnPostDamaged) == 0x000008, "Wrong alignment on FangExecutionerBloodVial_OnPostDamaged");
static_assert(sizeof(FangExecutionerBloodVial_OnPostDamaged) == 0x0002D8, "Wrong size on FangExecutionerBloodVial_OnPostDamaged");
static_assert(offsetof(FangExecutionerBloodVial_OnPostDamaged, Param) == 0x000000, "Member 'FangExecutionerBloodVial_OnPostDamaged::Param' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.GetParentManUserWidgetBase
// 0x0008 (0x0008 - 0x0000)
struct ManSlotUserWidgetBase_GetParentManUserWidgetBase final
{
public:
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_GetParentManUserWidgetBase) == 0x000008, "Wrong alignment on ManSlotUserWidgetBase_GetParentManUserWidgetBase");
static_assert(sizeof(ManSlotUserWidgetBase_GetParentManUserWidgetBase) == 0x000008, "Wrong size on ManSlotUserWidgetBase_GetParentManUserWidgetBase");
static_assert(offsetof(ManSlotUserWidgetBase_GetParentManUserWidgetBase, ReturnValue) == 0x000000, "Member 'ManSlotUserWidgetBase_GetParentManUserWidgetBase::ReturnValue' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.IsParentVisible
// 0x0001 (0x0001 - 0x0000)
struct ManSlotUserWidgetBase_IsParentVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_IsParentVisible) == 0x000001, "Wrong alignment on ManSlotUserWidgetBase_IsParentVisible");
static_assert(sizeof(ManSlotUserWidgetBase_IsParentVisible) == 0x000001, "Wrong size on ManSlotUserWidgetBase_IsParentVisible");
static_assert(offsetof(ManSlotUserWidgetBase_IsParentVisible, ReturnValue) == 0x000000, "Member 'ManSlotUserWidgetBase_IsParentVisible::ReturnValue' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.OnFocused
// 0x0001 (0x0001 - 0x0000)
struct ManSlotUserWidgetBase_OnFocused final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_OnFocused) == 0x000001, "Wrong alignment on ManSlotUserWidgetBase_OnFocused");
static_assert(sizeof(ManSlotUserWidgetBase_OnFocused) == 0x000001, "Wrong size on ManSlotUserWidgetBase_OnFocused");
static_assert(offsetof(ManSlotUserWidgetBase_OnFocused, bAnimate) == 0x000000, "Member 'ManSlotUserWidgetBase_OnFocused::bAnimate' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.OnHighlighted
// 0x0002 (0x0002 - 0x0000)
struct ManSlotUserWidgetBase_OnHighlighted final
{
public:
	bool                                          bHighlighted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_OnHighlighted) == 0x000001, "Wrong alignment on ManSlotUserWidgetBase_OnHighlighted");
static_assert(sizeof(ManSlotUserWidgetBase_OnHighlighted) == 0x000002, "Wrong size on ManSlotUserWidgetBase_OnHighlighted");
static_assert(offsetof(ManSlotUserWidgetBase_OnHighlighted, bHighlighted) == 0x000000, "Member 'ManSlotUserWidgetBase_OnHighlighted::bHighlighted' has a wrong offset!");
static_assert(offsetof(ManSlotUserWidgetBase_OnHighlighted, bAnimate) == 0x000001, "Member 'ManSlotUserWidgetBase_OnHighlighted::bAnimate' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.OnUnfocused
// 0x0001 (0x0001 - 0x0000)
struct ManSlotUserWidgetBase_OnUnfocused final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_OnUnfocused) == 0x000001, "Wrong alignment on ManSlotUserWidgetBase_OnUnfocused");
static_assert(sizeof(ManSlotUserWidgetBase_OnUnfocused) == 0x000001, "Wrong size on ManSlotUserWidgetBase_OnUnfocused");
static_assert(offsetof(ManSlotUserWidgetBase_OnUnfocused, bAnimate) == 0x000000, "Member 'ManSlotUserWidgetBase_OnUnfocused::bAnimate' has a wrong offset!");

// Function man.ManSlotUserWidgetBase.IsFocused
// 0x0001 (0x0001 - 0x0000)
struct ManSlotUserWidgetBase_IsFocused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSlotUserWidgetBase_IsFocused) == 0x000001, "Wrong alignment on ManSlotUserWidgetBase_IsFocused");
static_assert(sizeof(ManSlotUserWidgetBase_IsFocused) == 0x000001, "Wrong size on ManSlotUserWidgetBase_IsFocused");
static_assert(offsetof(ManSlotUserWidgetBase_IsFocused, ReturnValue) == 0x000000, "Member 'ManSlotUserWidgetBase_IsFocused::ReturnValue' has a wrong offset!");

// Function man.SkillTreeNodeUserWidget.OnSetLearnedUpgrades
// 0x0010 (0x0010 - 0x0000)
struct SkillTreeNodeUserWidget_OnSetLearnedUpgrades final
{
public:
	TArray<EAttribute>                            UnlockedAttributes;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeNodeUserWidget_OnSetLearnedUpgrades) == 0x000008, "Wrong alignment on SkillTreeNodeUserWidget_OnSetLearnedUpgrades");
static_assert(sizeof(SkillTreeNodeUserWidget_OnSetLearnedUpgrades) == 0x000010, "Wrong size on SkillTreeNodeUserWidget_OnSetLearnedUpgrades");
static_assert(offsetof(SkillTreeNodeUserWidget_OnSetLearnedUpgrades, UnlockedAttributes) == 0x000000, "Member 'SkillTreeNodeUserWidget_OnSetLearnedUpgrades::UnlockedAttributes' has a wrong offset!");

// Function man.SkillTreeNodeUserWidget.OnSetLocked
// 0x0002 (0x0002 - 0x0000)
struct SkillTreeNodeUserWidget_OnSetLocked final
{
public:
	bool                                          bInLocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAkAudioEvent;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeNodeUserWidget_OnSetLocked) == 0x000001, "Wrong alignment on SkillTreeNodeUserWidget_OnSetLocked");
static_assert(sizeof(SkillTreeNodeUserWidget_OnSetLocked) == 0x000002, "Wrong size on SkillTreeNodeUserWidget_OnSetLocked");
static_assert(offsetof(SkillTreeNodeUserWidget_OnSetLocked, bInLocked) == 0x000000, "Member 'SkillTreeNodeUserWidget_OnSetLocked::bInLocked' has a wrong offset!");
static_assert(offsetof(SkillTreeNodeUserWidget_OnSetLocked, bPlayAkAudioEvent) == 0x000001, "Member 'SkillTreeNodeUserWidget_OnSetLocked::bPlayAkAudioEvent' has a wrong offset!");

// Function man.SkillTreeNodeUserWidget.OnSetNode
// 0x0020 (0x0020 - 0x0000)
struct SkillTreeNodeUserWidget_OnSetNode final
{
public:
	class FText                                   NodeName;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             NodeIcon;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeNodeUserWidget_OnSetNode) == 0x000008, "Wrong alignment on SkillTreeNodeUserWidget_OnSetNode");
static_assert(sizeof(SkillTreeNodeUserWidget_OnSetNode) == 0x000020, "Wrong size on SkillTreeNodeUserWidget_OnSetNode");
static_assert(offsetof(SkillTreeNodeUserWidget_OnSetNode, NodeName) == 0x000000, "Member 'SkillTreeNodeUserWidget_OnSetNode::NodeName' has a wrong offset!");
static_assert(offsetof(SkillTreeNodeUserWidget_OnSetNode, NodeIcon) == 0x000018, "Member 'SkillTreeNodeUserWidget_OnSetNode::NodeIcon' has a wrong offset!");

// Function man.SkillTreeNodeUserWidget.GetNodeRegion
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeNodeUserWidget_GetNodeRegion final
{
public:
	ECharacterClass                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeNodeUserWidget_GetNodeRegion) == 0x000001, "Wrong alignment on SkillTreeNodeUserWidget_GetNodeRegion");
static_assert(sizeof(SkillTreeNodeUserWidget_GetNodeRegion) == 0x000001, "Wrong size on SkillTreeNodeUserWidget_GetNodeRegion");
static_assert(offsetof(SkillTreeNodeUserWidget_GetNodeRegion, ReturnValue) == 0x000000, "Member 'SkillTreeNodeUserWidget_GetNodeRegion::ReturnValue' has a wrong offset!");

// Function man.InterpolComponentNode.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct InterpolComponentNode_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpolComponentNode_GetEditorName) == 0x000008, "Wrong alignment on InterpolComponentNode_GetEditorName");
static_assert(sizeof(InterpolComponentNode_GetEditorName) == 0x000010, "Wrong size on InterpolComponentNode_GetEditorName");
static_assert(offsetof(InterpolComponentNode_GetEditorName, ReturnValue) == 0x000000, "Member 'InterpolComponentNode_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.BladeDanceAbility.GetCurrentCharge
// 0x0004 (0x0004 - 0x0000)
struct BladeDanceAbility_GetCurrentCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BladeDanceAbility_GetCurrentCharge) == 0x000004, "Wrong alignment on BladeDanceAbility_GetCurrentCharge");
static_assert(sizeof(BladeDanceAbility_GetCurrentCharge) == 0x000004, "Wrong size on BladeDanceAbility_GetCurrentCharge");
static_assert(offsetof(BladeDanceAbility_GetCurrentCharge, ReturnValue) == 0x000000, "Member 'BladeDanceAbility_GetCurrentCharge::ReturnValue' has a wrong offset!");

// Function man.BladeDanceAbility.GetMaxCharge
// 0x0004 (0x0004 - 0x0000)
struct BladeDanceAbility_GetMaxCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BladeDanceAbility_GetMaxCharge) == 0x000004, "Wrong alignment on BladeDanceAbility_GetMaxCharge");
static_assert(sizeof(BladeDanceAbility_GetMaxCharge) == 0x000004, "Wrong size on BladeDanceAbility_GetMaxCharge");
static_assert(offsetof(BladeDanceAbility_GetMaxCharge, ReturnValue) == 0x000000, "Member 'BladeDanceAbility_GetMaxCharge::ReturnValue' has a wrong offset!");

// Function man.BladeDanceAbility.ResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct BladeDanceAbility_ResourceUsed final
{
public:
	int32                                         amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BladeDanceAbility_ResourceUsed) == 0x000008, "Wrong alignment on BladeDanceAbility_ResourceUsed");
static_assert(sizeof(BladeDanceAbility_ResourceUsed) == 0x000010, "Wrong size on BladeDanceAbility_ResourceUsed");
static_assert(offsetof(BladeDanceAbility_ResourceUsed, amount) == 0x000000, "Member 'BladeDanceAbility_ResourceUsed::amount' has a wrong offset!");
static_assert(offsetof(BladeDanceAbility_ResourceUsed, SourceAbility) == 0x000008, "Member 'BladeDanceAbility_ResourceUsed::SourceAbility' has a wrong offset!");

// Function man.ModifyDamageTakenAbilityComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct ModifyDamageTakenAbilityComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyDamageTakenAbilityComponent_OnPreDamaged) == 0x000008, "Wrong alignment on ModifyDamageTakenAbilityComponent_OnPreDamaged");
static_assert(sizeof(ModifyDamageTakenAbilityComponent_OnPreDamaged) == 0x0002D8, "Wrong size on ModifyDamageTakenAbilityComponent_OnPreDamaged");
static_assert(offsetof(ModifyDamageTakenAbilityComponent_OnPreDamaged, Param) == 0x000000, "Member 'ModifyDamageTakenAbilityComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.ModifyDamageDoneAbilityComponent.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct ModifyDamageDoneAbilityComponent_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifyDamageDoneAbilityComponent_OnPreDamageCaused) == 0x000008, "Wrong alignment on ModifyDamageDoneAbilityComponent_OnPreDamageCaused");
static_assert(sizeof(ModifyDamageDoneAbilityComponent_OnPreDamageCaused) == 0x0002D8, "Wrong size on ModifyDamageDoneAbilityComponent_OnPreDamageCaused");
static_assert(offsetof(ModifyDamageDoneAbilityComponent_OnPreDamageCaused, Param) == 0x000000, "Member 'ModifyDamageDoneAbilityComponent_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnPlayLearnAbilityAnim
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnPlayLearnAbilityAnim final
{
public:
	bool                                          bPlayAnim;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnPlayLearnAbilityAnim) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnPlayLearnAbilityAnim");
static_assert(sizeof(AbilitySlotUserWidget_OnPlayLearnAbilityAnim) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnPlayLearnAbilityAnim");
static_assert(offsetof(AbilitySlotUserWidget_OnPlayLearnAbilityAnim, bPlayAnim) == 0x000000, "Member 'AbilitySlotUserWidget_OnPlayLearnAbilityAnim::bPlayAnim' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnSetEquips
// 0x0002 (0x0002 - 0x0000)
struct AbilitySlotUserWidget_OnSetEquips final
{
public:
	bool                                          bAbilitySet1Contain;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbilitySet2Contain;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnSetEquips) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnSetEquips");
static_assert(sizeof(AbilitySlotUserWidget_OnSetEquips) == 0x000002, "Wrong size on AbilitySlotUserWidget_OnSetEquips");
static_assert(offsetof(AbilitySlotUserWidget_OnSetEquips, bAbilitySet1Contain) == 0x000000, "Member 'AbilitySlotUserWidget_OnSetEquips::bAbilitySet1Contain' has a wrong offset!");
static_assert(offsetof(AbilitySlotUserWidget_OnSetEquips, bAbilitySet2Contain) == 0x000001, "Member 'AbilitySlotUserWidget_OnSetEquips::bAbilitySet2Contain' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnSetSlot
// 0x0010 (0x0010 - 0x0000)
struct AbilitySlotUserWidget_OnSetSlot final
{
public:
	const class UTexture2D*                       InIcon;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGhostIcon;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilitySlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on AbilitySlotUserWidget_OnSetSlot");
static_assert(sizeof(AbilitySlotUserWidget_OnSetSlot) == 0x000010, "Wrong size on AbilitySlotUserWidget_OnSetSlot");
static_assert(offsetof(AbilitySlotUserWidget_OnSetSlot, InIcon) == 0x000000, "Member 'AbilitySlotUserWidget_OnSetSlot::InIcon' has a wrong offset!");
static_assert(offsetof(AbilitySlotUserWidget_OnSetSlot, bGhostIcon) == 0x000008, "Member 'AbilitySlotUserWidget_OnSetSlot::bGhostIcon' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnSetUpgrades
// 0x0008 (0x0008 - 0x0000)
struct AbilitySlotUserWidget_OnSetUpgrades final
{
public:
	int32                                         InMaxUpgrades;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InLearnedUpgrades;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnSetUpgrades) == 0x000004, "Wrong alignment on AbilitySlotUserWidget_OnSetUpgrades");
static_assert(sizeof(AbilitySlotUserWidget_OnSetUpgrades) == 0x000008, "Wrong size on AbilitySlotUserWidget_OnSetUpgrades");
static_assert(offsetof(AbilitySlotUserWidget_OnSetUpgrades, InMaxUpgrades) == 0x000000, "Member 'AbilitySlotUserWidget_OnSetUpgrades::InMaxUpgrades' has a wrong offset!");
static_assert(offsetof(AbilitySlotUserWidget_OnSetUpgrades, InLearnedUpgrades) == 0x000004, "Member 'AbilitySlotUserWidget_OnSetUpgrades::InLearnedUpgrades' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleActive
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleActive final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleActive) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleActive");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleActive) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleActive");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleActive, bActive) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleActive::bActive' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleCrossHighlight
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleCrossHighlight final
{
public:
	bool                                          bCrossHighlight;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleCrossHighlight) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleCrossHighlight");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleCrossHighlight) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleCrossHighlight");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleCrossHighlight, bCrossHighlight) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleCrossHighlight::bCrossHighlight' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleEquipped
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleEquipped final
{
public:
	bool                                          bEquipped;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleEquipped) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleEquipped");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleEquipped) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleEquipped");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleEquipped, bEquipped) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleEquipped::bEquipped' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleEquipState
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleEquipState final
{
public:
	bool                                          bEquipState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleEquipState) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleEquipState");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleEquipState) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleEquipState");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleEquipState, bEquipState) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleEquipState::bEquipState' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleLocked
// 0x0020 (0x0020 - 0x0000)
struct AbilitySlotUserWidget_OnToggleLocked final
{
public:
	bool                                          bLocked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LockedLevel;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleLocked) == 0x000008, "Wrong alignment on AbilitySlotUserWidget_OnToggleLocked");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleLocked) == 0x000020, "Wrong size on AbilitySlotUserWidget_OnToggleLocked");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleLocked, bLocked) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleLocked::bLocked' has a wrong offset!");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleLocked, LockedLevel) == 0x000008, "Member 'AbilitySlotUserWidget_OnToggleLocked::LockedLevel' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleSelected
// 0x0002 (0x0002 - 0x0000)
struct AbilitySlotUserWidget_OnToggleSelected final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnim;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleSelected) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleSelected");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleSelected) == 0x000002, "Wrong size on AbilitySlotUserWidget_OnToggleSelected");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleSelected, bSelected) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleSelected::bSelected' has a wrong offset!");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleSelected, bPlayAnim) == 0x000001, "Member 'AbilitySlotUserWidget_OnToggleSelected::bPlayAnim' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleSwapped
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleSwapped final
{
public:
	bool                                          bSwapped;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleSwapped) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleSwapped");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleSwapped) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleSwapped");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleSwapped, bSwapped) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleSwapped::bSwapped' has a wrong offset!");

// Function man.AbilitySlotUserWidget.OnToggleUnknown
// 0x0001 (0x0001 - 0x0000)
struct AbilitySlotUserWidget_OnToggleUnknown final
{
public:
	bool                                          bUnknown;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilitySlotUserWidget_OnToggleUnknown) == 0x000001, "Wrong alignment on AbilitySlotUserWidget_OnToggleUnknown");
static_assert(sizeof(AbilitySlotUserWidget_OnToggleUnknown) == 0x000001, "Wrong size on AbilitySlotUserWidget_OnToggleUnknown");
static_assert(offsetof(AbilitySlotUserWidget_OnToggleUnknown, bUnknown) == 0x000000, "Member 'AbilitySlotUserWidget_OnToggleUnknown::bUnknown' has a wrong offset!");

// Function man.HoldAnim.OnHitEvent
// 0x0020 (0x0020 - 0x0000)
struct HoldAnim_OnHitEvent final
{
public:
	class ACharacterBase*                         Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbility;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                InAnim;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoldAnim_OnHitEvent) == 0x000008, "Wrong alignment on HoldAnim_OnHitEvent");
static_assert(sizeof(HoldAnim_OnHitEvent) == 0x000020, "Wrong size on HoldAnim_OnHitEvent");
static_assert(offsetof(HoldAnim_OnHitEvent, Source) == 0x000000, "Member 'HoldAnim_OnHitEvent::Source' has a wrong offset!");
static_assert(offsetof(HoldAnim_OnHitEvent, Target) == 0x000008, "Member 'HoldAnim_OnHitEvent::Target' has a wrong offset!");
static_assert(offsetof(HoldAnim_OnHitEvent, InAbility) == 0x000010, "Member 'HoldAnim_OnHitEvent::InAbility' has a wrong offset!");
static_assert(offsetof(HoldAnim_OnHitEvent, InAnim) == 0x000018, "Member 'HoldAnim_OnHitEvent::InAnim' has a wrong offset!");

// Function man.ConcetrationSkillController.DamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct ConcetrationSkillController_DamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConcetrationSkillController_DamageTaken) == 0x000008, "Wrong alignment on ConcetrationSkillController_DamageTaken");
static_assert(sizeof(ConcetrationSkillController_DamageTaken) == 0x0002D8, "Wrong size on ConcetrationSkillController_DamageTaken");
static_assert(offsetof(ConcetrationSkillController_DamageTaken, DamageParams) == 0x000000, "Member 'ConcetrationSkillController_DamageTaken::DamageParams' has a wrong offset!");

// Function man.GroundSlamAbility.OnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct GroundSlamAbility_OnGameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundSlamAbility_OnGameplayEvent) == 0x000008, "Wrong alignment on GroundSlamAbility_OnGameplayEvent");
static_assert(sizeof(GroundSlamAbility_OnGameplayEvent) == 0x000020, "Wrong size on GroundSlamAbility_OnGameplayEvent");
static_assert(offsetof(GroundSlamAbility_OnGameplayEvent, AbilityController) == 0x000000, "Member 'GroundSlamAbility_OnGameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(GroundSlamAbility_OnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'GroundSlamAbility_OnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(GroundSlamAbility_OnGameplayEvent, CustomName) == 0x000010, "Member 'GroundSlamAbility_OnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(GroundSlamAbility_OnGameplayEvent, paramActorSoul) == 0x000018, "Member 'GroundSlamAbility_OnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.GroundSlamAbility.PreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct GroundSlamAbility_PreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundSlamAbility_PreDamaged) == 0x000008, "Wrong alignment on GroundSlamAbility_PreDamaged");
static_assert(sizeof(GroundSlamAbility_PreDamaged) == 0x0002D8, "Wrong size on GroundSlamAbility_PreDamaged");
static_assert(offsetof(GroundSlamAbility_PreDamaged, Param) == 0x000000, "Member 'GroundSlamAbility_PreDamaged::Param' has a wrong offset!");

// Function man.SkillTreeManager.OnRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct SkillTreeManager_OnRemoveItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RemovedItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeManager_OnRemoveItem) == 0x000008, "Wrong alignment on SkillTreeManager_OnRemoveItem");
static_assert(sizeof(SkillTreeManager_OnRemoveItem) == 0x000010, "Wrong size on SkillTreeManager_OnRemoveItem");
static_assert(offsetof(SkillTreeManager_OnRemoveItem, InventorySlot) == 0x000000, "Member 'SkillTreeManager_OnRemoveItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_OnRemoveItem, RemovedItem) == 0x000008, "Member 'SkillTreeManager_OnRemoveItem::RemovedItem' has a wrong offset!");

// Function man.SkillTreeManager.OnUpdateItem
// 0x0008 (0x0008 - 0x0000)
struct SkillTreeManager_OnUpdateItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeManager_OnUpdateItem) == 0x000008, "Wrong alignment on SkillTreeManager_OnUpdateItem");
static_assert(sizeof(SkillTreeManager_OnUpdateItem) == 0x000008, "Wrong size on SkillTreeManager_OnUpdateItem");
static_assert(offsetof(SkillTreeManager_OnUpdateItem, InventorySlot) == 0x000000, "Member 'SkillTreeManager_OnUpdateItem::InventorySlot' has a wrong offset!");

// Function man.SkillTreeManager.UnlockAllNodesForUnlockedStartNodes
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeManager_UnlockAllNodesForUnlockedStartNodes final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeManager_UnlockAllNodesForUnlockedStartNodes) == 0x000001, "Wrong alignment on SkillTreeManager_UnlockAllNodesForUnlockedStartNodes");
static_assert(sizeof(SkillTreeManager_UnlockAllNodesForUnlockedStartNodes) == 0x000001, "Wrong size on SkillTreeManager_UnlockAllNodesForUnlockedStartNodes");
static_assert(offsetof(SkillTreeManager_UnlockAllNodesForUnlockedStartNodes, ReturnValue) == 0x000000, "Member 'SkillTreeManager_UnlockAllNodesForUnlockedStartNodes::ReturnValue' has a wrong offset!");

// Function man.SkillTreeManager.UnlockNodeByID
// 0x0030 (0x0030 - 0x0000)
struct SkillTreeManager_UnlockNodeByID final
{
public:
	TSoftObjectPtr<class UPrimalSkillTree>        InSkillTree;                                       // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUnlock;                                      // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeManager_UnlockNodeByID) == 0x000008, "Wrong alignment on SkillTreeManager_UnlockNodeByID");
static_assert(sizeof(SkillTreeManager_UnlockNodeByID) == 0x000030, "Wrong size on SkillTreeManager_UnlockNodeByID");
static_assert(offsetof(SkillTreeManager_UnlockNodeByID, InSkillTree) == 0x000000, "Member 'SkillTreeManager_UnlockNodeByID::InSkillTree' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByID, ID) == 0x000028, "Member 'SkillTreeManager_UnlockNodeByID::ID' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByID, bForceUnlock) == 0x00002C, "Member 'SkillTreeManager_UnlockNodeByID::bForceUnlock' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByID, ReturnValue) == 0x00002D, "Member 'SkillTreeManager_UnlockNodeByID::ReturnValue' has a wrong offset!");

// Function man.SkillTreeManager.UnlockNodeByName
// 0x0040 (0x0040 - 0x0000)
struct SkillTreeManager_UnlockNodeByName final
{
public:
	TSoftObjectPtr<class UPrimalSkillTree>        InSkillTree;                                       // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NodeName;                                          // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUnlock;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeManager_UnlockNodeByName) == 0x000008, "Wrong alignment on SkillTreeManager_UnlockNodeByName");
static_assert(sizeof(SkillTreeManager_UnlockNodeByName) == 0x000040, "Wrong size on SkillTreeManager_UnlockNodeByName");
static_assert(offsetof(SkillTreeManager_UnlockNodeByName, InSkillTree) == 0x000000, "Member 'SkillTreeManager_UnlockNodeByName::InSkillTree' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByName, NodeName) == 0x000028, "Member 'SkillTreeManager_UnlockNodeByName::NodeName' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByName, bForceUnlock) == 0x000038, "Member 'SkillTreeManager_UnlockNodeByName::bForceUnlock' has a wrong offset!");
static_assert(offsetof(SkillTreeManager_UnlockNodeByName, ReturnValue) == 0x000039, "Member 'SkillTreeManager_UnlockNodeByName::ReturnValue' has a wrong offset!");

// Function man.ForceParryAbilityComponent.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct ForceParryAbilityComponent_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ForceParryAbilityComponent_OnPreDamagedPriority) == 0x000008, "Wrong alignment on ForceParryAbilityComponent_OnPreDamagedPriority");
static_assert(sizeof(ForceParryAbilityComponent_OnPreDamagedPriority) == 0x0002D8, "Wrong size on ForceParryAbilityComponent_OnPreDamagedPriority");
static_assert(offsetof(ForceParryAbilityComponent_OnPreDamagedPriority, Param) == 0x000000, "Member 'ForceParryAbilityComponent_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.OptionsUserWidgetBase.DoClose
// 0x0001 (0x0001 - 0x0000)
struct OptionsUserWidgetBase_DoClose final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_DoClose) == 0x000001, "Wrong alignment on OptionsUserWidgetBase_DoClose");
static_assert(sizeof(OptionsUserWidgetBase_DoClose) == 0x000001, "Wrong size on OptionsUserWidgetBase_DoClose");
static_assert(offsetof(OptionsUserWidgetBase_DoClose, ReturnValue) == 0x000000, "Member 'OptionsUserWidgetBase_DoClose::ReturnValue' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnDialogueResetToDefault
// 0x0001 (0x0001 - 0x0000)
struct OptionsUserWidgetBase_OnDialogueResetToDefault final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnDialogueResetToDefault) == 0x000001, "Wrong alignment on OptionsUserWidgetBase_OnDialogueResetToDefault");
static_assert(sizeof(OptionsUserWidgetBase_OnDialogueResetToDefault) == 0x000001, "Wrong size on OptionsUserWidgetBase_OnDialogueResetToDefault");
static_assert(offsetof(OptionsUserWidgetBase_OnDialogueResetToDefault, ButtonType) == 0x000000, "Member 'OptionsUserWidgetBase_OnDialogueResetToDefault::ButtonType' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnDialogueSaveChangesResult
// 0x0001 (0x0001 - 0x0000)
struct OptionsUserWidgetBase_OnDialogueSaveChangesResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnDialogueSaveChangesResult) == 0x000001, "Wrong alignment on OptionsUserWidgetBase_OnDialogueSaveChangesResult");
static_assert(sizeof(OptionsUserWidgetBase_OnDialogueSaveChangesResult) == 0x000001, "Wrong size on OptionsUserWidgetBase_OnDialogueSaveChangesResult");
static_assert(offsetof(OptionsUserWidgetBase_OnDialogueSaveChangesResult, ButtonType) == 0x000000, "Member 'OptionsUserWidgetBase_OnDialogueSaveChangesResult::ButtonType' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnSelectorValueChanged
// 0x0008 (0x0008 - 0x0000)
struct OptionsUserWidgetBase_OnSelectorValueChanged final
{
public:
	EOptionsType                                  OptionsType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewIndex;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnSelectorValueChanged) == 0x000004, "Wrong alignment on OptionsUserWidgetBase_OnSelectorValueChanged");
static_assert(sizeof(OptionsUserWidgetBase_OnSelectorValueChanged) == 0x000008, "Wrong size on OptionsUserWidgetBase_OnSelectorValueChanged");
static_assert(offsetof(OptionsUserWidgetBase_OnSelectorValueChanged, OptionsType) == 0x000000, "Member 'OptionsUserWidgetBase_OnSelectorValueChanged::OptionsType' has a wrong offset!");
static_assert(offsetof(OptionsUserWidgetBase_OnSelectorValueChanged, NewIndex) == 0x000004, "Member 'OptionsUserWidgetBase_OnSelectorValueChanged::NewIndex' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnSetDescription
// 0x0018 (0x0018 - 0x0000)
struct OptionsUserWidgetBase_OnSetDescription final
{
public:
	class FText                                   InDescription;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnSetDescription) == 0x000008, "Wrong alignment on OptionsUserWidgetBase_OnSetDescription");
static_assert(sizeof(OptionsUserWidgetBase_OnSetDescription) == 0x000018, "Wrong size on OptionsUserWidgetBase_OnSetDescription");
static_assert(offsetof(OptionsUserWidgetBase_OnSetDescription, InDescription) == 0x000000, "Member 'OptionsUserWidgetBase_OnSetDescription::InDescription' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnSliderValueChanged
// 0x0008 (0x0008 - 0x0000)
struct OptionsUserWidgetBase_OnSliderValueChanged final
{
public:
	EOptionsType                                  OptionsType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnSliderValueChanged) == 0x000004, "Wrong alignment on OptionsUserWidgetBase_OnSliderValueChanged");
static_assert(sizeof(OptionsUserWidgetBase_OnSliderValueChanged) == 0x000008, "Wrong size on OptionsUserWidgetBase_OnSliderValueChanged");
static_assert(offsetof(OptionsUserWidgetBase_OnSliderValueChanged, OptionsType) == 0x000000, "Member 'OptionsUserWidgetBase_OnSliderValueChanged::OptionsType' has a wrong offset!");
static_assert(offsetof(OptionsUserWidgetBase_OnSliderValueChanged, NewValue) == 0x000004, "Member 'OptionsUserWidgetBase_OnSliderValueChanged::NewValue' has a wrong offset!");

// Function man.OptionsUserWidgetBase.OnUserInterfaceScaleChanged
// 0x0001 (0x0001 - 0x0000)
struct OptionsUserWidgetBase_OnUserInterfaceScaleChanged final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_OnUserInterfaceScaleChanged) == 0x000001, "Wrong alignment on OptionsUserWidgetBase_OnUserInterfaceScaleChanged");
static_assert(sizeof(OptionsUserWidgetBase_OnUserInterfaceScaleChanged) == 0x000001, "Wrong size on OptionsUserWidgetBase_OnUserInterfaceScaleChanged");
static_assert(offsetof(OptionsUserWidgetBase_OnUserInterfaceScaleChanged, ButtonType) == 0x000000, "Member 'OptionsUserWidgetBase_OnUserInterfaceScaleChanged::ButtonType' has a wrong offset!");

// Function man.OptionsUserWidgetBase.RequestTab
// 0x0001 (0x0001 - 0x0000)
struct OptionsUserWidgetBase_RequestTab final
{
public:
	ETabButtonType                                TabButtonType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsUserWidgetBase_RequestTab) == 0x000001, "Wrong alignment on OptionsUserWidgetBase_RequestTab");
static_assert(sizeof(OptionsUserWidgetBase_RequestTab) == 0x000001, "Wrong size on OptionsUserWidgetBase_RequestTab");
static_assert(offsetof(OptionsUserWidgetBase_RequestTab, TabButtonType) == 0x000000, "Member 'OptionsUserWidgetBase_RequestTab::TabButtonType' has a wrong offset!");

// Function man.OptionsControllerUserWidget.OnSetQuickUseDefault
// 0x0001 (0x0001 - 0x0000)
struct OptionsControllerUserWidget_OnSetQuickUseDefault final
{
public:
	bool                                          bQuickUseDefault;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsControllerUserWidget_OnSetQuickUseDefault) == 0x000001, "Wrong alignment on OptionsControllerUserWidget_OnSetQuickUseDefault");
static_assert(sizeof(OptionsControllerUserWidget_OnSetQuickUseDefault) == 0x000001, "Wrong size on OptionsControllerUserWidget_OnSetQuickUseDefault");
static_assert(offsetof(OptionsControllerUserWidget_OnSetQuickUseDefault, bQuickUseDefault) == 0x000000, "Member 'OptionsControllerUserWidget_OnSetQuickUseDefault::bQuickUseDefault' has a wrong offset!");

// Function man.AddAbility_AbilityComponent.DamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct AddAbility_AbilityComponent_DamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AddAbility_AbilityComponent_DamageTaken) == 0x000008, "Wrong alignment on AddAbility_AbilityComponent_DamageTaken");
static_assert(sizeof(AddAbility_AbilityComponent_DamageTaken) == 0x0002D8, "Wrong size on AddAbility_AbilityComponent_DamageTaken");
static_assert(offsetof(AddAbility_AbilityComponent_DamageTaken, DamageParams) == 0x000000, "Member 'AddAbility_AbilityComponent_DamageTaken::DamageParams' has a wrong offset!");

// Function man.AirAI.DamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct AirAI_DamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AirAI_DamageTaken) == 0x000008, "Wrong alignment on AirAI_DamageTaken");
static_assert(sizeof(AirAI_DamageTaken) == 0x0002D8, "Wrong size on AirAI_DamageTaken");
static_assert(offsetof(AirAI_DamageTaken, DamageParams) == 0x000000, "Member 'AirAI_DamageTaken::DamageParams' has a wrong offset!");

// Function man.AirAI.OnTargetPositionReached
// 0x0001 (0x0001 - 0x0000)
struct AirAI_OnTargetPositionReached final
{
public:
	bool                                          AirMoveInterrupted;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AirAI_OnTargetPositionReached) == 0x000001, "Wrong alignment on AirAI_OnTargetPositionReached");
static_assert(sizeof(AirAI_OnTargetPositionReached) == 0x000001, "Wrong size on AirAI_OnTargetPositionReached");
static_assert(offsetof(AirAI_OnTargetPositionReached, AirMoveInterrupted) == 0x000000, "Member 'AirAI_OnTargetPositionReached::AirMoveInterrupted' has a wrong offset!");

// Function man.MeleeAirAI.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct MeleeAirAI_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeleeAirAI_OnPostDamageDone) == 0x000008, "Wrong alignment on MeleeAirAI_OnPostDamageDone");
static_assert(sizeof(MeleeAirAI_OnPostDamageDone) == 0x0002D8, "Wrong size on MeleeAirAI_OnPostDamageDone");
static_assert(offsetof(MeleeAirAI_OnPostDamageDone, DamageParams) == 0x000000, "Member 'MeleeAirAI_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.PlayAnim_AbilityComponent.OnAbilityAnimReplaced
// 0x0018 (0x0018 - 0x0000)
struct PlayAnim_AbilityComponent_OnAbilityAnimReplaced final
{
public:
	class UAnimID*                                SrcAnimId;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                DestAnimId;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReplacerObject;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayAnim_AbilityComponent_OnAbilityAnimReplaced) == 0x000008, "Wrong alignment on PlayAnim_AbilityComponent_OnAbilityAnimReplaced");
static_assert(sizeof(PlayAnim_AbilityComponent_OnAbilityAnimReplaced) == 0x000018, "Wrong size on PlayAnim_AbilityComponent_OnAbilityAnimReplaced");
static_assert(offsetof(PlayAnim_AbilityComponent_OnAbilityAnimReplaced, SrcAnimId) == 0x000000, "Member 'PlayAnim_AbilityComponent_OnAbilityAnimReplaced::SrcAnimId' has a wrong offset!");
static_assert(offsetof(PlayAnim_AbilityComponent_OnAbilityAnimReplaced, DestAnimId) == 0x000008, "Member 'PlayAnim_AbilityComponent_OnAbilityAnimReplaced::DestAnimId' has a wrong offset!");
static_assert(offsetof(PlayAnim_AbilityComponent_OnAbilityAnimReplaced, ReplacerObject) == 0x000010, "Member 'PlayAnim_AbilityComponent_OnAbilityAnimReplaced::ReplacerObject' has a wrong offset!");

// Function man.BrawlerBashConditionComponent.DamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct BrawlerBashConditionComponent_DamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerBashConditionComponent_DamageTaken) == 0x000008, "Wrong alignment on BrawlerBashConditionComponent_DamageTaken");
static_assert(sizeof(BrawlerBashConditionComponent_DamageTaken) == 0x0002D8, "Wrong size on BrawlerBashConditionComponent_DamageTaken");
static_assert(offsetof(BrawlerBashConditionComponent_DamageTaken, DamageParams) == 0x000000, "Member 'BrawlerBashConditionComponent_DamageTaken::DamageParams' has a wrong offset!");

// Function man.BrawlerBashConditionComponent.ParryEvent
// 0x0020 (0x0020 - 0x0000)
struct BrawlerBashConditionComponent_ParryEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerBashConditionComponent_ParryEvent) == 0x000008, "Wrong alignment on BrawlerBashConditionComponent_ParryEvent");
static_assert(sizeof(BrawlerBashConditionComponent_ParryEvent) == 0x000020, "Wrong size on BrawlerBashConditionComponent_ParryEvent");
static_assert(offsetof(BrawlerBashConditionComponent_ParryEvent, AbilityController) == 0x000000, "Member 'BrawlerBashConditionComponent_ParryEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(BrawlerBashConditionComponent_ParryEvent, _GameplayEventID) == 0x000008, "Member 'BrawlerBashConditionComponent_ParryEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(BrawlerBashConditionComponent_ParryEvent, CustomName) == 0x000010, "Member 'BrawlerBashConditionComponent_ParryEvent::CustomName' has a wrong offset!");
static_assert(offsetof(BrawlerBashConditionComponent_ParryEvent, paramActorSoul) == 0x000018, "Member 'BrawlerBashConditionComponent_ParryEvent::paramActorSoul' has a wrong offset!");

// Function man.FangCultistPriestessAI.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct FangCultistPriestessAI_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FangCultistPriestessAI_IsCollideSignature) == 0x000008, "Wrong alignment on FangCultistPriestessAI_IsCollideSignature");
static_assert(sizeof(FangCultistPriestessAI_IsCollideSignature) == 0x000010, "Wrong size on FangCultistPriestessAI_IsCollideSignature");
static_assert(offsetof(FangCultistPriestessAI_IsCollideSignature, Actor) == 0x000000, "Member 'FangCultistPriestessAI_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(FangCultistPriestessAI_IsCollideSignature, bOverride) == 0x000008, "Member 'FangCultistPriestessAI_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(FangCultistPriestessAI_IsCollideSignature, bCollide) == 0x000009, "Member 'FangCultistPriestessAI_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.WarriorsMight.OnConstitutionChanged
// 0x0010 (0x0010 - 0x0000)
struct WarriorsMight_OnConstitutionChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WarriorsMight_OnConstitutionChanged) == 0x000008, "Wrong alignment on WarriorsMight_OnConstitutionChanged");
static_assert(sizeof(WarriorsMight_OnConstitutionChanged) == 0x000010, "Wrong size on WarriorsMight_OnConstitutionChanged");
static_assert(offsetof(WarriorsMight_OnConstitutionChanged, attribute) == 0x000000, "Member 'WarriorsMight_OnConstitutionChanged::attribute' has a wrong offset!");
static_assert(offsetof(WarriorsMight_OnConstitutionChanged, preValue) == 0x000008, "Member 'WarriorsMight_OnConstitutionChanged::preValue' has a wrong offset!");

// Function man.WarriorsMight.OnDefenseChanged
// 0x0010 (0x0010 - 0x0000)
struct WarriorsMight_OnDefenseChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WarriorsMight_OnDefenseChanged) == 0x000008, "Wrong alignment on WarriorsMight_OnDefenseChanged");
static_assert(sizeof(WarriorsMight_OnDefenseChanged) == 0x000010, "Wrong size on WarriorsMight_OnDefenseChanged");
static_assert(offsetof(WarriorsMight_OnDefenseChanged, attribute) == 0x000000, "Member 'WarriorsMight_OnDefenseChanged::attribute' has a wrong offset!");
static_assert(offsetof(WarriorsMight_OnDefenseChanged, preValue) == 0x000008, "Member 'WarriorsMight_OnDefenseChanged::preValue' has a wrong offset!");

// Function man.LevelTransitionUserWidget.OnShowWidget
// 0x0008 (0x0008 - 0x0000)
struct LevelTransitionUserWidget_OnShowWidget final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelTransitionUserWidget_OnShowWidget) == 0x000008, "Wrong alignment on LevelTransitionUserWidget_OnShowWidget");
static_assert(sizeof(LevelTransitionUserWidget_OnShowWidget) == 0x000008, "Wrong size on LevelTransitionUserWidget_OnShowWidget");
static_assert(offsetof(LevelTransitionUserWidget_OnShowWidget, Material) == 0x000000, "Member 'LevelTransitionUserWidget_OnShowWidget::Material' has a wrong offset!");

// Function man.CustomEventOnUserInput.OnUserInput
// 0x0004 (0x0004 - 0x0000)
struct CustomEventOnUserInput_OnUserInput final
{
public:
	int32                                         InputCommandNum;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnUserInput_OnUserInput) == 0x000004, "Wrong alignment on CustomEventOnUserInput_OnUserInput");
static_assert(sizeof(CustomEventOnUserInput_OnUserInput) == 0x000004, "Wrong size on CustomEventOnUserInput_OnUserInput");
static_assert(offsetof(CustomEventOnUserInput_OnUserInput, InputCommandNum) == 0x000000, "Member 'CustomEventOnUserInput_OnUserInput::InputCommandNum' has a wrong offset!");

// Function man.ManProjectile.GetImpactSurfaceNormal
// 0x000C (0x000C - 0x0000)
struct ManProjectile_GetImpactSurfaceNormal final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_GetImpactSurfaceNormal) == 0x000004, "Wrong alignment on ManProjectile_GetImpactSurfaceNormal");
static_assert(sizeof(ManProjectile_GetImpactSurfaceNormal) == 0x00000C, "Wrong size on ManProjectile_GetImpactSurfaceNormal");
static_assert(offsetof(ManProjectile_GetImpactSurfaceNormal, ReturnValue) == 0x000000, "Member 'ManProjectile_GetImpactSurfaceNormal::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.GetKillerActor
// 0x0008 (0x0008 - 0x0000)
struct ManProjectile_GetKillerActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_GetKillerActor) == 0x000008, "Wrong alignment on ManProjectile_GetKillerActor");
static_assert(sizeof(ManProjectile_GetKillerActor) == 0x000008, "Wrong size on ManProjectile_GetKillerActor");
static_assert(offsetof(ManProjectile_GetKillerActor, ReturnValue) == 0x000000, "Member 'ManProjectile_GetKillerActor::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.GetKillerDamageType
// 0x0001 (0x0001 - 0x0000)
struct ManProjectile_GetKillerDamageType final
{
public:
	EDamageType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_GetKillerDamageType) == 0x000001, "Wrong alignment on ManProjectile_GetKillerDamageType");
static_assert(sizeof(ManProjectile_GetKillerDamageType) == 0x000001, "Wrong size on ManProjectile_GetKillerDamageType");
static_assert(offsetof(ManProjectile_GetKillerDamageType, ReturnValue) == 0x000000, "Member 'ManProjectile_GetKillerDamageType::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.GetProjectileVelocity
// 0x000C (0x000C - 0x0000)
struct ManProjectile_GetProjectileVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_GetProjectileVelocity) == 0x000004, "Wrong alignment on ManProjectile_GetProjectileVelocity");
static_assert(sizeof(ManProjectile_GetProjectileVelocity) == 0x00000C, "Wrong size on ManProjectile_GetProjectileVelocity");
static_assert(offsetof(ManProjectile_GetProjectileVelocity, ReturnValue) == 0x000000, "Member 'ManProjectile_GetProjectileVelocity::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.GetTargetExtent
// 0x000C (0x000C - 0x0000)
struct ManProjectile_GetTargetExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_GetTargetExtent) == 0x000004, "Wrong alignment on ManProjectile_GetTargetExtent");
static_assert(sizeof(ManProjectile_GetTargetExtent) == 0x00000C, "Wrong size on ManProjectile_GetTargetExtent");
static_assert(offsetof(ManProjectile_GetTargetExtent, ReturnValue) == 0x000000, "Member 'ManProjectile_GetTargetExtent::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.HasImpactSurface
// 0x0001 (0x0001 - 0x0000)
struct ManProjectile_HasImpactSurface final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_HasImpactSurface) == 0x000001, "Wrong alignment on ManProjectile_HasImpactSurface");
static_assert(sizeof(ManProjectile_HasImpactSurface) == 0x000001, "Wrong size on ManProjectile_HasImpactSurface");
static_assert(offsetof(ManProjectile_HasImpactSurface, ReturnValue) == 0x000000, "Member 'ManProjectile_HasImpactSurface::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.IsParried
// 0x0001 (0x0001 - 0x0000)
struct ManProjectile_IsParried final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_IsParried) == 0x000001, "Wrong alignment on ManProjectile_IsParried");
static_assert(sizeof(ManProjectile_IsParried) == 0x000001, "Wrong size on ManProjectile_IsParried");
static_assert(offsetof(ManProjectile_IsParried, ReturnValue) == 0x000000, "Member 'ManProjectile_IsParried::ReturnValue' has a wrong offset!");

// Function man.ManProjectile.OnStaticObjectPostCollide
// 0x0010 (0x0010 - 0x0000)
struct ManProjectile_OnStaticObjectPostCollide final
{
public:
	TArray<struct FHitResult>                     HitResult;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_OnStaticObjectPostCollide) == 0x000008, "Wrong alignment on ManProjectile_OnStaticObjectPostCollide");
static_assert(sizeof(ManProjectile_OnStaticObjectPostCollide) == 0x000010, "Wrong size on ManProjectile_OnStaticObjectPostCollide");
static_assert(offsetof(ManProjectile_OnStaticObjectPostCollide, HitResult) == 0x000000, "Member 'ManProjectile_OnStaticObjectPostCollide::HitResult' has a wrong offset!");

// Function man.ManProjectile.OnStaticObjectPreCollide
// 0x0010 (0x0010 - 0x0000)
struct ManProjectile_OnStaticObjectPreCollide final
{
public:
	TArray<struct FHitResult>                     HitResult;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManProjectile_OnStaticObjectPreCollide) == 0x000008, "Wrong alignment on ManProjectile_OnStaticObjectPreCollide");
static_assert(sizeof(ManProjectile_OnStaticObjectPreCollide) == 0x000010, "Wrong size on ManProjectile_OnStaticObjectPreCollide");
static_assert(offsetof(ManProjectile_OnStaticObjectPreCollide, HitResult) == 0x000000, "Member 'ManProjectile_OnStaticObjectPreCollide::HitResult' has a wrong offset!");

// Function man.MotesOfChaosPassive.AbilityChaos
// 0x0008 (0x0008 - 0x0000)
struct MotesOfChaosPassive_AbilityChaos final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotesOfChaosPassive_AbilityChaos) == 0x000008, "Wrong alignment on MotesOfChaosPassive_AbilityChaos");
static_assert(sizeof(MotesOfChaosPassive_AbilityChaos) == 0x000008, "Wrong size on MotesOfChaosPassive_AbilityChaos");
static_assert(offsetof(MotesOfChaosPassive_AbilityChaos, Ability) == 0x000000, "Member 'MotesOfChaosPassive_AbilityChaos::Ability' has a wrong offset!");

// Function man.MotesOfChaosPassive.AbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct MotesOfChaosPassive_AbilityStarted final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MotesOfChaosPassive_AbilityStarted) == 0x000008, "Wrong alignment on MotesOfChaosPassive_AbilityStarted");
static_assert(sizeof(MotesOfChaosPassive_AbilityStarted) == 0x000010, "Wrong size on MotesOfChaosPassive_AbilityStarted");
static_assert(offsetof(MotesOfChaosPassive_AbilityStarted, Ability) == 0x000000, "Member 'MotesOfChaosPassive_AbilityStarted::Ability' has a wrong offset!");
static_assert(offsetof(MotesOfChaosPassive_AbilityStarted, bDesired) == 0x000008, "Member 'MotesOfChaosPassive_AbilityStarted::bDesired' has a wrong offset!");

// Function man.MotesOfChaosPassive.DamageCasued
// 0x02D8 (0x02D8 - 0x0000)
struct MotesOfChaosPassive_DamageCasued final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotesOfChaosPassive_DamageCasued) == 0x000008, "Wrong alignment on MotesOfChaosPassive_DamageCasued");
static_assert(sizeof(MotesOfChaosPassive_DamageCasued) == 0x0002D8, "Wrong size on MotesOfChaosPassive_DamageCasued");
static_assert(offsetof(MotesOfChaosPassive_DamageCasued, Param) == 0x000000, "Member 'MotesOfChaosPassive_DamageCasued::Param' has a wrong offset!");

// Function man.MotesOfChaosPassive.ResourceUsed
// 0x0008 (0x0008 - 0x0000)
struct MotesOfChaosPassive_ResourceUsed final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotesOfChaosPassive_ResourceUsed) == 0x000008, "Wrong alignment on MotesOfChaosPassive_ResourceUsed");
static_assert(sizeof(MotesOfChaosPassive_ResourceUsed) == 0x000008, "Wrong size on MotesOfChaosPassive_ResourceUsed");
static_assert(offsetof(MotesOfChaosPassive_ResourceUsed, Ability) == 0x000000, "Member 'MotesOfChaosPassive_ResourceUsed::Ability' has a wrong offset!");

// Function man.MotesOfChaosPassive.StatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct MotesOfChaosPassive_StatusEffectCaused final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotesOfChaosPassive_StatusEffectCaused) == 0x000008, "Wrong alignment on MotesOfChaosPassive_StatusEffectCaused");
static_assert(sizeof(MotesOfChaosPassive_StatusEffectCaused) == 0x000018, "Wrong size on MotesOfChaosPassive_StatusEffectCaused");
static_assert(offsetof(MotesOfChaosPassive_StatusEffectCaused, TargetActor) == 0x000000, "Member 'MotesOfChaosPassive_StatusEffectCaused::TargetActor' has a wrong offset!");
static_assert(offsetof(MotesOfChaosPassive_StatusEffectCaused, Type) == 0x000008, "Member 'MotesOfChaosPassive_StatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(MotesOfChaosPassive_StatusEffectCaused, IsNewEffect) == 0x000009, "Member 'MotesOfChaosPassive_StatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(MotesOfChaosPassive_StatusEffectCaused, Instance) == 0x000010, "Member 'MotesOfChaosPassive_StatusEffectCaused::Instance' has a wrong offset!");

// Function man.FinishEm.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct FinishEm_OnAbilityEnded final
{
public:
	class UAbilityBase*                           EndedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FinishEm_OnAbilityEnded) == 0x000008, "Wrong alignment on FinishEm_OnAbilityEnded");
static_assert(sizeof(FinishEm_OnAbilityEnded) == 0x000008, "Wrong size on FinishEm_OnAbilityEnded");
static_assert(offsetof(FinishEm_OnAbilityEnded, EndedAbility) == 0x000000, "Member 'FinishEm_OnAbilityEnded::EndedAbility' has a wrong offset!");

// Function man.FinishEm.OnPostAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct FinishEm_OnPostAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FinishEm_OnPostAbilityStarted) == 0x000008, "Wrong alignment on FinishEm_OnPostAbilityStarted");
static_assert(sizeof(FinishEm_OnPostAbilityStarted) == 0x000010, "Wrong size on FinishEm_OnPostAbilityStarted");
static_assert(offsetof(FinishEm_OnPostAbilityStarted, StartedAbility) == 0x000000, "Member 'FinishEm_OnPostAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(FinishEm_OnPostAbilityStarted, bDesired) == 0x000008, "Member 'FinishEm_OnPostAbilityStarted::bDesired' has a wrong offset!");

// Function man.WildFire.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct WildFire_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WildFire_OnPreDamageCaused) == 0x000008, "Wrong alignment on WildFire_OnPreDamageCaused");
static_assert(sizeof(WildFire_OnPreDamageCaused) == 0x0002D8, "Wrong size on WildFire_OnPreDamageCaused");
static_assert(offsetof(WildFire_OnPreDamageCaused, Param) == 0x000000, "Member 'WildFire_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.AddAbilityInAreaComponent.GetDamageHBounds
// 0x0008 (0x0008 - 0x0000)
struct AddAbilityInAreaComponent_GetDamageHBounds final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AddAbilityInAreaComponent_GetDamageHBounds) == 0x000004, "Wrong alignment on AddAbilityInAreaComponent_GetDamageHBounds");
static_assert(sizeof(AddAbilityInAreaComponent_GetDamageHBounds) == 0x000008, "Wrong size on AddAbilityInAreaComponent_GetDamageHBounds");
static_assert(offsetof(AddAbilityInAreaComponent_GetDamageHBounds, ReturnValue) == 0x000000, "Member 'AddAbilityInAreaComponent_GetDamageHBounds::ReturnValue' has a wrong offset!");

// Function man.MomentumPassive.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct MomentumPassive_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MomentumPassive_PostDamageDealt) == 0x000008, "Wrong alignment on MomentumPassive_PostDamageDealt");
static_assert(sizeof(MomentumPassive_PostDamageDealt) == 0x0002D8, "Wrong size on MomentumPassive_PostDamageDealt");
static_assert(offsetof(MomentumPassive_PostDamageDealt, Param) == 0x000000, "Member 'MomentumPassive_PostDamageDealt::Param' has a wrong offset!");

// Function man.SpellPenetration.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpellPenetration_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellPenetration_OnPreDamageCaused) == 0x000008, "Wrong alignment on SpellPenetration_OnPreDamageCaused");
static_assert(sizeof(SpellPenetration_OnPreDamageCaused) == 0x0002D8, "Wrong size on SpellPenetration_OnPreDamageCaused");
static_assert(offsetof(SpellPenetration_OnPreDamageCaused, Param) == 0x000000, "Member 'SpellPenetration_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.ManTriggerVolumePureBase.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManTriggerVolumePureBase_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManTriggerVolumePureBase_OnBeginOverlap) == 0x000008, "Wrong alignment on ManTriggerVolumePureBase_OnBeginOverlap");
static_assert(sizeof(ManTriggerVolumePureBase_OnBeginOverlap) == 0x000010, "Wrong size on ManTriggerVolumePureBase_OnBeginOverlap");
static_assert(offsetof(ManTriggerVolumePureBase_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'ManTriggerVolumePureBase_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManTriggerVolumePureBase_OnBeginOverlap, OtherActor) == 0x000008, "Member 'ManTriggerVolumePureBase_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.ManTriggerVolumePureBase.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManTriggerVolumePureBase_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManTriggerVolumePureBase_OnEndOverlap) == 0x000008, "Wrong alignment on ManTriggerVolumePureBase_OnEndOverlap");
static_assert(sizeof(ManTriggerVolumePureBase_OnEndOverlap) == 0x000010, "Wrong size on ManTriggerVolumePureBase_OnEndOverlap");
static_assert(offsetof(ManTriggerVolumePureBase_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'ManTriggerVolumePureBase_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManTriggerVolumePureBase_OnEndOverlap, OtherActor) == 0x000008, "Member 'ManTriggerVolumePureBase_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.LevelUpWindowUserWidget.OnSetDefaultLevelDiff
// 0x0004 (0x0004 - 0x0000)
struct LevelUpWindowUserWidget_OnSetDefaultLevelDiff final
{
public:
	int32                                         InDefaultLevelDiff;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelUpWindowUserWidget_OnSetDefaultLevelDiff) == 0x000004, "Wrong alignment on LevelUpWindowUserWidget_OnSetDefaultLevelDiff");
static_assert(sizeof(LevelUpWindowUserWidget_OnSetDefaultLevelDiff) == 0x000004, "Wrong size on LevelUpWindowUserWidget_OnSetDefaultLevelDiff");
static_assert(offsetof(LevelUpWindowUserWidget_OnSetDefaultLevelDiff, InDefaultLevelDiff) == 0x000000, "Member 'LevelUpWindowUserWidget_OnSetDefaultLevelDiff::InDefaultLevelDiff' has a wrong offset!");

// Function man.LevelUpWindowUserWidget.OnSetMaxLevelText
// 0x0018 (0x0018 - 0x0000)
struct LevelUpWindowUserWidget_OnSetMaxLevelText final
{
public:
	class FText                                   InMaxLevelText;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelUpWindowUserWidget_OnSetMaxLevelText) == 0x000008, "Wrong alignment on LevelUpWindowUserWidget_OnSetMaxLevelText");
static_assert(sizeof(LevelUpWindowUserWidget_OnSetMaxLevelText) == 0x000018, "Wrong size on LevelUpWindowUserWidget_OnSetMaxLevelText");
static_assert(offsetof(LevelUpWindowUserWidget_OnSetMaxLevelText, InMaxLevelText) == 0x000000, "Member 'LevelUpWindowUserWidget_OnSetMaxLevelText::InMaxLevelText' has a wrong offset!");

// Function man.DialogueActor.OnTriggerVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct DialogueActor_OnTriggerVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DialogueActor_OnTriggerVolumeOverlap) == 0x000008, "Wrong alignment on DialogueActor_OnTriggerVolumeOverlap");
static_assert(sizeof(DialogueActor_OnTriggerVolumeOverlap) == 0x000010, "Wrong size on DialogueActor_OnTriggerVolumeOverlap");
static_assert(offsetof(DialogueActor_OnTriggerVolumeOverlap, OverlappedActor) == 0x000000, "Member 'DialogueActor_OnTriggerVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(DialogueActor_OnTriggerVolumeOverlap, OtherActor) == 0x000008, "Member 'DialogueActor_OnTriggerVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.HeatingUpEffect.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct HeatingUpEffect_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeatingUpEffect_OnPreDamageCaused) == 0x000008, "Wrong alignment on HeatingUpEffect_OnPreDamageCaused");
static_assert(sizeof(HeatingUpEffect_OnPreDamageCaused) == 0x0002D8, "Wrong size on HeatingUpEffect_OnPreDamageCaused");
static_assert(offsetof(HeatingUpEffect_OnPreDamageCaused, Param) == 0x000000, "Member 'HeatingUpEffect_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.MapExplorationGridVolume.OnMapGridVolumeBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct MapExplorationGridVolume_OnMapGridVolumeBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapExplorationGridVolume_OnMapGridVolumeBeginOverlap) == 0x000008, "Wrong alignment on MapExplorationGridVolume_OnMapGridVolumeBeginOverlap");
static_assert(sizeof(MapExplorationGridVolume_OnMapGridVolumeBeginOverlap) == 0x000010, "Wrong size on MapExplorationGridVolume_OnMapGridVolumeBeginOverlap");
static_assert(offsetof(MapExplorationGridVolume_OnMapGridVolumeBeginOverlap, OverlappedActor) == 0x000000, "Member 'MapExplorationGridVolume_OnMapGridVolumeBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(MapExplorationGridVolume_OnMapGridVolumeBeginOverlap, OtherActor) == 0x000008, "Member 'MapExplorationGridVolume_OnMapGridVolumeBeginOverlap::OtherActor' has a wrong offset!");

// Function man.AdditionalDamageOnDamageDone.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct AdditionalDamageOnDamageDone_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AdditionalDamageOnDamageDone_OnPostDamageCaused) == 0x000008, "Wrong alignment on AdditionalDamageOnDamageDone_OnPostDamageCaused");
static_assert(sizeof(AdditionalDamageOnDamageDone_OnPostDamageCaused) == 0x0002D8, "Wrong size on AdditionalDamageOnDamageDone_OnPostDamageCaused");
static_assert(offsetof(AdditionalDamageOnDamageDone_OnPostDamageCaused, Param) == 0x000000, "Member 'AdditionalDamageOnDamageDone_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.AdditionalDamageOnDamageDone.OnPostDamageCausedGroupFinished
// 0x0028 (0x0028 - 0x0000)
struct AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished final
{
public:
	int32                                         DamageGroupID;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageValue>                   DamageValues;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished) == 0x000008, "Wrong alignment on AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished");
static_assert(sizeof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished) == 0x000028, "Wrong size on AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished");
static_assert(offsetof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished, DamageGroupID) == 0x000000, "Member 'AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished::DamageGroupID' has a wrong offset!");
static_assert(offsetof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished, Source) == 0x000008, "Member 'AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished::Source' has a wrong offset!");
static_assert(offsetof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished, Target) == 0x000010, "Member 'AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished::Target' has a wrong offset!");
static_assert(offsetof(AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished, DamageValues) == 0x000018, "Member 'AdditionalDamageOnDamageDone_OnPostDamageCausedGroupFinished::DamageValues' has a wrong offset!");

// Function man.HealOverTimeEffectAbilityComponent.OnLanternStateSwitched
// 0x0001 (0x0001 - 0x0000)
struct HealOverTimeEffectAbilityComponent_OnLanternStateSwitched final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealOverTimeEffectAbilityComponent_OnLanternStateSwitched) == 0x000001, "Wrong alignment on HealOverTimeEffectAbilityComponent_OnLanternStateSwitched");
static_assert(sizeof(HealOverTimeEffectAbilityComponent_OnLanternStateSwitched) == 0x000001, "Wrong size on HealOverTimeEffectAbilityComponent_OnLanternStateSwitched");
static_assert(offsetof(HealOverTimeEffectAbilityComponent_OnLanternStateSwitched, bActive) == 0x000000, "Member 'HealOverTimeEffectAbilityComponent_OnLanternStateSwitched::bActive' has a wrong offset!");

// Function man.Charge_AbilityComponent.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct Charge_AbilityComponent_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Charge_AbilityComponent_IsCollideSignature) == 0x000008, "Wrong alignment on Charge_AbilityComponent_IsCollideSignature");
static_assert(sizeof(Charge_AbilityComponent_IsCollideSignature) == 0x000010, "Wrong size on Charge_AbilityComponent_IsCollideSignature");
static_assert(offsetof(Charge_AbilityComponent_IsCollideSignature, Actor) == 0x000000, "Member 'Charge_AbilityComponent_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(Charge_AbilityComponent_IsCollideSignature, bOverride) == 0x000008, "Member 'Charge_AbilityComponent_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(Charge_AbilityComponent_IsCollideSignature, bCollide) == 0x000009, "Member 'Charge_AbilityComponent_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.GrowCollectibleActor.GetGrowthPercent
// 0x0004 (0x0004 - 0x0000)
struct GrowCollectibleActor_GetGrowthPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrowCollectibleActor_GetGrowthPercent) == 0x000004, "Wrong alignment on GrowCollectibleActor_GetGrowthPercent");
static_assert(sizeof(GrowCollectibleActor_GetGrowthPercent) == 0x000004, "Wrong size on GrowCollectibleActor_GetGrowthPercent");
static_assert(offsetof(GrowCollectibleActor_GetGrowthPercent, ReturnValue) == 0x000000, "Member 'GrowCollectibleActor_GetGrowthPercent::ReturnValue' has a wrong offset!");

// Function man.GrowCollectibleActor.Harvestable
// 0x0001 (0x0001 - 0x0000)
struct GrowCollectibleActor_Harvestable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrowCollectibleActor_Harvestable) == 0x000001, "Wrong alignment on GrowCollectibleActor_Harvestable");
static_assert(sizeof(GrowCollectibleActor_Harvestable) == 0x000001, "Wrong size on GrowCollectibleActor_Harvestable");
static_assert(offsetof(GrowCollectibleActor_Harvestable, ReturnValue) == 0x000000, "Member 'GrowCollectibleActor_Harvestable::ReturnValue' has a wrong offset!");

// Function man.GrowCollectibleActor.OnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct GrowCollectibleActor_OnGameplayEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrowCollectibleActor_OnGameplayEvent) == 0x000008, "Wrong alignment on GrowCollectibleActor_OnGameplayEvent");
static_assert(sizeof(GrowCollectibleActor_OnGameplayEvent) == 0x000020, "Wrong size on GrowCollectibleActor_OnGameplayEvent");
static_assert(offsetof(GrowCollectibleActor_OnGameplayEvent, InAbilityController) == 0x000000, "Member 'GrowCollectibleActor_OnGameplayEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(GrowCollectibleActor_OnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'GrowCollectibleActor_OnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(GrowCollectibleActor_OnGameplayEvent, CustomName) == 0x000010, "Member 'GrowCollectibleActor_OnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(GrowCollectibleActor_OnGameplayEvent, paramActorSoul) == 0x000018, "Member 'GrowCollectibleActor_OnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.GrowCollectibleActor.OnPostHardSleepChanged
// 0x0001 (0x0001 - 0x0000)
struct GrowCollectibleActor_OnPostHardSleepChanged final
{
public:
	bool                                          bSleep;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrowCollectibleActor_OnPostHardSleepChanged) == 0x000001, "Wrong alignment on GrowCollectibleActor_OnPostHardSleepChanged");
static_assert(sizeof(GrowCollectibleActor_OnPostHardSleepChanged) == 0x000001, "Wrong size on GrowCollectibleActor_OnPostHardSleepChanged");
static_assert(offsetof(GrowCollectibleActor_OnPostHardSleepChanged, bSleep) == 0x000000, "Member 'GrowCollectibleActor_OnPostHardSleepChanged::bSleep' has a wrong offset!");

// Function man.LoadMapSlotUserWidget.OnSetSlot
// 0x0008 (0x0008 - 0x0000)
struct LoadMapSlotUserWidget_OnSetSlot final
{
public:
	class FName                                   InSlotName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapSlotUserWidget_OnSetSlot) == 0x000004, "Wrong alignment on LoadMapSlotUserWidget_OnSetSlot");
static_assert(sizeof(LoadMapSlotUserWidget_OnSetSlot) == 0x000008, "Wrong size on LoadMapSlotUserWidget_OnSetSlot");
static_assert(offsetof(LoadMapSlotUserWidget_OnSetSlot, InSlotName) == 0x000000, "Member 'LoadMapSlotUserWidget_OnSetSlot::InSlotName' has a wrong offset!");

// Function man.DefendAbility.IsInStateDefend
// 0x0001 (0x0001 - 0x0000)
struct DefendAbility_IsInStateDefend final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefendAbility_IsInStateDefend) == 0x000001, "Wrong alignment on DefendAbility_IsInStateDefend");
static_assert(sizeof(DefendAbility_IsInStateDefend) == 0x000001, "Wrong size on DefendAbility_IsInStateDefend");
static_assert(offsetof(DefendAbility_IsInStateDefend, ReturnValue) == 0x000000, "Member 'DefendAbility_IsInStateDefend::ReturnValue' has a wrong offset!");

// Function man.DefendAbility.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct DefendAbility_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefendAbility_OnPreDamagedPriority) == 0x000008, "Wrong alignment on DefendAbility_OnPreDamagedPriority");
static_assert(sizeof(DefendAbility_OnPreDamagedPriority) == 0x0002D8, "Wrong size on DefendAbility_OnPreDamagedPriority");
static_assert(offsetof(DefendAbility_OnPreDamagedPriority, Param) == 0x000000, "Member 'DefendAbility_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.CustomEventOnGlobalAbilityAnimEvent.OnAbilityAnimEvent
// 0x0018 (0x0018 - 0x0000)
struct CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                InAnim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                InAnimEventType;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent) == 0x000008, "Wrong alignment on CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent");
static_assert(sizeof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent) == 0x000018, "Wrong size on CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent");
static_assert(offsetof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent, InAbility) == 0x000000, "Member 'CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent::InAbility' has a wrong offset!");
static_assert(offsetof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent, InAnim) == 0x000008, "Member 'CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent::InAnim' has a wrong offset!");
static_assert(offsetof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent, InAnimEventType) == 0x000010, "Member 'CustomEventOnGlobalAbilityAnimEvent_OnAbilityAnimEvent::InAnimEventType' has a wrong offset!");

// Function man.CustomEventOnGlobalAbilityAnimEvent.OnAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded final
{
public:
	class UAbilityBase*                           EndedAbility;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded) == 0x000008, "Wrong alignment on CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded");
static_assert(sizeof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded) == 0x000008, "Wrong size on CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded");
static_assert(offsetof(CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded, EndedAbility) == 0x000000, "Member 'CustomEventOnGlobalAbilityAnimEvent_OnAbilityEnded::EndedAbility' has a wrong offset!");

// Function man.HitCounter_AbilityComponent.OnPostDamage
// 0x02D8 (0x02D8 - 0x0000)
struct HitCounter_AbilityComponent_OnPostDamage final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitCounter_AbilityComponent_OnPostDamage) == 0x000008, "Wrong alignment on HitCounter_AbilityComponent_OnPostDamage");
static_assert(sizeof(HitCounter_AbilityComponent_OnPostDamage) == 0x0002D8, "Wrong size on HitCounter_AbilityComponent_OnPostDamage");
static_assert(offsetof(HitCounter_AbilityComponent_OnPostDamage, Param) == 0x000000, "Member 'HitCounter_AbilityComponent_OnPostDamage::Param' has a wrong offset!");

// Function man.ChaoticRejuvenationPassive.ChaosTriggered
// 0x0008 (0x0008 - 0x0000)
struct ChaoticRejuvenationPassive_ChaosTriggered final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRejuvenationPassive_ChaosTriggered) == 0x000008, "Wrong alignment on ChaoticRejuvenationPassive_ChaosTriggered");
static_assert(sizeof(ChaoticRejuvenationPassive_ChaosTriggered) == 0x000008, "Wrong size on ChaoticRejuvenationPassive_ChaosTriggered");
static_assert(offsetof(ChaoticRejuvenationPassive_ChaosTriggered, Ability) == 0x000000, "Member 'ChaoticRejuvenationPassive_ChaosTriggered::Ability' has a wrong offset!");

// Function man.ChaoticRejuvenationPassive.StatusEffectApplied
// 0x0018 (0x0018 - 0x0000)
struct ChaoticRejuvenationPassive_StatusEffectApplied final
{
public:
	class AActor*                                 effecttarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRejuvenationPassive_StatusEffectApplied) == 0x000008, "Wrong alignment on ChaoticRejuvenationPassive_StatusEffectApplied");
static_assert(sizeof(ChaoticRejuvenationPassive_StatusEffectApplied) == 0x000018, "Wrong size on ChaoticRejuvenationPassive_StatusEffectApplied");
static_assert(offsetof(ChaoticRejuvenationPassive_StatusEffectApplied, effecttarget) == 0x000000, "Member 'ChaoticRejuvenationPassive_StatusEffectApplied::effecttarget' has a wrong offset!");
static_assert(offsetof(ChaoticRejuvenationPassive_StatusEffectApplied, Type) == 0x000008, "Member 'ChaoticRejuvenationPassive_StatusEffectApplied::Type' has a wrong offset!");
static_assert(offsetof(ChaoticRejuvenationPassive_StatusEffectApplied, IsNewEffect) == 0x000009, "Member 'ChaoticRejuvenationPassive_StatusEffectApplied::IsNewEffect' has a wrong offset!");
static_assert(offsetof(ChaoticRejuvenationPassive_StatusEffectApplied, Instance) == 0x000010, "Member 'ChaoticRejuvenationPassive_StatusEffectApplied::Instance' has a wrong offset!");

// Function man.QuestManagerComponent.OnInfoScreenClose
// 0x0008 (0x0008 - 0x0000)
struct QuestManagerComponent_OnInfoScreenClose final
{
public:
	class UInfoScreentDataAsset*                  InfoScreenData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestManagerComponent_OnInfoScreenClose) == 0x000008, "Wrong alignment on QuestManagerComponent_OnInfoScreenClose");
static_assert(sizeof(QuestManagerComponent_OnInfoScreenClose) == 0x000008, "Wrong size on QuestManagerComponent_OnInfoScreenClose");
static_assert(offsetof(QuestManagerComponent_OnInfoScreenClose, InfoScreenData) == 0x000000, "Member 'QuestManagerComponent_OnInfoScreenClose::InfoScreenData' has a wrong offset!");

// Function man.SubtitleUserWidget.OnMoveToNormal
// 0x0004 (0x0004 - 0x0000)
struct SubtitleUserWidget_OnMoveToNormal final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SubtitleUserWidget_OnMoveToNormal) == 0x000004, "Wrong alignment on SubtitleUserWidget_OnMoveToNormal");
static_assert(sizeof(SubtitleUserWidget_OnMoveToNormal) == 0x000004, "Wrong size on SubtitleUserWidget_OnMoveToNormal");
static_assert(offsetof(SubtitleUserWidget_OnMoveToNormal, AnimDuration) == 0x000000, "Member 'SubtitleUserWidget_OnMoveToNormal::AnimDuration' has a wrong offset!");

// Function man.SubtitleUserWidget.OnMoveToUltrawide
// 0x0004 (0x0004 - 0x0000)
struct SubtitleUserWidget_OnMoveToUltrawide final
{
public:
	float                                         AnimDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SubtitleUserWidget_OnMoveToUltrawide) == 0x000004, "Wrong alignment on SubtitleUserWidget_OnMoveToUltrawide");
static_assert(sizeof(SubtitleUserWidget_OnMoveToUltrawide) == 0x000004, "Wrong size on SubtitleUserWidget_OnMoveToUltrawide");
static_assert(offsetof(SubtitleUserWidget_OnMoveToUltrawide, AnimDuration) == 0x000000, "Member 'SubtitleUserWidget_OnMoveToUltrawide::AnimDuration' has a wrong offset!");

// Function man.SubtitleUserWidget.OnShowSubtitleText
// 0x0030 (0x0030 - 0x0000)
struct SubtitleUserWidget_OnShowSubtitleText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InLineIDText;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SubtitleUserWidget_OnShowSubtitleText) == 0x000008, "Wrong alignment on SubtitleUserWidget_OnShowSubtitleText");
static_assert(sizeof(SubtitleUserWidget_OnShowSubtitleText) == 0x000030, "Wrong size on SubtitleUserWidget_OnShowSubtitleText");
static_assert(offsetof(SubtitleUserWidget_OnShowSubtitleText, InText) == 0x000000, "Member 'SubtitleUserWidget_OnShowSubtitleText::InText' has a wrong offset!");
static_assert(offsetof(SubtitleUserWidget_OnShowSubtitleText, InLineIDText) == 0x000018, "Member 'SubtitleUserWidget_OnShowSubtitleText::InLineIDText' has a wrong offset!");

// Function man.SubtitleUserWidget.OnSubtitleEnable
// 0x0001 (0x0001 - 0x0000)
struct SubtitleUserWidget_OnSubtitleEnable final
{
public:
	bool                                          bSubtitleEnable;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SubtitleUserWidget_OnSubtitleEnable) == 0x000001, "Wrong alignment on SubtitleUserWidget_OnSubtitleEnable");
static_assert(sizeof(SubtitleUserWidget_OnSubtitleEnable) == 0x000001, "Wrong size on SubtitleUserWidget_OnSubtitleEnable");
static_assert(offsetof(SubtitleUserWidget_OnSubtitleEnable, bSubtitleEnable) == 0x000000, "Member 'SubtitleUserWidget_OnSubtitleEnable::bSubtitleEnable' has a wrong offset!");

// Function man.HeightenedSensesAbilityComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct HeightenedSensesAbilityComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeightenedSensesAbilityComponent_OnPreDamaged) == 0x000008, "Wrong alignment on HeightenedSensesAbilityComponent_OnPreDamaged");
static_assert(sizeof(HeightenedSensesAbilityComponent_OnPreDamaged) == 0x0002D8, "Wrong size on HeightenedSensesAbilityComponent_OnPreDamaged");
static_assert(offsetof(HeightenedSensesAbilityComponent_OnPreDamaged, Param) == 0x000000, "Member 'HeightenedSensesAbilityComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.CustomEventOnItemSlotChange.OnInventorySlotChanged
// 0x0010 (0x0010 - 0x0000)
struct CustomEventOnItemSlotChange_OnInventorySlotChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnItemSlotChange_OnInventorySlotChanged) == 0x000008, "Wrong alignment on CustomEventOnItemSlotChange_OnInventorySlotChanged");
static_assert(sizeof(CustomEventOnItemSlotChange_OnInventorySlotChanged) == 0x000010, "Wrong size on CustomEventOnItemSlotChange_OnInventorySlotChanged");
static_assert(offsetof(CustomEventOnItemSlotChange_OnInventorySlotChanged, SourceSlot) == 0x000000, "Member 'CustomEventOnItemSlotChange_OnInventorySlotChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(CustomEventOnItemSlotChange_OnInventorySlotChanged, DestinationSlot) == 0x000008, "Member 'CustomEventOnItemSlotChange_OnInventorySlotChanged::DestinationSlot' has a wrong offset!");

// Function man.CustomEventOnItemSlotChange.OnPreRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct CustomEventOnItemSlotChange_OnPreRemoveItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RemovedItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnItemSlotChange_OnPreRemoveItem) == 0x000008, "Wrong alignment on CustomEventOnItemSlotChange_OnPreRemoveItem");
static_assert(sizeof(CustomEventOnItemSlotChange_OnPreRemoveItem) == 0x000010, "Wrong size on CustomEventOnItemSlotChange_OnPreRemoveItem");
static_assert(offsetof(CustomEventOnItemSlotChange_OnPreRemoveItem, InventorySlot) == 0x000000, "Member 'CustomEventOnItemSlotChange_OnPreRemoveItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(CustomEventOnItemSlotChange_OnPreRemoveItem, RemovedItem) == 0x000008, "Member 'CustomEventOnItemSlotChange_OnPreRemoveItem::RemovedItem' has a wrong offset!");

// Function man.CustomEventOnCodeEvent.OnPostAbilitySlotRotated
// 0x0004 (0x0004 - 0x0000)
struct CustomEventOnCodeEvent_OnPostAbilitySlotRotated final
{
public:
	int32                                         CurrectSubslot;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnCodeEvent_OnPostAbilitySlotRotated) == 0x000004, "Wrong alignment on CustomEventOnCodeEvent_OnPostAbilitySlotRotated");
static_assert(sizeof(CustomEventOnCodeEvent_OnPostAbilitySlotRotated) == 0x000004, "Wrong size on CustomEventOnCodeEvent_OnPostAbilitySlotRotated");
static_assert(offsetof(CustomEventOnCodeEvent_OnPostAbilitySlotRotated, CurrectSubslot) == 0x000000, "Member 'CustomEventOnCodeEvent_OnPostAbilitySlotRotated::CurrectSubslot' has a wrong offset!");

// Function man.CustomEventOnCodeEvent.OnSkillTreeReset
// 0x0008 (0x0008 - 0x0000)
struct CustomEventOnCodeEvent_OnSkillTreeReset final
{
public:
	class UPrimalSkillTree*                       Tree;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnCodeEvent_OnSkillTreeReset) == 0x000008, "Wrong alignment on CustomEventOnCodeEvent_OnSkillTreeReset");
static_assert(sizeof(CustomEventOnCodeEvent_OnSkillTreeReset) == 0x000008, "Wrong size on CustomEventOnCodeEvent_OnSkillTreeReset");
static_assert(offsetof(CustomEventOnCodeEvent_OnSkillTreeReset, Tree) == 0x000000, "Member 'CustomEventOnCodeEvent_OnSkillTreeReset::Tree' has a wrong offset!");

// Function man.BountyBoardNoteUserWidget.OnSetAccepted
// 0x0001 (0x0001 - 0x0000)
struct BountyBoardNoteUserWidget_OnSetAccepted final
{
public:
	bool                                          bInAccepted;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BountyBoardNoteUserWidget_OnSetAccepted) == 0x000001, "Wrong alignment on BountyBoardNoteUserWidget_OnSetAccepted");
static_assert(sizeof(BountyBoardNoteUserWidget_OnSetAccepted) == 0x000001, "Wrong size on BountyBoardNoteUserWidget_OnSetAccepted");
static_assert(offsetof(BountyBoardNoteUserWidget_OnSetAccepted, bInAccepted) == 0x000000, "Member 'BountyBoardNoteUserWidget_OnSetAccepted::bInAccepted' has a wrong offset!");

// Function man.BountyBoardNoteUserWidget.OnSetCompleted
// 0x0002 (0x0002 - 0x0000)
struct BountyBoardNoteUserWidget_OnSetCompleted final
{
public:
	bool                                          bInCompleted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPlayCompleteAnim;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BountyBoardNoteUserWidget_OnSetCompleted) == 0x000001, "Wrong alignment on BountyBoardNoteUserWidget_OnSetCompleted");
static_assert(sizeof(BountyBoardNoteUserWidget_OnSetCompleted) == 0x000002, "Wrong size on BountyBoardNoteUserWidget_OnSetCompleted");
static_assert(offsetof(BountyBoardNoteUserWidget_OnSetCompleted, bInCompleted) == 0x000000, "Member 'BountyBoardNoteUserWidget_OnSetCompleted::bInCompleted' has a wrong offset!");
static_assert(offsetof(BountyBoardNoteUserWidget_OnSetCompleted, bInPlayCompleteAnim) == 0x000001, "Member 'BountyBoardNoteUserWidget_OnSetCompleted::bInPlayCompleteAnim' has a wrong offset!");

// Function man.CustomEventOnDamage.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct CustomEventOnDamage_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnDamage_OnPostDamageDone) == 0x000008, "Wrong alignment on CustomEventOnDamage_OnPostDamageDone");
static_assert(sizeof(CustomEventOnDamage_OnPostDamageDone) == 0x0002D8, "Wrong size on CustomEventOnDamage_OnPostDamageDone");
static_assert(offsetof(CustomEventOnDamage_OnPostDamageDone, DamageParams) == 0x000000, "Member 'CustomEventOnDamage_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.CustomEventOnDamage.OnPostDamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct CustomEventOnDamage_OnPostDamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnDamage_OnPostDamageTaken) == 0x000008, "Wrong alignment on CustomEventOnDamage_OnPostDamageTaken");
static_assert(sizeof(CustomEventOnDamage_OnPostDamageTaken) == 0x0002D8, "Wrong size on CustomEventOnDamage_OnPostDamageTaken");
static_assert(offsetof(CustomEventOnDamage_OnPostDamageTaken, DamageParams) == 0x000000, "Member 'CustomEventOnDamage_OnPostDamageTaken::DamageParams' has a wrong offset!");

// Function man.EquilibriumComponent.OnAbilityResourceConsumed
// 0x0008 (0x0008 - 0x0000)
struct EquilibriumComponent_OnAbilityResourceConsumed final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquilibriumComponent_OnAbilityResourceConsumed) == 0x000008, "Wrong alignment on EquilibriumComponent_OnAbilityResourceConsumed");
static_assert(sizeof(EquilibriumComponent_OnAbilityResourceConsumed) == 0x000008, "Wrong size on EquilibriumComponent_OnAbilityResourceConsumed");
static_assert(offsetof(EquilibriumComponent_OnAbilityResourceConsumed, StartedAbility) == 0x000000, "Member 'EquilibriumComponent_OnAbilityResourceConsumed::StartedAbility' has a wrong offset!");

// Function man.EquilibriumComponent.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct EquilibriumComponent_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquilibriumComponent_OnPreDamageCaused) == 0x000008, "Wrong alignment on EquilibriumComponent_OnPreDamageCaused");
static_assert(sizeof(EquilibriumComponent_OnPreDamageCaused) == 0x0002D8, "Wrong size on EquilibriumComponent_OnPreDamageCaused");
static_assert(offsetof(EquilibriumComponent_OnPreDamageCaused, Param) == 0x000000, "Member 'EquilibriumComponent_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.LinkActorsComponent.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct LinkActorsComponent_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LinkActorsComponent_OnPreDamagedPriority) == 0x000008, "Wrong alignment on LinkActorsComponent_OnPreDamagedPriority");
static_assert(sizeof(LinkActorsComponent_OnPreDamagedPriority) == 0x0002D8, "Wrong size on LinkActorsComponent_OnPreDamagedPriority");
static_assert(offsetof(LinkActorsComponent_OnPreDamagedPriority, Param) == 0x000000, "Member 'LinkActorsComponent_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.CustomEventOnHUDMessage.OnHudMessage
// 0x0001 (0x0001 - 0x0000)
struct CustomEventOnHUDMessage_OnHudMessage final
{
public:
	EHudMessage                                   Msg;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CustomEventOnHUDMessage_OnHudMessage) == 0x000001, "Wrong alignment on CustomEventOnHUDMessage_OnHudMessage");
static_assert(sizeof(CustomEventOnHUDMessage_OnHudMessage) == 0x000001, "Wrong size on CustomEventOnHUDMessage_OnHudMessage");
static_assert(offsetof(CustomEventOnHUDMessage_OnHudMessage, Msg) == 0x000000, "Member 'CustomEventOnHUDMessage_OnHudMessage::Msg' has a wrong offset!");

// Function man.GrabAndBite.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct GrabAndBite_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrabAndBite_OnPostDamageCaused) == 0x000008, "Wrong alignment on GrabAndBite_OnPostDamageCaused");
static_assert(sizeof(GrabAndBite_OnPostDamageCaused) == 0x0002D8, "Wrong size on GrabAndBite_OnPostDamageCaused");
static_assert(offsetof(GrabAndBite_OnPostDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'GrabAndBite_OnPostDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.ManageAbilityComponentsByModifier.OnAbilityModifierChanged
// 0x000C (0x000C - 0x0000)
struct ManageAbilityComponentsByModifier_OnAbilityModifierChanged final
{
public:
	bool                                          bAdded;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGeneralAbilityModifier                       GeneralID;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomID;                                          // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManageAbilityComponentsByModifier_OnAbilityModifierChanged) == 0x000004, "Wrong alignment on ManageAbilityComponentsByModifier_OnAbilityModifierChanged");
static_assert(sizeof(ManageAbilityComponentsByModifier_OnAbilityModifierChanged) == 0x00000C, "Wrong size on ManageAbilityComponentsByModifier_OnAbilityModifierChanged");
static_assert(offsetof(ManageAbilityComponentsByModifier_OnAbilityModifierChanged, bAdded) == 0x000000, "Member 'ManageAbilityComponentsByModifier_OnAbilityModifierChanged::bAdded' has a wrong offset!");
static_assert(offsetof(ManageAbilityComponentsByModifier_OnAbilityModifierChanged, GeneralID) == 0x000001, "Member 'ManageAbilityComponentsByModifier_OnAbilityModifierChanged::GeneralID' has a wrong offset!");
static_assert(offsetof(ManageAbilityComponentsByModifier_OnAbilityModifierChanged, CustomID) == 0x000004, "Member 'ManageAbilityComponentsByModifier_OnAbilityModifierChanged::CustomID' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnAddItem
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnAddItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnAddItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnAddItem");
static_assert(sizeof(CharacterWindowUserWidget_OnAddItem) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnAddItem");
static_assert(offsetof(CharacterWindowUserWidget_OnAddItem, InventorySlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnAddItem::InventorySlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnApplyEnchant
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnApplyEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnApplyEnchant) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnApplyEnchant");
static_assert(sizeof(CharacterWindowUserWidget_OnApplyEnchant) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnApplyEnchant");
static_assert(offsetof(CharacterWindowUserWidget_OnApplyEnchant, TargetItem) == 0x000000, "Member 'CharacterWindowUserWidget_OnApplyEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnApplyEnchant, Enchant) == 0x000008, "Member 'CharacterWindowUserWidget_OnApplyEnchant::Enchant' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnAttributeChanged
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnAttributeChanged final
{
public:
	EAttribute                                    AttributeType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnAttributeChanged) == 0x000004, "Wrong alignment on CharacterWindowUserWidget_OnAttributeChanged");
static_assert(sizeof(CharacterWindowUserWidget_OnAttributeChanged) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnAttributeChanged");
static_assert(offsetof(CharacterWindowUserWidget_OnAttributeChanged, AttributeType) == 0x000000, "Member 'CharacterWindowUserWidget_OnAttributeChanged::AttributeType' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnAttributeChanged, Value) == 0x000004, "Member 'CharacterWindowUserWidget_OnAttributeChanged::Value' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnEquipItem
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnEquipItem final
{
public:
	class UCharacterWinFilterSlotUserWidget*      FilterSlotUserWidget;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlotUserWidget*               InventorySlotUserWidget;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnEquipItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnEquipItem");
static_assert(sizeof(CharacterWindowUserWidget_OnEquipItem) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnEquipItem");
static_assert(offsetof(CharacterWindowUserWidget_OnEquipItem, FilterSlotUserWidget) == 0x000000, "Member 'CharacterWindowUserWidget_OnEquipItem::FilterSlotUserWidget' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnEquipItem, InventorySlotUserWidget) == 0x000008, "Member 'CharacterWindowUserWidget_OnEquipItem::InventorySlotUserWidget' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnItemSlotChanged
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnItemSlotChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnItemSlotChanged) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnItemSlotChanged");
static_assert(sizeof(CharacterWindowUserWidget_OnItemSlotChanged) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnItemSlotChanged");
static_assert(offsetof(CharacterWindowUserWidget_OnItemSlotChanged, SourceSlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnItemSlotChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnItemSlotChanged, DestinationSlot) == 0x000008, "Member 'CharacterWindowUserWidget_OnItemSlotChanged::DestinationSlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnNewItem
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnNewItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnNewItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnNewItem");
static_assert(sizeof(CharacterWindowUserWidget_OnNewItem) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnNewItem");
static_assert(offsetof(CharacterWindowUserWidget_OnNewItem, InventorySlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnNewItem::InventorySlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct CharacterWindowUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterWindowUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on CharacterWindowUserWidget_OnPropertyChanged");
static_assert(sizeof(CharacterWindowUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on CharacterWindowUserWidget_OnPropertyChanged");
static_assert(offsetof(CharacterWindowUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'CharacterWindowUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'CharacterWindowUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'CharacterWindowUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'CharacterWindowUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'CharacterWindowUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnRemovedRingItem
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnRemovedRingItem final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnRemovedRingItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnRemovedRingItem");
static_assert(sizeof(CharacterWindowUserWidget_OnRemovedRingItem) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnRemovedRingItem");
static_assert(offsetof(CharacterWindowUserWidget_OnRemovedRingItem, Widget) == 0x000000, "Member 'CharacterWindowUserWidget_OnRemovedRingItem::Widget' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnRemovedRingItem, Item) == 0x000008, "Member 'CharacterWindowUserWidget_OnRemovedRingItem::Item' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnRemoveEnchant
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnRemoveEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnRemoveEnchant) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnRemoveEnchant");
static_assert(sizeof(CharacterWindowUserWidget_OnRemoveEnchant) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnRemoveEnchant");
static_assert(offsetof(CharacterWindowUserWidget_OnRemoveEnchant, TargetItem) == 0x000000, "Member 'CharacterWindowUserWidget_OnRemoveEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnRemoveEnchant, Enchant) == 0x000008, "Member 'CharacterWindowUserWidget_OnRemoveEnchant::Enchant' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnSetFilterSlot
// 0x0020 (0x0020 - 0x0000)
struct CharacterWindowUserWidget_OnSetFilterSlot final
{
public:
	EItemSlot                                     ItemSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FilterName;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnSetFilterSlot) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnSetFilterSlot");
static_assert(sizeof(CharacterWindowUserWidget_OnSetFilterSlot) == 0x000020, "Wrong size on CharacterWindowUserWidget_OnSetFilterSlot");
static_assert(offsetof(CharacterWindowUserWidget_OnSetFilterSlot, ItemSlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnSetFilterSlot::ItemSlot' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnSetFilterSlot, FilterName) == 0x000008, "Member 'CharacterWindowUserWidget_OnSetFilterSlot::FilterName' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnSetFilterView
// 0x0001 (0x0001 - 0x0000)
struct CharacterWindowUserWidget_OnSetFilterView final
{
public:
	bool                                          bInFilterView;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnSetFilterView) == 0x000001, "Wrong alignment on CharacterWindowUserWidget_OnSetFilterView");
static_assert(sizeof(CharacterWindowUserWidget_OnSetFilterView) == 0x000001, "Wrong size on CharacterWindowUserWidget_OnSetFilterView");
static_assert(offsetof(CharacterWindowUserWidget_OnSetFilterView, bInFilterView) == 0x000000, "Member 'CharacterWindowUserWidget_OnSetFilterView::bInFilterView' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnSetRequestEquippedItem
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnSetRequestEquippedItem final
{
public:
	class UItemAbility*                           InItemAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnSetRequestEquippedItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnSetRequestEquippedItem");
static_assert(sizeof(CharacterWindowUserWidget_OnSetRequestEquippedItem) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnSetRequestEquippedItem");
static_assert(offsetof(CharacterWindowUserWidget_OnSetRequestEquippedItem, InItemAbility) == 0x000000, "Member 'CharacterWindowUserWidget_OnSetRequestEquippedItem::InItemAbility' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnToggleStats
// 0x0001 (0x0001 - 0x0000)
struct CharacterWindowUserWidget_OnToggleStats final
{
public:
	bool                                          bInStatsVisible;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnToggleStats) == 0x000001, "Wrong alignment on CharacterWindowUserWidget_OnToggleStats");
static_assert(sizeof(CharacterWindowUserWidget_OnToggleStats) == 0x000001, "Wrong size on CharacterWindowUserWidget_OnToggleStats");
static_assert(offsetof(CharacterWindowUserWidget_OnToggleStats, bInStatsVisible) == 0x000000, "Member 'CharacterWindowUserWidget_OnToggleStats::bInStatsVisible' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUnlockAbilityUpgrade
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnUnlockAbilityUpgrade final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnUnlockAbilityUpgrade) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUnlockAbilityUpgrade");
static_assert(sizeof(CharacterWindowUserWidget_OnUnlockAbilityUpgrade) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnUnlockAbilityUpgrade");
static_assert(offsetof(CharacterWindowUserWidget_OnUnlockAbilityUpgrade, AbilityType) == 0x000000, "Member 'CharacterWindowUserWidget_OnUnlockAbilityUpgrade::AbilityType' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUpdateDetailsPanel
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnUpdateDetailsPanel final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterWindowUserWidget_OnUpdateDetailsPanel) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUpdateDetailsPanel");
static_assert(sizeof(CharacterWindowUserWidget_OnUpdateDetailsPanel) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnUpdateDetailsPanel");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateDetailsPanel, ManItemSlotBase) == 0x000000, "Member 'CharacterWindowUserWidget_OnUpdateDetailsPanel::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateDetailsPanel, bAnimate) == 0x000008, "Member 'CharacterWindowUserWidget_OnUpdateDetailsPanel::bAnimate' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUpdateEquippedItemDetailsPanel
// 0x0030 (0x0030 - 0x0000)
struct CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel final
{
public:
	class FText                                   ItemRequirementText;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UItemAbility*                           InItem;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InComparedItem;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel");
static_assert(sizeof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel) == 0x000030, "Wrong size on CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel, ItemRequirementText) == 0x000000, "Member 'CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel::ItemRequirementText' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel, InItem) == 0x000018, "Member 'CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel::InItem' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel, InComparedItem) == 0x000020, "Member 'CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel::InComparedItem' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel, bEquipped) == 0x000028, "Member 'CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel::bEquipped' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel, bAnimate) == 0x000029, "Member 'CharacterWindowUserWidget_OnUpdateEquippedItemDetailsPanel::bAnimate' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUpdateItem
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnUpdateItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnUpdateItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUpdateItem");
static_assert(sizeof(CharacterWindowUserWidget_OnUpdateItem) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnUpdateItem");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateItem, InventorySlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnUpdateItem::InventorySlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUpdateQuickUseSlot
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnUpdateQuickUseSlot final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnUpdateQuickUseSlot) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUpdateQuickUseSlot");
static_assert(sizeof(CharacterWindowUserWidget_OnUpdateQuickUseSlot) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnUpdateQuickUseSlot");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateQuickUseSlot, InventorySlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnUpdateQuickUseSlot::InventorySlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUpdateSlot
// 0x0008 (0x0008 - 0x0000)
struct CharacterWindowUserWidget_OnUpdateSlot final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnUpdateSlot) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUpdateSlot");
static_assert(sizeof(CharacterWindowUserWidget_OnUpdateSlot) == 0x000008, "Wrong size on CharacterWindowUserWidget_OnUpdateSlot");
static_assert(offsetof(CharacterWindowUserWidget_OnUpdateSlot, InventorySlot) == 0x000000, "Member 'CharacterWindowUserWidget_OnUpdateSlot::InventorySlot' has a wrong offset!");

// Function man.CharacterWindowUserWidget.OnUseItem
// 0x0010 (0x0010 - 0x0000)
struct CharacterWindowUserWidget_OnUseItem final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_OnUseItem) == 0x000008, "Wrong alignment on CharacterWindowUserWidget_OnUseItem");
static_assert(sizeof(CharacterWindowUserWidget_OnUseItem) == 0x000010, "Wrong size on CharacterWindowUserWidget_OnUseItem");
static_assert(offsetof(CharacterWindowUserWidget_OnUseItem, Widget) == 0x000000, "Member 'CharacterWindowUserWidget_OnUseItem::Widget' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_OnUseItem, Item) == 0x000008, "Member 'CharacterWindowUserWidget_OnUseItem::Item' has a wrong offset!");

// Function man.CharacterWindowUserWidget.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct CharacterWindowUserWidget_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterWindowUserWidget_PropertyChanged) == 0x000004, "Wrong alignment on CharacterWindowUserWidget_PropertyChanged");
static_assert(sizeof(CharacterWindowUserWidget_PropertyChanged) == 0x000014, "Wrong size on CharacterWindowUserWidget_PropertyChanged");
static_assert(offsetof(CharacterWindowUserWidget_PropertyChanged, PropertyType) == 0x000000, "Member 'CharacterWindowUserWidget_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_PropertyChanged, Value) == 0x000004, "Member 'CharacterWindowUserWidget_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'CharacterWindowUserWidget_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'CharacterWindowUserWidget_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_PropertyChanged, bAnimate) == 0x000010, "Member 'CharacterWindowUserWidget_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.CharacterWindowUserWidget.SetFilterView
// 0x0002 (0x0002 - 0x0000)
struct CharacterWindowUserWidget_SetFilterView final
{
public:
	bool                                          bInFilterView;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAkAudioEvent;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_SetFilterView) == 0x000001, "Wrong alignment on CharacterWindowUserWidget_SetFilterView");
static_assert(sizeof(CharacterWindowUserWidget_SetFilterView) == 0x000002, "Wrong size on CharacterWindowUserWidget_SetFilterView");
static_assert(offsetof(CharacterWindowUserWidget_SetFilterView, bInFilterView) == 0x000000, "Member 'CharacterWindowUserWidget_SetFilterView::bInFilterView' has a wrong offset!");
static_assert(offsetof(CharacterWindowUserWidget_SetFilterView, bPlayAkAudioEvent) == 0x000001, "Member 'CharacterWindowUserWidget_SetFilterView::bPlayAkAudioEvent' has a wrong offset!");

// Function man.CharacterWindowUserWidget.IsItemEquippedMode
// 0x0001 (0x0001 - 0x0000)
struct CharacterWindowUserWidget_IsItemEquippedMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWindowUserWidget_IsItemEquippedMode) == 0x000001, "Wrong alignment on CharacterWindowUserWidget_IsItemEquippedMode");
static_assert(sizeof(CharacterWindowUserWidget_IsItemEquippedMode) == 0x000001, "Wrong size on CharacterWindowUserWidget_IsItemEquippedMode");
static_assert(offsetof(CharacterWindowUserWidget_IsItemEquippedMode, ReturnValue) == 0x000000, "Member 'CharacterWindowUserWidget_IsItemEquippedMode::ReturnValue' has a wrong offset!");

// Function man.BloodTrance.AbilityModifierChanged
// 0x000C (0x000C - 0x0000)
struct BloodTrance_AbilityModifierChanged final
{
public:
	bool                                          bAddedModifier;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGeneralAbilityModifier                       GeneralID;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomID;                                          // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodTrance_AbilityModifierChanged) == 0x000004, "Wrong alignment on BloodTrance_AbilityModifierChanged");
static_assert(sizeof(BloodTrance_AbilityModifierChanged) == 0x00000C, "Wrong size on BloodTrance_AbilityModifierChanged");
static_assert(offsetof(BloodTrance_AbilityModifierChanged, bAddedModifier) == 0x000000, "Member 'BloodTrance_AbilityModifierChanged::bAddedModifier' has a wrong offset!");
static_assert(offsetof(BloodTrance_AbilityModifierChanged, GeneralID) == 0x000001, "Member 'BloodTrance_AbilityModifierChanged::GeneralID' has a wrong offset!");
static_assert(offsetof(BloodTrance_AbilityModifierChanged, CustomID) == 0x000004, "Member 'BloodTrance_AbilityModifierChanged::CustomID' has a wrong offset!");

// Function man.GremlinSuicideAttack.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct GremlinSuicideAttack_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GremlinSuicideAttack_OnPreDamagedPriority) == 0x000008, "Wrong alignment on GremlinSuicideAttack_OnPreDamagedPriority");
static_assert(sizeof(GremlinSuicideAttack_OnPreDamagedPriority) == 0x0002D8, "Wrong size on GremlinSuicideAttack_OnPreDamagedPriority");
static_assert(offsetof(GremlinSuicideAttack_OnPreDamagedPriority, Param) == 0x000000, "Member 'GremlinSuicideAttack_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.LarcenistMBEnvenom.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct LarcenistMBEnvenom_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LarcenistMBEnvenom_OnPostDamageDone) == 0x000008, "Wrong alignment on LarcenistMBEnvenom_OnPostDamageDone");
static_assert(sizeof(LarcenistMBEnvenom_OnPostDamageDone) == 0x0002D8, "Wrong size on LarcenistMBEnvenom_OnPostDamageDone");
static_assert(offsetof(LarcenistMBEnvenom_OnPostDamageDone, DamageParams) == 0x000000, "Member 'LarcenistMBEnvenom_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.ChaoticRemnantsPassive.AbilityStart
// 0x0010 (0x0010 - 0x0000)
struct ChaoticRemnantsPassive_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChaoticRemnantsPassive_AbilityStart) == 0x000008, "Wrong alignment on ChaoticRemnantsPassive_AbilityStart");
static_assert(sizeof(ChaoticRemnantsPassive_AbilityStart) == 0x000010, "Wrong size on ChaoticRemnantsPassive_AbilityStart");
static_assert(offsetof(ChaoticRemnantsPassive_AbilityStart, Ability) == 0x000000, "Member 'ChaoticRemnantsPassive_AbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(ChaoticRemnantsPassive_AbilityStart, bDesired) == 0x000008, "Member 'ChaoticRemnantsPassive_AbilityStart::bDesired' has a wrong offset!");

// Function man.ChaoticRemnantsPassive.DamageCasued
// 0x02D8 (0x02D8 - 0x0000)
struct ChaoticRemnantsPassive_DamageCasued final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRemnantsPassive_DamageCasued) == 0x000008, "Wrong alignment on ChaoticRemnantsPassive_DamageCasued");
static_assert(sizeof(ChaoticRemnantsPassive_DamageCasued) == 0x0002D8, "Wrong size on ChaoticRemnantsPassive_DamageCasued");
static_assert(offsetof(ChaoticRemnantsPassive_DamageCasued, Param) == 0x000000, "Member 'ChaoticRemnantsPassive_DamageCasued::Param' has a wrong offset!");

// Function man.ChaoticRemnantsPassive.RemnantPickedUp
// 0x0008 (0x0008 - 0x0000)
struct ChaoticRemnantsPassive_RemnantPickedUp final
{
public:
	class AActorBase*                             Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRemnantsPassive_RemnantPickedUp) == 0x000008, "Wrong alignment on ChaoticRemnantsPassive_RemnantPickedUp");
static_assert(sizeof(ChaoticRemnantsPassive_RemnantPickedUp) == 0x000008, "Wrong size on ChaoticRemnantsPassive_RemnantPickedUp");
static_assert(offsetof(ChaoticRemnantsPassive_RemnantPickedUp, Actor) == 0x000000, "Member 'ChaoticRemnantsPassive_RemnantPickedUp::Actor' has a wrong offset!");

// Function man.ChaoticRemnantsPassive.ResourceUsed
// 0x0008 (0x0008 - 0x0000)
struct ChaoticRemnantsPassive_ResourceUsed final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRemnantsPassive_ResourceUsed) == 0x000008, "Wrong alignment on ChaoticRemnantsPassive_ResourceUsed");
static_assert(sizeof(ChaoticRemnantsPassive_ResourceUsed) == 0x000008, "Wrong size on ChaoticRemnantsPassive_ResourceUsed");
static_assert(offsetof(ChaoticRemnantsPassive_ResourceUsed, Ability) == 0x000000, "Member 'ChaoticRemnantsPassive_ResourceUsed::Ability' has a wrong offset!");

// Function man.ChaoticRemnantsPassive.StatusEffectApplied
// 0x0018 (0x0018 - 0x0000)
struct ChaoticRemnantsPassive_StatusEffectApplied final
{
public:
	class AActor*                                 effecttarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticRemnantsPassive_StatusEffectApplied) == 0x000008, "Wrong alignment on ChaoticRemnantsPassive_StatusEffectApplied");
static_assert(sizeof(ChaoticRemnantsPassive_StatusEffectApplied) == 0x000018, "Wrong size on ChaoticRemnantsPassive_StatusEffectApplied");
static_assert(offsetof(ChaoticRemnantsPassive_StatusEffectApplied, effecttarget) == 0x000000, "Member 'ChaoticRemnantsPassive_StatusEffectApplied::effecttarget' has a wrong offset!");
static_assert(offsetof(ChaoticRemnantsPassive_StatusEffectApplied, Type) == 0x000008, "Member 'ChaoticRemnantsPassive_StatusEffectApplied::Type' has a wrong offset!");
static_assert(offsetof(ChaoticRemnantsPassive_StatusEffectApplied, IsNewEffect) == 0x000009, "Member 'ChaoticRemnantsPassive_StatusEffectApplied::IsNewEffect' has a wrong offset!");
static_assert(offsetof(ChaoticRemnantsPassive_StatusEffectApplied, Instance) == 0x000010, "Member 'ChaoticRemnantsPassive_StatusEffectApplied::Instance' has a wrong offset!");

// Function man.SwitchActorBase.StartGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct SwitchActorBase_StartGameplayEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SwitchActorBase_StartGameplayEvent) == 0x000008, "Wrong alignment on SwitchActorBase_StartGameplayEvent");
static_assert(sizeof(SwitchActorBase_StartGameplayEvent) == 0x000020, "Wrong size on SwitchActorBase_StartGameplayEvent");
static_assert(offsetof(SwitchActorBase_StartGameplayEvent, InAbilityController) == 0x000000, "Member 'SwitchActorBase_StartGameplayEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(SwitchActorBase_StartGameplayEvent, _GameplayEventID) == 0x000008, "Member 'SwitchActorBase_StartGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(SwitchActorBase_StartGameplayEvent, CustomName) == 0x000010, "Member 'SwitchActorBase_StartGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(SwitchActorBase_StartGameplayEvent, paramActorSoul) == 0x000018, "Member 'SwitchActorBase_StartGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.ManQuestManager.AddQuest
// 0x0018 (0x0018 - 0x0000)
struct ManQuestManager_AddQuest final
{
public:
	TSubclassOf<class UManQuest>                  QuestBlueprint;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuestPopupShowingDelayTime;                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UManQuest*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_AddQuest) == 0x000008, "Wrong alignment on ManQuestManager_AddQuest");
static_assert(sizeof(ManQuestManager_AddQuest) == 0x000018, "Wrong size on ManQuestManager_AddQuest");
static_assert(offsetof(ManQuestManager_AddQuest, QuestBlueprint) == 0x000000, "Member 'ManQuestManager_AddQuest::QuestBlueprint' has a wrong offset!");
static_assert(offsetof(ManQuestManager_AddQuest, QuestPopupShowingDelayTime) == 0x000008, "Member 'ManQuestManager_AddQuest::QuestPopupShowingDelayTime' has a wrong offset!");
static_assert(offsetof(ManQuestManager_AddQuest, ReturnValue) == 0x000010, "Member 'ManQuestManager_AddQuest::ReturnValue' has a wrong offset!");

// Function man.ManQuestManager.AddQuestProgress
// 0x0028 (0x0028 - 0x0000)
struct ManQuestManager_AddQuestProgress final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CallSource;                                        // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_AddQuestProgress) == 0x000008, "Wrong alignment on ManQuestManager_AddQuestProgress");
static_assert(sizeof(ManQuestManager_AddQuestProgress) == 0x000028, "Wrong size on ManQuestManager_AddQuestProgress");
static_assert(offsetof(ManQuestManager_AddQuestProgress, QClass) == 0x000000, "Member 'ManQuestManager_AddQuestProgress::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_AddQuestProgress, Objective) == 0x000008, "Member 'ManQuestManager_AddQuestProgress::Objective' has a wrong offset!");
static_assert(offsetof(ManQuestManager_AddQuestProgress, ObjectiveName) == 0x000010, "Member 'ManQuestManager_AddQuestProgress::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuestManager_AddQuestProgress, CallSource) == 0x000018, "Member 'ManQuestManager_AddQuestProgress::CallSource' has a wrong offset!");

// Function man.ManQuestManager.CompleteQuest
// 0x0008 (0x0008 - 0x0000)
struct ManQuestManager_CompleteQuest final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_CompleteQuest) == 0x000008, "Wrong alignment on ManQuestManager_CompleteQuest");
static_assert(sizeof(ManQuestManager_CompleteQuest) == 0x000008, "Wrong size on ManQuestManager_CompleteQuest");
static_assert(offsetof(ManQuestManager_CompleteQuest, QClass) == 0x000000, "Member 'ManQuestManager_CompleteQuest::QClass' has a wrong offset!");

// Function man.ManQuestManager.GetQuests
// 0x0010 (0x0010 - 0x0000)
struct ManQuestManager_GetQuests final
{
public:
	TArray<class UManQuest*>                      ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_GetQuests) == 0x000008, "Wrong alignment on ManQuestManager_GetQuests");
static_assert(sizeof(ManQuestManager_GetQuests) == 0x000010, "Wrong size on ManQuestManager_GetQuests");
static_assert(offsetof(ManQuestManager_GetQuests, ReturnValue) == 0x000000, "Member 'ManQuestManager_GetQuests::ReturnValue' has a wrong offset!");

// Function man.ManQuestManager.HasQuest
// 0x0010 (0x0010 - 0x0000)
struct ManQuestManager_HasQuest final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuestManager_HasQuest) == 0x000008, "Wrong alignment on ManQuestManager_HasQuest");
static_assert(sizeof(ManQuestManager_HasQuest) == 0x000010, "Wrong size on ManQuestManager_HasQuest");
static_assert(offsetof(ManQuestManager_HasQuest, QClass) == 0x000000, "Member 'ManQuestManager_HasQuest::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_HasQuest, ReturnValue) == 0x000008, "Member 'ManQuestManager_HasQuest::ReturnValue' has a wrong offset!");

// Function man.ManQuestManager.IsQuestObjectiveCompleted
// 0x0018 (0x0018 - 0x0000)
struct ManQuestManager_IsQuestObjectiveCompleted final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuestManager_IsQuestObjectiveCompleted) == 0x000008, "Wrong alignment on ManQuestManager_IsQuestObjectiveCompleted");
static_assert(sizeof(ManQuestManager_IsQuestObjectiveCompleted) == 0x000018, "Wrong size on ManQuestManager_IsQuestObjectiveCompleted");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveCompleted, QClass) == 0x000000, "Member 'ManQuestManager_IsQuestObjectiveCompleted::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveCompleted, ObjectiveName) == 0x000008, "Member 'ManQuestManager_IsQuestObjectiveCompleted::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveCompleted, ReturnValue) == 0x000010, "Member 'ManQuestManager_IsQuestObjectiveCompleted::ReturnValue' has a wrong offset!");

// Function man.ManQuestManager.IsQuestObjectiveFailed
// 0x0018 (0x0018 - 0x0000)
struct ManQuestManager_IsQuestObjectiveFailed final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuestManager_IsQuestObjectiveFailed) == 0x000008, "Wrong alignment on ManQuestManager_IsQuestObjectiveFailed");
static_assert(sizeof(ManQuestManager_IsQuestObjectiveFailed) == 0x000018, "Wrong size on ManQuestManager_IsQuestObjectiveFailed");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveFailed, QClass) == 0x000000, "Member 'ManQuestManager_IsQuestObjectiveFailed::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveFailed, ObjectiveName) == 0x000008, "Member 'ManQuestManager_IsQuestObjectiveFailed::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuestManager_IsQuestObjectiveFailed, ReturnValue) == 0x000010, "Member 'ManQuestManager_IsQuestObjectiveFailed::ReturnValue' has a wrong offset!");

// Function man.ManQuestManager.OnActorEnteredZone
// 0x0010 (0x0010 - 0x0000)
struct ManQuestManager_OnActorEnteredZone final
{
public:
	class AActor*                                 ZoneActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorEntered;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_OnActorEnteredZone) == 0x000008, "Wrong alignment on ManQuestManager_OnActorEnteredZone");
static_assert(sizeof(ManQuestManager_OnActorEnteredZone) == 0x000010, "Wrong size on ManQuestManager_OnActorEnteredZone");
static_assert(offsetof(ManQuestManager_OnActorEnteredZone, ZoneActor) == 0x000000, "Member 'ManQuestManager_OnActorEnteredZone::ZoneActor' has a wrong offset!");
static_assert(offsetof(ManQuestManager_OnActorEnteredZone, ActorEntered) == 0x000008, "Member 'ManQuestManager_OnActorEnteredZone::ActorEntered' has a wrong offset!");

// Function man.ManQuestManager.OnEntityKilled
// 0x0008 (0x0008 - 0x0000)
struct ManQuestManager_OnEntityKilled final
{
public:
	class AActor*                                 KilledActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_OnEntityKilled) == 0x000008, "Wrong alignment on ManQuestManager_OnEntityKilled");
static_assert(sizeof(ManQuestManager_OnEntityKilled) == 0x000008, "Wrong size on ManQuestManager_OnEntityKilled");
static_assert(offsetof(ManQuestManager_OnEntityKilled, KilledActor) == 0x000000, "Member 'ManQuestManager_OnEntityKilled::KilledActor' has a wrong offset!");

// Function man.ManQuestManager.OnGlobalVariableChanged
// 0x0008 (0x0008 - 0x0000)
struct ManQuestManager_OnGlobalVariableChanged final
{
public:
	class FName                                   EntryKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_OnGlobalVariableChanged) == 0x000004, "Wrong alignment on ManQuestManager_OnGlobalVariableChanged");
static_assert(sizeof(ManQuestManager_OnGlobalVariableChanged) == 0x000008, "Wrong size on ManQuestManager_OnGlobalVariableChanged");
static_assert(offsetof(ManQuestManager_OnGlobalVariableChanged, EntryKey) == 0x000000, "Member 'ManQuestManager_OnGlobalVariableChanged::EntryKey' has a wrong offset!");

// Function man.ManQuestManager.OnItemAdded
// 0x0010 (0x0010 - 0x0000)
struct ManQuestManager_OnItemAdded final
{
public:
	class UItemAbility*                           Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemStack;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuestManager_OnItemAdded) == 0x000008, "Wrong alignment on ManQuestManager_OnItemAdded");
static_assert(sizeof(ManQuestManager_OnItemAdded) == 0x000010, "Wrong size on ManQuestManager_OnItemAdded");
static_assert(offsetof(ManQuestManager_OnItemAdded, Item) == 0x000000, "Member 'ManQuestManager_OnItemAdded::Item' has a wrong offset!");
static_assert(offsetof(ManQuestManager_OnItemAdded, ItemStack) == 0x000008, "Member 'ManQuestManager_OnItemAdded::ItemStack' has a wrong offset!");

// Function man.ManQuestManager.OnItemsChanged
// 0x0010 (0x0010 - 0x0000)
struct ManQuestManager_OnItemsChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_OnItemsChanged) == 0x000008, "Wrong alignment on ManQuestManager_OnItemsChanged");
static_assert(sizeof(ManQuestManager_OnItemsChanged) == 0x000010, "Wrong size on ManQuestManager_OnItemsChanged");
static_assert(offsetof(ManQuestManager_OnItemsChanged, SourceSlot) == 0x000000, "Member 'ManQuestManager_OnItemsChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(ManQuestManager_OnItemsChanged, DestinationSlot) == 0x000008, "Member 'ManQuestManager_OnItemsChanged::DestinationSlot' has a wrong offset!");

// Function man.ManQuestManager.RemoveQuest
// 0x0008 (0x0008 - 0x0000)
struct ManQuestManager_RemoveQuest final
{
public:
	TSubclassOf<class UManQuest>                  QuestBlueprint;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_RemoveQuest) == 0x000008, "Wrong alignment on ManQuestManager_RemoveQuest");
static_assert(sizeof(ManQuestManager_RemoveQuest) == 0x000008, "Wrong size on ManQuestManager_RemoveQuest");
static_assert(offsetof(ManQuestManager_RemoveQuest, QuestBlueprint) == 0x000000, "Member 'ManQuestManager_RemoveQuest::QuestBlueprint' has a wrong offset!");

// Function man.ManQuestManager.SetObjectiveFailed
// 0x0018 (0x0018 - 0x0000)
struct ManQuestManager_SetObjectiveFailed final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_SetObjectiveFailed) == 0x000008, "Wrong alignment on ManQuestManager_SetObjectiveFailed");
static_assert(sizeof(ManQuestManager_SetObjectiveFailed) == 0x000018, "Wrong size on ManQuestManager_SetObjectiveFailed");
static_assert(offsetof(ManQuestManager_SetObjectiveFailed, QClass) == 0x000000, "Member 'ManQuestManager_SetObjectiveFailed::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetObjectiveFailed, Objective) == 0x000008, "Member 'ManQuestManager_SetObjectiveFailed::Objective' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetObjectiveFailed, ObjectiveName) == 0x000010, "Member 'ManQuestManager_SetObjectiveFailed::ObjectiveName' has a wrong offset!");

// Function man.ManQuestManager.SetObjectiveQuestMarker
// 0x0028 (0x0028 - 0x0000)
struct ManQuestManager_SetObjectiveQuestMarker final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     Objective;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0018(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_SetObjectiveQuestMarker) == 0x000008, "Wrong alignment on ManQuestManager_SetObjectiveQuestMarker");
static_assert(sizeof(ManQuestManager_SetObjectiveQuestMarker) == 0x000028, "Wrong size on ManQuestManager_SetObjectiveQuestMarker");
static_assert(offsetof(ManQuestManager_SetObjectiveQuestMarker, QClass) == 0x000000, "Member 'ManQuestManager_SetObjectiveQuestMarker::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetObjectiveQuestMarker, Objective) == 0x000008, "Member 'ManQuestManager_SetObjectiveQuestMarker::Objective' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetObjectiveQuestMarker, ObjectiveName) == 0x000010, "Member 'ManQuestManager_SetObjectiveQuestMarker::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetObjectiveQuestMarker, QuestMarker) == 0x000018, "Member 'ManQuestManager_SetObjectiveQuestMarker::QuestMarker' has a wrong offset!");

// Function man.ManQuestManager.SetQuestConclusion
// 0x0020 (0x0020 - 0x0000)
struct ManQuestManager_SetQuestConclusion final
{
public:
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InQuestConclusion;                                 // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuestManager_SetQuestConclusion) == 0x000008, "Wrong alignment on ManQuestManager_SetQuestConclusion");
static_assert(sizeof(ManQuestManager_SetQuestConclusion) == 0x000020, "Wrong size on ManQuestManager_SetQuestConclusion");
static_assert(offsetof(ManQuestManager_SetQuestConclusion, QClass) == 0x000000, "Member 'ManQuestManager_SetQuestConclusion::QClass' has a wrong offset!");
static_assert(offsetof(ManQuestManager_SetQuestConclusion, InQuestConclusion) == 0x000008, "Member 'ManQuestManager_SetQuestConclusion::InQuestConclusion' has a wrong offset!");

// Function man.ReflectDamageComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct ReflectDamageComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReflectDamageComponent_OnPreDamaged) == 0x000008, "Wrong alignment on ReflectDamageComponent_OnPreDamaged");
static_assert(sizeof(ReflectDamageComponent_OnPreDamaged) == 0x0002D8, "Wrong size on ReflectDamageComponent_OnPreDamaged");
static_assert(offsetof(ReflectDamageComponent_OnPreDamaged, Param) == 0x000000, "Member 'ReflectDamageComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.CriticalBatteryPassive.AbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct CriticalBatteryPassive_AbilityEnd final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CriticalBatteryPassive_AbilityEnd) == 0x000008, "Wrong alignment on CriticalBatteryPassive_AbilityEnd");
static_assert(sizeof(CriticalBatteryPassive_AbilityEnd) == 0x000008, "Wrong size on CriticalBatteryPassive_AbilityEnd");
static_assert(offsetof(CriticalBatteryPassive_AbilityEnd, Ability) == 0x000000, "Member 'CriticalBatteryPassive_AbilityEnd::Ability' has a wrong offset!");

// Function man.CriticalBatteryPassive.AbilityStart
// 0x0010 (0x0010 - 0x0000)
struct CriticalBatteryPassive_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CriticalBatteryPassive_AbilityStart) == 0x000008, "Wrong alignment on CriticalBatteryPassive_AbilityStart");
static_assert(sizeof(CriticalBatteryPassive_AbilityStart) == 0x000010, "Wrong size on CriticalBatteryPassive_AbilityStart");
static_assert(offsetof(CriticalBatteryPassive_AbilityStart, Ability) == 0x000000, "Member 'CriticalBatteryPassive_AbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(CriticalBatteryPassive_AbilityStart, bDesired) == 0x000008, "Member 'CriticalBatteryPassive_AbilityStart::bDesired' has a wrong offset!");

// Function man.CriticalBatteryPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct CriticalBatteryPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CriticalBatteryPassive_DamageDealt) == 0x000008, "Wrong alignment on CriticalBatteryPassive_DamageDealt");
static_assert(sizeof(CriticalBatteryPassive_DamageDealt) == 0x0002D8, "Wrong size on CriticalBatteryPassive_DamageDealt");
static_assert(offsetof(CriticalBatteryPassive_DamageDealt, Param) == 0x000000, "Member 'CriticalBatteryPassive_DamageDealt::Param' has a wrong offset!");

// Function man.TrailEmitter.BPGetTrailLifeTime
// 0x0004 (0x0004 - 0x0000)
struct TrailEmitter_BPGetTrailLifeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrailEmitter_BPGetTrailLifeTime) == 0x000004, "Wrong alignment on TrailEmitter_BPGetTrailLifeTime");
static_assert(sizeof(TrailEmitter_BPGetTrailLifeTime) == 0x000004, "Wrong size on TrailEmitter_BPGetTrailLifeTime");
static_assert(offsetof(TrailEmitter_BPGetTrailLifeTime, ReturnValue) == 0x000000, "Member 'TrailEmitter_BPGetTrailLifeTime::ReturnValue' has a wrong offset!");

// Function man.HitCounter.OnHit
// 0x0003 (0x0003 - 0x0000)
struct HitCounter_OnHit final
{
public:
	struct FACOnHitPatam                          OnHitPatam;                                        // 0x0000(0x0003)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitCounter_OnHit) == 0x000001, "Wrong alignment on HitCounter_OnHit");
static_assert(sizeof(HitCounter_OnHit) == 0x000003, "Wrong size on HitCounter_OnHit");
static_assert(offsetof(HitCounter_OnHit, OnHitPatam) == 0x000000, "Member 'HitCounter_OnHit::OnHitPatam' has a wrong offset!");

// Function man.InteractAbility.BPGetInteractInRange
// 0x0010 (0x0010 - 0x0000)
struct InteractAbility_BPGetInteractInRange final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractAbility_BPGetInteractInRange) == 0x000008, "Wrong alignment on InteractAbility_BPGetInteractInRange");
static_assert(sizeof(InteractAbility_BPGetInteractInRange) == 0x000010, "Wrong size on InteractAbility_BPGetInteractInRange");
static_assert(offsetof(InteractAbility_BPGetInteractInRange, ReturnValue) == 0x000000, "Member 'InteractAbility_BPGetInteractInRange::ReturnValue' has a wrong offset!");

// Function man.OptionsSelectHotkeyUserWidget.OnHotkeyBindingsNotAllowedKey
// 0x0001 (0x0001 - 0x0000)
struct OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey) == 0x000001, "Wrong alignment on OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey");
static_assert(sizeof(OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey) == 0x000001, "Wrong size on OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey");
static_assert(offsetof(OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey, ButtonType) == 0x000000, "Member 'OptionsSelectHotkeyUserWidget_OnHotkeyBindingsNotAllowedKey::ButtonType' has a wrong offset!");

// Function man.InventorySlotUserWidget.GetItemAbility
// 0x0008 (0x0008 - 0x0000)
struct InventorySlotUserWidget_GetItemAbility final
{
public:
	class UItemAbility*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_GetItemAbility) == 0x000008, "Wrong alignment on InventorySlotUserWidget_GetItemAbility");
static_assert(sizeof(InventorySlotUserWidget_GetItemAbility) == 0x000008, "Wrong size on InventorySlotUserWidget_GetItemAbility");
static_assert(offsetof(InventorySlotUserWidget_GetItemAbility, ReturnValue) == 0x000000, "Member 'InventorySlotUserWidget_GetItemAbility::ReturnValue' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct InventorySlotUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(InventorySlotUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on InventorySlotUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(InventorySlotUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'InventorySlotUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'InventorySlotUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnPermanentEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct InventorySlotUserWidget_OnPermanentEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InPermanentEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(sizeof(InventorySlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000010, "Wrong size on InventorySlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(offsetof(InventorySlotUserWidget_OnPermanentEnchantIconsChanged, InPermanentEnchantIcons) == 0x000000, "Member 'InventorySlotUserWidget_OnPermanentEnchantIconsChanged::InPermanentEnchantIcons' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnSetCountdown
// 0x0020 (0x0020 - 0x0000)
struct InventorySlotUserWidget_OnSetCountdown final
{
public:
	float                                         ElapsedCooldownPercent;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimeLeft;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnSetCountdown) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnSetCountdown");
static_assert(sizeof(InventorySlotUserWidget_OnSetCountdown) == 0x000020, "Wrong size on InventorySlotUserWidget_OnSetCountdown");
static_assert(offsetof(InventorySlotUserWidget_OnSetCountdown, ElapsedCooldownPercent) == 0x000000, "Member 'InventorySlotUserWidget_OnSetCountdown::ElapsedCooldownPercent' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnSetCountdown, TimeLeft) == 0x000008, "Member 'InventorySlotUserWidget_OnSetCountdown::TimeLeft' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnSetEquipState
// 0x0001 (0x0001 - 0x0000)
struct InventorySlotUserWidget_OnSetEquipState final
{
public:
	bool                                          bEquipState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnSetEquipState) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnSetEquipState");
static_assert(sizeof(InventorySlotUserWidget_OnSetEquipState) == 0x000001, "Wrong size on InventorySlotUserWidget_OnSetEquipState");
static_assert(offsetof(InventorySlotUserWidget_OnSetEquipState, bEquipState) == 0x000000, "Member 'InventorySlotUserWidget_OnSetEquipState::bEquipState' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnSetSetIndexes
// 0x0010 (0x0010 - 0x0000)
struct InventorySlotUserWidget_OnSetSetIndexes final
{
public:
	TArray<int32>                                 InSetIndexes;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnSetSetIndexes) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnSetSetIndexes");
static_assert(sizeof(InventorySlotUserWidget_OnSetSetIndexes) == 0x000010, "Wrong size on InventorySlotUserWidget_OnSetSetIndexes");
static_assert(offsetof(InventorySlotUserWidget_OnSetSetIndexes, InSetIndexes) == 0x000000, "Member 'InventorySlotUserWidget_OnSetSetIndexes::InSetIndexes' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnSetSlot
// 0x0010 (0x0010 - 0x0000)
struct InventorySlotUserWidget_OnSetSlot final
{
public:
	class UManItemSlotBase*                       InManItemSlotBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InItemAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnSetSlot");
static_assert(sizeof(InventorySlotUserWidget_OnSetSlot) == 0x000010, "Wrong size on InventorySlotUserWidget_OnSetSlot");
static_assert(offsetof(InventorySlotUserWidget_OnSetSlot, InManItemSlotBase) == 0x000000, "Member 'InventorySlotUserWidget_OnSetSlot::InManItemSlotBase' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnSetSlot, InItemAbility) == 0x000008, "Member 'InventorySlotUserWidget_OnSetSlot::InItemAbility' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnStackNumChanged
// 0x000C (0x000C - 0x0000)
struct InventorySlotUserWidget_OnStackNumChanged final
{
public:
	int32                                         InStackNum;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxStackNum;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsStackable;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventorySlotUserWidget_OnStackNumChanged) == 0x000004, "Wrong alignment on InventorySlotUserWidget_OnStackNumChanged");
static_assert(sizeof(InventorySlotUserWidget_OnStackNumChanged) == 0x00000C, "Wrong size on InventorySlotUserWidget_OnStackNumChanged");
static_assert(offsetof(InventorySlotUserWidget_OnStackNumChanged, InStackNum) == 0x000000, "Member 'InventorySlotUserWidget_OnStackNumChanged::InStackNum' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnStackNumChanged, InMaxStackNum) == 0x000004, "Member 'InventorySlotUserWidget_OnStackNumChanged::InMaxStackNum' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnStackNumChanged, bInIsStackable) == 0x000008, "Member 'InventorySlotUserWidget_OnStackNumChanged::bInIsStackable' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnTemporaryEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct InventorySlotUserWidget_OnTemporaryEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InTemporaryEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000008, "Wrong alignment on InventorySlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(sizeof(InventorySlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000010, "Wrong size on InventorySlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(offsetof(InventorySlotUserWidget_OnTemporaryEnchantIconsChanged, InTemporaryEnchantIcons) == 0x000000, "Member 'InventorySlotUserWidget_OnTemporaryEnchantIconsChanged::InTemporaryEnchantIcons' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleEmptySlot
// 0x0002 (0x0002 - 0x0000)
struct InventorySlotUserWidget_OnToggleEmptySlot final
{
public:
	bool                                          bInEmptySlot;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     InSlotType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleEmptySlot) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleEmptySlot");
static_assert(sizeof(InventorySlotUserWidget_OnToggleEmptySlot) == 0x000002, "Wrong size on InventorySlotUserWidget_OnToggleEmptySlot");
static_assert(offsetof(InventorySlotUserWidget_OnToggleEmptySlot, bInEmptySlot) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleEmptySlot::bInEmptySlot' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnToggleEmptySlot, InSlotType) == 0x000001, "Member 'InventorySlotUserWidget_OnToggleEmptySlot::InSlotType' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleEquipped
// 0x0001 (0x0001 - 0x0000)
struct InventorySlotUserWidget_OnToggleEquipped final
{
public:
	bool                                          bInIsEquipped;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleEquipped) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleEquipped");
static_assert(sizeof(InventorySlotUserWidget_OnToggleEquipped) == 0x000001, "Wrong size on InventorySlotUserWidget_OnToggleEquipped");
static_assert(offsetof(InventorySlotUserWidget_OnToggleEquipped, bInIsEquipped) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleEquipped::bInIsEquipped' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleNewItemWarning
// 0x0002 (0x0002 - 0x0000)
struct InventorySlotUserWidget_OnToggleNewItemWarning final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInAnimate;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleNewItemWarning");
static_assert(sizeof(InventorySlotUserWidget_OnToggleNewItemWarning) == 0x000002, "Wrong size on InventorySlotUserWidget_OnToggleNewItemWarning");
static_assert(offsetof(InventorySlotUserWidget_OnToggleNewItemWarning, bInVisible) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleNewItemWarning::bInVisible' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnToggleNewItemWarning, bInAnimate) == 0x000001, "Member 'InventorySlotUserWidget_OnToggleNewItemWarning::bInAnimate' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleSelected
// 0x0001 (0x0001 - 0x0000)
struct InventorySlotUserWidget_OnToggleSelected final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleSelected) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleSelected");
static_assert(sizeof(InventorySlotUserWidget_OnToggleSelected) == 0x000001, "Wrong size on InventorySlotUserWidget_OnToggleSelected");
static_assert(offsetof(InventorySlotUserWidget_OnToggleSelected, bSelected) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleSelected::bSelected' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleSoldItem
// 0x0001 (0x0001 - 0x0000)
struct InventorySlotUserWidget_OnToggleSoldItem final
{
public:
	bool                                          bInSoldItem;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleSoldItem) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleSoldItem");
static_assert(sizeof(InventorySlotUserWidget_OnToggleSoldItem) == 0x000001, "Wrong size on InventorySlotUserWidget_OnToggleSoldItem");
static_assert(offsetof(InventorySlotUserWidget_OnToggleSoldItem, bInSoldItem) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleSoldItem::bInSoldItem' has a wrong offset!");

// Function man.InventorySlotUserWidget.OnToggleUnavailable
// 0x0002 (0x0002 - 0x0000)
struct InventorySlotUserWidget_OnToggleUnavailable final
{
public:
	bool                                          bUnavailable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnavailableByResource;                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_OnToggleUnavailable) == 0x000001, "Wrong alignment on InventorySlotUserWidget_OnToggleUnavailable");
static_assert(sizeof(InventorySlotUserWidget_OnToggleUnavailable) == 0x000002, "Wrong size on InventorySlotUserWidget_OnToggleUnavailable");
static_assert(offsetof(InventorySlotUserWidget_OnToggleUnavailable, bUnavailable) == 0x000000, "Member 'InventorySlotUserWidget_OnToggleUnavailable::bUnavailable' has a wrong offset!");
static_assert(offsetof(InventorySlotUserWidget_OnToggleUnavailable, bUnavailableByResource) == 0x000001, "Member 'InventorySlotUserWidget_OnToggleUnavailable::bUnavailableByResource' has a wrong offset!");

// Function man.InventorySlotUserWidget.GetManItemSlotBase
// 0x0008 (0x0008 - 0x0000)
struct InventorySlotUserWidget_GetManItemSlotBase final
{
public:
	class UManItemSlotBase*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_GetManItemSlotBase) == 0x000008, "Wrong alignment on InventorySlotUserWidget_GetManItemSlotBase");
static_assert(sizeof(InventorySlotUserWidget_GetManItemSlotBase) == 0x000008, "Wrong size on InventorySlotUserWidget_GetManItemSlotBase");
static_assert(offsetof(InventorySlotUserWidget_GetManItemSlotBase, ReturnValue) == 0x000000, "Member 'InventorySlotUserWidget_GetManItemSlotBase::ReturnValue' has a wrong offset!");

// Function man.InventorySlotUserWidget.IsInfiniteAmount
// 0x0001 (0x0001 - 0x0000)
struct InventorySlotUserWidget_IsInfiniteAmount final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventorySlotUserWidget_IsInfiniteAmount) == 0x000001, "Wrong alignment on InventorySlotUserWidget_IsInfiniteAmount");
static_assert(sizeof(InventorySlotUserWidget_IsInfiniteAmount) == 0x000001, "Wrong size on InventorySlotUserWidget_IsInfiniteAmount");
static_assert(offsetof(InventorySlotUserWidget_IsInfiniteAmount, ReturnValue) == 0x000000, "Member 'InventorySlotUserWidget_IsInfiniteAmount::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.HasControllerConnected
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_HasControllerConnected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_HasControllerConnected) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_HasControllerConnected");
static_assert(sizeof(ConsoleFunctionLibrary_HasControllerConnected) == 0x000001, "Wrong size on ConsoleFunctionLibrary_HasControllerConnected");
static_assert(offsetof(ConsoleFunctionLibrary_HasControllerConnected, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_HasControllerConnected::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsConsole
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsConsole final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsConsole) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsConsole");
static_assert(sizeof(ConsoleFunctionLibrary_IsConsole) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsConsole");
static_assert(offsetof(ConsoleFunctionLibrary_IsConsole, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsConsole::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsPlayStation
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsPlayStation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsPlayStation) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsPlayStation");
static_assert(sizeof(ConsoleFunctionLibrary_IsPlayStation) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsPlayStation");
static_assert(offsetof(ConsoleFunctionLibrary_IsPlayStation, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsPlayStation::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsSteamDeck
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsSteamDeck final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsSteamDeck) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsSteamDeck");
static_assert(sizeof(ConsoleFunctionLibrary_IsSteamDeck) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsSteamDeck");
static_assert(offsetof(ConsoleFunctionLibrary_IsSteamDeck, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsSteamDeck::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsSwitch
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsSwitch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsSwitch) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsSwitch");
static_assert(sizeof(ConsoleFunctionLibrary_IsSwitch) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsSwitch");
static_assert(offsetof(ConsoleFunctionLibrary_IsSwitch, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsSwitch::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsWinGDK
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsWinGDK final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsWinGDK) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsWinGDK");
static_assert(sizeof(ConsoleFunctionLibrary_IsWinGDK) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsWinGDK");
static_assert(offsetof(ConsoleFunctionLibrary_IsWinGDK, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsWinGDK::ReturnValue' has a wrong offset!");

// Function man.ConsoleFunctionLibrary.IsXbox
// 0x0001 (0x0001 - 0x0000)
struct ConsoleFunctionLibrary_IsXbox final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConsoleFunctionLibrary_IsXbox) == 0x000001, "Wrong alignment on ConsoleFunctionLibrary_IsXbox");
static_assert(sizeof(ConsoleFunctionLibrary_IsXbox) == 0x000001, "Wrong size on ConsoleFunctionLibrary_IsXbox");
static_assert(offsetof(ConsoleFunctionLibrary_IsXbox, ReturnValue) == 0x000000, "Member 'ConsoleFunctionLibrary_IsXbox::ReturnValue' has a wrong offset!");

// Function man.LaserBeam.GetLaserBeamVector
// 0x000C (0x000C - 0x0000)
struct LaserBeam_GetLaserBeamVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LaserBeam_GetLaserBeamVector) == 0x000004, "Wrong alignment on LaserBeam_GetLaserBeamVector");
static_assert(sizeof(LaserBeam_GetLaserBeamVector) == 0x00000C, "Wrong size on LaserBeam_GetLaserBeamVector");
static_assert(offsetof(LaserBeam_GetLaserBeamVector, ReturnValue) == 0x000000, "Member 'LaserBeam_GetLaserBeamVector::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPActivateDeveloperItemSet
// 0x0004 (0x0004 - 0x0000)
struct Inventory_BPActivateDeveloperItemSet final
{
public:
	int32                                         SetIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPActivateDeveloperItemSet) == 0x000004, "Wrong alignment on Inventory_BPActivateDeveloperItemSet");
static_assert(sizeof(Inventory_BPActivateDeveloperItemSet) == 0x000004, "Wrong size on Inventory_BPActivateDeveloperItemSet");
static_assert(offsetof(Inventory_BPActivateDeveloperItemSet, SetIndex) == 0x000000, "Member 'Inventory_BPActivateDeveloperItemSet::SetIndex' has a wrong offset!");

// Function man.Inventory.BPAddItem
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPAddItem final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConversationAddItemShowingDelayTime;               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPAddItem) == 0x000008, "Wrong alignment on Inventory_BPAddItem");
static_assert(sizeof(Inventory_BPAddItem) == 0x000010, "Wrong size on Inventory_BPAddItem");
static_assert(offsetof(Inventory_BPAddItem, ItemAbilityClass) == 0x000000, "Member 'Inventory_BPAddItem::ItemAbilityClass' has a wrong offset!");
static_assert(offsetof(Inventory_BPAddItem, ConversationAddItemShowingDelayTime) == 0x000008, "Member 'Inventory_BPAddItem::ConversationAddItemShowingDelayTime' has a wrong offset!");

// Function man.Inventory.BPChangeSetIndex
// 0x0004 (0x0004 - 0x0000)
struct Inventory_BPChangeSetIndex final
{
public:
	int32                                         SetIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPChangeSetIndex) == 0x000004, "Wrong alignment on Inventory_BPChangeSetIndex");
static_assert(sizeof(Inventory_BPChangeSetIndex) == 0x000004, "Wrong size on Inventory_BPChangeSetIndex");
static_assert(offsetof(Inventory_BPChangeSetIndex, SetIndex) == 0x000000, "Member 'Inventory_BPChangeSetIndex::SetIndex' has a wrong offset!");

// Function man.Inventory.BPEquipItem
// 0x0008 (0x0008 - 0x0000)
struct Inventory_BPEquipItem final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPEquipItem) == 0x000008, "Wrong alignment on Inventory_BPEquipItem");
static_assert(sizeof(Inventory_BPEquipItem) == 0x000008, "Wrong size on Inventory_BPEquipItem");
static_assert(offsetof(Inventory_BPEquipItem, ItemAbilityClass) == 0x000000, "Member 'Inventory_BPEquipItem::ItemAbilityClass' has a wrong offset!");

// Function man.Inventory.BPFindItemNum
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPFindItemNum final
{
public:
	TSubclassOf<class UItemAbility>               ItemClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPFindItemNum) == 0x000008, "Wrong alignment on Inventory_BPFindItemNum");
static_assert(sizeof(Inventory_BPFindItemNum) == 0x000010, "Wrong size on Inventory_BPFindItemNum");
static_assert(offsetof(Inventory_BPFindItemNum, ItemClass) == 0x000000, "Member 'Inventory_BPFindItemNum::ItemClass' has a wrong offset!");
static_assert(offsetof(Inventory_BPFindItemNum, ReturnValue) == 0x000008, "Member 'Inventory_BPFindItemNum::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPGetEntropyLantern
// 0x0008 (0x0008 - 0x0000)
struct Inventory_BPGetEntropyLantern final
{
public:
	class UEntropyLantern*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPGetEntropyLantern) == 0x000008, "Wrong alignment on Inventory_BPGetEntropyLantern");
static_assert(sizeof(Inventory_BPGetEntropyLantern) == 0x000008, "Wrong size on Inventory_BPGetEntropyLantern");
static_assert(offsetof(Inventory_BPGetEntropyLantern, ReturnValue) == 0x000000, "Member 'Inventory_BPGetEntropyLantern::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPGetItemSlot
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPGetItemSlot final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventorySlot                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPGetItemSlot) == 0x000008, "Wrong alignment on Inventory_BPGetItemSlot");
static_assert(sizeof(Inventory_BPGetItemSlot) == 0x000010, "Wrong size on Inventory_BPGetItemSlot");
static_assert(offsetof(Inventory_BPGetItemSlot, ItemAbilityClass) == 0x000000, "Member 'Inventory_BPGetItemSlot::ItemAbilityClass' has a wrong offset!");
static_assert(offsetof(Inventory_BPGetItemSlot, ReturnValue) == 0x000008, "Member 'Inventory_BPGetItemSlot::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPIncreaseFlaskCapacity
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPIncreaseFlaskCapacity final
{
public:
	TSubclassOf<class UFlaskItemAbility>          FlaskType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseNum;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddCharge;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPIncreaseFlaskCapacity) == 0x000008, "Wrong alignment on Inventory_BPIncreaseFlaskCapacity");
static_assert(sizeof(Inventory_BPIncreaseFlaskCapacity) == 0x000010, "Wrong size on Inventory_BPIncreaseFlaskCapacity");
static_assert(offsetof(Inventory_BPIncreaseFlaskCapacity, FlaskType) == 0x000000, "Member 'Inventory_BPIncreaseFlaskCapacity::FlaskType' has a wrong offset!");
static_assert(offsetof(Inventory_BPIncreaseFlaskCapacity, IncreaseNum) == 0x000008, "Member 'Inventory_BPIncreaseFlaskCapacity::IncreaseNum' has a wrong offset!");
static_assert(offsetof(Inventory_BPIncreaseFlaskCapacity, bAddCharge) == 0x00000C, "Member 'Inventory_BPIncreaseFlaskCapacity::bAddCharge' has a wrong offset!");

// Function man.Inventory.BPIsItemEquipped
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPIsItemEquipped final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPIsItemEquipped) == 0x000008, "Wrong alignment on Inventory_BPIsItemEquipped");
static_assert(sizeof(Inventory_BPIsItemEquipped) == 0x000010, "Wrong size on Inventory_BPIsItemEquipped");
static_assert(offsetof(Inventory_BPIsItemEquipped, InventorySlot) == 0x000000, "Member 'Inventory_BPIsItemEquipped::InventorySlot' has a wrong offset!");
static_assert(offsetof(Inventory_BPIsItemEquipped, ReturnValue) == 0x000008, "Member 'Inventory_BPIsItemEquipped::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPIsItemInInventory
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPIsItemInInventory final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPIsItemInInventory) == 0x000008, "Wrong alignment on Inventory_BPIsItemInInventory");
static_assert(sizeof(Inventory_BPIsItemInInventory) == 0x000010, "Wrong size on Inventory_BPIsItemInInventory");
static_assert(offsetof(Inventory_BPIsItemInInventory, ItemAbilityClass) == 0x000000, "Member 'Inventory_BPIsItemInInventory::ItemAbilityClass' has a wrong offset!");
static_assert(offsetof(Inventory_BPIsItemInInventory, ReturnValue) == 0x000008, "Member 'Inventory_BPIsItemInInventory::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPOnItemSlotChanged
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPOnItemSlotChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPOnItemSlotChanged) == 0x000008, "Wrong alignment on Inventory_BPOnItemSlotChanged");
static_assert(sizeof(Inventory_BPOnItemSlotChanged) == 0x000010, "Wrong size on Inventory_BPOnItemSlotChanged");
static_assert(offsetof(Inventory_BPOnItemSlotChanged, SourceSlot) == 0x000000, "Member 'Inventory_BPOnItemSlotChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(Inventory_BPOnItemSlotChanged, DestinationSlot) == 0x000008, "Member 'Inventory_BPOnItemSlotChanged::DestinationSlot' has a wrong offset!");

// Function man.Inventory.BPPutToBackpack
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPPutToBackpack final
{
public:
	class UInventorySlot*                         Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPPutToBackpack) == 0x000008, "Wrong alignment on Inventory_BPPutToBackpack");
static_assert(sizeof(Inventory_BPPutToBackpack) == 0x000010, "Wrong size on Inventory_BPPutToBackpack");
static_assert(offsetof(Inventory_BPPutToBackpack, Item) == 0x000000, "Member 'Inventory_BPPutToBackpack::Item' has a wrong offset!");
static_assert(offsetof(Inventory_BPPutToBackpack, ReturnValue) == 0x000008, "Member 'Inventory_BPPutToBackpack::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPRemoveItem final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackNum;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseItem;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPRemoveItem) == 0x000008, "Wrong alignment on Inventory_BPRemoveItem");
static_assert(sizeof(Inventory_BPRemoveItem) == 0x000010, "Wrong size on Inventory_BPRemoveItem");
static_assert(offsetof(Inventory_BPRemoveItem, ItemAbilityClass) == 0x000000, "Member 'Inventory_BPRemoveItem::ItemAbilityClass' has a wrong offset!");
static_assert(offsetof(Inventory_BPRemoveItem, StackNum) == 0x000008, "Member 'Inventory_BPRemoveItem::StackNum' has a wrong offset!");
static_assert(offsetof(Inventory_BPRemoveItem, bUseItem) == 0x00000C, "Member 'Inventory_BPRemoveItem::bUseItem' has a wrong offset!");
static_assert(offsetof(Inventory_BPRemoveItem, ReturnValue) == 0x00000D, "Member 'Inventory_BPRemoveItem::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPShowHUDPopup
// 0x0050 (0x0050 - 0x0000)
struct Inventory_BPShowHUDPopup final
{
public:
	class FText                                   Name_0;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ItemAbility;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConversationAddItemShowingDelayTime;               // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideNewItemTitle;                                 // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPShowHUDPopup) == 0x000008, "Wrong alignment on Inventory_BPShowHUDPopup");
static_assert(sizeof(Inventory_BPShowHUDPopup) == 0x000050, "Wrong size on Inventory_BPShowHUDPopup");
static_assert(offsetof(Inventory_BPShowHUDPopup, Name_0) == 0x000000, "Member 'Inventory_BPShowHUDPopup::Name_0' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, Description) == 0x000018, "Member 'Inventory_BPShowHUDPopup::Description' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, Icon) == 0x000030, "Member 'Inventory_BPShowHUDPopup::Icon' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, Timeout) == 0x000038, "Member 'Inventory_BPShowHUDPopup::Timeout' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, Number) == 0x00003C, "Member 'Inventory_BPShowHUDPopup::Number' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, ItemAbility) == 0x000040, "Member 'Inventory_BPShowHUDPopup::ItemAbility' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, ConversationAddItemShowingDelayTime) == 0x000048, "Member 'Inventory_BPShowHUDPopup::ConversationAddItemShowingDelayTime' has a wrong offset!");
static_assert(offsetof(Inventory_BPShowHUDPopup, bHideNewItemTitle) == 0x00004C, "Member 'Inventory_BPShowHUDPopup::bHideNewItemTitle' has a wrong offset!");

// Function man.Inventory.BPSwitchQuickUseSlots
// 0x000C (0x000C - 0x0000)
struct Inventory_BPSwitchQuickUseSlots final
{
public:
	int32                                         Slot1Index;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot2Index;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Inventory_BPSwitchQuickUseSlots) == 0x000004, "Wrong alignment on Inventory_BPSwitchQuickUseSlots");
static_assert(sizeof(Inventory_BPSwitchQuickUseSlots) == 0x00000C, "Wrong size on Inventory_BPSwitchQuickUseSlots");
static_assert(offsetof(Inventory_BPSwitchQuickUseSlots, Slot1Index) == 0x000000, "Member 'Inventory_BPSwitchQuickUseSlots::Slot1Index' has a wrong offset!");
static_assert(offsetof(Inventory_BPSwitchQuickUseSlots, Slot2Index) == 0x000004, "Member 'Inventory_BPSwitchQuickUseSlots::Slot2Index' has a wrong offset!");
static_assert(offsetof(Inventory_BPSwitchQuickUseSlots, ReturnValue) == 0x000008, "Member 'Inventory_BPSwitchQuickUseSlots::ReturnValue' has a wrong offset!");

// Function man.Inventory.BPUnEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct Inventory_BPUnEquipSlot final
{
public:
	EInventorySlot                                Slot;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRuningAnims;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UItemAbility>               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_BPUnEquipSlot) == 0x000008, "Wrong alignment on Inventory_BPUnEquipSlot");
static_assert(sizeof(Inventory_BPUnEquipSlot) == 0x000010, "Wrong size on Inventory_BPUnEquipSlot");
static_assert(offsetof(Inventory_BPUnEquipSlot, Slot) == 0x000000, "Member 'Inventory_BPUnEquipSlot::Slot' has a wrong offset!");
static_assert(offsetof(Inventory_BPUnEquipSlot, bIgnoreRuningAnims) == 0x000001, "Member 'Inventory_BPUnEquipSlot::bIgnoreRuningAnims' has a wrong offset!");
static_assert(offsetof(Inventory_BPUnEquipSlot, bForced) == 0x000002, "Member 'Inventory_BPUnEquipSlot::bForced' has a wrong offset!");
static_assert(offsetof(Inventory_BPUnEquipSlot, ReturnValue) == 0x000008, "Member 'Inventory_BPUnEquipSlot::ReturnValue' has a wrong offset!");

// Function man.Inventory.GetGameMode
// 0x0008 (0x0008 - 0x0000)
struct Inventory_GetGameMode final
{
public:
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetGameMode) == 0x000008, "Wrong alignment on Inventory_GetGameMode");
static_assert(sizeof(Inventory_GetGameMode) == 0x000008, "Wrong size on Inventory_GetGameMode");
static_assert(offsetof(Inventory_GetGameMode, ReturnValue) == 0x000000, "Member 'Inventory_GetGameMode::ReturnValue' has a wrong offset!");

// Function man.Inventory.GetHPFlaskEfficiencyModifier
// 0x0004 (0x0004 - 0x0000)
struct Inventory_GetHPFlaskEfficiencyModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetHPFlaskEfficiencyModifier) == 0x000004, "Wrong alignment on Inventory_GetHPFlaskEfficiencyModifier");
static_assert(sizeof(Inventory_GetHPFlaskEfficiencyModifier) == 0x000004, "Wrong size on Inventory_GetHPFlaskEfficiencyModifier");
static_assert(offsetof(Inventory_GetHPFlaskEfficiencyModifier, ReturnValue) == 0x000000, "Member 'Inventory_GetHPFlaskEfficiencyModifier::ReturnValue' has a wrong offset!");

// Function man.Inventory.GetQuestManager
// 0x0008 (0x0008 - 0x0000)
struct Inventory_GetQuestManager final
{
public:
	class UManQuestManager*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_GetQuestManager) == 0x000008, "Wrong alignment on Inventory_GetQuestManager");
static_assert(sizeof(Inventory_GetQuestManager) == 0x000008, "Wrong size on Inventory_GetQuestManager");
static_assert(offsetof(Inventory_GetQuestManager, ReturnValue) == 0x000000, "Member 'Inventory_GetQuestManager::ReturnValue' has a wrong offset!");

// Function man.Inventory.ModifyHealthFlaskEfficiency
// 0x0004 (0x0004 - 0x0000)
struct Inventory_ModifyHealthFlaskEfficiency final
{
public:
	float                                         Modifier;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_ModifyHealthFlaskEfficiency) == 0x000004, "Wrong alignment on Inventory_ModifyHealthFlaskEfficiency");
static_assert(sizeof(Inventory_ModifyHealthFlaskEfficiency) == 0x000004, "Wrong size on Inventory_ModifyHealthFlaskEfficiency");
static_assert(offsetof(Inventory_ModifyHealthFlaskEfficiency, Modifier) == 0x000000, "Member 'Inventory_ModifyHealthFlaskEfficiency::Modifier' has a wrong offset!");

// Function man.Inventory.OnCharacterWindowClose
// 0x0008 (0x0008 - 0x0000)
struct Inventory_OnCharacterWindowClose final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_OnCharacterWindowClose) == 0x000008, "Wrong alignment on Inventory_OnCharacterWindowClose");
static_assert(sizeof(Inventory_OnCharacterWindowClose) == 0x000008, "Wrong size on Inventory_OnCharacterWindowClose");
static_assert(offsetof(Inventory_OnCharacterWindowClose, ManUserWidgetBase) == 0x000000, "Member 'Inventory_OnCharacterWindowClose::ManUserWidgetBase' has a wrong offset!");

// Function man.Inventory.OnCharacterWindowOpen
// 0x0008 (0x0008 - 0x0000)
struct Inventory_OnCharacterWindowOpen final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Inventory_OnCharacterWindowOpen) == 0x000008, "Wrong alignment on Inventory_OnCharacterWindowOpen");
static_assert(sizeof(Inventory_OnCharacterWindowOpen) == 0x000008, "Wrong size on Inventory_OnCharacterWindowOpen");
static_assert(offsetof(Inventory_OnCharacterWindowOpen, ManUserWidgetBase) == 0x000000, "Member 'Inventory_OnCharacterWindowOpen::ManUserWidgetBase' has a wrong offset!");

// Function man.CancelAbilitiesComponent.RegisterCanceledAbilityOnPreCompStart
// 0x0010 (0x0010 - 0x0000)
struct CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart final
{
public:
	TArray<class UAbilityBase*>                   AbilitiesCanceled;                                 // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart) == 0x000008, "Wrong alignment on CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart");
static_assert(sizeof(CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart) == 0x000010, "Wrong size on CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart");
static_assert(offsetof(CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart, AbilitiesCanceled) == 0x000000, "Member 'CancelAbilitiesComponent_RegisterCanceledAbilityOnPreCompStart::AbilitiesCanceled' has a wrong offset!");

// Function man.FireShield.OnPreProjectileContact
// 0x0008 (0x0008 - 0x0000)
struct FireShield_OnPreProjectileContact final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FireShield_OnPreProjectileContact) == 0x000008, "Wrong alignment on FireShield_OnPreProjectileContact");
static_assert(sizeof(FireShield_OnPreProjectileContact) == 0x000008, "Wrong size on FireShield_OnPreProjectileContact");
static_assert(offsetof(FireShield_OnPreProjectileContact, Projectile) == 0x000000, "Member 'FireShield_OnPreProjectileContact::Projectile' has a wrong offset!");

// Function man.DarkFireImpAI.OnImpKilled
// 0x0010 (0x0010 - 0x0000)
struct DarkFireImpAI_OnImpKilled final
{
public:
	class UObject*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     KillerAbilityController;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFireImpAI_OnImpKilled) == 0x000008, "Wrong alignment on DarkFireImpAI_OnImpKilled");
static_assert(sizeof(DarkFireImpAI_OnImpKilled) == 0x000010, "Wrong size on DarkFireImpAI_OnImpKilled");
static_assert(offsetof(DarkFireImpAI_OnImpKilled, Killer) == 0x000000, "Member 'DarkFireImpAI_OnImpKilled::Killer' has a wrong offset!");
static_assert(offsetof(DarkFireImpAI_OnImpKilled, KillerAbilityController) == 0x000008, "Member 'DarkFireImpAI_OnImpKilled::KillerAbilityController' has a wrong offset!");

// Function man.ModifySpellDamage.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct ModifySpellDamage_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModifySpellDamage_OnPreDamageCaused) == 0x000008, "Wrong alignment on ModifySpellDamage_OnPreDamageCaused");
static_assert(sizeof(ModifySpellDamage_OnPreDamageCaused) == 0x0002D8, "Wrong size on ModifySpellDamage_OnPreDamageCaused");
static_assert(offsetof(ModifySpellDamage_OnPreDamageCaused, Param) == 0x000000, "Member 'ModifySpellDamage_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.ManLootTable.GetEntityLootTable
// 0x0018 (0x0018 - 0x0000)
struct ManLootTable_GetEntityLootTable final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceReload;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEntityLootTable*                       ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLootTable_GetEntityLootTable) == 0x000008, "Wrong alignment on ManLootTable_GetEntityLootTable");
static_assert(sizeof(ManLootTable_GetEntityLootTable) == 0x000018, "Wrong size on ManLootTable_GetEntityLootTable");
static_assert(offsetof(ManLootTable_GetEntityLootTable, ActorClass) == 0x000000, "Member 'ManLootTable_GetEntityLootTable::ActorClass' has a wrong offset!");
static_assert(offsetof(ManLootTable_GetEntityLootTable, bForceReload) == 0x000008, "Member 'ManLootTable_GetEntityLootTable::bForceReload' has a wrong offset!");
static_assert(offsetof(ManLootTable_GetEntityLootTable, ReturnValue) == 0x000010, "Member 'ManLootTable_GetEntityLootTable::ReturnValue' has a wrong offset!");

// Function man.ChannelAbility.GetChargeRate
// 0x0004 (0x0004 - 0x0000)
struct ChannelAbility_GetChargeRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChannelAbility_GetChargeRate) == 0x000004, "Wrong alignment on ChannelAbility_GetChargeRate");
static_assert(sizeof(ChannelAbility_GetChargeRate) == 0x000004, "Wrong size on ChannelAbility_GetChargeRate");
static_assert(offsetof(ChannelAbility_GetChargeRate, ReturnValue) == 0x000000, "Member 'ChannelAbility_GetChargeRate::ReturnValue' has a wrong offset!");

// Function man.CStalkerChargeAbility.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct CStalkerChargeAbility_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CStalkerChargeAbility_IsCollideSignature) == 0x000008, "Wrong alignment on CStalkerChargeAbility_IsCollideSignature");
static_assert(sizeof(CStalkerChargeAbility_IsCollideSignature) == 0x000010, "Wrong size on CStalkerChargeAbility_IsCollideSignature");
static_assert(offsetof(CStalkerChargeAbility_IsCollideSignature, Actor) == 0x000000, "Member 'CStalkerChargeAbility_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(CStalkerChargeAbility_IsCollideSignature, bOverride) == 0x000008, "Member 'CStalkerChargeAbility_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(CStalkerChargeAbility_IsCollideSignature, bCollide) == 0x000009, "Member 'CStalkerChargeAbility_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.CStalkerChargeAbility.IsCollideSignatureEx_Pre
// 0x0030 (0x0030 - 0x0000)
struct CStalkerChargeAbility_IsCollideSignatureEx_Pre final
{
public:
	struct FGroundMovecollideIsCollideSignatureParam Param;                                             // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CStalkerChargeAbility_IsCollideSignatureEx_Pre) == 0x000008, "Wrong alignment on CStalkerChargeAbility_IsCollideSignatureEx_Pre");
static_assert(sizeof(CStalkerChargeAbility_IsCollideSignatureEx_Pre) == 0x000030, "Wrong size on CStalkerChargeAbility_IsCollideSignatureEx_Pre");
static_assert(offsetof(CStalkerChargeAbility_IsCollideSignatureEx_Pre, Param) == 0x000000, "Member 'CStalkerChargeAbility_IsCollideSignatureEx_Pre::Param' has a wrong offset!");

// Function man.BlessedWeaponComponent.EntityAbilityAnimEvent
// 0x0018 (0x0018 - 0x0000)
struct BlessedWeaponComponent_EntityAbilityAnimEvent final
{
public:
	class UAbilityBase*                           SourceAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                Anim;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlessedWeaponComponent_EntityAbilityAnimEvent) == 0x000008, "Wrong alignment on BlessedWeaponComponent_EntityAbilityAnimEvent");
static_assert(sizeof(BlessedWeaponComponent_EntityAbilityAnimEvent) == 0x000018, "Wrong size on BlessedWeaponComponent_EntityAbilityAnimEvent");
static_assert(offsetof(BlessedWeaponComponent_EntityAbilityAnimEvent, SourceAbility) == 0x000000, "Member 'BlessedWeaponComponent_EntityAbilityAnimEvent::SourceAbility' has a wrong offset!");
static_assert(offsetof(BlessedWeaponComponent_EntityAbilityAnimEvent, Anim) == 0x000008, "Member 'BlessedWeaponComponent_EntityAbilityAnimEvent::Anim' has a wrong offset!");
static_assert(offsetof(BlessedWeaponComponent_EntityAbilityAnimEvent, AnimEventType) == 0x000010, "Member 'BlessedWeaponComponent_EntityAbilityAnimEvent::AnimEventType' has a wrong offset!");

// Function man.BlessedWeaponComponent.OnDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct BlessedWeaponComponent_OnDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlessedWeaponComponent_OnDamageDealt) == 0x000008, "Wrong alignment on BlessedWeaponComponent_OnDamageDealt");
static_assert(sizeof(BlessedWeaponComponent_OnDamageDealt) == 0x0002D8, "Wrong size on BlessedWeaponComponent_OnDamageDealt");
static_assert(offsetof(BlessedWeaponComponent_OnDamageDealt, Param) == 0x000000, "Member 'BlessedWeaponComponent_OnDamageDealt::Param' has a wrong offset!");

// Function man.ManBtnUserWidget.IsBtnEnabled
// 0x0001 (0x0001 - 0x0000)
struct ManBtnUserWidget_IsBtnEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManBtnUserWidget_IsBtnEnabled) == 0x000001, "Wrong alignment on ManBtnUserWidget_IsBtnEnabled");
static_assert(sizeof(ManBtnUserWidget_IsBtnEnabled) == 0x000001, "Wrong size on ManBtnUserWidget_IsBtnEnabled");
static_assert(offsetof(ManBtnUserWidget_IsBtnEnabled, ReturnValue) == 0x000000, "Member 'ManBtnUserWidget_IsBtnEnabled::ReturnValue' has a wrong offset!");

// Function man.ManBtnUserWidget.OnSetBtnEnabled
// 0x0001 (0x0001 - 0x0000)
struct ManBtnUserWidget_OnSetBtnEnabled final
{
public:
	bool                                          bInBtnEnabled;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManBtnUserWidget_OnSetBtnEnabled) == 0x000001, "Wrong alignment on ManBtnUserWidget_OnSetBtnEnabled");
static_assert(sizeof(ManBtnUserWidget_OnSetBtnEnabled) == 0x000001, "Wrong size on ManBtnUserWidget_OnSetBtnEnabled");
static_assert(offsetof(ManBtnUserWidget_OnSetBtnEnabled, bInBtnEnabled) == 0x000000, "Member 'ManBtnUserWidget_OnSetBtnEnabled::bInBtnEnabled' has a wrong offset!");

// Function man.ManBtnUserWidget.OnSetText
// 0x0018 (0x0018 - 0x0000)
struct ManBtnUserWidget_OnSetText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManBtnUserWidget_OnSetText) == 0x000008, "Wrong alignment on ManBtnUserWidget_OnSetText");
static_assert(sizeof(ManBtnUserWidget_OnSetText) == 0x000018, "Wrong size on ManBtnUserWidget_OnSetText");
static_assert(offsetof(ManBtnUserWidget_OnSetText, Text) == 0x000000, "Member 'ManBtnUserWidget_OnSetText::Text' has a wrong offset!");

// Function man.ManBtnUserWidget.SetBtnEnabled
// 0x0001 (0x0001 - 0x0000)
struct ManBtnUserWidget_SetBtnEnabled final
{
public:
	bool                                          bInBtnEnabled;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManBtnUserWidget_SetBtnEnabled) == 0x000001, "Wrong alignment on ManBtnUserWidget_SetBtnEnabled");
static_assert(sizeof(ManBtnUserWidget_SetBtnEnabled) == 0x000001, "Wrong size on ManBtnUserWidget_SetBtnEnabled");
static_assert(offsetof(ManBtnUserWidget_SetBtnEnabled, bInBtnEnabled) == 0x000000, "Member 'ManBtnUserWidget_SetBtnEnabled::bInBtnEnabled' has a wrong offset!");

// Function man.EnvenomComponent.OnDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct EnvenomComponent_OnDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnvenomComponent_OnDamageDealt) == 0x000008, "Wrong alignment on EnvenomComponent_OnDamageDealt");
static_assert(sizeof(EnvenomComponent_OnDamageDealt) == 0x0002D8, "Wrong size on EnvenomComponent_OnDamageDealt");
static_assert(offsetof(EnvenomComponent_OnDamageDealt, Param) == 0x000000, "Member 'EnvenomComponent_OnDamageDealt::Param' has a wrong offset!");

// Function man.VendorItemSlotUserWidget.OnHighlighted
// 0x0002 (0x0002 - 0x0000)
struct VendorItemSlotUserWidget_OnHighlighted final
{
public:
	bool                                          bHighlighted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItemSlotUserWidget_OnHighlighted) == 0x000001, "Wrong alignment on VendorItemSlotUserWidget_OnHighlighted");
static_assert(sizeof(VendorItemSlotUserWidget_OnHighlighted) == 0x000002, "Wrong size on VendorItemSlotUserWidget_OnHighlighted");
static_assert(offsetof(VendorItemSlotUserWidget_OnHighlighted, bHighlighted) == 0x000000, "Member 'VendorItemSlotUserWidget_OnHighlighted::bHighlighted' has a wrong offset!");
static_assert(offsetof(VendorItemSlotUserWidget_OnHighlighted, bAnimate) == 0x000001, "Member 'VendorItemSlotUserWidget_OnHighlighted::bAnimate' has a wrong offset!");

// Function man.VendorItemSlotUserWidget.OnPermanentEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InPermanentEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000008, "Wrong alignment on VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(sizeof(VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000010, "Wrong size on VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(offsetof(VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged, InPermanentEnchantIcons) == 0x000000, "Member 'VendorItemSlotUserWidget_OnPermanentEnchantIconsChanged::InPermanentEnchantIcons' has a wrong offset!");

// Function man.VendorItemSlotUserWidget.OnSetSlot
// 0x0020 (0x0020 - 0x0000)
struct VendorItemSlotUserWidget_OnSetSlot final
{
public:
	const class UTexture2D*                       InIcon;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InName;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItemSlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on VendorItemSlotUserWidget_OnSetSlot");
static_assert(sizeof(VendorItemSlotUserWidget_OnSetSlot) == 0x000020, "Wrong size on VendorItemSlotUserWidget_OnSetSlot");
static_assert(offsetof(VendorItemSlotUserWidget_OnSetSlot, InIcon) == 0x000000, "Member 'VendorItemSlotUserWidget_OnSetSlot::InIcon' has a wrong offset!");
static_assert(offsetof(VendorItemSlotUserWidget_OnSetSlot, InName) == 0x000008, "Member 'VendorItemSlotUserWidget_OnSetSlot::InName' has a wrong offset!");

// Function man.VendorItemSlotUserWidget.OnSetSlotCost
// 0x0008 (0x0008 - 0x0000)
struct VendorItemSlotUserWidget_OnSetSlotCost final
{
public:
	int32                                         InCost;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InAvailable;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItemSlotUserWidget_OnSetSlotCost) == 0x000004, "Wrong alignment on VendorItemSlotUserWidget_OnSetSlotCost");
static_assert(sizeof(VendorItemSlotUserWidget_OnSetSlotCost) == 0x000008, "Wrong size on VendorItemSlotUserWidget_OnSetSlotCost");
static_assert(offsetof(VendorItemSlotUserWidget_OnSetSlotCost, InCost) == 0x000000, "Member 'VendorItemSlotUserWidget_OnSetSlotCost::InCost' has a wrong offset!");
static_assert(offsetof(VendorItemSlotUserWidget_OnSetSlotCost, InAvailable) == 0x000004, "Member 'VendorItemSlotUserWidget_OnSetSlotCost::InAvailable' has a wrong offset!");

// Function man.VendorItemSlotUserWidget.OnTemporaryEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InTemporaryEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000008, "Wrong alignment on VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(sizeof(VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000010, "Wrong size on VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(offsetof(VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged, InTemporaryEnchantIcons) == 0x000000, "Member 'VendorItemSlotUserWidget_OnTemporaryEnchantIconsChanged::InTemporaryEnchantIcons' has a wrong offset!");

// Function man.NPCBestiaryFilterSlotUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryFilterSlotUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on NPCBestiaryFilterSlotUserWidget_OnSetEnabled");
static_assert(sizeof(NPCBestiaryFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong size on NPCBestiaryFilterSlotUserWidget_OnSetEnabled");
static_assert(offsetof(NPCBestiaryFilterSlotUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'NPCBestiaryFilterSlotUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.NPCBestiaryFilterSlotUserWidget.OnSetSelected
// 0x0002 (0x0002 - 0x0000)
struct NPCBestiaryFilterSlotUserWidget_OnSetSelected final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong alignment on NPCBestiaryFilterSlotUserWidget_OnSetSelected");
static_assert(sizeof(NPCBestiaryFilterSlotUserWidget_OnSetSelected) == 0x000002, "Wrong size on NPCBestiaryFilterSlotUserWidget_OnSetSelected");
static_assert(offsetof(NPCBestiaryFilterSlotUserWidget_OnSetSelected, bInSelected) == 0x000000, "Member 'NPCBestiaryFilterSlotUserWidget_OnSetSelected::bInSelected' has a wrong offset!");
static_assert(offsetof(NPCBestiaryFilterSlotUserWidget_OnSetSelected, bAnimate) == 0x000001, "Member 'NPCBestiaryFilterSlotUserWidget_OnSetSelected::bAnimate' has a wrong offset!");

// Function man.NPCBestiaryFilterSlotUserWidget.OnToggleNewRegistry
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry) == 0x000001, "Wrong alignment on NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry");
static_assert(sizeof(NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry) == 0x000001, "Wrong size on NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry");
static_assert(offsetof(NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry, bInVisible) == 0x000000, "Member 'NPCBestiaryFilterSlotUserWidget_OnToggleNewRegistry::bInVisible' has a wrong offset!");

// Function man.NPCBestiaryFilterSlotUserWidget.IsFilterEnabled
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryFilterSlotUserWidget_IsFilterEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong alignment on NPCBestiaryFilterSlotUserWidget_IsFilterEnabled");
static_assert(sizeof(NPCBestiaryFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong size on NPCBestiaryFilterSlotUserWidget_IsFilterEnabled");
static_assert(offsetof(NPCBestiaryFilterSlotUserWidget_IsFilterEnabled, ReturnValue) == 0x000000, "Member 'NPCBestiaryFilterSlotUserWidget_IsFilterEnabled::ReturnValue' has a wrong offset!");

// Function man.ArcaneCultistBlink.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct ArcaneCultistBlink_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArcaneCultistBlink_BPGetTeleportLocation) == 0x000004, "Wrong alignment on ArcaneCultistBlink_BPGetTeleportLocation");
static_assert(sizeof(ArcaneCultistBlink_BPGetTeleportLocation) == 0x00000C, "Wrong size on ArcaneCultistBlink_BPGetTeleportLocation");
static_assert(offsetof(ArcaneCultistBlink_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'ArcaneCultistBlink_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.SQ26SecondaryQuest.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct SQ26SecondaryQuest_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SQ26SecondaryQuest_OnPreDamaged) == 0x000008, "Wrong alignment on SQ26SecondaryQuest_OnPreDamaged");
static_assert(sizeof(SQ26SecondaryQuest_OnPreDamaged) == 0x0002D8, "Wrong size on SQ26SecondaryQuest_OnPreDamaged");
static_assert(offsetof(SQ26SecondaryQuest_OnPreDamaged, Param) == 0x000000, "Member 'SQ26SecondaryQuest_OnPreDamaged::Param' has a wrong offset!");

// Function man.InquisitorDivineHammer.ProjectileShot
// 0x0008 (0x0008 - 0x0000)
struct InquisitorDivineHammer_ProjectileShot final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorDivineHammer_ProjectileShot) == 0x000008, "Wrong alignment on InquisitorDivineHammer_ProjectileShot");
static_assert(sizeof(InquisitorDivineHammer_ProjectileShot) == 0x000008, "Wrong size on InquisitorDivineHammer_ProjectileShot");
static_assert(offsetof(InquisitorDivineHammer_ProjectileShot, Projectile) == 0x000000, "Member 'InquisitorDivineHammer_ProjectileShot::Projectile' has a wrong offset!");

// Function man.CameraTriggerBox.SetActive
// 0x0001 (0x0001 - 0x0000)
struct CameraTriggerBox_SetActive final
{
public:
	bool                                          NewActive;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraTriggerBox_SetActive) == 0x000001, "Wrong alignment on CameraTriggerBox_SetActive");
static_assert(sizeof(CameraTriggerBox_SetActive) == 0x000001, "Wrong size on CameraTriggerBox_SetActive");
static_assert(offsetof(CameraTriggerBox_SetActive, NewActive) == 0x000000, "Member 'CameraTriggerBox_SetActive::NewActive' has a wrong offset!");

// Function man.CameraTriggerBox.IsActive
// 0x0001 (0x0001 - 0x0000)
struct CameraTriggerBox_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraTriggerBox_IsActive) == 0x000001, "Wrong alignment on CameraTriggerBox_IsActive");
static_assert(sizeof(CameraTriggerBox_IsActive) == 0x000001, "Wrong size on CameraTriggerBox_IsActive");
static_assert(offsetof(CameraTriggerBox_IsActive, ReturnValue) == 0x000000, "Member 'CameraTriggerBox_IsActive::ReturnValue' has a wrong offset!");

// Function man.InquisitorDuoAI.OnTurnEnded
// 0x0008 (0x0008 - 0x0000)
struct InquisitorDuoAI_OnTurnEnded final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorDuoAI_OnTurnEnded) == 0x000008, "Wrong alignment on InquisitorDuoAI_OnTurnEnded");
static_assert(sizeof(InquisitorDuoAI_OnTurnEnded) == 0x000008, "Wrong size on InquisitorDuoAI_OnTurnEnded");
static_assert(offsetof(InquisitorDuoAI_OnTurnEnded, InAbility) == 0x000000, "Member 'InquisitorDuoAI_OnTurnEnded::InAbility' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetActive
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_OnSetActive final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetActive) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_OnSetActive");
static_assert(sizeof(AttributeSlotUserWidget_OnSetActive) == 0x000001, "Wrong size on AttributeSlotUserWidget_OnSetActive");
static_assert(offsetof(AttributeSlotUserWidget_OnSetActive, bActive) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetActive::bActive' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetActualValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_OnSetActualValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetActualValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_OnSetActualValue");
static_assert(sizeof(AttributeSlotUserWidget_OnSetActualValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_OnSetActualValue");
static_assert(offsetof(AttributeSlotUserWidget_OnSetActualValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetActualValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetCurrentValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_OnSetCurrentValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetCurrentValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_OnSetCurrentValue");
static_assert(sizeof(AttributeSlotUserWidget_OnSetCurrentValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_OnSetCurrentValue");
static_assert(offsetof(AttributeSlotUserWidget_OnSetCurrentValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetCurrentValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetLeftButtonEnabled
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_OnSetLeftButtonEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetLeftButtonEnabled) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_OnSetLeftButtonEnabled");
static_assert(sizeof(AttributeSlotUserWidget_OnSetLeftButtonEnabled) == 0x000001, "Wrong size on AttributeSlotUserWidget_OnSetLeftButtonEnabled");
static_assert(offsetof(AttributeSlotUserWidget_OnSetLeftButtonEnabled, bEnabled) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetLeftButtonEnabled::bEnabled' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetNewValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_OnSetNewValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetNewValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_OnSetNewValue");
static_assert(sizeof(AttributeSlotUserWidget_OnSetNewValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_OnSetNewValue");
static_assert(offsetof(AttributeSlotUserWidget_OnSetNewValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetNewValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetRightButtonEnabled
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_OnSetRightButtonEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetRightButtonEnabled) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_OnSetRightButtonEnabled");
static_assert(sizeof(AttributeSlotUserWidget_OnSetRightButtonEnabled) == 0x000001, "Wrong size on AttributeSlotUserWidget_OnSetRightButtonEnabled");
static_assert(offsetof(AttributeSlotUserWidget_OnSetRightButtonEnabled, bEnabled) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetRightButtonEnabled::bEnabled' has a wrong offset!");

// Function man.AttributeSlotUserWidget.OnSetShowCurrentValue
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_OnSetShowCurrentValue final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_OnSetShowCurrentValue) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_OnSetShowCurrentValue");
static_assert(sizeof(AttributeSlotUserWidget_OnSetShowCurrentValue) == 0x000001, "Wrong size on AttributeSlotUserWidget_OnSetShowCurrentValue");
static_assert(offsetof(AttributeSlotUserWidget_OnSetShowCurrentValue, bShow) == 0x000000, "Member 'AttributeSlotUserWidget_OnSetShowCurrentValue::bShow' has a wrong offset!");

// Function man.AttributeSlotUserWidget.SetActualValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_SetActualValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_SetActualValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_SetActualValue");
static_assert(sizeof(AttributeSlotUserWidget_SetActualValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_SetActualValue");
static_assert(offsetof(AttributeSlotUserWidget_SetActualValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_SetActualValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.SetCurrentValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_SetCurrentValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_SetCurrentValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_SetCurrentValue");
static_assert(sizeof(AttributeSlotUserWidget_SetCurrentValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_SetCurrentValue");
static_assert(offsetof(AttributeSlotUserWidget_SetCurrentValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_SetCurrentValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.SetNewValue
// 0x0004 (0x0004 - 0x0000)
struct AttributeSlotUserWidget_SetNewValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_SetNewValue) == 0x000004, "Wrong alignment on AttributeSlotUserWidget_SetNewValue");
static_assert(sizeof(AttributeSlotUserWidget_SetNewValue) == 0x000004, "Wrong size on AttributeSlotUserWidget_SetNewValue");
static_assert(offsetof(AttributeSlotUserWidget_SetNewValue, Value) == 0x000000, "Member 'AttributeSlotUserWidget_SetNewValue::Value' has a wrong offset!");

// Function man.AttributeSlotUserWidget.SetShowCurrentValue
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_SetShowCurrentValue final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_SetShowCurrentValue) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_SetShowCurrentValue");
static_assert(sizeof(AttributeSlotUserWidget_SetShowCurrentValue) == 0x000001, "Wrong size on AttributeSlotUserWidget_SetShowCurrentValue");
static_assert(offsetof(AttributeSlotUserWidget_SetShowCurrentValue, bShow) == 0x000000, "Member 'AttributeSlotUserWidget_SetShowCurrentValue::bShow' has a wrong offset!");

// Function man.AttributeSlotUserWidget.GetFormattedAttributeName
// 0x0018 (0x0018 - 0x0000)
struct AttributeSlotUserWidget_GetFormattedAttributeName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_GetFormattedAttributeName) == 0x000008, "Wrong alignment on AttributeSlotUserWidget_GetFormattedAttributeName");
static_assert(sizeof(AttributeSlotUserWidget_GetFormattedAttributeName) == 0x000018, "Wrong size on AttributeSlotUserWidget_GetFormattedAttributeName");
static_assert(offsetof(AttributeSlotUserWidget_GetFormattedAttributeName, ReturnValue) == 0x000000, "Member 'AttributeSlotUserWidget_GetFormattedAttributeName::ReturnValue' has a wrong offset!");

// Function man.AttributeSlotUserWidget.GetFormattedValueText
// 0x0020 (0x0020 - 0x0000)
struct AttributeSlotUserWidget_GetFormattedValueText final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_GetFormattedValueText) == 0x000008, "Wrong alignment on AttributeSlotUserWidget_GetFormattedValueText");
static_assert(sizeof(AttributeSlotUserWidget_GetFormattedValueText) == 0x000020, "Wrong size on AttributeSlotUserWidget_GetFormattedValueText");
static_assert(offsetof(AttributeSlotUserWidget_GetFormattedValueText, Value) == 0x000000, "Member 'AttributeSlotUserWidget_GetFormattedValueText::Value' has a wrong offset!");
static_assert(offsetof(AttributeSlotUserWidget_GetFormattedValueText, ReturnValue) == 0x000008, "Member 'AttributeSlotUserWidget_GetFormattedValueText::ReturnValue' has a wrong offset!");

// Function man.AttributeSlotUserWidget.IsShowActualValue
// 0x0001 (0x0001 - 0x0000)
struct AttributeSlotUserWidget_IsShowActualValue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeSlotUserWidget_IsShowActualValue) == 0x000001, "Wrong alignment on AttributeSlotUserWidget_IsShowActualValue");
static_assert(sizeof(AttributeSlotUserWidget_IsShowActualValue) == 0x000001, "Wrong size on AttributeSlotUserWidget_IsShowActualValue");
static_assert(offsetof(AttributeSlotUserWidget_IsShowActualValue, ReturnValue) == 0x000000, "Member 'AttributeSlotUserWidget_IsShowActualValue::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetGamepadHotkeyImages
// 0x0018 (0x0018 - 0x0000)
struct InteractButtonUserWidget_GetGamepadHotkeyImages final
{
public:
	EInputDisplay                                 InInputDisplay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetGamepadHotkeyImages) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetGamepadHotkeyImages");
static_assert(sizeof(InteractButtonUserWidget_GetGamepadHotkeyImages) == 0x000018, "Wrong size on InteractButtonUserWidget_GetGamepadHotkeyImages");
static_assert(offsetof(InteractButtonUserWidget_GetGamepadHotkeyImages, InInputDisplay) == 0x000000, "Member 'InteractButtonUserWidget_GetGamepadHotkeyImages::InInputDisplay' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_GetGamepadHotkeyImages, ReturnValue) == 0x000008, "Member 'InteractButtonUserWidget_GetGamepadHotkeyImages::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetHotkeyIconUserWidgets
// 0x0010 (0x0010 - 0x0000)
struct InteractButtonUserWidget_GetHotkeyIconUserWidgets final
{
public:
	TArray<class UImage*>                         ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetHotkeyIconUserWidgets) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetHotkeyIconUserWidgets");
static_assert(sizeof(InteractButtonUserWidget_GetHotkeyIconUserWidgets) == 0x000010, "Wrong size on InteractButtonUserWidget_GetHotkeyIconUserWidgets");
static_assert(offsetof(InteractButtonUserWidget_GetHotkeyIconUserWidgets, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_GetHotkeyIconUserWidgets::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetHotkeyTextBorderUserWidgets
// 0x0010 (0x0010 - 0x0000)
struct InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets final
{
public:
	TArray<class UBorder*>                        ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets");
static_assert(sizeof(InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets) == 0x000010, "Wrong size on InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets");
static_assert(offsetof(InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_GetHotkeyTextBorderUserWidgets::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetHotkeyTextUserWidgets
// 0x0010 (0x0010 - 0x0000)
struct InteractButtonUserWidget_GetHotkeyTextUserWidgets final
{
public:
	TArray<class UTextBlock*>                     ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetHotkeyTextUserWidgets) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetHotkeyTextUserWidgets");
static_assert(sizeof(InteractButtonUserWidget_GetHotkeyTextUserWidgets) == 0x000010, "Wrong size on InteractButtonUserWidget_GetHotkeyTextUserWidgets");
static_assert(offsetof(InteractButtonUserWidget_GetHotkeyTextUserWidgets, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_GetHotkeyTextUserWidgets::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetKeyboardHotkeyImages
// 0x0018 (0x0018 - 0x0000)
struct InteractButtonUserWidget_GetKeyboardHotkeyImages final
{
public:
	bool                                          bOnlyPrimary;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySecondary;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetKeyboardHotkeyImages) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetKeyboardHotkeyImages");
static_assert(sizeof(InteractButtonUserWidget_GetKeyboardHotkeyImages) == 0x000018, "Wrong size on InteractButtonUserWidget_GetKeyboardHotkeyImages");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyImages, bOnlyPrimary) == 0x000000, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyImages::bOnlyPrimary' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyImages, bOnlySecondary) == 0x000001, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyImages::bOnlySecondary' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyImages, ReturnValue) == 0x000008, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyImages::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetKeyboardHotkeyText
// 0x0018 (0x0018 - 0x0000)
struct InteractButtonUserWidget_GetKeyboardHotkeyText final
{
public:
	bool                                          bOnlyPrimary;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySecondary;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetKeyboardHotkeyText) == 0x000008, "Wrong alignment on InteractButtonUserWidget_GetKeyboardHotkeyText");
static_assert(sizeof(InteractButtonUserWidget_GetKeyboardHotkeyText) == 0x000018, "Wrong size on InteractButtonUserWidget_GetKeyboardHotkeyText");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyText, bOnlyPrimary) == 0x000000, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyText::bOnlyPrimary' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyText, bOnlySecondary) == 0x000001, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyText::bOnlySecondary' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_GetKeyboardHotkeyText, ReturnValue) == 0x000008, "Member 'InteractButtonUserWidget_GetKeyboardHotkeyText::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.OnSetHold
// 0x0001 (0x0001 - 0x0000)
struct InteractButtonUserWidget_OnSetHold final
{
public:
	bool                                          bInHold;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_OnSetHold) == 0x000001, "Wrong alignment on InteractButtonUserWidget_OnSetHold");
static_assert(sizeof(InteractButtonUserWidget_OnSetHold) == 0x000001, "Wrong size on InteractButtonUserWidget_OnSetHold");
static_assert(offsetof(InteractButtonUserWidget_OnSetHold, bInHold) == 0x000000, "Member 'InteractButtonUserWidget_OnSetHold::bInHold' has a wrong offset!");

// Function man.InteractButtonUserWidget.OnSetHotkeyImages
// 0x0010 (0x0010 - 0x0000)
struct InteractButtonUserWidget_OnSetHotkeyImages final
{
public:
	TArray<class UTexture2D*>                     HotkeyImages;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_OnSetHotkeyImages) == 0x000008, "Wrong alignment on InteractButtonUserWidget_OnSetHotkeyImages");
static_assert(sizeof(InteractButtonUserWidget_OnSetHotkeyImages) == 0x000010, "Wrong size on InteractButtonUserWidget_OnSetHotkeyImages");
static_assert(offsetof(InteractButtonUserWidget_OnSetHotkeyImages, HotkeyImages) == 0x000000, "Member 'InteractButtonUserWidget_OnSetHotkeyImages::HotkeyImages' has a wrong offset!");

// Function man.InteractButtonUserWidget.OnSetHotkeyText
// 0x0010 (0x0010 - 0x0000)
struct InteractButtonUserWidget_OnSetHotkeyText final
{
public:
	TArray<class FText>                           HotkeyTexts;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_OnSetHotkeyText) == 0x000008, "Wrong alignment on InteractButtonUserWidget_OnSetHotkeyText");
static_assert(sizeof(InteractButtonUserWidget_OnSetHotkeyText) == 0x000010, "Wrong size on InteractButtonUserWidget_OnSetHotkeyText");
static_assert(offsetof(InteractButtonUserWidget_OnSetHotkeyText, HotkeyTexts) == 0x000000, "Member 'InteractButtonUserWidget_OnSetHotkeyText::HotkeyTexts' has a wrong offset!");

// Function man.InteractButtonUserWidget.OnSetState
// 0x0002 (0x0002 - 0x0000)
struct InteractButtonUserWidget_OnSetState final
{
public:
	bool                                          bInCaption1Active;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCaption2Active;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_OnSetState) == 0x000001, "Wrong alignment on InteractButtonUserWidget_OnSetState");
static_assert(sizeof(InteractButtonUserWidget_OnSetState) == 0x000002, "Wrong size on InteractButtonUserWidget_OnSetState");
static_assert(offsetof(InteractButtonUserWidget_OnSetState, bInCaption1Active) == 0x000000, "Member 'InteractButtonUserWidget_OnSetState::bInCaption1Active' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_OnSetState, bInCaption2Active) == 0x000001, "Member 'InteractButtonUserWidget_OnSetState::bInCaption2Active' has a wrong offset!");

// Function man.InteractButtonUserWidget.SetState
// 0x0002 (0x0002 - 0x0000)
struct InteractButtonUserWidget_SetState final
{
public:
	bool                                          bInCaption1Active;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCaption2Active;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_SetState) == 0x000001, "Wrong alignment on InteractButtonUserWidget_SetState");
static_assert(sizeof(InteractButtonUserWidget_SetState) == 0x000002, "Wrong size on InteractButtonUserWidget_SetState");
static_assert(offsetof(InteractButtonUserWidget_SetState, bInCaption1Active) == 0x000000, "Member 'InteractButtonUserWidget_SetState::bInCaption1Active' has a wrong offset!");
static_assert(offsetof(InteractButtonUserWidget_SetState, bInCaption2Active) == 0x000001, "Member 'InteractButtonUserWidget_SetState::bInCaption2Active' has a wrong offset!");

// Function man.InteractButtonUserWidget.GetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct InteractButtonUserWidget_GetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_GetElapsedTime) == 0x000004, "Wrong alignment on InteractButtonUserWidget_GetElapsedTime");
static_assert(sizeof(InteractButtonUserWidget_GetElapsedTime) == 0x000004, "Wrong size on InteractButtonUserWidget_GetElapsedTime");
static_assert(offsetof(InteractButtonUserWidget_GetElapsedTime, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_GetElapsedTime::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.IsActive
// 0x0001 (0x0001 - 0x0000)
struct InteractButtonUserWidget_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_IsActive) == 0x000001, "Wrong alignment on InteractButtonUserWidget_IsActive");
static_assert(sizeof(InteractButtonUserWidget_IsActive) == 0x000001, "Wrong size on InteractButtonUserWidget_IsActive");
static_assert(offsetof(InteractButtonUserWidget_IsActive, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_IsActive::ReturnValue' has a wrong offset!");

// Function man.InteractButtonUserWidget.IsHold
// 0x0001 (0x0001 - 0x0000)
struct InteractButtonUserWidget_IsHold final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractButtonUserWidget_IsHold) == 0x000001, "Wrong alignment on InteractButtonUserWidget_IsHold");
static_assert(sizeof(InteractButtonUserWidget_IsHold) == 0x000001, "Wrong size on InteractButtonUserWidget_IsHold");
static_assert(offsetof(InteractButtonUserWidget_IsHold, ReturnValue) == 0x000000, "Member 'InteractButtonUserWidget_IsHold::ReturnValue' has a wrong offset!");

// Function man.OptionsHotkeyBtnUserWidget.OnSetEmpty
// 0x0001 (0x0001 - 0x0000)
struct OptionsHotkeyBtnUserWidget_OnSetEmpty final
{
public:
	bool                                          bInEmpty;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsHotkeyBtnUserWidget_OnSetEmpty) == 0x000001, "Wrong alignment on OptionsHotkeyBtnUserWidget_OnSetEmpty");
static_assert(sizeof(OptionsHotkeyBtnUserWidget_OnSetEmpty) == 0x000001, "Wrong size on OptionsHotkeyBtnUserWidget_OnSetEmpty");
static_assert(offsetof(OptionsHotkeyBtnUserWidget_OnSetEmpty, bInEmpty) == 0x000000, "Member 'OptionsHotkeyBtnUserWidget_OnSetEmpty::bInEmpty' has a wrong offset!");

// Function man.OptionsHotkeyBtnUserWidget.OnSetLocked
// 0x0001 (0x0001 - 0x0000)
struct OptionsHotkeyBtnUserWidget_OnSetLocked final
{
public:
	bool                                          bInLocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsHotkeyBtnUserWidget_OnSetLocked) == 0x000001, "Wrong alignment on OptionsHotkeyBtnUserWidget_OnSetLocked");
static_assert(sizeof(OptionsHotkeyBtnUserWidget_OnSetLocked) == 0x000001, "Wrong size on OptionsHotkeyBtnUserWidget_OnSetLocked");
static_assert(offsetof(OptionsHotkeyBtnUserWidget_OnSetLocked, bInLocked) == 0x000000, "Member 'OptionsHotkeyBtnUserWidget_OnSetLocked::bInLocked' has a wrong offset!");

// Function man.OptionsHotkeyBtnUserWidget.OnSetWaiting
// 0x0001 (0x0001 - 0x0000)
struct OptionsHotkeyBtnUserWidget_OnSetWaiting final
{
public:
	bool                                          bInWaiting;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsHotkeyBtnUserWidget_OnSetWaiting) == 0x000001, "Wrong alignment on OptionsHotkeyBtnUserWidget_OnSetWaiting");
static_assert(sizeof(OptionsHotkeyBtnUserWidget_OnSetWaiting) == 0x000001, "Wrong size on OptionsHotkeyBtnUserWidget_OnSetWaiting");
static_assert(offsetof(OptionsHotkeyBtnUserWidget_OnSetWaiting, bInWaiting) == 0x000000, "Member 'OptionsHotkeyBtnUserWidget_OnSetWaiting::bInWaiting' has a wrong offset!");

// Function man.OptionsHotkeyBtnUserWidget.SetWaiting
// 0x0001 (0x0001 - 0x0000)
struct OptionsHotkeyBtnUserWidget_SetWaiting final
{
public:
	bool                                          bInWaiting;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsHotkeyBtnUserWidget_SetWaiting) == 0x000001, "Wrong alignment on OptionsHotkeyBtnUserWidget_SetWaiting");
static_assert(sizeof(OptionsHotkeyBtnUserWidget_SetWaiting) == 0x000001, "Wrong size on OptionsHotkeyBtnUserWidget_SetWaiting");
static_assert(offsetof(OptionsHotkeyBtnUserWidget_SetWaiting, bInWaiting) == 0x000000, "Member 'OptionsHotkeyBtnUserWidget_SetWaiting::bInWaiting' has a wrong offset!");

// Function man.EventOnHit.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct EventOnHit_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EventOnHit_OnPostDamageDone) == 0x000008, "Wrong alignment on EventOnHit_OnPostDamageDone");
static_assert(sizeof(EventOnHit_OnPostDamageDone) == 0x0002D8, "Wrong size on EventOnHit_OnPostDamageDone");
static_assert(offsetof(EventOnHit_OnPostDamageDone, DamageParams) == 0x000000, "Member 'EventOnHit_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.PrimalVFX.InterpolateMaterials
// 0x0058 (0x0058 - 0x0000)
struct PrimalVFX_InterpolateMaterials final
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              Sources;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<float>                                 Alphas;                                            // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           ScalarParameterNames;                              // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           VectorParameterNames;                              // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   UniquenessWeightParameterName;                     // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniquenessWeightPower;                             // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimalVFX_InterpolateMaterials) == 0x000008, "Wrong alignment on PrimalVFX_InterpolateMaterials");
static_assert(sizeof(PrimalVFX_InterpolateMaterials) == 0x000058, "Wrong size on PrimalVFX_InterpolateMaterials");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, MeshComponent) == 0x000000, "Member 'PrimalVFX_InterpolateMaterials::MeshComponent' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, Sources) == 0x000008, "Member 'PrimalVFX_InterpolateMaterials::Sources' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, Alphas) == 0x000018, "Member 'PrimalVFX_InterpolateMaterials::Alphas' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, ScalarParameterNames) == 0x000028, "Member 'PrimalVFX_InterpolateMaterials::ScalarParameterNames' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, VectorParameterNames) == 0x000038, "Member 'PrimalVFX_InterpolateMaterials::VectorParameterNames' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, UniquenessWeightParameterName) == 0x000048, "Member 'PrimalVFX_InterpolateMaterials::UniquenessWeightParameterName' has a wrong offset!");
static_assert(offsetof(PrimalVFX_InterpolateMaterials, UniquenessWeightPower) == 0x000050, "Member 'PrimalVFX_InterpolateMaterials::UniquenessWeightPower' has a wrong offset!");

// Function man.ChaosTenticles.AbilityStart
// 0x0010 (0x0010 - 0x0000)
struct ChaosTenticles_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChaosTenticles_AbilityStart) == 0x000008, "Wrong alignment on ChaosTenticles_AbilityStart");
static_assert(sizeof(ChaosTenticles_AbilityStart) == 0x000010, "Wrong size on ChaosTenticles_AbilityStart");
static_assert(offsetof(ChaosTenticles_AbilityStart, Ability) == 0x000000, "Member 'ChaosTenticles_AbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(ChaosTenticles_AbilityStart, bDesired) == 0x000008, "Member 'ChaosTenticles_AbilityStart::bDesired' has a wrong offset!");

// Function man.ChaosTenticles.AnimEvent
// 0x0018 (0x0018 - 0x0000)
struct ChaosTenticles_AnimEvent final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                Anim;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChaosTenticles_AnimEvent) == 0x000008, "Wrong alignment on ChaosTenticles_AnimEvent");
static_assert(sizeof(ChaosTenticles_AnimEvent) == 0x000018, "Wrong size on ChaosTenticles_AnimEvent");
static_assert(offsetof(ChaosTenticles_AnimEvent, Ability) == 0x000000, "Member 'ChaosTenticles_AnimEvent::Ability' has a wrong offset!");
static_assert(offsetof(ChaosTenticles_AnimEvent, Anim) == 0x000008, "Member 'ChaosTenticles_AnimEvent::Anim' has a wrong offset!");
static_assert(offsetof(ChaosTenticles_AnimEvent, AnimEventType) == 0x000010, "Member 'ChaosTenticles_AnimEvent::AnimEventType' has a wrong offset!");

// Function man.ChaosTenticles.ResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct ChaosTenticles_ResourceUsed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delta;                                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaosTenticles_ResourceUsed) == 0x000008, "Wrong alignment on ChaosTenticles_ResourceUsed");
static_assert(sizeof(ChaosTenticles_ResourceUsed) == 0x000010, "Wrong size on ChaosTenticles_ResourceUsed");
static_assert(offsetof(ChaosTenticles_ResourceUsed, resource) == 0x000000, "Member 'ChaosTenticles_ResourceUsed::resource' has a wrong offset!");
static_assert(offsetof(ChaosTenticles_ResourceUsed, Delta) == 0x000004, "Member 'ChaosTenticles_ResourceUsed::Delta' has a wrong offset!");
static_assert(offsetof(ChaosTenticles_ResourceUsed, SourceAbility) == 0x000008, "Member 'ChaosTenticles_ResourceUsed::SourceAbility' has a wrong offset!");

// Function man.ItemAbility.BPGetEnchantItems
// 0x0010 (0x0010 - 0x0000)
struct ItemAbility_BPGetEnchantItems final
{
public:
	TArray<class UItemEnchantItemAbility*>        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetEnchantItems) == 0x000008, "Wrong alignment on ItemAbility_BPGetEnchantItems");
static_assert(sizeof(ItemAbility_BPGetEnchantItems) == 0x000010, "Wrong size on ItemAbility_BPGetEnchantItems");
static_assert(offsetof(ItemAbility_BPGetEnchantItems, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetEnchantItems::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetItemFlavorText
// 0x0018 (0x0018 - 0x0000)
struct ItemAbility_BPGetItemFlavorText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetItemFlavorText) == 0x000008, "Wrong alignment on ItemAbility_BPGetItemFlavorText");
static_assert(sizeof(ItemAbility_BPGetItemFlavorText) == 0x000018, "Wrong size on ItemAbility_BPGetItemFlavorText");
static_assert(offsetof(ItemAbility_BPGetItemFlavorText, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetItemFlavorText::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetItemName
// 0x0018 (0x0018 - 0x0000)
struct ItemAbility_BPGetItemName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetItemName) == 0x000008, "Wrong alignment on ItemAbility_BPGetItemName");
static_assert(sizeof(ItemAbility_BPGetItemName) == 0x000018, "Wrong size on ItemAbility_BPGetItemName");
static_assert(offsetof(ItemAbility_BPGetItemName, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetItemName::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetPermanentEnchantIcons
// 0x0010 (0x0010 - 0x0000)
struct ItemAbility_BPGetPermanentEnchantIcons final
{
public:
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetPermanentEnchantIcons) == 0x000008, "Wrong alignment on ItemAbility_BPGetPermanentEnchantIcons");
static_assert(sizeof(ItemAbility_BPGetPermanentEnchantIcons) == 0x000010, "Wrong size on ItemAbility_BPGetPermanentEnchantIcons");
static_assert(offsetof(ItemAbility_BPGetPermanentEnchantIcons, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetPermanentEnchantIcons::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetTemporaryEnchantIcons
// 0x0010 (0x0010 - 0x0000)
struct ItemAbility_BPGetTemporaryEnchantIcons final
{
public:
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetTemporaryEnchantIcons) == 0x000008, "Wrong alignment on ItemAbility_BPGetTemporaryEnchantIcons");
static_assert(sizeof(ItemAbility_BPGetTemporaryEnchantIcons) == 0x000010, "Wrong size on ItemAbility_BPGetTemporaryEnchantIcons");
static_assert(offsetof(ItemAbility_BPGetTemporaryEnchantIcons, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetTemporaryEnchantIcons::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetIcon
// 0x0008 (0x0008 - 0x0000)
struct ItemAbility_BPGetIcon final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetIcon) == 0x000008, "Wrong alignment on ItemAbility_BPGetIcon");
static_assert(sizeof(ItemAbility_BPGetIcon) == 0x000008, "Wrong size on ItemAbility_BPGetIcon");
static_assert(offsetof(ItemAbility_BPGetIcon, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetIcon::ReturnValue' has a wrong offset!");

// Function man.ItemAbility.BPGetIconTransparent
// 0x0008 (0x0008 - 0x0000)
struct ItemAbility_BPGetIconTransparent final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemAbility_BPGetIconTransparent) == 0x000008, "Wrong alignment on ItemAbility_BPGetIconTransparent");
static_assert(sizeof(ItemAbility_BPGetIconTransparent) == 0x000008, "Wrong size on ItemAbility_BPGetIconTransparent");
static_assert(offsetof(ItemAbility_BPGetIconTransparent, ReturnValue) == 0x000000, "Member 'ItemAbility_BPGetIconTransparent::ReturnValue' has a wrong offset!");

// Function man.OptionsVideoUserWidget.OnDialogueKeepResolutionResult
// 0x0001 (0x0001 - 0x0000)
struct OptionsVideoUserWidget_OnDialogueKeepResolutionResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoUserWidget_OnDialogueKeepResolutionResult) == 0x000001, "Wrong alignment on OptionsVideoUserWidget_OnDialogueKeepResolutionResult");
static_assert(sizeof(OptionsVideoUserWidget_OnDialogueKeepResolutionResult) == 0x000001, "Wrong size on OptionsVideoUserWidget_OnDialogueKeepResolutionResult");
static_assert(offsetof(OptionsVideoUserWidget_OnDialogueKeepResolutionResult, ButtonType) == 0x000000, "Member 'OptionsVideoUserWidget_OnDialogueKeepResolutionResult::ButtonType' has a wrong offset!");

// Function man.OptionsVideoUserWidget.OnSetVramText
// 0x0018 (0x0018 - 0x0000)
struct OptionsVideoUserWidget_OnSetVramText final
{
public:
	class FText                                   VRamText;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoUserWidget_OnSetVramText) == 0x000008, "Wrong alignment on OptionsVideoUserWidget_OnSetVramText");
static_assert(sizeof(OptionsVideoUserWidget_OnSetVramText) == 0x000018, "Wrong size on OptionsVideoUserWidget_OnSetVramText");
static_assert(offsetof(OptionsVideoUserWidget_OnSetVramText, VRamText) == 0x000000, "Member 'OptionsVideoUserWidget_OnSetVramText::VRamText' has a wrong offset!");

// Function man.OptionsVideoUserWidget.SetDisplayModeIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsVideoUserWidget_SetDisplayModeIndex final
{
public:
	int32                                         NewDisplayModeIndex;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoUserWidget_SetDisplayModeIndex) == 0x000004, "Wrong alignment on OptionsVideoUserWidget_SetDisplayModeIndex");
static_assert(sizeof(OptionsVideoUserWidget_SetDisplayModeIndex) == 0x000004, "Wrong size on OptionsVideoUserWidget_SetDisplayModeIndex");
static_assert(offsetof(OptionsVideoUserWidget_SetDisplayModeIndex, NewDisplayModeIndex) == 0x000000, "Member 'OptionsVideoUserWidget_SetDisplayModeIndex::NewDisplayModeIndex' has a wrong offset!");

// Function man.OptionsVideoUserWidget.SetResolutionIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsVideoUserWidget_SetResolutionIndex final
{
public:
	int32                                         NewResolutionIndex;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoUserWidget_SetResolutionIndex) == 0x000004, "Wrong alignment on OptionsVideoUserWidget_SetResolutionIndex");
static_assert(sizeof(OptionsVideoUserWidget_SetResolutionIndex) == 0x000004, "Wrong size on OptionsVideoUserWidget_SetResolutionIndex");
static_assert(offsetof(OptionsVideoUserWidget_SetResolutionIndex, NewResolutionIndex) == 0x000000, "Member 'OptionsVideoUserWidget_SetResolutionIndex::NewResolutionIndex' has a wrong offset!");

// Function man.OptionsVideoUserWidget.HasResolutionChanged
// 0x0001 (0x0001 - 0x0000)
struct OptionsVideoUserWidget_HasResolutionChanged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoUserWidget_HasResolutionChanged) == 0x000001, "Wrong alignment on OptionsVideoUserWidget_HasResolutionChanged");
static_assert(sizeof(OptionsVideoUserWidget_HasResolutionChanged) == 0x000001, "Wrong size on OptionsVideoUserWidget_HasResolutionChanged");
static_assert(offsetof(OptionsVideoUserWidget_HasResolutionChanged, ReturnValue) == 0x000000, "Member 'OptionsVideoUserWidget_HasResolutionChanged::ReturnValue' has a wrong offset!");

// Function man.VendorUserWidgetBase.BPSetFilter
// 0x0008 (0x0008 - 0x0000)
struct VendorUserWidgetBase_BPSetFilter final
{
public:
	class UVendorFilterSlotUserWidget*            VendorFilterSlotUserWidget;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_BPSetFilter) == 0x000008, "Wrong alignment on VendorUserWidgetBase_BPSetFilter");
static_assert(sizeof(VendorUserWidgetBase_BPSetFilter) == 0x000008, "Wrong size on VendorUserWidgetBase_BPSetFilter");
static_assert(offsetof(VendorUserWidgetBase_BPSetFilter, VendorFilterSlotUserWidget) == 0x000000, "Member 'VendorUserWidgetBase_BPSetFilter::VendorFilterSlotUserWidget' has a wrong offset!");

// Function man.VendorUserWidgetBase.GetFocusedItemHeroInventoryStackNum
// 0x0018 (0x0018 - 0x0000)
struct VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum) == 0x000008, "Wrong alignment on VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum");
static_assert(sizeof(VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum) == 0x000018, "Wrong size on VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum");
static_assert(offsetof(VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum, ReturnValue) == 0x000000, "Member 'VendorUserWidgetBase_GetFocusedItemHeroInventoryStackNum::ReturnValue' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnSetCurrency
// 0x0001 (0x0001 - 0x0000)
struct VendorUserWidgetBase_OnSetCurrency final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_OnSetCurrency) == 0x000001, "Wrong alignment on VendorUserWidgetBase_OnSetCurrency");
static_assert(sizeof(VendorUserWidgetBase_OnSetCurrency) == 0x000001, "Wrong size on VendorUserWidgetBase_OnSetCurrency");
static_assert(offsetof(VendorUserWidgetBase_OnSetCurrency, PropertyType) == 0x000000, "Member 'VendorUserWidgetBase_OnSetCurrency::PropertyType' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnSetFilterSlot
// 0x0020 (0x0020 - 0x0000)
struct VendorUserWidgetBase_OnSetFilterSlot final
{
public:
	EItemSlot                                     ItemSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FilterName;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_OnSetFilterSlot) == 0x000008, "Wrong alignment on VendorUserWidgetBase_OnSetFilterSlot");
static_assert(sizeof(VendorUserWidgetBase_OnSetFilterSlot) == 0x000020, "Wrong size on VendorUserWidgetBase_OnSetFilterSlot");
static_assert(offsetof(VendorUserWidgetBase_OnSetFilterSlot, ItemSlot) == 0x000000, "Member 'VendorUserWidgetBase_OnSetFilterSlot::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetFilterSlot, FilterName) == 0x000008, "Member 'VendorUserWidgetBase_OnSetFilterSlot::FilterName' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnSetSelectedItemProperty
// 0x00A8 (0x00A8 - 0x0000)
struct VendorUserWidgetBase_OnSetSelectedItemProperty final
{
public:
	class UTexture2D*                             InItemIcon;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InItemName;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InSelectedCount;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxCount;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InPriceText;                                       // 0x0028(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InPriceGoldValue;                                  // 0x0040(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InPriceEssenceValue;                               // 0x0058(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InRequirementText;                                 // 0x0070(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InItemTypeText;                                    // 0x0088(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bHasEnoughGold;                                    // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEnoughEssence;                                 // 0x00A1(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorUserWidgetBase_OnSetSelectedItemProperty) == 0x000008, "Wrong alignment on VendorUserWidgetBase_OnSetSelectedItemProperty");
static_assert(sizeof(VendorUserWidgetBase_OnSetSelectedItemProperty) == 0x0000A8, "Wrong size on VendorUserWidgetBase_OnSetSelectedItemProperty");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InItemIcon) == 0x000000, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InItemIcon' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InItemName) == 0x000008, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InItemName' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InSelectedCount) == 0x000020, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InSelectedCount' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InMaxCount) == 0x000024, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InMaxCount' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InPriceText) == 0x000028, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InPriceText' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InPriceGoldValue) == 0x000040, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InPriceGoldValue' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InPriceEssenceValue) == 0x000058, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InPriceEssenceValue' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InRequirementText) == 0x000070, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InRequirementText' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, InItemTypeText) == 0x000088, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::InItemTypeText' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, bHasEnoughGold) == 0x0000A0, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::bHasEnoughGold' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnSetSelectedItemProperty, bHasEnoughEssence) == 0x0000A1, "Member 'VendorUserWidgetBase_OnSetSelectedItemProperty::bHasEnoughEssence' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnSetVendorName
// 0x0018 (0x0018 - 0x0000)
struct VendorUserWidgetBase_OnSetVendorName final
{
public:
	class FText                                   VendorName;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_OnSetVendorName) == 0x000008, "Wrong alignment on VendorUserWidgetBase_OnSetVendorName");
static_assert(sizeof(VendorUserWidgetBase_OnSetVendorName) == 0x000018, "Wrong size on VendorUserWidgetBase_OnSetVendorName");
static_assert(offsetof(VendorUserWidgetBase_OnSetVendorName, VendorName) == 0x000000, "Member 'VendorUserWidgetBase_OnSetVendorName::VendorName' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnUpdateDetailsPanel
// 0x0010 (0x0010 - 0x0000)
struct VendorUserWidgetBase_OnUpdateDetailsPanel final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorUserWidgetBase_OnUpdateDetailsPanel) == 0x000008, "Wrong alignment on VendorUserWidgetBase_OnUpdateDetailsPanel");
static_assert(sizeof(VendorUserWidgetBase_OnUpdateDetailsPanel) == 0x000010, "Wrong size on VendorUserWidgetBase_OnUpdateDetailsPanel");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateDetailsPanel, ManItemSlotBase) == 0x000000, "Member 'VendorUserWidgetBase_OnUpdateDetailsPanel::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateDetailsPanel, bAnimate) == 0x000008, "Member 'VendorUserWidgetBase_OnUpdateDetailsPanel::bAnimate' has a wrong offset!");

// Function man.VendorUserWidgetBase.OnUpdateSelectedItemDetailsPanel
// 0x0030 (0x0030 - 0x0000)
struct VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel final
{
public:
	class FText                                   ItemRequirementText;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UItemAbility*                           InItem;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InComparedItem;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel) == 0x000008, "Wrong alignment on VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel");
static_assert(sizeof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel) == 0x000030, "Wrong size on VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel, ItemRequirementText) == 0x000000, "Member 'VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel::ItemRequirementText' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel, InItem) == 0x000018, "Member 'VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel::InItem' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel, InComparedItem) == 0x000020, "Member 'VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel::InComparedItem' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel, bEquipped) == 0x000028, "Member 'VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel::bEquipped' has a wrong offset!");
static_assert(offsetof(VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel, bAnimate) == 0x000029, "Member 'VendorUserWidgetBase_OnUpdateSelectedItemDetailsPanel::bAnimate' has a wrong offset!");

// Function man.VendorUserWidgetBase.GetFocusedInventorySlotUserWidget
// 0x0008 (0x0008 - 0x0000)
struct VendorUserWidgetBase_GetFocusedInventorySlotUserWidget final
{
public:
	class UInventorySlotUserWidget*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_GetFocusedInventorySlotUserWidget) == 0x000008, "Wrong alignment on VendorUserWidgetBase_GetFocusedInventorySlotUserWidget");
static_assert(sizeof(VendorUserWidgetBase_GetFocusedInventorySlotUserWidget) == 0x000008, "Wrong size on VendorUserWidgetBase_GetFocusedInventorySlotUserWidget");
static_assert(offsetof(VendorUserWidgetBase_GetFocusedInventorySlotUserWidget, ReturnValue) == 0x000000, "Member 'VendorUserWidgetBase_GetFocusedInventorySlotUserWidget::ReturnValue' has a wrong offset!");

// Function man.VendorUserWidgetBase.IsChangeValue
// 0x0001 (0x0001 - 0x0000)
struct VendorUserWidgetBase_IsChangeValue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUserWidgetBase_IsChangeValue) == 0x000001, "Wrong alignment on VendorUserWidgetBase_IsChangeValue");
static_assert(sizeof(VendorUserWidgetBase_IsChangeValue) == 0x000001, "Wrong size on VendorUserWidgetBase_IsChangeValue");
static_assert(offsetof(VendorUserWidgetBase_IsChangeValue, ReturnValue) == 0x000000, "Member 'VendorUserWidgetBase_IsChangeValue::ReturnValue' has a wrong offset!");

// Function man.VendorSellUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct VendorSellUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorSellUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on VendorSellUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(VendorSellUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on VendorSellUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(VendorSellUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'VendorSellUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(VendorSellUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'VendorSellUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.VendorSellUserWidget.OnSellItem
// 0x0058 (0x0058 - 0x0000)
struct VendorSellUserWidget_OnSellItem final
{
public:
	struct FSellHistoryItem                       SellHistoryItem;                                   // 0x0000(0x0058)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorSellUserWidget_OnSellItem) == 0x000008, "Wrong alignment on VendorSellUserWidget_OnSellItem");
static_assert(sizeof(VendorSellUserWidget_OnSellItem) == 0x000058, "Wrong size on VendorSellUserWidget_OnSellItem");
static_assert(offsetof(VendorSellUserWidget_OnSellItem, SellHistoryItem) == 0x000000, "Member 'VendorSellUserWidget_OnSellItem::SellHistoryItem' has a wrong offset!");

// Function man.CharacterTransform.OnAnimEventBase_Target
// 0x0030 (0x0030 - 0x0000)
struct CharacterTransform_OnAnimEventBase_Target final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterTransform_OnAnimEventBase_Target) == 0x000008, "Wrong alignment on CharacterTransform_OnAnimEventBase_Target");
static_assert(sizeof(CharacterTransform_OnAnimEventBase_Target) == 0x000030, "Wrong size on CharacterTransform_OnAnimEventBase_Target");
static_assert(offsetof(CharacterTransform_OnAnimEventBase_Target, AnimEventParam) == 0x000000, "Member 'CharacterTransform_OnAnimEventBase_Target::AnimEventParam' has a wrong offset!");

// Function man.VisualEntity.AttachParentAnimEvent
// 0x0018 (0x0018 - 0x0000)
struct VisualEntity_AttachParentAnimEvent final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                InAnim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                InAnimEventType;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VisualEntity_AttachParentAnimEvent) == 0x000008, "Wrong alignment on VisualEntity_AttachParentAnimEvent");
static_assert(sizeof(VisualEntity_AttachParentAnimEvent) == 0x000018, "Wrong size on VisualEntity_AttachParentAnimEvent");
static_assert(offsetof(VisualEntity_AttachParentAnimEvent, InAbility) == 0x000000, "Member 'VisualEntity_AttachParentAnimEvent::InAbility' has a wrong offset!");
static_assert(offsetof(VisualEntity_AttachParentAnimEvent, InAnim) == 0x000008, "Member 'VisualEntity_AttachParentAnimEvent::InAnim' has a wrong offset!");
static_assert(offsetof(VisualEntity_AttachParentAnimEvent, InAnimEventType) == 0x000010, "Member 'VisualEntity_AttachParentAnimEvent::InAnimEventType' has a wrong offset!");

// Function man.VisualEntity.AttachParentWeaponTrail
// 0x0001 (0x0001 - 0x0000)
struct VisualEntity_AttachParentWeaponTrail final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_AttachParentWeaponTrail) == 0x000001, "Wrong alignment on VisualEntity_AttachParentWeaponTrail");
static_assert(sizeof(VisualEntity_AttachParentWeaponTrail) == 0x000001, "Wrong size on VisualEntity_AttachParentWeaponTrail");
static_assert(offsetof(VisualEntity_AttachParentWeaponTrail, bStart) == 0x000000, "Member 'VisualEntity_AttachParentWeaponTrail::bStart' has a wrong offset!");

// Function man.VisualEntity.Kill
// 0x0001 (0x0001 - 0x0000)
struct VisualEntity_Kill final
{
public:
	bool                                          bDetachFromActor;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_Kill) == 0x000001, "Wrong alignment on VisualEntity_Kill");
static_assert(sizeof(VisualEntity_Kill) == 0x000001, "Wrong size on VisualEntity_Kill");
static_assert(offsetof(VisualEntity_Kill, bDetachFromActor) == 0x000000, "Member 'VisualEntity_Kill::bDetachFromActor' has a wrong offset!");

// Function man.VisualEntity.OnCascadeSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct VisualEntity_OnCascadeSystemFinished final
{
public:
	class UParticleSystemComponent*               PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_OnCascadeSystemFinished) == 0x000008, "Wrong alignment on VisualEntity_OnCascadeSystemFinished");
static_assert(sizeof(VisualEntity_OnCascadeSystemFinished) == 0x000008, "Wrong size on VisualEntity_OnCascadeSystemFinished");
static_assert(offsetof(VisualEntity_OnCascadeSystemFinished, PSystem) == 0x000000, "Member 'VisualEntity_OnCascadeSystemFinished::PSystem' has a wrong offset!");

// Function man.VisualEntity.OnNiagaraSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct VisualEntity_OnNiagaraSystemFinished final
{
public:
	class UNiagaraComponent*                      PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_OnNiagaraSystemFinished) == 0x000008, "Wrong alignment on VisualEntity_OnNiagaraSystemFinished");
static_assert(sizeof(VisualEntity_OnNiagaraSystemFinished) == 0x000008, "Wrong size on VisualEntity_OnNiagaraSystemFinished");
static_assert(offsetof(VisualEntity_OnNiagaraSystemFinished, PSystem) == 0x000000, "Member 'VisualEntity_OnNiagaraSystemFinished::PSystem' has a wrong offset!");

// Function man.VisualEntity.SetDeathFadeRate
// 0x0008 (0x0008 - 0x0000)
struct VisualEntity_SetDeathFadeRate final
{
public:
	float                                         DeathFadeRate;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSet;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VisualEntity_SetDeathFadeRate) == 0x000004, "Wrong alignment on VisualEntity_SetDeathFadeRate");
static_assert(sizeof(VisualEntity_SetDeathFadeRate) == 0x000008, "Wrong size on VisualEntity_SetDeathFadeRate");
static_assert(offsetof(VisualEntity_SetDeathFadeRate, DeathFadeRate) == 0x000000, "Member 'VisualEntity_SetDeathFadeRate::DeathFadeRate' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetDeathFadeRate, bForceSet) == 0x000004, "Member 'VisualEntity_SetDeathFadeRate::bForceSet' has a wrong offset!");

// Function man.VisualEntity.SetDecalColorParameter
// 0x0018 (0x0018 - 0x0000)
struct VisualEntity_SetDecalColorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Param;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_SetDecalColorParameter) == 0x000004, "Wrong alignment on VisualEntity_SetDecalColorParameter");
static_assert(sizeof(VisualEntity_SetDecalColorParameter) == 0x000018, "Wrong size on VisualEntity_SetDecalColorParameter");
static_assert(offsetof(VisualEntity_SetDecalColorParameter, ParameterName) == 0x000000, "Member 'VisualEntity_SetDecalColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetDecalColorParameter, Param) == 0x000008, "Member 'VisualEntity_SetDecalColorParameter::Param' has a wrong offset!");

// Function man.VisualEntity.SetDecalFloatParameter
// 0x000C (0x000C - 0x0000)
struct VisualEntity_SetDecalFloatParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_SetDecalFloatParameter) == 0x000004, "Wrong alignment on VisualEntity_SetDecalFloatParameter");
static_assert(sizeof(VisualEntity_SetDecalFloatParameter) == 0x00000C, "Wrong size on VisualEntity_SetDecalFloatParameter");
static_assert(offsetof(VisualEntity_SetDecalFloatParameter, ParameterName) == 0x000000, "Member 'VisualEntity_SetDecalFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetDecalFloatParameter, Param) == 0x000008, "Member 'VisualEntity_SetDecalFloatParameter::Param' has a wrong offset!");

// Function man.VisualEntity.SetParticleColorParameter
// 0x0018 (0x0018 - 0x0000)
struct VisualEntity_SetParticleColorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Param;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_SetParticleColorParameter) == 0x000004, "Wrong alignment on VisualEntity_SetParticleColorParameter");
static_assert(sizeof(VisualEntity_SetParticleColorParameter) == 0x000018, "Wrong size on VisualEntity_SetParticleColorParameter");
static_assert(offsetof(VisualEntity_SetParticleColorParameter, ParameterName) == 0x000000, "Member 'VisualEntity_SetParticleColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetParticleColorParameter, Param) == 0x000008, "Member 'VisualEntity_SetParticleColorParameter::Param' has a wrong offset!");

// Function man.VisualEntity.SetParticleFloatParameter
// 0x000C (0x000C - 0x0000)
struct VisualEntity_SetParticleFloatParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_SetParticleFloatParameter) == 0x000004, "Wrong alignment on VisualEntity_SetParticleFloatParameter");
static_assert(sizeof(VisualEntity_SetParticleFloatParameter) == 0x00000C, "Wrong size on VisualEntity_SetParticleFloatParameter");
static_assert(offsetof(VisualEntity_SetParticleFloatParameter, ParameterName) == 0x000000, "Member 'VisualEntity_SetParticleFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetParticleFloatParameter, Param) == 0x000008, "Member 'VisualEntity_SetParticleFloatParameter::Param' has a wrong offset!");

// Function man.VisualEntity.SetParticleVectorParameter
// 0x0014 (0x0014 - 0x0000)
struct VisualEntity_SetParticleVectorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Param;                                             // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualEntity_SetParticleVectorParameter) == 0x000004, "Wrong alignment on VisualEntity_SetParticleVectorParameter");
static_assert(sizeof(VisualEntity_SetParticleVectorParameter) == 0x000014, "Wrong size on VisualEntity_SetParticleVectorParameter");
static_assert(offsetof(VisualEntity_SetParticleVectorParameter, ParameterName) == 0x000000, "Member 'VisualEntity_SetParticleVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(VisualEntity_SetParticleVectorParameter, Param) == 0x000008, "Member 'VisualEntity_SetParticleVectorParameter::Param' has a wrong offset!");

// Function man.KingPriestAttackCatharsis.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestAttackCatharsis_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestAttackCatharsis_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestAttackCatharsis_BPGetTeleportLocation");
static_assert(sizeof(KingPriestAttackCatharsis_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestAttackCatharsis_BPGetTeleportLocation");
static_assert(offsetof(KingPriestAttackCatharsis_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestAttackCatharsis_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.EntropyLantern.GetLifeAuraRadiusRate
// 0x0004 (0x0004 - 0x0000)
struct EntropyLantern_GetLifeAuraRadiusRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyLantern_GetLifeAuraRadiusRate) == 0x000004, "Wrong alignment on EntropyLantern_GetLifeAuraRadiusRate");
static_assert(sizeof(EntropyLantern_GetLifeAuraRadiusRate) == 0x000004, "Wrong size on EntropyLantern_GetLifeAuraRadiusRate");
static_assert(offsetof(EntropyLantern_GetLifeAuraRadiusRate, ReturnValue) == 0x000000, "Member 'EntropyLantern_GetLifeAuraRadiusRate::ReturnValue' has a wrong offset!");

// Function man.EntropyLantern.GetLifeAuraRate
// 0x0004 (0x0004 - 0x0000)
struct EntropyLantern_GetLifeAuraRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyLantern_GetLifeAuraRate) == 0x000004, "Wrong alignment on EntropyLantern_GetLifeAuraRate");
static_assert(sizeof(EntropyLantern_GetLifeAuraRate) == 0x000004, "Wrong size on EntropyLantern_GetLifeAuraRate");
static_assert(offsetof(EntropyLantern_GetLifeAuraRate, ReturnValue) == 0x000000, "Member 'EntropyLantern_GetLifeAuraRate::ReturnValue' has a wrong offset!");

// Function man.EntropyLantern.GetLifeAuraValue
// 0x0004 (0x0004 - 0x0000)
struct EntropyLantern_GetLifeAuraValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyLantern_GetLifeAuraValue) == 0x000004, "Wrong alignment on EntropyLantern_GetLifeAuraValue");
static_assert(sizeof(EntropyLantern_GetLifeAuraValue) == 0x000004, "Wrong size on EntropyLantern_GetLifeAuraValue");
static_assert(offsetof(EntropyLantern_GetLifeAuraValue, ReturnValue) == 0x000000, "Member 'EntropyLantern_GetLifeAuraValue::ReturnValue' has a wrong offset!");

// Function man.EntropyLantern.GetMaxLifeAuraValue
// 0x0004 (0x0004 - 0x0000)
struct EntropyLantern_GetMaxLifeAuraValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyLantern_GetMaxLifeAuraValue) == 0x000004, "Wrong alignment on EntropyLantern_GetMaxLifeAuraValue");
static_assert(sizeof(EntropyLantern_GetMaxLifeAuraValue) == 0x000004, "Wrong size on EntropyLantern_GetMaxLifeAuraValue");
static_assert(offsetof(EntropyLantern_GetMaxLifeAuraValue, ReturnValue) == 0x000000, "Member 'EntropyLantern_GetMaxLifeAuraValue::ReturnValue' has a wrong offset!");

// Function man.EntropyLantern.IsActive
// 0x0001 (0x0001 - 0x0000)
struct EntropyLantern_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyLantern_IsActive) == 0x000001, "Wrong alignment on EntropyLantern_IsActive");
static_assert(sizeof(EntropyLantern_IsActive) == 0x000001, "Wrong size on EntropyLantern_IsActive");
static_assert(offsetof(EntropyLantern_IsActive, ReturnValue) == 0x000000, "Member 'EntropyLantern_IsActive::ReturnValue' has a wrong offset!");

// Function man.KingPriestSelfProjection.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestSelfProjection_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestSelfProjection_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestSelfProjection_BPGetTeleportLocation");
static_assert(sizeof(KingPriestSelfProjection_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestSelfProjection_BPGetTeleportLocation");
static_assert(offsetof(KingPriestSelfProjection_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestSelfProjection_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.PanningAgentBase.EnableHeroCollision
// 0x0001 (0x0001 - 0x0000)
struct PanningAgentBase_EnableHeroCollision final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PanningAgentBase_EnableHeroCollision) == 0x000001, "Wrong alignment on PanningAgentBase_EnableHeroCollision");
static_assert(sizeof(PanningAgentBase_EnableHeroCollision) == 0x000001, "Wrong size on PanningAgentBase_EnableHeroCollision");
static_assert(offsetof(PanningAgentBase_EnableHeroCollision, bEnable) == 0x000000, "Member 'PanningAgentBase_EnableHeroCollision::bEnable' has a wrong offset!");

// Function man.PanningAgentBase.EnableHeroGodmode
// 0x0001 (0x0001 - 0x0000)
struct PanningAgentBase_EnableHeroGodmode final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PanningAgentBase_EnableHeroGodmode) == 0x000001, "Wrong alignment on PanningAgentBase_EnableHeroGodmode");
static_assert(sizeof(PanningAgentBase_EnableHeroGodmode) == 0x000001, "Wrong size on PanningAgentBase_EnableHeroGodmode");
static_assert(offsetof(PanningAgentBase_EnableHeroGodmode, bEnable) == 0x000000, "Member 'PanningAgentBase_EnableHeroGodmode::bEnable' has a wrong offset!");

// Function man.PanningAgentBase.SetHeroLocation
// 0x0010 (0x0010 - 0x0000)
struct PanningAgentBase_SetHeroLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PanningAgentBase_SetHeroLocation) == 0x000004, "Wrong alignment on PanningAgentBase_SetHeroLocation");
static_assert(sizeof(PanningAgentBase_SetHeroLocation) == 0x000010, "Wrong size on PanningAgentBase_SetHeroLocation");
static_assert(offsetof(PanningAgentBase_SetHeroLocation, NewLocation) == 0x000000, "Member 'PanningAgentBase_SetHeroLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(PanningAgentBase_SetHeroLocation, bTeleport) == 0x00000C, "Member 'PanningAgentBase_SetHeroLocation::bTeleport' has a wrong offset!");

// Function man.PanningAgentBase.GetHeroGroundSpeed
// 0x0004 (0x0004 - 0x0000)
struct PanningAgentBase_GetHeroGroundSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PanningAgentBase_GetHeroGroundSpeed) == 0x000004, "Wrong alignment on PanningAgentBase_GetHeroGroundSpeed");
static_assert(sizeof(PanningAgentBase_GetHeroGroundSpeed) == 0x000004, "Wrong size on PanningAgentBase_GetHeroGroundSpeed");
static_assert(offsetof(PanningAgentBase_GetHeroGroundSpeed, ReturnValue) == 0x000000, "Member 'PanningAgentBase_GetHeroGroundSpeed::ReturnValue' has a wrong offset!");

// Function man.PanningAgentBase.GetHeroLocation
// 0x000C (0x000C - 0x0000)
struct PanningAgentBase_GetHeroLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PanningAgentBase_GetHeroLocation) == 0x000004, "Wrong alignment on PanningAgentBase_GetHeroLocation");
static_assert(sizeof(PanningAgentBase_GetHeroLocation) == 0x00000C, "Wrong size on PanningAgentBase_GetHeroLocation");
static_assert(offsetof(PanningAgentBase_GetHeroLocation, ReturnValue) == 0x000000, "Member 'PanningAgentBase_GetHeroLocation::ReturnValue' has a wrong offset!");

// Function man.ConversationPortraitUserWidget.GetVideoDimensions
// 0x000C (0x000C - 0x0000)
struct ConversationPortraitUserWidget_GetVideoDimensions final
{
public:
	bool                                          bIdleBridge;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationPortraitUserWidget_GetVideoDimensions) == 0x000004, "Wrong alignment on ConversationPortraitUserWidget_GetVideoDimensions");
static_assert(sizeof(ConversationPortraitUserWidget_GetVideoDimensions) == 0x00000C, "Wrong size on ConversationPortraitUserWidget_GetVideoDimensions");
static_assert(offsetof(ConversationPortraitUserWidget_GetVideoDimensions, bIdleBridge) == 0x000000, "Member 'ConversationPortraitUserWidget_GetVideoDimensions::bIdleBridge' has a wrong offset!");
static_assert(offsetof(ConversationPortraitUserWidget_GetVideoDimensions, ReturnValue) == 0x000004, "Member 'ConversationPortraitUserWidget_GetVideoDimensions::ReturnValue' has a wrong offset!");

// Function man.ConversationPortraitUserWidget.OnShowSlot
// 0x0050 (0x0050 - 0x0000)
struct ConversationPortraitUserWidget_OnShowSlot final
{
public:
	struct FConversationSpeakerInfo               InSpeakerInfo;                                     // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationPortraitUserWidget_OnShowSlot) == 0x000008, "Wrong alignment on ConversationPortraitUserWidget_OnShowSlot");
static_assert(sizeof(ConversationPortraitUserWidget_OnShowSlot) == 0x000050, "Wrong size on ConversationPortraitUserWidget_OnShowSlot");
static_assert(offsetof(ConversationPortraitUserWidget_OnShowSlot, InSpeakerInfo) == 0x000000, "Member 'ConversationPortraitUserWidget_OnShowSlot::InSpeakerInfo' has a wrong offset!");

// Function man.ConversationPortraitUserWidget.PlayVideo
// 0x0018 (0x0018 - 0x0000)
struct ConversationPortraitUserWidget_PlayVideo final
{
public:
	class FString                                 VideoUrl;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleBridge;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationPortraitUserWidget_PlayVideo) == 0x000008, "Wrong alignment on ConversationPortraitUserWidget_PlayVideo");
static_assert(sizeof(ConversationPortraitUserWidget_PlayVideo) == 0x000018, "Wrong size on ConversationPortraitUserWidget_PlayVideo");
static_assert(offsetof(ConversationPortraitUserWidget_PlayVideo, VideoUrl) == 0x000000, "Member 'ConversationPortraitUserWidget_PlayVideo::VideoUrl' has a wrong offset!");
static_assert(offsetof(ConversationPortraitUserWidget_PlayVideo, bIdleBridge) == 0x000010, "Member 'ConversationPortraitUserWidget_PlayVideo::bIdleBridge' has a wrong offset!");

// Function man.ActorComponentBase.GetActor
// 0x0008 (0x0008 - 0x0000)
struct ActorComponentBase_GetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetActor) == 0x000008, "Wrong alignment on ActorComponentBase_GetActor");
static_assert(sizeof(ActorComponentBase_GetActor) == 0x000008, "Wrong size on ActorComponentBase_GetActor");
static_assert(offsetof(ActorComponentBase_GetActor, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetActor::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.GetActorBase
// 0x0008 (0x0008 - 0x0000)
struct ActorComponentBase_GetActorBase final
{
public:
	class AActorBase*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetActorBase) == 0x000008, "Wrong alignment on ActorComponentBase_GetActorBase");
static_assert(sizeof(ActorComponentBase_GetActorBase) == 0x000008, "Wrong size on ActorComponentBase_GetActorBase");
static_assert(offsetof(ActorComponentBase_GetActorBase, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetActorBase::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.GetCharacter
// 0x0008 (0x0008 - 0x0000)
struct ActorComponentBase_GetCharacter final
{
public:
	class ACharacterBase*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetCharacter) == 0x000008, "Wrong alignment on ActorComponentBase_GetCharacter");
static_assert(sizeof(ActorComponentBase_GetCharacter) == 0x000008, "Wrong size on ActorComponentBase_GetCharacter");
static_assert(offsetof(ActorComponentBase_GetCharacter, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetCharacter::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.GetGameFrame
// 0x0004 (0x0004 - 0x0000)
struct ActorComponentBase_GetGameFrame final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetGameFrame) == 0x000004, "Wrong alignment on ActorComponentBase_GetGameFrame");
static_assert(sizeof(ActorComponentBase_GetGameFrame) == 0x000004, "Wrong size on ActorComponentBase_GetGameFrame");
static_assert(offsetof(ActorComponentBase_GetGameFrame, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetGameFrame::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.GetGameMode
// 0x0008 (0x0008 - 0x0000)
struct ActorComponentBase_GetGameMode final
{
public:
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetGameMode) == 0x000008, "Wrong alignment on ActorComponentBase_GetGameMode");
static_assert(sizeof(ActorComponentBase_GetGameMode) == 0x000008, "Wrong size on ActorComponentBase_GetGameMode");
static_assert(offsetof(ActorComponentBase_GetGameMode, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetGameMode::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.GetGameTime
// 0x0004 (0x0004 - 0x0000)
struct ActorComponentBase_GetGameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_GetGameTime) == 0x000004, "Wrong alignment on ActorComponentBase_GetGameTime");
static_assert(sizeof(ActorComponentBase_GetGameTime) == 0x000004, "Wrong size on ActorComponentBase_GetGameTime");
static_assert(offsetof(ActorComponentBase_GetGameTime, ReturnValue) == 0x000000, "Member 'ActorComponentBase_GetGameTime::ReturnValue' has a wrong offset!");

// Function man.ActorComponentBase.IsAlive
// 0x0001 (0x0001 - 0x0000)
struct ActorComponentBase_IsAlive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponentBase_IsAlive) == 0x000001, "Wrong alignment on ActorComponentBase_IsAlive");
static_assert(sizeof(ActorComponentBase_IsAlive) == 0x000001, "Wrong size on ActorComponentBase_IsAlive");
static_assert(offsetof(ActorComponentBase_IsAlive, ReturnValue) == 0x000000, "Member 'ActorComponentBase_IsAlive::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPAddAbility
// 0x0010 (0x0010 - 0x0000)
struct AbilityController_BPAddAbility final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPAddAbility) == 0x000008, "Wrong alignment on AbilityController_BPAddAbility");
static_assert(sizeof(AbilityController_BPAddAbility) == 0x000010, "Wrong size on AbilityController_BPAddAbility");
static_assert(offsetof(AbilityController_BPAddAbility, AbilityClass) == 0x000000, "Member 'AbilityController_BPAddAbility::AbilityClass' has a wrong offset!");
static_assert(offsetof(AbilityController_BPAddAbility, ReturnValue) == 0x000008, "Member 'AbilityController_BPAddAbility::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPAddHitBox
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_BPAddHitBox final
{
public:
	class UHitBox*                                HitBox;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPAddHitBox) == 0x000008, "Wrong alignment on AbilityController_BPAddHitBox");
static_assert(sizeof(AbilityController_BPAddHitBox) == 0x000008, "Wrong size on AbilityController_BPAddHitBox");
static_assert(offsetof(AbilityController_BPAddHitBox, HitBox) == 0x000000, "Member 'AbilityController_BPAddHitBox::HitBox' has a wrong offset!");

// Function man.AbilityController.BPGetAbilityByClass
// 0x0018 (0x0018 - 0x0000)
struct AbilityController_BPGetAbilityByClass final
{
public:
	class UClass*                                 AbilityClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSub;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPGetAbilityByClass) == 0x000008, "Wrong alignment on AbilityController_BPGetAbilityByClass");
static_assert(sizeof(AbilityController_BPGetAbilityByClass) == 0x000018, "Wrong size on AbilityController_BPGetAbilityByClass");
static_assert(offsetof(AbilityController_BPGetAbilityByClass, AbilityClass) == 0x000000, "Member 'AbilityController_BPGetAbilityByClass::AbilityClass' has a wrong offset!");
static_assert(offsetof(AbilityController_BPGetAbilityByClass, bSub) == 0x000008, "Member 'AbilityController_BPGetAbilityByClass::bSub' has a wrong offset!");
static_assert(offsetof(AbilityController_BPGetAbilityByClass, ReturnValue) == 0x000010, "Member 'AbilityController_BPGetAbilityByClass::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPGetAbilityByName
// 0x0010 (0x0010 - 0x0000)
struct AbilityController_BPGetAbilityByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPGetAbilityByName) == 0x000008, "Wrong alignment on AbilityController_BPGetAbilityByName");
static_assert(sizeof(AbilityController_BPGetAbilityByName) == 0x000010, "Wrong size on AbilityController_BPGetAbilityByName");
static_assert(offsetof(AbilityController_BPGetAbilityByName, Name_0) == 0x000000, "Member 'AbilityController_BPGetAbilityByName::Name_0' has a wrong offset!");
static_assert(offsetof(AbilityController_BPGetAbilityByName, ReturnValue) == 0x000008, "Member 'AbilityController_BPGetAbilityByName::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPGetSummoner
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_BPGetSummoner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPGetSummoner) == 0x000008, "Wrong alignment on AbilityController_BPGetSummoner");
static_assert(sizeof(AbilityController_BPGetSummoner) == 0x000008, "Wrong size on AbilityController_BPGetSummoner");
static_assert(offsetof(AbilityController_BPGetSummoner, ReturnValue) == 0x000000, "Member 'AbilityController_BPGetSummoner::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPGetVarlist
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_BPGetVarlist final
{
public:
	class UVarlist*                               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPGetVarlist) == 0x000008, "Wrong alignment on AbilityController_BPGetVarlist");
static_assert(sizeof(AbilityController_BPGetVarlist) == 0x000008, "Wrong size on AbilityController_BPGetVarlist");
static_assert(offsetof(AbilityController_BPGetVarlist, ReturnValue) == 0x000000, "Member 'AbilityController_BPGetVarlist::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPKill
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_BPKill final
{
public:
	class UAbilityController*                     Killer_0;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPKill) == 0x000008, "Wrong alignment on AbilityController_BPKill");
static_assert(sizeof(AbilityController_BPKill) == 0x000008, "Wrong size on AbilityController_BPKill");
static_assert(offsetof(AbilityController_BPKill, Killer_0) == 0x000000, "Member 'AbilityController_BPKill::Killer_0' has a wrong offset!");

// Function man.AbilityController.BPRemoveAbility
// 0x0010 (0x0010 - 0x0000)
struct AbilityController_BPRemoveAbility final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubclass;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityController_BPRemoveAbility) == 0x000008, "Wrong alignment on AbilityController_BPRemoveAbility");
static_assert(sizeof(AbilityController_BPRemoveAbility) == 0x000010, "Wrong size on AbilityController_BPRemoveAbility");
static_assert(offsetof(AbilityController_BPRemoveAbility, AbilityClass) == 0x000000, "Member 'AbilityController_BPRemoveAbility::AbilityClass' has a wrong offset!");
static_assert(offsetof(AbilityController_BPRemoveAbility, bSubclass) == 0x000008, "Member 'AbilityController_BPRemoveAbility::bSubclass' has a wrong offset!");
static_assert(offsetof(AbilityController_BPRemoveAbility, ReturnValue) == 0x000009, "Member 'AbilityController_BPRemoveAbility::ReturnValue' has a wrong offset!");

// Function man.AbilityController.BPSetGodMode
// 0x0001 (0x0001 - 0x0000)
struct AbilityController_BPSetGodMode final
{
public:
	bool                                          bInGodMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPSetGodMode) == 0x000001, "Wrong alignment on AbilityController_BPSetGodMode");
static_assert(sizeof(AbilityController_BPSetGodMode) == 0x000001, "Wrong size on AbilityController_BPSetGodMode");
static_assert(offsetof(AbilityController_BPSetGodMode, bInGodMode) == 0x000000, "Member 'AbilityController_BPSetGodMode::bInGodMode' has a wrong offset!");

// Function man.AbilityController.BPStartAnim
// 0x0010 (0x0010 - 0x0000)
struct AbilityController_BPStartAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoEnd;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventHardSleep;                                 // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AbilityController_BPStartAnim) == 0x000008, "Wrong alignment on AbilityController_BPStartAnim");
static_assert(sizeof(AbilityController_BPStartAnim) == 0x000010, "Wrong size on AbilityController_BPStartAnim");
static_assert(offsetof(AbilityController_BPStartAnim, AnimID) == 0x000000, "Member 'AbilityController_BPStartAnim::AnimID' has a wrong offset!");
static_assert(offsetof(AbilityController_BPStartAnim, bAutoEnd) == 0x000008, "Member 'AbilityController_BPStartAnim::bAutoEnd' has a wrong offset!");
static_assert(offsetof(AbilityController_BPStartAnim, bPreventHardSleep) == 0x000009, "Member 'AbilityController_BPStartAnim::bPreventHardSleep' has a wrong offset!");

// Function man.AbilityController.BPStopAnim
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_BPStopAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_BPStopAnim) == 0x000008, "Wrong alignment on AbilityController_BPStopAnim");
static_assert(sizeof(AbilityController_BPStopAnim) == 0x000008, "Wrong size on AbilityController_BPStopAnim");
static_assert(offsetof(AbilityController_BPStopAnim, AnimID) == 0x000000, "Member 'AbilityController_BPStopAnim::AnimID' has a wrong offset!");

// Function man.AbilityController.GetAFKTime
// 0x0004 (0x0004 - 0x0000)
struct AbilityController_GetAFKTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetAFKTime) == 0x000004, "Wrong alignment on AbilityController_GetAFKTime");
static_assert(sizeof(AbilityController_GetAFKTime) == 0x000004, "Wrong size on AbilityController_GetAFKTime");
static_assert(offsetof(AbilityController_GetAFKTime, ReturnValue) == 0x000000, "Member 'AbilityController_GetAFKTime::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetAI
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetAI final
{
public:
	class UAIBase*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetAI) == 0x000008, "Wrong alignment on AbilityController_GetAI");
static_assert(sizeof(AbilityController_GetAI) == 0x000008, "Wrong size on AbilityController_GetAI");
static_assert(offsetof(AbilityController_GetAI, ReturnValue) == 0x000000, "Member 'AbilityController_GetAI::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetAirAI
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetAirAI final
{
public:
	class UAirAI*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetAirAI) == 0x000008, "Wrong alignment on AbilityController_GetAirAI");
static_assert(sizeof(AbilityController_GetAirAI) == 0x000008, "Wrong size on AbilityController_GetAirAI");
static_assert(offsetof(AbilityController_GetAirAI, ReturnValue) == 0x000000, "Member 'AbilityController_GetAirAI::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetAttributeContainer) == 0x000008, "Wrong alignment on AbilityController_GetAttributeContainer");
static_assert(sizeof(AbilityController_GetAttributeContainer) == 0x000008, "Wrong size on AbilityController_GetAttributeContainer");
static_assert(offsetof(AbilityController_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'AbilityController_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetGroundAI
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetGroundAI final
{
public:
	class UBasicAI*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetGroundAI) == 0x000008, "Wrong alignment on AbilityController_GetGroundAI");
static_assert(sizeof(AbilityController_GetGroundAI) == 0x000008, "Wrong size on AbilityController_GetGroundAI");
static_assert(offsetof(AbilityController_GetGroundAI, ReturnValue) == 0x000000, "Member 'AbilityController_GetGroundAI::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetHeroAbilityData
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetHeroAbilityData final
{
public:
	class UHeroAbilitiesData*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetHeroAbilityData) == 0x000008, "Wrong alignment on AbilityController_GetHeroAbilityData");
static_assert(sizeof(AbilityController_GetHeroAbilityData) == 0x000008, "Wrong size on AbilityController_GetHeroAbilityData");
static_assert(offsetof(AbilityController_GetHeroAbilityData, ReturnValue) == 0x000000, "Member 'AbilityController_GetHeroAbilityData::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetHitReactionPassive
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetHitReactionPassive final
{
public:
	class UHitReactionPassive*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetHitReactionPassive) == 0x000008, "Wrong alignment on AbilityController_GetHitReactionPassive");
static_assert(sizeof(AbilityController_GetHitReactionPassive) == 0x000008, "Wrong size on AbilityController_GetHitReactionPassive");
static_assert(offsetof(AbilityController_GetHitReactionPassive, ReturnValue) == 0x000000, "Member 'AbilityController_GetHitReactionPassive::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetInventory
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetInventory) == 0x000008, "Wrong alignment on AbilityController_GetInventory");
static_assert(sizeof(AbilityController_GetInventory) == 0x000008, "Wrong size on AbilityController_GetInventory");
static_assert(offsetof(AbilityController_GetInventory, ReturnValue) == 0x000000, "Member 'AbilityController_GetInventory::ReturnValue' has a wrong offset!");

// Function man.AbilityController.GetPlayerController
// 0x0008 (0x0008 - 0x0000)
struct AbilityController_GetPlayerController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_GetPlayerController) == 0x000008, "Wrong alignment on AbilityController_GetPlayerController");
static_assert(sizeof(AbilityController_GetPlayerController) == 0x000008, "Wrong size on AbilityController_GetPlayerController");
static_assert(offsetof(AbilityController_GetPlayerController, ReturnValue) == 0x000000, "Member 'AbilityController_GetPlayerController::ReturnValue' has a wrong offset!");

// Function man.AbilityController.WakeUpSignal
// 0x0004 (0x0004 - 0x0000)
struct AbilityController_WakeUpSignal final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityController_WakeUpSignal) == 0x000004, "Wrong alignment on AbilityController_WakeUpSignal");
static_assert(sizeof(AbilityController_WakeUpSignal) == 0x000004, "Wrong size on AbilityController_WakeUpSignal");
static_assert(offsetof(AbilityController_WakeUpSignal, Time) == 0x000000, "Member 'AbilityController_WakeUpSignal::Time' has a wrong offset!");

// Function man.MainMenuUserWidget.HasValidSaveGameSlot
// 0x0001 (0x0001 - 0x0000)
struct MainMenuUserWidget_HasValidSaveGameSlot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainMenuUserWidget_HasValidSaveGameSlot) == 0x000001, "Wrong alignment on MainMenuUserWidget_HasValidSaveGameSlot");
static_assert(sizeof(MainMenuUserWidget_HasValidSaveGameSlot) == 0x000001, "Wrong size on MainMenuUserWidget_HasValidSaveGameSlot");
static_assert(offsetof(MainMenuUserWidget_HasValidSaveGameSlot, ReturnValue) == 0x000000, "Member 'MainMenuUserWidget_HasValidSaveGameSlot::ReturnValue' has a wrong offset!");

// Function man.MainMenuUserWidget.OnDeleteSaveGame
// 0x0008 (0x0008 - 0x0000)
struct MainMenuUserWidget_OnDeleteSaveGame final
{
public:
	bool                                          bSucceeded;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MainMenuUserWidget_OnDeleteSaveGame) == 0x000004, "Wrong alignment on MainMenuUserWidget_OnDeleteSaveGame");
static_assert(sizeof(MainMenuUserWidget_OnDeleteSaveGame) == 0x000008, "Wrong size on MainMenuUserWidget_OnDeleteSaveGame");
static_assert(offsetof(MainMenuUserWidget_OnDeleteSaveGame, bSucceeded) == 0x000000, "Member 'MainMenuUserWidget_OnDeleteSaveGame::bSucceeded' has a wrong offset!");
static_assert(offsetof(MainMenuUserWidget_OnDeleteSaveGame, SlotID) == 0x000004, "Member 'MainMenuUserWidget_OnDeleteSaveGame::SlotID' has a wrong offset!");

// Function man.EternalRagePassive.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct EternalRagePassive_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EternalRagePassive_PropertyChanged) == 0x000004, "Wrong alignment on EternalRagePassive_PropertyChanged");
static_assert(sizeof(EternalRagePassive_PropertyChanged) == 0x000014, "Wrong size on EternalRagePassive_PropertyChanged");
static_assert(offsetof(EternalRagePassive_PropertyChanged, PropertyType) == 0x000000, "Member 'EternalRagePassive_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(EternalRagePassive_PropertyChanged, Value) == 0x000004, "Member 'EternalRagePassive_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(EternalRagePassive_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'EternalRagePassive_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(EternalRagePassive_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'EternalRagePassive_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(EternalRagePassive_PropertyChanged, bAnimate) == 0x000010, "Member 'EternalRagePassive_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.AbilityUpgradeSlotUserWidget.OnSetConnectionsVisibility
// 0x0010 (0x0010 - 0x0000)
struct AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility final
{
public:
	TArray<ESkillUpgradeConnectionType>           SkillUpgradeConnectionTypes;                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility) == 0x000008, "Wrong alignment on AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility");
static_assert(sizeof(AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility) == 0x000010, "Wrong size on AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility");
static_assert(offsetof(AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility, SkillUpgradeConnectionTypes) == 0x000000, "Member 'AbilityUpgradeSlotUserWidget_OnSetConnectionsVisibility::SkillUpgradeConnectionTypes' has a wrong offset!");

// Function man.AbilityUpgradeSlotUserWidget.OnSetIcon
// 0x0008 (0x0008 - 0x0000)
struct AbilityUpgradeSlotUserWidget_OnSetIcon final
{
public:
	const class UTexture2D*                       InIcon;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityUpgradeSlotUserWidget_OnSetIcon) == 0x000008, "Wrong alignment on AbilityUpgradeSlotUserWidget_OnSetIcon");
static_assert(sizeof(AbilityUpgradeSlotUserWidget_OnSetIcon) == 0x000008, "Wrong size on AbilityUpgradeSlotUserWidget_OnSetIcon");
static_assert(offsetof(AbilityUpgradeSlotUserWidget_OnSetIcon, InIcon) == 0x000000, "Member 'AbilityUpgradeSlotUserWidget_OnSetIcon::InIcon' has a wrong offset!");

// Function man.AbilityUpgradeSlotUserWidget.OnSetState
// 0x0001 (0x0001 - 0x0000)
struct AbilityUpgradeSlotUserWidget_OnSetState final
{
public:
	EAbilityUpgradeState                          InAbilityUpgradeState;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityUpgradeSlotUserWidget_OnSetState) == 0x000001, "Wrong alignment on AbilityUpgradeSlotUserWidget_OnSetState");
static_assert(sizeof(AbilityUpgradeSlotUserWidget_OnSetState) == 0x000001, "Wrong size on AbilityUpgradeSlotUserWidget_OnSetState");
static_assert(offsetof(AbilityUpgradeSlotUserWidget_OnSetState, InAbilityUpgradeState) == 0x000000, "Member 'AbilityUpgradeSlotUserWidget_OnSetState::InAbilityUpgradeState' has a wrong offset!");

// Function man.AbilityUpgradeSlotUserWidget.OnSetUpgradeIcon
// 0x0004 (0x0004 - 0x0000)
struct AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon final
{
public:
	int32                                         UpgradeIconID;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon) == 0x000004, "Wrong alignment on AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon");
static_assert(sizeof(AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon) == 0x000004, "Wrong size on AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon");
static_assert(offsetof(AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon, UpgradeIconID) == 0x000000, "Member 'AbilityUpgradeSlotUserWidget_OnSetUpgradeIcon::UpgradeIconID' has a wrong offset!");

// Function man.EnergyShieldAbilityComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct EnergyShieldAbilityComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnergyShieldAbilityComponent_OnPreDamaged) == 0x000008, "Wrong alignment on EnergyShieldAbilityComponent_OnPreDamaged");
static_assert(sizeof(EnergyShieldAbilityComponent_OnPreDamaged) == 0x0002D8, "Wrong size on EnergyShieldAbilityComponent_OnPreDamaged");
static_assert(offsetof(EnergyShieldAbilityComponent_OnPreDamaged, Param) == 0x000000, "Member 'EnergyShieldAbilityComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.AbsorbDamageAbilityComponent.GetLastIncomingDamagePoint
// 0x000C (0x000C - 0x0000)
struct AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint) == 0x000004, "Wrong alignment on AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint");
static_assert(sizeof(AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint) == 0x00000C, "Wrong size on AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint");
static_assert(offsetof(AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint, ReturnValue) == 0x000000, "Member 'AbsorbDamageAbilityComponent_GetLastIncomingDamagePoint::ReturnValue' has a wrong offset!");

// Function man.AbsorbDamageAbilityComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct AbsorbDamageAbilityComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AbsorbDamageAbilityComponent_OnPreDamaged) == 0x000008, "Wrong alignment on AbsorbDamageAbilityComponent_OnPreDamaged");
static_assert(sizeof(AbsorbDamageAbilityComponent_OnPreDamaged) == 0x0002D8, "Wrong size on AbsorbDamageAbilityComponent_OnPreDamaged");
static_assert(offsetof(AbsorbDamageAbilityComponent_OnPreDamaged, Param) == 0x000000, "Member 'AbsorbDamageAbilityComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_OnSetEnabled");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong size on ActiveAbilFilterSlotUserWidget_OnSetEnabled");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.OnSetItemIcon
// 0x0008 (0x0008 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_OnSetItemIcon final
{
public:
	class UTexture2D*                             ItemIcon;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong alignment on ActiveAbilFilterSlotUserWidget_OnSetItemIcon");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong size on ActiveAbilFilterSlotUserWidget_OnSetItemIcon");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnSetItemIcon, ItemIcon) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_OnSetItemIcon::ItemIcon' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.OnSetSelected
// 0x0002 (0x0002 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_OnSetSelected final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_OnSetSelected");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_OnSetSelected) == 0x000002, "Wrong size on ActiveAbilFilterSlotUserWidget_OnSetSelected");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnSetSelected, bInSelected) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_OnSetSelected::bInSelected' has a wrong offset!");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnSetSelected, bAnimate) == 0x000001, "Member 'ActiveAbilFilterSlotUserWidget_OnSetSelected::bAnimate' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.OnSetVisible
// 0x0001 (0x0001 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_OnSetVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_OnSetVisible");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong size on ActiveAbilFilterSlotUserWidget_OnSetVisible");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnSetVisible, bInVisible) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_OnSetVisible::bInVisible' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.OnToggleHasSkillBook
// 0x0001 (0x0001 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook) == 0x000001, "Wrong size on ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook, bInVisible) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_OnToggleHasSkillBook::bInVisible' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.GetAbilityWeaponType
// 0x0001 (0x0001 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType final
{
public:
	EWeaponType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType) == 0x000001, "Wrong size on ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType, ReturnValue) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_GetAbilityWeaponType::ReturnValue' has a wrong offset!");

// Function man.ActiveAbilFilterSlotUserWidget.IsFilterEnabled
// 0x0001 (0x0001 - 0x0000)
struct ActiveAbilFilterSlotUserWidget_IsFilterEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong alignment on ActiveAbilFilterSlotUserWidget_IsFilterEnabled");
static_assert(sizeof(ActiveAbilFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong size on ActiveAbilFilterSlotUserWidget_IsFilterEnabled");
static_assert(offsetof(ActiveAbilFilterSlotUserWidget_IsFilterEnabled, ReturnValue) == 0x000000, "Member 'ActiveAbilFilterSlotUserWidget_IsFilterEnabled::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterSlotUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterSlotUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on CreateCharacterSlotUserWidget_OnSetEnabled");
static_assert(sizeof(CreateCharacterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong size on CreateCharacterSlotUserWidget_OnSetEnabled");
static_assert(offsetof(CreateCharacterSlotUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'CreateCharacterSlotUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.CreateCharacterSlotUserWidget.OnSetFocusAnim
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterSlotUserWidget_OnSetFocusAnim final
{
public:
	bool                                          bInFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterSlotUserWidget_OnSetFocusAnim) == 0x000001, "Wrong alignment on CreateCharacterSlotUserWidget_OnSetFocusAnim");
static_assert(sizeof(CreateCharacterSlotUserWidget_OnSetFocusAnim) == 0x000001, "Wrong size on CreateCharacterSlotUserWidget_OnSetFocusAnim");
static_assert(offsetof(CreateCharacterSlotUserWidget_OnSetFocusAnim, bInFocused) == 0x000000, "Member 'CreateCharacterSlotUserWidget_OnSetFocusAnim::bInFocused' has a wrong offset!");

// Function man.CreateCharacterSlotUserWidget.OnSetIcon
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterSlotUserWidget_OnSetIcon final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterSlotUserWidget_OnSetIcon) == 0x000008, "Wrong alignment on CreateCharacterSlotUserWidget_OnSetIcon");
static_assert(sizeof(CreateCharacterSlotUserWidget_OnSetIcon) == 0x000008, "Wrong size on CreateCharacterSlotUserWidget_OnSetIcon");
static_assert(offsetof(CreateCharacterSlotUserWidget_OnSetIcon, Icon) == 0x000000, "Member 'CreateCharacterSlotUserWidget_OnSetIcon::Icon' has a wrong offset!");

// Function man.MapCharacterUserWidget.OnSetFacing
// 0x0001 (0x0001 - 0x0000)
struct MapCharacterUserWidget_OnSetFacing final
{
public:
	bool                                          bLeft;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCharacterUserWidget_OnSetFacing) == 0x000001, "Wrong alignment on MapCharacterUserWidget_OnSetFacing");
static_assert(sizeof(MapCharacterUserWidget_OnSetFacing) == 0x000001, "Wrong size on MapCharacterUserWidget_OnSetFacing");
static_assert(offsetof(MapCharacterUserWidget_OnSetFacing, bLeft) == 0x000000, "Member 'MapCharacterUserWidget_OnSetFacing::bLeft' has a wrong offset!");

// Function man.ManDLCManager.IsManDLCOwned
// 0x0002 (0x0002 - 0x0000)
struct ManDLCManager_IsManDLCOwned final
{
public:
	EManDLC                                       DLC;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManDLCManager_IsManDLCOwned) == 0x000001, "Wrong alignment on ManDLCManager_IsManDLCOwned");
static_assert(sizeof(ManDLCManager_IsManDLCOwned) == 0x000002, "Wrong size on ManDLCManager_IsManDLCOwned");
static_assert(offsetof(ManDLCManager_IsManDLCOwned, DLC) == 0x000000, "Member 'ManDLCManager_IsManDLCOwned::DLC' has a wrong offset!");
static_assert(offsetof(ManDLCManager_IsManDLCOwned, ReturnValue) == 0x000001, "Member 'ManDLCManager_IsManDLCOwned::ReturnValue' has a wrong offset!");

// Function man.SkillUpgradeWindowUserWidget.OnHasEnoughResource
// 0x0001 (0x0001 - 0x0000)
struct SkillUpgradeWindowUserWidget_OnHasEnoughResource final
{
public:
	bool                                          bHasEnoughResource;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillUpgradeWindowUserWidget_OnHasEnoughResource) == 0x000001, "Wrong alignment on SkillUpgradeWindowUserWidget_OnHasEnoughResource");
static_assert(sizeof(SkillUpgradeWindowUserWidget_OnHasEnoughResource) == 0x000001, "Wrong size on SkillUpgradeWindowUserWidget_OnHasEnoughResource");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnHasEnoughResource, bHasEnoughResource) == 0x000000, "Member 'SkillUpgradeWindowUserWidget_OnHasEnoughResource::bHasEnoughResource' has a wrong offset!");

// Function man.SkillUpgradeWindowUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct SkillUpgradeWindowUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillUpgradeWindowUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on SkillUpgradeWindowUserWidget_OnPropertyChanged");
static_assert(sizeof(SkillUpgradeWindowUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on SkillUpgradeWindowUserWidget_OnPropertyChanged");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'SkillUpgradeWindowUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'SkillUpgradeWindowUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'SkillUpgradeWindowUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'SkillUpgradeWindowUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'SkillUpgradeWindowUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.SkillUpgradeWindowUserWidget.OnSetSkillsView
// 0x0001 (0x0001 - 0x0000)
struct SkillUpgradeWindowUserWidget_OnSetSkillsView final
{
public:
	bool                                          bInSkillsView;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillUpgradeWindowUserWidget_OnSetSkillsView) == 0x000001, "Wrong alignment on SkillUpgradeWindowUserWidget_OnSetSkillsView");
static_assert(sizeof(SkillUpgradeWindowUserWidget_OnSetSkillsView) == 0x000001, "Wrong size on SkillUpgradeWindowUserWidget_OnSetSkillsView");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnSetSkillsView, bInSkillsView) == 0x000000, "Member 'SkillUpgradeWindowUserWidget_OnSetSkillsView::bInSkillsView' has a wrong offset!");

// Function man.SkillUpgradeWindowUserWidget.OnUpdateUpgradeDetails
// 0x0020 (0x0020 - 0x0000)
struct SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails) == 0x000008, "Wrong alignment on SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails");
static_assert(sizeof(SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails) == 0x000020, "Wrong size on SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails, Description) == 0x000000, "Member 'SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails::Description' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails, Cost) == 0x000018, "Member 'SkillUpgradeWindowUserWidget_OnUpdateUpgradeDetails::Cost' has a wrong offset!");

// Function man.SkillUpgradeWindowUserWidget.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct SkillUpgradeWindowUserWidget_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillUpgradeWindowUserWidget_PropertyChanged) == 0x000004, "Wrong alignment on SkillUpgradeWindowUserWidget_PropertyChanged");
static_assert(sizeof(SkillUpgradeWindowUserWidget_PropertyChanged) == 0x000014, "Wrong size on SkillUpgradeWindowUserWidget_PropertyChanged");
static_assert(offsetof(SkillUpgradeWindowUserWidget_PropertyChanged, PropertyType) == 0x000000, "Member 'SkillUpgradeWindowUserWidget_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_PropertyChanged, Value) == 0x000004, "Member 'SkillUpgradeWindowUserWidget_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'SkillUpgradeWindowUserWidget_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'SkillUpgradeWindowUserWidget_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(SkillUpgradeWindowUserWidget_PropertyChanged, bAnimate) == 0x000010, "Member 'SkillUpgradeWindowUserWidget_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.ActiveAbilitiesUpgradeWindow.OnSetAbilityName
// 0x0018 (0x0018 - 0x0000)
struct ActiveAbilitiesUpgradeWindow_OnSetAbilityName final
{
public:
	class FText                                   AbilityName;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilitiesUpgradeWindow_OnSetAbilityName) == 0x000008, "Wrong alignment on ActiveAbilitiesUpgradeWindow_OnSetAbilityName");
static_assert(sizeof(ActiveAbilitiesUpgradeWindow_OnSetAbilityName) == 0x000018, "Wrong size on ActiveAbilitiesUpgradeWindow_OnSetAbilityName");
static_assert(offsetof(ActiveAbilitiesUpgradeWindow_OnSetAbilityName, AbilityName) == 0x000000, "Member 'ActiveAbilitiesUpgradeWindow_OnSetAbilityName::AbilityName' has a wrong offset!");

// Function man.ActiveAbilitiesWindowUserWidget.EndUnequipState
// 0x0008 (0x0008 - 0x0000)
struct ActiveAbilitiesWindowUserWidget_EndUnequipState final
{
public:
	class UAbilitySlotUserWidget*                 NewFocusedAbilitySlotUserWidget;                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilitiesWindowUserWidget_EndUnequipState) == 0x000008, "Wrong alignment on ActiveAbilitiesWindowUserWidget_EndUnequipState");
static_assert(sizeof(ActiveAbilitiesWindowUserWidget_EndUnequipState) == 0x000008, "Wrong size on ActiveAbilitiesWindowUserWidget_EndUnequipState");
static_assert(offsetof(ActiveAbilitiesWindowUserWidget_EndUnequipState, NewFocusedAbilitySlotUserWidget) == 0x000000, "Member 'ActiveAbilitiesWindowUserWidget_EndUnequipState::NewFocusedAbilitySlotUserWidget' has a wrong offset!");

// Function man.ActiveAbilitiesWindowUserWidget.OnAddItem
// 0x0008 (0x0008 - 0x0000)
struct ActiveAbilitiesWindowUserWidget_OnAddItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActiveAbilitiesWindowUserWidget_OnAddItem) == 0x000008, "Wrong alignment on ActiveAbilitiesWindowUserWidget_OnAddItem");
static_assert(sizeof(ActiveAbilitiesWindowUserWidget_OnAddItem) == 0x000008, "Wrong size on ActiveAbilitiesWindowUserWidget_OnAddItem");
static_assert(offsetof(ActiveAbilitiesWindowUserWidget_OnAddItem, InventorySlot) == 0x000000, "Member 'ActiveAbilitiesWindowUserWidget_OnAddItem::InventorySlot' has a wrong offset!");

// Function man.WeaponIC.GetRelicChargeDamageType
// 0x0010 (0x0010 - 0x0000)
struct WeaponIC_GetRelicChargeDamageType final
{
public:
	TArray<EDamageType>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponIC_GetRelicChargeDamageType) == 0x000008, "Wrong alignment on WeaponIC_GetRelicChargeDamageType");
static_assert(sizeof(WeaponIC_GetRelicChargeDamageType) == 0x000010, "Wrong size on WeaponIC_GetRelicChargeDamageType");
static_assert(offsetof(WeaponIC_GetRelicChargeDamageType, ReturnValue) == 0x000000, "Member 'WeaponIC_GetRelicChargeDamageType::ReturnValue' has a wrong offset!");

// Function man.WeaponIC.OnAttributeChanged
// 0x0010 (0x0010 - 0x0000)
struct WeaponIC_OnAttributeChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponIC_OnAttributeChanged) == 0x000008, "Wrong alignment on WeaponIC_OnAttributeChanged");
static_assert(sizeof(WeaponIC_OnAttributeChanged) == 0x000010, "Wrong size on WeaponIC_OnAttributeChanged");
static_assert(offsetof(WeaponIC_OnAttributeChanged, attribute) == 0x000000, "Member 'WeaponIC_OnAttributeChanged::attribute' has a wrong offset!");
static_assert(offsetof(WeaponIC_OnAttributeChanged, preValue) == 0x000008, "Member 'WeaponIC_OnAttributeChanged::preValue' has a wrong offset!");

// Function man.AutosaveScreenUserWidget.OnSetTexts
// 0x0048 (0x0048 - 0x0000)
struct AutosaveScreenUserWidget_OnSetTexts final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Count;                                             // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutosaveScreenUserWidget_OnSetTexts) == 0x000008, "Wrong alignment on AutosaveScreenUserWidget_OnSetTexts");
static_assert(sizeof(AutosaveScreenUserWidget_OnSetTexts) == 0x000048, "Wrong size on AutosaveScreenUserWidget_OnSetTexts");
static_assert(offsetof(AutosaveScreenUserWidget_OnSetTexts, Title) == 0x000000, "Member 'AutosaveScreenUserWidget_OnSetTexts::Title' has a wrong offset!");
static_assert(offsetof(AutosaveScreenUserWidget_OnSetTexts, Description) == 0x000018, "Member 'AutosaveScreenUserWidget_OnSetTexts::Description' has a wrong offset!");
static_assert(offsetof(AutosaveScreenUserWidget_OnSetTexts, Count) == 0x000030, "Member 'AutosaveScreenUserWidget_OnSetTexts::Count' has a wrong offset!");

// Function man.ActorCheckPoint.IsCheckPointUnlocked
// 0x0001 (0x0001 - 0x0000)
struct ActorCheckPoint_IsCheckPointUnlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCheckPoint_IsCheckPointUnlocked) == 0x000001, "Wrong alignment on ActorCheckPoint_IsCheckPointUnlocked");
static_assert(sizeof(ActorCheckPoint_IsCheckPointUnlocked) == 0x000001, "Wrong size on ActorCheckPoint_IsCheckPointUnlocked");
static_assert(offsetof(ActorCheckPoint_IsCheckPointUnlocked, ReturnValue) == 0x000000, "Member 'ActorCheckPoint_IsCheckPointUnlocked::ReturnValue' has a wrong offset!");

// Function man.ActorCheckPoint.MapManagerLoaded
// 0x0001 (0x0001 - 0x0000)
struct ActorCheckPoint_MapManagerLoaded final
{
public:
	bool                                          bCheckpoinUnlocked;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCheckPoint_MapManagerLoaded) == 0x000001, "Wrong alignment on ActorCheckPoint_MapManagerLoaded");
static_assert(sizeof(ActorCheckPoint_MapManagerLoaded) == 0x000001, "Wrong size on ActorCheckPoint_MapManagerLoaded");
static_assert(offsetof(ActorCheckPoint_MapManagerLoaded, bCheckpoinUnlocked) == 0x000000, "Member 'ActorCheckPoint_MapManagerLoaded::bCheckpoinUnlocked' has a wrong offset!");

// Function man.ActorCheckPoint.OnBPActivated
// 0x0001 (0x0001 - 0x0000)
struct ActorCheckPoint_OnBPActivated final
{
public:
	bool                                          bFirstUnlock;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCheckPoint_OnBPActivated) == 0x000001, "Wrong alignment on ActorCheckPoint_OnBPActivated");
static_assert(sizeof(ActorCheckPoint_OnBPActivated) == 0x000001, "Wrong size on ActorCheckPoint_OnBPActivated");
static_assert(offsetof(ActorCheckPoint_OnBPActivated, bFirstUnlock) == 0x000000, "Member 'ActorCheckPoint_OnBPActivated::bFirstUnlock' has a wrong offset!");

// Function man.ActorCheckPoint.OnCheckPointUnlockSequenceEnd
// 0x0001 (0x0001 - 0x0000)
struct ActorCheckPoint_OnCheckPointUnlockSequenceEnd final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCheckPoint_OnCheckPointUnlockSequenceEnd) == 0x000001, "Wrong alignment on ActorCheckPoint_OnCheckPointUnlockSequenceEnd");
static_assert(sizeof(ActorCheckPoint_OnCheckPointUnlockSequenceEnd) == 0x000001, "Wrong size on ActorCheckPoint_OnCheckPointUnlockSequenceEnd");
static_assert(offsetof(ActorCheckPoint_OnCheckPointUnlockSequenceEnd, bSuccess) == 0x000000, "Member 'ActorCheckPoint_OnCheckPointUnlockSequenceEnd::bSuccess' has a wrong offset!");

// Function man.BasicAttackAbility.BPSetAnim
// 0x0008 (0x0008 - 0x0000)
struct BasicAttackAbility_BPSetAnim final
{
public:
	class UAnimID*                                inAnimId;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BasicAttackAbility_BPSetAnim) == 0x000008, "Wrong alignment on BasicAttackAbility_BPSetAnim");
static_assert(sizeof(BasicAttackAbility_BPSetAnim) == 0x000008, "Wrong size on BasicAttackAbility_BPSetAnim");
static_assert(offsetof(BasicAttackAbility_BPSetAnim, inAnimId) == 0x000000, "Member 'BasicAttackAbility_BPSetAnim::inAnimId' has a wrong offset!");

// Function man.ActorSoul.GetBondAbilityController
// 0x0008 (0x0008 - 0x0000)
struct ActorSoul_GetBondAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSoul_GetBondAbilityController) == 0x000008, "Wrong alignment on ActorSoul_GetBondAbilityController");
static_assert(sizeof(ActorSoul_GetBondAbilityController) == 0x000008, "Wrong size on ActorSoul_GetBondAbilityController");
static_assert(offsetof(ActorSoul_GetBondAbilityController, ReturnValue) == 0x000000, "Member 'ActorSoul_GetBondAbilityController::ReturnValue' has a wrong offset!");

// Function man.ActorSoul.GetBondActor
// 0x0008 (0x0008 - 0x0000)
struct ActorSoul_GetBondActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSoul_GetBondActor) == 0x000008, "Wrong alignment on ActorSoul_GetBondActor");
static_assert(sizeof(ActorSoul_GetBondActor) == 0x000008, "Wrong size on ActorSoul_GetBondActor");
static_assert(offsetof(ActorSoul_GetBondActor, ReturnValue) == 0x000000, "Member 'ActorSoul_GetBondActor::ReturnValue' has a wrong offset!");

// Function man.ActorSoul.GetBondActorBase
// 0x0008 (0x0008 - 0x0000)
struct ActorSoul_GetBondActorBase final
{
public:
	class AActorBase*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSoul_GetBondActorBase) == 0x000008, "Wrong alignment on ActorSoul_GetBondActorBase");
static_assert(sizeof(ActorSoul_GetBondActorBase) == 0x000008, "Wrong size on ActorSoul_GetBondActorBase");
static_assert(offsetof(ActorSoul_GetBondActorBase, ReturnValue) == 0x000000, "Member 'ActorSoul_GetBondActorBase::ReturnValue' has a wrong offset!");

// Function man.ActorSoul.GetBondCharacter
// 0x0010 (0x0010 - 0x0000)
struct ActorSoul_GetBondCharacter final
{
public:
	bool                                          bLivingOnly;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBase*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorSoul_GetBondCharacter) == 0x000008, "Wrong alignment on ActorSoul_GetBondCharacter");
static_assert(sizeof(ActorSoul_GetBondCharacter) == 0x000010, "Wrong size on ActorSoul_GetBondCharacter");
static_assert(offsetof(ActorSoul_GetBondCharacter, bLivingOnly) == 0x000000, "Member 'ActorSoul_GetBondCharacter::bLivingOnly' has a wrong offset!");
static_assert(offsetof(ActorSoul_GetBondCharacter, ReturnValue) == 0x000008, "Member 'ActorSoul_GetBondCharacter::ReturnValue' has a wrong offset!");

// Function man.ActorSoul.OnGPEvent_ToggleAbility
// 0x0028 (0x0028 - 0x0000)
struct ActorSoul_OnGPEvent_ToggleAbility final
{
public:
	class AActorSoul*                             EventOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       GameplayEventID;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityName;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Disable;                                           // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Start;                                             // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          End;                                               // 0x0023(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Add;                                               // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Remove;                                            // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorSoul_OnGPEvent_ToggleAbility) == 0x000008, "Wrong alignment on ActorSoul_OnGPEvent_ToggleAbility");
static_assert(sizeof(ActorSoul_OnGPEvent_ToggleAbility) == 0x000028, "Wrong size on ActorSoul_OnGPEvent_ToggleAbility");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, EventOwner) == 0x000000, "Member 'ActorSoul_OnGPEvent_ToggleAbility::EventOwner' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, GameplayEventID) == 0x000008, "Member 'ActorSoul_OnGPEvent_ToggleAbility::GameplayEventID' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, AbilityClass) == 0x000010, "Member 'ActorSoul_OnGPEvent_ToggleAbility::AbilityClass' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, AbilityName) == 0x000018, "Member 'ActorSoul_OnGPEvent_ToggleAbility::AbilityName' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, Enable) == 0x000020, "Member 'ActorSoul_OnGPEvent_ToggleAbility::Enable' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, Disable) == 0x000021, "Member 'ActorSoul_OnGPEvent_ToggleAbility::Disable' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, Start) == 0x000022, "Member 'ActorSoul_OnGPEvent_ToggleAbility::Start' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, End) == 0x000023, "Member 'ActorSoul_OnGPEvent_ToggleAbility::End' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, Add) == 0x000024, "Member 'ActorSoul_OnGPEvent_ToggleAbility::Add' has a wrong offset!");
static_assert(offsetof(ActorSoul_OnGPEvent_ToggleAbility, Remove) == 0x000025, "Member 'ActorSoul_OnGPEvent_ToggleAbility::Remove' has a wrong offset!");

// Function man.EnemyHPBarUserWidget.OnEnemyHealthBarsVisible
// 0x0001 (0x0001 - 0x0000)
struct EnemyHPBarUserWidget_OnEnemyHealthBarsVisible final
{
public:
	bool                                          bEnemyHealthBarsVisible;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemyHPBarUserWidget_OnEnemyHealthBarsVisible) == 0x000001, "Wrong alignment on EnemyHPBarUserWidget_OnEnemyHealthBarsVisible");
static_assert(sizeof(EnemyHPBarUserWidget_OnEnemyHealthBarsVisible) == 0x000001, "Wrong size on EnemyHPBarUserWidget_OnEnemyHealthBarsVisible");
static_assert(offsetof(EnemyHPBarUserWidget_OnEnemyHealthBarsVisible, bEnemyHealthBarsVisible) == 0x000000, "Member 'EnemyHPBarUserWidget_OnEnemyHealthBarsVisible::bEnemyHealthBarsVisible' has a wrong offset!");

// Function man.EnemyHPBarUserWidget.OnSetBarrierDamageValue
// 0x0004 (0x0004 - 0x0000)
struct EnemyHPBarUserWidget_OnSetBarrierDamageValue final
{
public:
	int32                                         InBarrierDamageValue;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemyHPBarUserWidget_OnSetBarrierDamageValue) == 0x000004, "Wrong alignment on EnemyHPBarUserWidget_OnSetBarrierDamageValue");
static_assert(sizeof(EnemyHPBarUserWidget_OnSetBarrierDamageValue) == 0x000004, "Wrong size on EnemyHPBarUserWidget_OnSetBarrierDamageValue");
static_assert(offsetof(EnemyHPBarUserWidget_OnSetBarrierDamageValue, InBarrierDamageValue) == 0x000000, "Member 'EnemyHPBarUserWidget_OnSetBarrierDamageValue::InBarrierDamageValue' has a wrong offset!");

// Function man.EnemyHPBarUserWidget.OnSetDamageValue
// 0x0008 (0x0008 - 0x0000)
struct EnemyHPBarUserWidget_OnSetDamageValue final
{
public:
	int32                                         InDamageValue;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCriticalHit;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnemyHPBarUserWidget_OnSetDamageValue) == 0x000004, "Wrong alignment on EnemyHPBarUserWidget_OnSetDamageValue");
static_assert(sizeof(EnemyHPBarUserWidget_OnSetDamageValue) == 0x000008, "Wrong size on EnemyHPBarUserWidget_OnSetDamageValue");
static_assert(offsetof(EnemyHPBarUserWidget_OnSetDamageValue, InDamageValue) == 0x000000, "Member 'EnemyHPBarUserWidget_OnSetDamageValue::InDamageValue' has a wrong offset!");
static_assert(offsetof(EnemyHPBarUserWidget_OnSetDamageValue, bInCriticalHit) == 0x000004, "Member 'EnemyHPBarUserWidget_OnSetDamageValue::bInCriticalHit' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.BPSetNewMinMax
// 0x0010 (0x0010 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_BPSetNewMinMax final
{
public:
	float                                         NewMin;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMax;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthRatio;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_BPSetNewMinMax");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax) == 0x000010, "Wrong size on HUDAnimatedProgressBarUserWidget_BPSetNewMinMax");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax, NewMin) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewMinMax::NewMin' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax, NewMax) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewMinMax::NewMax' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax, LengthRatio) == 0x000008, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewMinMax::LengthRatio' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewMinMax, bAnimate) == 0x00000C, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewMinMax::bAnimate' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.BPSetNewValue
// 0x0008 (0x0008 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_BPSetNewValue final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightChange;                                  // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedExtraHighlight;                               // 0x0006(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_BPSetNewValue) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_BPSetNewValue");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_BPSetNewValue) == 0x000008, "Wrong size on HUDAnimatedProgressBarUserWidget_BPSetNewValue");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewValue, NewValue) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewValue::NewValue' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewValue, bHighlightChange) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewValue::bHighlightChange' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewValue, bAnimate) == 0x000005, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewValue::bAnimate' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_BPSetNewValue, bNeedExtraHighlight) == 0x000006, "Member 'HUDAnimatedProgressBarUserWidget_BPSetNewValue::bNeedExtraHighlight' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.DisplayPercentageOnResourceBars
// 0x0004 (0x0004 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars final
{
public:
	int32                                         bInDisplayPercentageOnResourceBars;                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars) == 0x000004, "Wrong size on HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars, bInDisplayPercentageOnResourceBars) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_DisplayPercentageOnResourceBars::bInDisplayPercentageOnResourceBars' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnAttributeChanged
// 0x0008 (0x0008 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnAttributeChanged final
{
public:
	EAttribute                                    AttributeType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnAttributeChanged) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnAttributeChanged");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnAttributeChanged) == 0x000008, "Wrong size on HUDAnimatedProgressBarUserWidget_OnAttributeChanged");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnAttributeChanged, AttributeType) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnAttributeChanged::AttributeType' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnAttributeChanged, Value) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_OnAttributeChanged::Value' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnBossHealthBarsVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible final
{
public:
	bool                                          bBossHealthBarsVisible;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible) == 0x000001, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible) == 0x000001, "Wrong size on HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible, bBossHealthBarsVisible) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnBossHealthBarsVisible::bBossHealthBarsVisible' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnDisplayPercentageOnResourceBars
// 0x0001 (0x0001 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars final
{
public:
	bool                                          bInDisplayPercentageOnResourceBars;                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars) == 0x000001, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars) == 0x000001, "Wrong size on HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars, bInDisplayPercentageOnResourceBars) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnDisplayPercentageOnResourceBars::bInDisplayPercentageOnResourceBars' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnPropertyChanged");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on HUDAnimatedProgressBarUserWidget_OnPropertyChanged");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'HUDAnimatedProgressBarUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'HUDAnimatedProgressBarUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'HUDAnimatedProgressBarUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnSetHealthBarTypeModifier
// 0x0010 (0x0010 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier final
{
public:
	TArray<EHealthBarTypeModifier>                InHealthBarTypeModifiers;                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier) == 0x000008, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier) == 0x000010, "Wrong size on HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier, InHealthBarTypeModifiers) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnSetHealthBarTypeModifier::InHealthBarTypeModifiers' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnSetNewMinMax
// 0x0010 (0x0010 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnSetNewMinMax final
{
public:
	float                                         NewMin;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMax;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthRatio;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnSetNewMinMax");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax) == 0x000010, "Wrong size on HUDAnimatedProgressBarUserWidget_OnSetNewMinMax");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax, NewMin) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewMinMax::NewMin' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax, NewMax) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewMinMax::NewMax' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax, LengthRatio) == 0x000008, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewMinMax::LengthRatio' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewMinMax, bAnimate) == 0x00000C, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewMinMax::bAnimate' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnSetNewValue
// 0x0008 (0x0008 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnSetNewValue final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightChange;                                  // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedExtraHighlight;                               // 0x0006(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnSetNewValue) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnSetNewValue");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnSetNewValue) == 0x000008, "Wrong size on HUDAnimatedProgressBarUserWidget_OnSetNewValue");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewValue, NewValue) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewValue::NewValue' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewValue, bHighlightChange) == 0x000004, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewValue::bHighlightChange' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewValue, bAnimate) == 0x000005, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewValue::bAnimate' has a wrong offset!");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetNewValue, bNeedExtraHighlight) == 0x000006, "Member 'HUDAnimatedProgressBarUserWidget_OnSetNewValue::bNeedExtraHighlight' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnSetPercentageText
// 0x0018 (0x0018 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnSetPercentageText final
{
public:
	class FText                                   PercentageText;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnSetPercentageText) == 0x000008, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnSetPercentageText");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnSetPercentageText) == 0x000018, "Wrong size on HUDAnimatedProgressBarUserWidget_OnSetPercentageText");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetPercentageText, PercentageText) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnSetPercentageText::PercentageText' has a wrong offset!");

// Function man.HUDAnimatedProgressBarUserWidget.OnSetReservedValue
// 0x0004 (0x0004 - 0x0000)
struct HUDAnimatedProgressBarUserWidget_OnSetReservedValue final
{
public:
	float                                         InReservedValue;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAnimatedProgressBarUserWidget_OnSetReservedValue) == 0x000004, "Wrong alignment on HUDAnimatedProgressBarUserWidget_OnSetReservedValue");
static_assert(sizeof(HUDAnimatedProgressBarUserWidget_OnSetReservedValue) == 0x000004, "Wrong size on HUDAnimatedProgressBarUserWidget_OnSetReservedValue");
static_assert(offsetof(HUDAnimatedProgressBarUserWidget_OnSetReservedValue, InReservedValue) == 0x000000, "Member 'HUDAnimatedProgressBarUserWidget_OnSetReservedValue::InReservedValue' has a wrong offset!");

// Function man.NewArea.ZoneTriggered
// 0x0020 (0x0020 - 0x0000)
struct NewArea_ZoneTriggered final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NewArea_ZoneTriggered) == 0x000008, "Wrong alignment on NewArea_ZoneTriggered");
static_assert(sizeof(NewArea_ZoneTriggered) == 0x000020, "Wrong size on NewArea_ZoneTriggered");
static_assert(offsetof(NewArea_ZoneTriggered, InAbilityController) == 0x000000, "Member 'NewArea_ZoneTriggered::InAbilityController' has a wrong offset!");
static_assert(offsetof(NewArea_ZoneTriggered, _GameplayEventID) == 0x000008, "Member 'NewArea_ZoneTriggered::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(NewArea_ZoneTriggered, CustomName) == 0x000010, "Member 'NewArea_ZoneTriggered::CustomName' has a wrong offset!");
static_assert(offsetof(NewArea_ZoneTriggered, paramActorSoul) == 0x000018, "Member 'NewArea_ZoneTriggered::paramActorSoul' has a wrong offset!");

// Function man.AttributeTransfuse.OnValueChanged
// 0x0010 (0x0010 - 0x0000)
struct AttributeTransfuse_OnValueChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeTransfuse_OnValueChanged) == 0x000008, "Wrong alignment on AttributeTransfuse_OnValueChanged");
static_assert(sizeof(AttributeTransfuse_OnValueChanged) == 0x000010, "Wrong size on AttributeTransfuse_OnValueChanged");
static_assert(offsetof(AttributeTransfuse_OnValueChanged, attribute) == 0x000000, "Member 'AttributeTransfuse_OnValueChanged::attribute' has a wrong offset!");
static_assert(offsetof(AttributeTransfuse_OnValueChanged, preValue) == 0x000008, "Member 'AttributeTransfuse_OnValueChanged::preValue' has a wrong offset!");

// Function man.HUDWarningUserWidget.OnDisplayErrorMessages
// 0x0001 (0x0001 - 0x0000)
struct HUDWarningUserWidget_OnDisplayErrorMessages final
{
public:
	bool                                          bDisplayErrorMessages;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDWarningUserWidget_OnDisplayErrorMessages) == 0x000001, "Wrong alignment on HUDWarningUserWidget_OnDisplayErrorMessages");
static_assert(sizeof(HUDWarningUserWidget_OnDisplayErrorMessages) == 0x000001, "Wrong size on HUDWarningUserWidget_OnDisplayErrorMessages");
static_assert(offsetof(HUDWarningUserWidget_OnDisplayErrorMessages, bDisplayErrorMessages) == 0x000000, "Member 'HUDWarningUserWidget_OnDisplayErrorMessages::bDisplayErrorMessages' has a wrong offset!");

// Function man.BeamAbility.GetBeamDirection
// 0x000C (0x000C - 0x0000)
struct BeamAbility_GetBeamDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BeamAbility_GetBeamDirection) == 0x000004, "Wrong alignment on BeamAbility_GetBeamDirection");
static_assert(sizeof(BeamAbility_GetBeamDirection) == 0x00000C, "Wrong size on BeamAbility_GetBeamDirection");
static_assert(offsetof(BeamAbility_GetBeamDirection, ReturnValue) == 0x000000, "Member 'BeamAbility_GetBeamDirection::ReturnValue' has a wrong offset!");

// Function man.BeamAbility.GetDamagedEntities
// 0x0010 (0x0010 - 0x0000)
struct BeamAbility_GetDamagedEntities final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BeamAbility_GetDamagedEntities) == 0x000008, "Wrong alignment on BeamAbility_GetDamagedEntities");
static_assert(sizeof(BeamAbility_GetDamagedEntities) == 0x000010, "Wrong size on BeamAbility_GetDamagedEntities");
static_assert(offsetof(BeamAbility_GetDamagedEntities, ReturnValue) == 0x000000, "Member 'BeamAbility_GetDamagedEntities::ReturnValue' has a wrong offset!");

// Function man.BeamAbility.GetLastBeamEndPoint
// 0x000C (0x000C - 0x0000)
struct BeamAbility_GetLastBeamEndPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BeamAbility_GetLastBeamEndPoint) == 0x000004, "Wrong alignment on BeamAbility_GetLastBeamEndPoint");
static_assert(sizeof(BeamAbility_GetLastBeamEndPoint) == 0x00000C, "Wrong size on BeamAbility_GetLastBeamEndPoint");
static_assert(offsetof(BeamAbility_GetLastBeamEndPoint, ReturnValue) == 0x000000, "Member 'BeamAbility_GetLastBeamEndPoint::ReturnValue' has a wrong offset!");

// Function man.BeamAbility.GetLastBeamHitResult
// 0x0088 (0x0088 - 0x0000)
struct BeamAbility_GetLastBeamHitResult final
{
public:
	struct FHitResult                             ReturnValue;                                       // 0x0000(0x0088)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BeamAbility_GetLastBeamHitResult) == 0x000004, "Wrong alignment on BeamAbility_GetLastBeamHitResult");
static_assert(sizeof(BeamAbility_GetLastBeamHitResult) == 0x000088, "Wrong size on BeamAbility_GetLastBeamHitResult");
static_assert(offsetof(BeamAbility_GetLastBeamHitResult, ReturnValue) == 0x000000, "Member 'BeamAbility_GetLastBeamHitResult::ReturnValue' has a wrong offset!");

// Function man.BeamAbility.GetLastBeamStartPoint
// 0x000C (0x000C - 0x0000)
struct BeamAbility_GetLastBeamStartPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BeamAbility_GetLastBeamStartPoint) == 0x000004, "Wrong alignment on BeamAbility_GetLastBeamStartPoint");
static_assert(sizeof(BeamAbility_GetLastBeamStartPoint) == 0x00000C, "Wrong size on BeamAbility_GetLastBeamStartPoint");
static_assert(offsetof(BeamAbility_GetLastBeamStartPoint, ReturnValue) == 0x000000, "Member 'BeamAbility_GetLastBeamStartPoint::ReturnValue' has a wrong offset!");

// Function man.ArbitersFuryAbility.GetBeamDimensions
// 0x000C (0x000C - 0x0000)
struct ArbitersFuryAbility_GetBeamDimensions final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArbitersFuryAbility_GetBeamDimensions) == 0x000004, "Wrong alignment on ArbitersFuryAbility_GetBeamDimensions");
static_assert(sizeof(ArbitersFuryAbility_GetBeamDimensions) == 0x00000C, "Wrong size on ArbitersFuryAbility_GetBeamDimensions");
static_assert(offsetof(ArbitersFuryAbility_GetBeamDimensions, ReturnValue) == 0x000000, "Member 'ArbitersFuryAbility_GetBeamDimensions::ReturnValue' has a wrong offset!");

// Function man.ArbitersFuryAbility.GetSavedTriggerDelay
// 0x0004 (0x0004 - 0x0000)
struct ArbitersFuryAbility_GetSavedTriggerDelay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArbitersFuryAbility_GetSavedTriggerDelay) == 0x000004, "Wrong alignment on ArbitersFuryAbility_GetSavedTriggerDelay");
static_assert(sizeof(ArbitersFuryAbility_GetSavedTriggerDelay) == 0x000004, "Wrong size on ArbitersFuryAbility_GetSavedTriggerDelay");
static_assert(offsetof(ArbitersFuryAbility_GetSavedTriggerDelay, ReturnValue) == 0x000000, "Member 'ArbitersFuryAbility_GetSavedTriggerDelay::ReturnValue' has a wrong offset!");

// Function man.ArbitersFuryAbility.GetVirtualChargeRate
// 0x0004 (0x0004 - 0x0000)
struct ArbitersFuryAbility_GetVirtualChargeRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArbitersFuryAbility_GetVirtualChargeRate) == 0x000004, "Wrong alignment on ArbitersFuryAbility_GetVirtualChargeRate");
static_assert(sizeof(ArbitersFuryAbility_GetVirtualChargeRate) == 0x000004, "Wrong size on ArbitersFuryAbility_GetVirtualChargeRate");
static_assert(offsetof(ArbitersFuryAbility_GetVirtualChargeRate, ReturnValue) == 0x000000, "Member 'ArbitersFuryAbility_GetVirtualChargeRate::ReturnValue' has a wrong offset!");

// Function man.ArbitersFuryAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ArbitersFuryAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArbitersFuryAbility_PostDamageDealt) == 0x000008, "Wrong alignment on ArbitersFuryAbility_PostDamageDealt");
static_assert(sizeof(ArbitersFuryAbility_PostDamageDealt) == 0x0002D8, "Wrong size on ArbitersFuryAbility_PostDamageDealt");
static_assert(offsetof(ArbitersFuryAbility_PostDamageDealt, Param) == 0x000000, "Member 'ArbitersFuryAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.OlenDWControl.OnSummonerAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct OlenDWControl_OnSummonerAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OlenDWControl_OnSummonerAbilityStarted) == 0x000008, "Wrong alignment on OlenDWControl_OnSummonerAbilityStarted");
static_assert(sizeof(OlenDWControl_OnSummonerAbilityStarted) == 0x000010, "Wrong size on OlenDWControl_OnSummonerAbilityStarted");
static_assert(offsetof(OlenDWControl_OnSummonerAbilityStarted, StartedAbility) == 0x000000, "Member 'OlenDWControl_OnSummonerAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(OlenDWControl_OnSummonerAbilityStarted, bDesired) == 0x000008, "Member 'OlenDWControl_OnSummonerAbilityStarted::bDesired' has a wrong offset!");

// Function man.OlenDWControl.OnSummonerGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct OlenDWControl_OnSummonerGameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OlenDWControl_OnSummonerGameplayEvent) == 0x000008, "Wrong alignment on OlenDWControl_OnSummonerGameplayEvent");
static_assert(sizeof(OlenDWControl_OnSummonerGameplayEvent) == 0x000020, "Wrong size on OlenDWControl_OnSummonerGameplayEvent");
static_assert(offsetof(OlenDWControl_OnSummonerGameplayEvent, AbilityController) == 0x000000, "Member 'OlenDWControl_OnSummonerGameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(OlenDWControl_OnSummonerGameplayEvent, _GameplayEventID) == 0x000008, "Member 'OlenDWControl_OnSummonerGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(OlenDWControl_OnSummonerGameplayEvent, CustomName) == 0x000010, "Member 'OlenDWControl_OnSummonerGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(OlenDWControl_OnSummonerGameplayEvent, paramActorSoul) == 0x000018, "Member 'OlenDWControl_OnSummonerGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.AIActionSequenceNode_UseAbility.EventOnAbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct AIActionSequenceNode_UseAbility_EventOnAbilityEnd final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionSequenceNode_UseAbility_EventOnAbilityEnd) == 0x000008, "Wrong alignment on AIActionSequenceNode_UseAbility_EventOnAbilityEnd");
static_assert(sizeof(AIActionSequenceNode_UseAbility_EventOnAbilityEnd) == 0x000008, "Wrong size on AIActionSequenceNode_UseAbility_EventOnAbilityEnd");
static_assert(offsetof(AIActionSequenceNode_UseAbility_EventOnAbilityEnd, InAbility) == 0x000000, "Member 'AIActionSequenceNode_UseAbility_EventOnAbilityEnd::InAbility' has a wrong offset!");

// Function man.BanditBruteAI.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct BanditBruteAI_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BanditBruteAI_OnPreDamagedPriority) == 0x000008, "Wrong alignment on BanditBruteAI_OnPreDamagedPriority");
static_assert(sizeof(BanditBruteAI_OnPreDamagedPriority) == 0x0002D8, "Wrong size on BanditBruteAI_OnPreDamagedPriority");
static_assert(offsetof(BanditBruteAI_OnPreDamagedPriority, Param) == 0x000000, "Member 'BanditBruteAI_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.HUDTimerUserWidget.IsTimerVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDTimerUserWidget_IsTimerVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDTimerUserWidget_IsTimerVisible) == 0x000001, "Wrong alignment on HUDTimerUserWidget_IsTimerVisible");
static_assert(sizeof(HUDTimerUserWidget_IsTimerVisible) == 0x000001, "Wrong size on HUDTimerUserWidget_IsTimerVisible");
static_assert(offsetof(HUDTimerUserWidget_IsTimerVisible, ReturnValue) == 0x000000, "Member 'HUDTimerUserWidget_IsTimerVisible::ReturnValue' has a wrong offset!");

// Function man.HUDTimerUserWidget.OnSetTimer
// 0x0018 (0x0018 - 0x0000)
struct HUDTimerUserWidget_OnSetTimer final
{
public:
	class FText                                   InTimerText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDTimerUserWidget_OnSetTimer) == 0x000008, "Wrong alignment on HUDTimerUserWidget_OnSetTimer");
static_assert(sizeof(HUDTimerUserWidget_OnSetTimer) == 0x000018, "Wrong size on HUDTimerUserWidget_OnSetTimer");
static_assert(offsetof(HUDTimerUserWidget_OnSetTimer, InTimerText) == 0x000000, "Member 'HUDTimerUserWidget_OnSetTimer::InTimerText' has a wrong offset!");

// Function man.HUDTimerUserWidget.SetTimer
// 0x0008 (0x0008 - 0x0000)
struct HUDTimerUserWidget_SetTimer final
{
public:
	float                                         Timer;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDTimerUserWidget_SetTimer) == 0x000004, "Wrong alignment on HUDTimerUserWidget_SetTimer");
static_assert(sizeof(HUDTimerUserWidget_SetTimer) == 0x000008, "Wrong size on HUDTimerUserWidget_SetTimer");
static_assert(offsetof(HUDTimerUserWidget_SetTimer, Timer) == 0x000000, "Member 'HUDTimerUserWidget_SetTimer::Timer' has a wrong offset!");
static_assert(offsetof(HUDTimerUserWidget_SetTimer, Delay) == 0x000004, "Member 'HUDTimerUserWidget_SetTimer::Delay' has a wrong offset!");

// Function man.DivineAegisAbility.IsDoubleSided
// 0x0001 (0x0001 - 0x0000)
struct DivineAegisAbility_IsDoubleSided final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineAegisAbility_IsDoubleSided) == 0x000001, "Wrong alignment on DivineAegisAbility_IsDoubleSided");
static_assert(sizeof(DivineAegisAbility_IsDoubleSided) == 0x000001, "Wrong size on DivineAegisAbility_IsDoubleSided");
static_assert(offsetof(DivineAegisAbility_IsDoubleSided, ReturnValue) == 0x000000, "Member 'DivineAegisAbility_IsDoubleSided::ReturnValue' has a wrong offset!");

// Function man.DivineAegisAbility.PostDamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct DivineAegisAbility_PostDamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineAegisAbility_PostDamageReceived) == 0x000008, "Wrong alignment on DivineAegisAbility_PostDamageReceived");
static_assert(sizeof(DivineAegisAbility_PostDamageReceived) == 0x0002D8, "Wrong size on DivineAegisAbility_PostDamageReceived");
static_assert(offsetof(DivineAegisAbility_PostDamageReceived, Param) == 0x000000, "Member 'DivineAegisAbility_PostDamageReceived::Param' has a wrong offset!");

// Function man.AIActionSequenceNode_Turn.EventOnAbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct AIActionSequenceNode_Turn_EventOnAbilityEnd final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionSequenceNode_Turn_EventOnAbilityEnd) == 0x000008, "Wrong alignment on AIActionSequenceNode_Turn_EventOnAbilityEnd");
static_assert(sizeof(AIActionSequenceNode_Turn_EventOnAbilityEnd) == 0x000008, "Wrong size on AIActionSequenceNode_Turn_EventOnAbilityEnd");
static_assert(offsetof(AIActionSequenceNode_Turn_EventOnAbilityEnd, InAbility) == 0x000000, "Member 'AIActionSequenceNode_Turn_EventOnAbilityEnd::InAbility' has a wrong offset!");

// Function man.AnimInstanceCore.OnAnimEvent
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceCore_OnAnimEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Animation;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnAnimEvent) == 0x000008, "Wrong alignment on AnimInstanceCore_OnAnimEvent");
static_assert(sizeof(AnimInstanceCore_OnAnimEvent) == 0x000018, "Wrong size on AnimInstanceCore_OnAnimEvent");
static_assert(offsetof(AnimInstanceCore_OnAnimEvent, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnAnimEvent::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimEvent, AnimEventType) == 0x000008, "Member 'AnimInstanceCore_OnAnimEvent::AnimEventType' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimEvent, Animation) == 0x000010, "Member 'AnimInstanceCore_OnAnimEvent::Animation' has a wrong offset!");

// Function man.AnimInstanceCore.OnAnimNotifyEvent
// 0x0028 (0x0028 - 0x0000)
struct AnimInstanceCore_OnAnimNotifyEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Animation;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimNotify*                      AnimNotify;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimEventTime;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceCore_OnAnimNotifyEvent) == 0x000008, "Wrong alignment on AnimInstanceCore_OnAnimNotifyEvent");
static_assert(sizeof(AnimInstanceCore_OnAnimNotifyEvent) == 0x000028, "Wrong size on AnimInstanceCore_OnAnimNotifyEvent");
static_assert(offsetof(AnimInstanceCore_OnAnimNotifyEvent, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnAnimNotifyEvent::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimNotifyEvent, AnimEventType) == 0x000008, "Member 'AnimInstanceCore_OnAnimNotifyEvent::AnimEventType' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimNotifyEvent, Animation) == 0x000010, "Member 'AnimInstanceCore_OnAnimNotifyEvent::Animation' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimNotifyEvent, AnimNotify) == 0x000018, "Member 'AnimInstanceCore_OnAnimNotifyEvent::AnimNotify' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimNotifyEvent, AnimEventTime) == 0x000020, "Member 'AnimInstanceCore_OnAnimNotifyEvent::AnimEventTime' has a wrong offset!");

// Function man.AnimInstanceCore.OnAnimReplacement
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceCore_OnAnimReplacement final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                ReplacementAnimID;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnAnimReplacement) == 0x000008, "Wrong alignment on AnimInstanceCore_OnAnimReplacement");
static_assert(sizeof(AnimInstanceCore_OnAnimReplacement) == 0x000010, "Wrong size on AnimInstanceCore_OnAnimReplacement");
static_assert(offsetof(AnimInstanceCore_OnAnimReplacement, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnAnimReplacement::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnAnimReplacement, ReplacementAnimID) == 0x000008, "Member 'AnimInstanceCore_OnAnimReplacement::ReplacementAnimID' has a wrong offset!");

// Function man.AnimInstanceCore.OnAnimStartRequest
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceCore_OnAnimStartRequest final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnAnimStartRequest) == 0x000008, "Wrong alignment on AnimInstanceCore_OnAnimStartRequest");
static_assert(sizeof(AnimInstanceCore_OnAnimStartRequest) == 0x000008, "Wrong size on AnimInstanceCore_OnAnimStartRequest");
static_assert(offsetof(AnimInstanceCore_OnAnimStartRequest, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnAnimStartRequest::AnimID' has a wrong offset!");

// Function man.AnimInstanceCore.OnAnimStopRequest
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceCore_OnAnimStopRequest final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnAnimStopRequest) == 0x000008, "Wrong alignment on AnimInstanceCore_OnAnimStopRequest");
static_assert(sizeof(AnimInstanceCore_OnAnimStopRequest) == 0x000008, "Wrong size on AnimInstanceCore_OnAnimStopRequest");
static_assert(offsetof(AnimInstanceCore_OnAnimStopRequest, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnAnimStopRequest::AnimID' has a wrong offset!");

// Function man.AnimInstanceCore.OnClothEvent
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceCore_OnClothEvent final
{
public:
	float                                         TargetBlendWeight;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnClothEvent) == 0x000004, "Wrong alignment on AnimInstanceCore_OnClothEvent");
static_assert(sizeof(AnimInstanceCore_OnClothEvent) == 0x000008, "Wrong size on AnimInstanceCore_OnClothEvent");
static_assert(offsetof(AnimInstanceCore_OnClothEvent, TargetBlendWeight) == 0x000000, "Member 'AnimInstanceCore_OnClothEvent::TargetBlendWeight' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnClothEvent, BlendDuration) == 0x000004, "Member 'AnimInstanceCore_OnClothEvent::BlendDuration' has a wrong offset!");

// Function man.AnimInstanceCore.OnNamedAnimEvent
// 0x0020 (0x0020 - 0x0000)
struct AnimInstanceCore_OnNamedAnimEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimEventTime;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceCore_OnNamedAnimEvent) == 0x000008, "Wrong alignment on AnimInstanceCore_OnNamedAnimEvent");
static_assert(sizeof(AnimInstanceCore_OnNamedAnimEvent) == 0x000020, "Wrong size on AnimInstanceCore_OnNamedAnimEvent");
static_assert(offsetof(AnimInstanceCore_OnNamedAnimEvent, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnNamedAnimEvent::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnNamedAnimEvent, Name_0) == 0x000008, "Member 'AnimInstanceCore_OnNamedAnimEvent::Name_0' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnNamedAnimEvent, Animation) == 0x000010, "Member 'AnimInstanceCore_OnNamedAnimEvent::Animation' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnNamedAnimEvent, AnimEventTime) == 0x000018, "Member 'AnimInstanceCore_OnNamedAnimEvent::AnimEventTime' has a wrong offset!");

// Function man.AnimInstanceCore.OnRagdollEvent
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceCore_OnRagdollEvent final
{
public:
	struct FVector                                ImpulseDirection;                                  // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrength;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnRagdollEvent) == 0x000004, "Wrong alignment on AnimInstanceCore_OnRagdollEvent");
static_assert(sizeof(AnimInstanceCore_OnRagdollEvent) == 0x000010, "Wrong size on AnimInstanceCore_OnRagdollEvent");
static_assert(offsetof(AnimInstanceCore_OnRagdollEvent, ImpulseDirection) == 0x000000, "Member 'AnimInstanceCore_OnRagdollEvent::ImpulseDirection' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnRagdollEvent, ImpulseStrength) == 0x00000C, "Member 'AnimInstanceCore_OnRagdollEvent::ImpulseStrength' has a wrong offset!");

// Function man.AnimInstanceCore.OnTextBubbleEvent
// 0x0020 (0x0020 - 0x0000)
struct AnimInstanceCore_OnTextBubbleEvent final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceCore_OnTextBubbleEvent) == 0x000008, "Wrong alignment on AnimInstanceCore_OnTextBubbleEvent");
static_assert(sizeof(AnimInstanceCore_OnTextBubbleEvent) == 0x000020, "Wrong size on AnimInstanceCore_OnTextBubbleEvent");
static_assert(offsetof(AnimInstanceCore_OnTextBubbleEvent, Text) == 0x000000, "Member 'AnimInstanceCore_OnTextBubbleEvent::Text' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnTextBubbleEvent, Time) == 0x000018, "Member 'AnimInstanceCore_OnTextBubbleEvent::Time' has a wrong offset!");

// Function man.AnimInstanceCore.OnVfxEvent
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceCore_OnVfxEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VfxEventType;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnVfxEvent) == 0x000008, "Wrong alignment on AnimInstanceCore_OnVfxEvent");
static_assert(sizeof(AnimInstanceCore_OnVfxEvent) == 0x000010, "Wrong size on AnimInstanceCore_OnVfxEvent");
static_assert(offsetof(AnimInstanceCore_OnVfxEvent, AnimID) == 0x000000, "Member 'AnimInstanceCore_OnVfxEvent::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnVfxEvent, VfxEventType) == 0x000008, "Member 'AnimInstanceCore_OnVfxEvent::VfxEventType' has a wrong offset!");

// Function man.AnimInstanceCore.OnWalkStartEvent
// 0x000C (0x000C - 0x0000)
struct AnimInstanceCore_OnWalkStartEvent final
{
public:
	float                                         WalkStartOC;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkStartOH;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkStartTH;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceCore_OnWalkStartEvent) == 0x000004, "Wrong alignment on AnimInstanceCore_OnWalkStartEvent");
static_assert(sizeof(AnimInstanceCore_OnWalkStartEvent) == 0x00000C, "Wrong size on AnimInstanceCore_OnWalkStartEvent");
static_assert(offsetof(AnimInstanceCore_OnWalkStartEvent, WalkStartOC) == 0x000000, "Member 'AnimInstanceCore_OnWalkStartEvent::WalkStartOC' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnWalkStartEvent, WalkStartOH) == 0x000004, "Member 'AnimInstanceCore_OnWalkStartEvent::WalkStartOH' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_OnWalkStartEvent, WalkStartTH) == 0x000008, "Member 'AnimInstanceCore_OnWalkStartEvent::WalkStartTH' has a wrong offset!");

// Function man.AnimInstanceCore.ToggleAnim
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceCore_ToggleAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceCore_ToggleAnim) == 0x000008, "Wrong alignment on AnimInstanceCore_ToggleAnim");
static_assert(sizeof(AnimInstanceCore_ToggleAnim) == 0x000010, "Wrong size on AnimInstanceCore_ToggleAnim");
static_assert(offsetof(AnimInstanceCore_ToggleAnim, AnimID) == 0x000000, "Member 'AnimInstanceCore_ToggleAnim::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_ToggleAnim, bStart) == 0x000008, "Member 'AnimInstanceCore_ToggleAnim::bStart' has a wrong offset!");

// Function man.AnimInstanceCore.IsAnimToggled
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceCore_IsAnimToggled final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceCore_IsAnimToggled) == 0x000008, "Wrong alignment on AnimInstanceCore_IsAnimToggled");
static_assert(sizeof(AnimInstanceCore_IsAnimToggled) == 0x000010, "Wrong size on AnimInstanceCore_IsAnimToggled");
static_assert(offsetof(AnimInstanceCore_IsAnimToggled, AnimID) == 0x000000, "Member 'AnimInstanceCore_IsAnimToggled::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceCore_IsAnimToggled, ReturnValue) == 0x000008, "Member 'AnimInstanceCore_IsAnimToggled::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeFootIK
// 0x0058 (0x0058 - 0x0000)
struct AnimInstanceBase_ComputeFootIK final
{
public:
	float                                         TraceStart;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffset;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlopeAngle;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeightUp;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightUp;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeightDown;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightDown;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTranslationLimitUp;                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTranslationLimitDown;                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootRotationLimit;                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootTranslationLimit;                              // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationRatio;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRatio;                                     // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalShearRatio;                                  // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDistanceMin;                                 // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDistanceMax;                                 // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootSlopeTranslationBlendSpeed;                    // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootSlopeRotationBlendSpeed;                       // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_ComputeFootIK) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeFootIK");
static_assert(sizeof(AnimInstanceBase_ComputeFootIK) == 0x000058, "Wrong size on AnimInstanceBase_ComputeFootIK");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, TraceStart) == 0x000000, "Member 'AnimInstanceBase_ComputeFootIK::TraceStart' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, TraceEnd) == 0x000004, "Member 'AnimInstanceBase_ComputeFootIK::TraceEnd' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, TraceOffset) == 0x000008, "Member 'AnimInstanceBase_ComputeFootIK::TraceOffset' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, MinSlopeAngle) == 0x00000C, "Member 'AnimInstanceBase_ComputeFootIK::MinSlopeAngle' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, MinHeightUp) == 0x000010, "Member 'AnimInstanceBase_ComputeFootIK::MinHeightUp' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, MaxHeightUp) == 0x000014, "Member 'AnimInstanceBase_ComputeFootIK::MaxHeightUp' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, MinHeightDown) == 0x000018, "Member 'AnimInstanceBase_ComputeFootIK::MinHeightDown' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, MaxHeightDown) == 0x00001C, "Member 'AnimInstanceBase_ComputeFootIK::MaxHeightDown' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, FootTranslationLimitUp) == 0x000020, "Member 'AnimInstanceBase_ComputeFootIK::FootTranslationLimitUp' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, FootTranslationLimitDown) == 0x000024, "Member 'AnimInstanceBase_ComputeFootIK::FootTranslationLimitDown' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, FootRotationLimit) == 0x000028, "Member 'AnimInstanceBase_ComputeFootIK::FootRotationLimit' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, RootTranslationLimit) == 0x00002C, "Member 'AnimInstanceBase_ComputeFootIK::RootTranslationLimit' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, TranslationRatio) == 0x000030, "Member 'AnimInstanceBase_ComputeFootIK::TranslationRatio' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, RotationRatio) == 0x000034, "Member 'AnimInstanceBase_ComputeFootIK::RotationRatio' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, NormalShearRatio) == 0x000038, "Member 'AnimInstanceBase_ComputeFootIK::NormalShearRatio' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, LerpSpeed) == 0x00003C, "Member 'AnimInstanceBase_ComputeFootIK::LerpSpeed' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, GroundDistanceMin) == 0x000040, "Member 'AnimInstanceBase_ComputeFootIK::GroundDistanceMin' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, GroundDistanceMax) == 0x000044, "Member 'AnimInstanceBase_ComputeFootIK::GroundDistanceMax' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, RootSlopeTranslationBlendSpeed) == 0x000048, "Member 'AnimInstanceBase_ComputeFootIK::RootSlopeTranslationBlendSpeed' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, RootSlopeRotationBlendSpeed) == 0x00004C, "Member 'AnimInstanceBase_ComputeFootIK::RootSlopeRotationBlendSpeed' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, DeltaSeconds) == 0x000050, "Member 'AnimInstanceBase_ComputeFootIK::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeFootIK, DrawDebug) == 0x000054, "Member 'AnimInstanceBase_ComputeFootIK::DrawDebug' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeGearRotation
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_ComputeGearRotation final
{
public:
	float                                         Rotation;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationPerAnimation;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationLength;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ComputeGearRotation) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeGearRotation");
static_assert(sizeof(AnimInstanceBase_ComputeGearRotation) == 0x000018, "Wrong size on AnimInstanceBase_ComputeGearRotation");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, Rotation) == 0x000000, "Member 'AnimInstanceBase_ComputeGearRotation::Rotation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, RotationPerAnimation) == 0x000004, "Member 'AnimInstanceBase_ComputeGearRotation::RotationPerAnimation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, AnimationLength) == 0x000008, "Member 'AnimInstanceBase_ComputeGearRotation::AnimationLength' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, PlayRate) == 0x00000C, "Member 'AnimInstanceBase_ComputeGearRotation::PlayRate' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, DeltaTime) == 0x000010, "Member 'AnimInstanceBase_ComputeGearRotation::DeltaTime' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeGearRotation, ReturnValue) == 0x000014, "Member 'AnimInstanceBase_ComputeGearRotation::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeJumpRatio
// 0x0024 (0x0024 - 0x0000)
struct AnimInstanceBase_ComputeJumpRatio final
{
public:
	float                                         JumpHeight;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDistance;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHeight;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceA;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceB;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceC;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceD;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ComputeJumpRatio) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeJumpRatio");
static_assert(sizeof(AnimInstanceBase_ComputeJumpRatio) == 0x000024, "Wrong size on AnimInstanceBase_ComputeJumpRatio");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, JumpHeight) == 0x000000, "Member 'AnimInstanceBase_ComputeJumpRatio::JumpHeight' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, JumpDistance) == 0x000004, "Member 'AnimInstanceBase_ComputeJumpRatio::JumpDistance' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, MinHeight) == 0x000008, "Member 'AnimInstanceBase_ComputeJumpRatio::MinHeight' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, DistanceA) == 0x00000C, "Member 'AnimInstanceBase_ComputeJumpRatio::DistanceA' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, DistanceB) == 0x000010, "Member 'AnimInstanceBase_ComputeJumpRatio::DistanceB' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, MaxHeight) == 0x000014, "Member 'AnimInstanceBase_ComputeJumpRatio::MaxHeight' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, DistanceC) == 0x000018, "Member 'AnimInstanceBase_ComputeJumpRatio::DistanceC' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, DistanceD) == 0x00001C, "Member 'AnimInstanceBase_ComputeJumpRatio::DistanceD' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeJumpRatio, ReturnValue) == 0x000020, "Member 'AnimInstanceBase_ComputeJumpRatio::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeLookAngle
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_ComputeLookAngle final
{
public:
	bool                                          Looking;                                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAngle;                                         // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAngleMin;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAngleMax;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAngleHoldMin;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAngleHoldMax;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ComputeLookAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeLookAngle");
static_assert(sizeof(AnimInstanceBase_ComputeLookAngle) == 0x000018, "Wrong size on AnimInstanceBase_ComputeLookAngle");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, Looking) == 0x000000, "Member 'AnimInstanceBase_ComputeLookAngle::Looking' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, LookAngle) == 0x000004, "Member 'AnimInstanceBase_ComputeLookAngle::LookAngle' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, LookAngleMin) == 0x000008, "Member 'AnimInstanceBase_ComputeLookAngle::LookAngleMin' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, LookAngleMax) == 0x00000C, "Member 'AnimInstanceBase_ComputeLookAngle::LookAngleMax' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, LookAngleHoldMin) == 0x000010, "Member 'AnimInstanceBase_ComputeLookAngle::LookAngleHoldMin' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeLookAngle, LookAngleHoldMax) == 0x000014, "Member 'AnimInstanceBase_ComputeLookAngle::LookAngleHoldMax' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeRope
// 0x0014 (0x0014 - 0x0000)
struct AnimInstanceBase_ComputeRope final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sag;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_ComputeRope) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeRope");
static_assert(sizeof(AnimInstanceBase_ComputeRope) == 0x000014, "Wrong size on AnimInstanceBase_ComputeRope");
static_assert(offsetof(AnimInstanceBase_ComputeRope, Target) == 0x000000, "Member 'AnimInstanceBase_ComputeRope::Target' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeRope, Sag) == 0x00000C, "Member 'AnimInstanceBase_ComputeRope::Sag' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeRope, DrawDebug) == 0x000010, "Member 'AnimInstanceBase_ComputeRope::DrawDebug' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeSlope
// 0x0020 (0x0020 - 0x0000)
struct AnimInstanceBase_ComputeSlope final
{
public:
	float                                         TraceStart;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlopeAngle;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRatio;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_ComputeSlope) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeSlope");
static_assert(sizeof(AnimInstanceBase_ComputeSlope) == 0x000020, "Wrong size on AnimInstanceBase_ComputeSlope");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, TraceStart) == 0x000000, "Member 'AnimInstanceBase_ComputeSlope::TraceStart' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, TraceEnd) == 0x000004, "Member 'AnimInstanceBase_ComputeSlope::TraceEnd' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, TraceDistance) == 0x000008, "Member 'AnimInstanceBase_ComputeSlope::TraceDistance' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, MinSlopeAngle) == 0x00000C, "Member 'AnimInstanceBase_ComputeSlope::MinSlopeAngle' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, RotationRatio) == 0x000010, "Member 'AnimInstanceBase_ComputeSlope::RotationRatio' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, LerpSpeed) == 0x000014, "Member 'AnimInstanceBase_ComputeSlope::LerpSpeed' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, DeltaSeconds) == 0x000018, "Member 'AnimInstanceBase_ComputeSlope::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSlope, DrawDebug) == 0x00001C, "Member 'AnimInstanceBase_ComputeSlope::DrawDebug' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeSpine
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_ComputeSpine final
{
public:
	float                                         TraceStart;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_ComputeSpine) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeSpine");
static_assert(sizeof(AnimInstanceBase_ComputeSpine) == 0x000018, "Wrong size on AnimInstanceBase_ComputeSpine");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, TraceStart) == 0x000000, "Member 'AnimInstanceBase_ComputeSpine::TraceStart' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, TraceEnd) == 0x000004, "Member 'AnimInstanceBase_ComputeSpine::TraceEnd' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, MinRange) == 0x000008, "Member 'AnimInstanceBase_ComputeSpine::MinRange' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, LerpSpeed) == 0x00000C, "Member 'AnimInstanceBase_ComputeSpine::LerpSpeed' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, DeltaSeconds) == 0x000010, "Member 'AnimInstanceBase_ComputeSpine::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpine, DrawDebug) == 0x000014, "Member 'AnimInstanceBase_ComputeSpine::DrawDebug' has a wrong offset!");

// Function man.AnimInstanceBase.ComputeSpineSlopeBiasAngle
// 0x0020 (0x0020 - 0x0000)
struct AnimInstanceBase_ComputeSpineSlopeBiasAngle final
{
public:
	float                                         TraceStart;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTraceAngle;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpineBoneName;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ComputeSpineSlopeBiasAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_ComputeSpineSlopeBiasAngle");
static_assert(sizeof(AnimInstanceBase_ComputeSpineSlopeBiasAngle) == 0x000020, "Wrong size on AnimInstanceBase_ComputeSpineSlopeBiasAngle");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, TraceStart) == 0x000000, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::TraceStart' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, TraceEnd) == 0x000004, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::TraceEnd' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, TraceDistance) == 0x000008, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::TraceDistance' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, MaxTraceAngle) == 0x00000C, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::MaxTraceAngle' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, BlendDuration) == 0x000010, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::BlendDuration' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, DeltaSeconds) == 0x000014, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ComputeSpineSlopeBiasAngle, SpineBoneName) == 0x000018, "Member 'AnimInstanceBase_ComputeSpineSlopeBiasAngle::SpineBoneName' has a wrong offset!");

// Function man.AnimInstanceBase.EnableLevelSequenceAnimationOverlay
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_EnableLevelSequenceAnimationOverlay final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_EnableLevelSequenceAnimationOverlay) == 0x000001, "Wrong alignment on AnimInstanceBase_EnableLevelSequenceAnimationOverlay");
static_assert(sizeof(AnimInstanceBase_EnableLevelSequenceAnimationOverlay) == 0x000001, "Wrong size on AnimInstanceBase_EnableLevelSequenceAnimationOverlay");
static_assert(offsetof(AnimInstanceBase_EnableLevelSequenceAnimationOverlay, bEnable) == 0x000000, "Member 'AnimInstanceBase_EnableLevelSequenceAnimationOverlay::bEnable' has a wrong offset!");

// Function man.AnimInstanceBase.FitToSlope
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_FitToSlope final
{
public:
	float                                         BlendDuration;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_FitToSlope) == 0x000004, "Wrong alignment on AnimInstanceBase_FitToSlope");
static_assert(sizeof(AnimInstanceBase_FitToSlope) == 0x000004, "Wrong size on AnimInstanceBase_FitToSlope");
static_assert(offsetof(AnimInstanceBase_FitToSlope, BlendDuration) == 0x000000, "Member 'AnimInstanceBase_FitToSlope::BlendDuration' has a wrong offset!");

// Function man.AnimInstanceBase.ForceIdle
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_ForceIdle final
{
public:
	bool                                          bForceIdle;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ForceIdle) == 0x000001, "Wrong alignment on AnimInstanceBase_ForceIdle");
static_assert(sizeof(AnimInstanceBase_ForceIdle) == 0x000001, "Wrong size on AnimInstanceBase_ForceIdle");
static_assert(offsetof(AnimInstanceBase_ForceIdle, bForceIdle) == 0x000000, "Member 'AnimInstanceBase_ForceIdle::bForceIdle' has a wrong offset!");

// Function man.AnimInstanceBase.ForceMirrorRate
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_ForceMirrorRate final
{
public:
	float                                         MirrorRate;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_ForceMirrorRate) == 0x000004, "Wrong alignment on AnimInstanceBase_ForceMirrorRate");
static_assert(sizeof(AnimInstanceBase_ForceMirrorRate) == 0x000008, "Wrong size on AnimInstanceBase_ForceMirrorRate");
static_assert(offsetof(AnimInstanceBase_ForceMirrorRate, MirrorRate) == 0x000000, "Member 'AnimInstanceBase_ForceMirrorRate::MirrorRate' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_ForceMirrorRate, bEnable) == 0x000004, "Member 'AnimInstanceBase_ForceMirrorRate::bEnable' has a wrong offset!");

// Function man.AnimInstanceBase.GetActiveAnimsequences
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_GetActiveAnimsequences final
{
public:
	TArray<class UAnimSequenceBase*>              ActiveAnimSequences;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetActiveAnimsequences) == 0x000008, "Wrong alignment on AnimInstanceBase_GetActiveAnimsequences");
static_assert(sizeof(AnimInstanceBase_GetActiveAnimsequences) == 0x000010, "Wrong size on AnimInstanceBase_GetActiveAnimsequences");
static_assert(offsetof(AnimInstanceBase_GetActiveAnimsequences, ActiveAnimSequences) == 0x000000, "Member 'AnimInstanceBase_GetActiveAnimsequences::ActiveAnimSequences' has a wrong offset!");

// Function man.AnimInstanceBase.GetAnimID
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_GetAnimID final
{
public:
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetAnimID) == 0x000008, "Wrong alignment on AnimInstanceBase_GetAnimID");
static_assert(sizeof(AnimInstanceBase_GetAnimID) == 0x000010, "Wrong size on AnimInstanceBase_GetAnimID");
static_assert(offsetof(AnimInstanceBase_GetAnimID, AnimSequence) == 0x000000, "Member 'AnimInstanceBase_GetAnimID::AnimSequence' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetAnimID, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_GetAnimID::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetAnimLength
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_GetAnimLength final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLength;                                        // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_GetAnimLength) == 0x000008, "Wrong alignment on AnimInstanceBase_GetAnimLength");
static_assert(sizeof(AnimInstanceBase_GetAnimLength) == 0x000010, "Wrong size on AnimInstanceBase_GetAnimLength");
static_assert(offsetof(AnimInstanceBase_GetAnimLength, AnimID) == 0x000000, "Member 'AnimInstanceBase_GetAnimLength::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetAnimLength, AnimLength) == 0x000008, "Member 'AnimInstanceBase_GetAnimLength::AnimLength' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetAnimLength, ReturnValue) == 0x00000C, "Member 'AnimInstanceBase_GetAnimLength::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetMaterialIndex
// 0x000C (0x000C - 0x0000)
struct AnimInstanceBase_GetMaterialIndex final
{
public:
	class FName                                   MaterialName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetMaterialIndex) == 0x000004, "Wrong alignment on AnimInstanceBase_GetMaterialIndex");
static_assert(sizeof(AnimInstanceBase_GetMaterialIndex) == 0x00000C, "Wrong size on AnimInstanceBase_GetMaterialIndex");
static_assert(offsetof(AnimInstanceBase_GetMaterialIndex, MaterialName) == 0x000000, "Member 'AnimInstanceBase_GetMaterialIndex::MaterialName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetMaterialIndex, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_GetMaterialIndex::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetParallaxDisplacement
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_GetParallaxDisplacement final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetParallaxDisplacement) == 0x000004, "Wrong alignment on AnimInstanceBase_GetParallaxDisplacement");
static_assert(sizeof(AnimInstanceBase_GetParallaxDisplacement) == 0x000018, "Wrong size on AnimInstanceBase_GetParallaxDisplacement");
static_assert(offsetof(AnimInstanceBase_GetParallaxDisplacement, SocketName) == 0x000000, "Member 'AnimInstanceBase_GetParallaxDisplacement::SocketName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetParallaxDisplacement, Offset) == 0x000008, "Member 'AnimInstanceBase_GetParallaxDisplacement::Offset' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetParallaxDisplacement, ReturnValue) == 0x00000C, "Member 'AnimInstanceBase_GetParallaxDisplacement::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetProgressAnimLength
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetProgressAnimLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetProgressAnimLength) == 0x000004, "Wrong alignment on AnimInstanceBase_GetProgressAnimLength");
static_assert(sizeof(AnimInstanceBase_GetProgressAnimLength) == 0x000004, "Wrong size on AnimInstanceBase_GetProgressAnimLength");
static_assert(offsetof(AnimInstanceBase_GetProgressAnimLength, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetProgressAnimLength::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetRootTransform
// 0x0040 (0x0040 - 0x0000)
struct AnimInstanceBase_GetRootTransform final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransformBySlope;                                 // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_GetRootTransform) == 0x000010, "Wrong alignment on AnimInstanceBase_GetRootTransform");
static_assert(sizeof(AnimInstanceBase_GetRootTransform) == 0x000040, "Wrong size on AnimInstanceBase_GetRootTransform");
static_assert(offsetof(AnimInstanceBase_GetRootTransform, Transform) == 0x000000, "Member 'AnimInstanceBase_GetRootTransform::Transform' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRootTransform, AnimSequence) == 0x000030, "Member 'AnimInstanceBase_GetRootTransform::AnimSequence' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRootTransform, AnimTime) == 0x000038, "Member 'AnimInstanceBase_GetRootTransform::AnimTime' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRootTransform, bTransformBySlope) == 0x00003C, "Member 'AnimInstanceBase_GetRootTransform::bTransformBySlope' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRootTransform, ReturnValue) == 0x00003D, "Member 'AnimInstanceBase_GetRootTransform::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetSocketTransform
// 0x0050 (0x0050 - 0x0000)
struct AnimInstanceBase_GetSocketTransform final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransformBySlope;                                 // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0045(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0xA];                                       // 0x0046(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_GetSocketTransform) == 0x000010, "Wrong alignment on AnimInstanceBase_GetSocketTransform");
static_assert(sizeof(AnimInstanceBase_GetSocketTransform) == 0x000050, "Wrong size on AnimInstanceBase_GetSocketTransform");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, Transform) == 0x000000, "Member 'AnimInstanceBase_GetSocketTransform::Transform' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, SocketName) == 0x000030, "Member 'AnimInstanceBase_GetSocketTransform::SocketName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, AnimSequence) == 0x000038, "Member 'AnimInstanceBase_GetSocketTransform::AnimSequence' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, AnimTime) == 0x000040, "Member 'AnimInstanceBase_GetSocketTransform::AnimTime' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, bTransformBySlope) == 0x000044, "Member 'AnimInstanceBase_GetSocketTransform::bTransformBySlope' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSocketTransform, ReturnValue) == 0x000045, "Member 'AnimInstanceBase_GetSocketTransform::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetTwinBoneTransform
// 0x0040 (0x0040 - 0x0000)
struct AnimInstanceBase_GetTwinBoneTransform final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetTwinBoneTransform) == 0x000010, "Wrong alignment on AnimInstanceBase_GetTwinBoneTransform");
static_assert(sizeof(AnimInstanceBase_GetTwinBoneTransform) == 0x000040, "Wrong size on AnimInstanceBase_GetTwinBoneTransform");
static_assert(offsetof(AnimInstanceBase_GetTwinBoneTransform, BoneName) == 0x000000, "Member 'AnimInstanceBase_GetTwinBoneTransform::BoneName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetTwinBoneTransform, ReturnValue) == 0x000010, "Member 'AnimInstanceBase_GetTwinBoneTransform::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.HideBodyPart
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_HideBodyPart final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_HideBodyPart) == 0x000004, "Wrong alignment on AnimInstanceBase_HideBodyPart");
static_assert(sizeof(AnimInstanceBase_HideBodyPart) == 0x000008, "Wrong size on AnimInstanceBase_HideBodyPart");
static_assert(offsetof(AnimInstanceBase_HideBodyPart, BoneName) == 0x000000, "Member 'AnimInstanceBase_HideBodyPart::BoneName' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimEventForceTurnEnd
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_OnAnimEventForceTurnEnd final
{
public:
	EAnimTurnType                                 TurnType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimEventForceTurnEnd) == 0x000001, "Wrong alignment on AnimInstanceBase_OnAnimEventForceTurnEnd");
static_assert(sizeof(AnimInstanceBase_OnAnimEventForceTurnEnd) == 0x000001, "Wrong size on AnimInstanceBase_OnAnimEventForceTurnEnd");
static_assert(offsetof(AnimInstanceBase_OnAnimEventForceTurnEnd, TurnType) == 0x000000, "Member 'AnimInstanceBase_OnAnimEventForceTurnEnd::TurnType' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimEventForceTurnStart
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_OnAnimEventForceTurnStart final
{
public:
	EAnimTurnType                                 TurnType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnDuration;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimEventForceTurnStart) == 0x000004, "Wrong alignment on AnimInstanceBase_OnAnimEventForceTurnStart");
static_assert(sizeof(AnimInstanceBase_OnAnimEventForceTurnStart) == 0x000008, "Wrong size on AnimInstanceBase_OnAnimEventForceTurnStart");
static_assert(offsetof(AnimInstanceBase_OnAnimEventForceTurnStart, TurnType) == 0x000000, "Member 'AnimInstanceBase_OnAnimEventForceTurnStart::TurnType' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimEventForceTurnStart, TurnDuration) == 0x000004, "Member 'AnimInstanceBase_OnAnimEventForceTurnStart::TurnDuration' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimEventReceived
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_OnAnimEventReceived final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      InAnimation;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimEventReceived) == 0x000008, "Wrong alignment on AnimInstanceBase_OnAnimEventReceived");
static_assert(sizeof(AnimInstanceBase_OnAnimEventReceived) == 0x000018, "Wrong size on AnimInstanceBase_OnAnimEventReceived");
static_assert(offsetof(AnimInstanceBase_OnAnimEventReceived, AnimID) == 0x000000, "Member 'AnimInstanceBase_OnAnimEventReceived::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimEventReceived, AnimEventType) == 0x000008, "Member 'AnimInstanceBase_OnAnimEventReceived::AnimEventType' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimEventReceived, InAnimation) == 0x000010, "Member 'AnimInstanceBase_OnAnimEventReceived::InAnimation' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimStateBegin
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_OnAnimStateBegin final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimNotifyStateType                          AnimStateType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      InAnimation;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimStateBegin) == 0x000008, "Wrong alignment on AnimInstanceBase_OnAnimStateBegin");
static_assert(sizeof(AnimInstanceBase_OnAnimStateBegin) == 0x000018, "Wrong size on AnimInstanceBase_OnAnimStateBegin");
static_assert(offsetof(AnimInstanceBase_OnAnimStateBegin, AnimID) == 0x000000, "Member 'AnimInstanceBase_OnAnimStateBegin::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateBegin, AnimStateType) == 0x000008, "Member 'AnimInstanceBase_OnAnimStateBegin::AnimStateType' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateBegin, InAnimation) == 0x000010, "Member 'AnimInstanceBase_OnAnimStateBegin::InAnimation' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimStateEnd
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_OnAnimStateEnd final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimNotifyStateType                          AnimStateType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      InAnimation;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimStateEnd) == 0x000008, "Wrong alignment on AnimInstanceBase_OnAnimStateEnd");
static_assert(sizeof(AnimInstanceBase_OnAnimStateEnd) == 0x000018, "Wrong size on AnimInstanceBase_OnAnimStateEnd");
static_assert(offsetof(AnimInstanceBase_OnAnimStateEnd, AnimID) == 0x000000, "Member 'AnimInstanceBase_OnAnimStateEnd::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateEnd, AnimStateType) == 0x000008, "Member 'AnimInstanceBase_OnAnimStateEnd::AnimStateType' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateEnd, InAnimation) == 0x000010, "Member 'AnimInstanceBase_OnAnimStateEnd::InAnimation' has a wrong offset!");

// Function man.AnimInstanceBase.OnAnimStateTick
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_OnAnimStateTick final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimNotifyStateType                          AnimStateType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      InAnimation;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnAnimStateTick) == 0x000008, "Wrong alignment on AnimInstanceBase_OnAnimStateTick");
static_assert(sizeof(AnimInstanceBase_OnAnimStateTick) == 0x000018, "Wrong size on AnimInstanceBase_OnAnimStateTick");
static_assert(offsetof(AnimInstanceBase_OnAnimStateTick, AnimID) == 0x000000, "Member 'AnimInstanceBase_OnAnimStateTick::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateTick, AnimStateType) == 0x000008, "Member 'AnimInstanceBase_OnAnimStateTick::AnimStateType' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_OnAnimStateTick, InAnimation) == 0x000010, "Member 'AnimInstanceBase_OnAnimStateTick::InAnimation' has a wrong offset!");

// Function man.AnimInstanceBase.OnFacingChanged
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_OnFacingChanged final
{
public:
	bool                                          bForced;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_OnFacingChanged) == 0x000001, "Wrong alignment on AnimInstanceBase_OnFacingChanged");
static_assert(sizeof(AnimInstanceBase_OnFacingChanged) == 0x000001, "Wrong size on AnimInstanceBase_OnFacingChanged");
static_assert(offsetof(AnimInstanceBase_OnFacingChanged, bForced) == 0x000000, "Member 'AnimInstanceBase_OnFacingChanged::bForced' has a wrong offset!");

// Function man.AnimInstanceBase.ResetMotionBlurStrength
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_ResetMotionBlurStrength final
{
public:
	float                                         BlendDuration;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ResetMotionBlurStrength) == 0x000004, "Wrong alignment on AnimInstanceBase_ResetMotionBlurStrength");
static_assert(sizeof(AnimInstanceBase_ResetMotionBlurStrength) == 0x000004, "Wrong size on AnimInstanceBase_ResetMotionBlurStrength");
static_assert(offsetof(AnimInstanceBase_ResetMotionBlurStrength, BlendDuration) == 0x000000, "Member 'AnimInstanceBase_ResetMotionBlurStrength::BlendDuration' has a wrong offset!");

// Function man.AnimInstanceBase.SendAnimNotifyEvent
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_SendAnimNotifyEvent final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_SendAnimNotifyEvent) == 0x000008, "Wrong alignment on AnimInstanceBase_SendAnimNotifyEvent");
static_assert(sizeof(AnimInstanceBase_SendAnimNotifyEvent) == 0x000010, "Wrong size on AnimInstanceBase_SendAnimNotifyEvent");
static_assert(offsetof(AnimInstanceBase_SendAnimNotifyEvent, AnimID) == 0x000000, "Member 'AnimInstanceBase_SendAnimNotifyEvent::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SendAnimNotifyEvent, AnimEventType) == 0x000008, "Member 'AnimInstanceBase_SendAnimNotifyEvent::AnimEventType' has a wrong offset!");

// Function man.AnimInstanceBase.SetDefaultAnimation
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_SetDefaultAnimation final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetDefaultAnimation) == 0x000008, "Wrong alignment on AnimInstanceBase_SetDefaultAnimation");
static_assert(sizeof(AnimInstanceBase_SetDefaultAnimation) == 0x000008, "Wrong size on AnimInstanceBase_SetDefaultAnimation");
static_assert(offsetof(AnimInstanceBase_SetDefaultAnimation, AnimID) == 0x000000, "Member 'AnimInstanceBase_SetDefaultAnimation::AnimID' has a wrong offset!");

// Function man.AnimInstanceBase.SetFlipFacingAnim
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_SetFlipFacingAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetFlipFacingAnim) == 0x000008, "Wrong alignment on AnimInstanceBase_SetFlipFacingAnim");
static_assert(sizeof(AnimInstanceBase_SetFlipFacingAnim) == 0x000010, "Wrong size on AnimInstanceBase_SetFlipFacingAnim");
static_assert(offsetof(AnimInstanceBase_SetFlipFacingAnim, AnimID) == 0x000000, "Member 'AnimInstanceBase_SetFlipFacingAnim::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SetFlipFacingAnim, AnimSequence) == 0x000008, "Member 'AnimInstanceBase_SetFlipFacingAnim::AnimSequence' has a wrong offset!");

// Function man.AnimInstanceBase.SetHidden
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_SetHidden final
{
public:
	bool                                          bHidden;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetHidden) == 0x000001, "Wrong alignment on AnimInstanceBase_SetHidden");
static_assert(sizeof(AnimInstanceBase_SetHidden) == 0x000001, "Wrong size on AnimInstanceBase_SetHidden");
static_assert(offsetof(AnimInstanceBase_SetHidden, bHidden) == 0x000000, "Member 'AnimInstanceBase_SetHidden::bHidden' has a wrong offset!");

// Function man.AnimInstanceBase.SetLevelSequenceCombatMode
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_SetLevelSequenceCombatMode final
{
public:
	bool                                          bCombatMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetLevelSequenceCombatMode) == 0x000001, "Wrong alignment on AnimInstanceBase_SetLevelSequenceCombatMode");
static_assert(sizeof(AnimInstanceBase_SetLevelSequenceCombatMode) == 0x000001, "Wrong size on AnimInstanceBase_SetLevelSequenceCombatMode");
static_assert(offsetof(AnimInstanceBase_SetLevelSequenceCombatMode, bCombatMode) == 0x000000, "Member 'AnimInstanceBase_SetLevelSequenceCombatMode::bCombatMode' has a wrong offset!");

// Function man.AnimInstanceBase.SetLevelSequenceConversationAnimID
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_SetLevelSequenceConversationAnimID final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong alignment on AnimInstanceBase_SetLevelSequenceConversationAnimID");
static_assert(sizeof(AnimInstanceBase_SetLevelSequenceConversationAnimID) == 0x000008, "Wrong size on AnimInstanceBase_SetLevelSequenceConversationAnimID");
static_assert(offsetof(AnimInstanceBase_SetLevelSequenceConversationAnimID, AnimID) == 0x000000, "Member 'AnimInstanceBase_SetLevelSequenceConversationAnimID::AnimID' has a wrong offset!");

// Function man.AnimInstanceBase.SetLevelSequenceMirrored
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_SetLevelSequenceMirrored final
{
public:
	bool                                          bMirrored;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetLevelSequenceMirrored) == 0x000001, "Wrong alignment on AnimInstanceBase_SetLevelSequenceMirrored");
static_assert(sizeof(AnimInstanceBase_SetLevelSequenceMirrored) == 0x000001, "Wrong size on AnimInstanceBase_SetLevelSequenceMirrored");
static_assert(offsetof(AnimInstanceBase_SetLevelSequenceMirrored, bMirrored) == 0x000000, "Member 'AnimInstanceBase_SetLevelSequenceMirrored::bMirrored' has a wrong offset!");

// Function man.AnimInstanceBase.SetLevelSequenceMirrorRate
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_SetLevelSequenceMirrorRate final
{
public:
	float                                         MirrorRate;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetLevelSequenceMirrorRate) == 0x000004, "Wrong alignment on AnimInstanceBase_SetLevelSequenceMirrorRate");
static_assert(sizeof(AnimInstanceBase_SetLevelSequenceMirrorRate) == 0x000004, "Wrong size on AnimInstanceBase_SetLevelSequenceMirrorRate");
static_assert(offsetof(AnimInstanceBase_SetLevelSequenceMirrorRate, MirrorRate) == 0x000000, "Member 'AnimInstanceBase_SetLevelSequenceMirrorRate::MirrorRate' has a wrong offset!");

// Function man.AnimInstanceBase.SetMotionBlurStrength
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_SetMotionBlurStrength final
{
public:
	float                                         MotionBlurAmount;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_SetMotionBlurStrength) == 0x000004, "Wrong alignment on AnimInstanceBase_SetMotionBlurStrength");
static_assert(sizeof(AnimInstanceBase_SetMotionBlurStrength) == 0x000008, "Wrong size on AnimInstanceBase_SetMotionBlurStrength");
static_assert(offsetof(AnimInstanceBase_SetMotionBlurStrength, MotionBlurAmount) == 0x000000, "Member 'AnimInstanceBase_SetMotionBlurStrength::MotionBlurAmount' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SetMotionBlurStrength, BlendDuration) == 0x000004, "Member 'AnimInstanceBase_SetMotionBlurStrength::BlendDuration' has a wrong offset!");

// Function man.AnimInstanceBase.SetProgress
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_SetProgress final
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Teleport;                                          // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Mirrored;                                          // 0x0006(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_SetProgress) == 0x000004, "Wrong alignment on AnimInstanceBase_SetProgress");
static_assert(sizeof(AnimInstanceBase_SetProgress) == 0x000008, "Wrong size on AnimInstanceBase_SetProgress");
static_assert(offsetof(AnimInstanceBase_SetProgress, Progress) == 0x000000, "Member 'AnimInstanceBase_SetProgress::Progress' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SetProgress, Loop) == 0x000004, "Member 'AnimInstanceBase_SetProgress::Loop' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SetProgress, Teleport) == 0x000005, "Member 'AnimInstanceBase_SetProgress::Teleport' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_SetProgress, Mirrored) == 0x000006, "Member 'AnimInstanceBase_SetProgress::Mirrored' has a wrong offset!");

// Function man.AnimInstanceBase.StartBodypartPhysics
// 0x0020 (0x0020 - 0x0000)
struct AnimInstanceBase_StartBodypartPhysics final
{
public:
	class FName                                   ConstraintName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpulseDirection;                                  // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrength;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_StartBodypartPhysics) == 0x000004, "Wrong alignment on AnimInstanceBase_StartBodypartPhysics");
static_assert(sizeof(AnimInstanceBase_StartBodypartPhysics) == 0x000020, "Wrong size on AnimInstanceBase_StartBodypartPhysics");
static_assert(offsetof(AnimInstanceBase_StartBodypartPhysics, ConstraintName) == 0x000000, "Member 'AnimInstanceBase_StartBodypartPhysics::ConstraintName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_StartBodypartPhysics, BoneName) == 0x000008, "Member 'AnimInstanceBase_StartBodypartPhysics::BoneName' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_StartBodypartPhysics, ImpulseDirection) == 0x000010, "Member 'AnimInstanceBase_StartBodypartPhysics::ImpulseDirection' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_StartBodypartPhysics, ImpulseStrength) == 0x00001C, "Member 'AnimInstanceBase_StartBodypartPhysics::ImpulseStrength' has a wrong offset!");

// Function man.AnimInstanceBase.StopBodypartAnimation
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_StopBodypartAnimation final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_StopBodypartAnimation) == 0x000004, "Wrong alignment on AnimInstanceBase_StopBodypartAnimation");
static_assert(sizeof(AnimInstanceBase_StopBodypartAnimation) == 0x000008, "Wrong size on AnimInstanceBase_StopBodypartAnimation");
static_assert(offsetof(AnimInstanceBase_StopBodypartAnimation, BoneName) == 0x000000, "Member 'AnimInstanceBase_StopBodypartAnimation::BoneName' has a wrong offset!");

// Function man.AnimInstanceBase.ToggleLevelSequence
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_ToggleLevelSequence final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_ToggleLevelSequence) == 0x000001, "Wrong alignment on AnimInstanceBase_ToggleLevelSequence");
static_assert(sizeof(AnimInstanceBase_ToggleLevelSequence) == 0x000001, "Wrong size on AnimInstanceBase_ToggleLevelSequence");
static_assert(offsetof(AnimInstanceBase_ToggleLevelSequence, bStart) == 0x000000, "Member 'AnimInstanceBase_ToggleLevelSequence::bStart' has a wrong offset!");

// Function man.AnimInstanceBase.UpdateActorRotationByFacing
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_UpdateActorRotationByFacing final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_UpdateActorRotationByFacing) == 0x000001, "Wrong alignment on AnimInstanceBase_UpdateActorRotationByFacing");
static_assert(sizeof(AnimInstanceBase_UpdateActorRotationByFacing) == 0x000001, "Wrong size on AnimInstanceBase_UpdateActorRotationByFacing");
static_assert(offsetof(AnimInstanceBase_UpdateActorRotationByFacing, bEnable) == 0x000000, "Member 'AnimInstanceBase_UpdateActorRotationByFacing::bEnable' has a wrong offset!");

// Function man.AnimInstanceBase.DumpAnimReplacements
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_DumpAnimReplacements final
{
public:
	TArray<class FString>                         AnimReplacementNames;                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_DumpAnimReplacements) == 0x000008, "Wrong alignment on AnimInstanceBase_DumpAnimReplacements");
static_assert(sizeof(AnimInstanceBase_DumpAnimReplacements) == 0x000010, "Wrong size on AnimInstanceBase_DumpAnimReplacements");
static_assert(offsetof(AnimInstanceBase_DumpAnimReplacements, AnimReplacementNames) == 0x000000, "Member 'AnimInstanceBase_DumpAnimReplacements::AnimReplacementNames' has a wrong offset!");

// Function man.AnimInstanceBase.DumpToggledAnims
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_DumpToggledAnims final
{
public:
	TArray<class FString>                         ToggledAnimNames;                                  // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_DumpToggledAnims) == 0x000008, "Wrong alignment on AnimInstanceBase_DumpToggledAnims");
static_assert(sizeof(AnimInstanceBase_DumpToggledAnims) == 0x000010, "Wrong size on AnimInstanceBase_DumpToggledAnims");
static_assert(offsetof(AnimInstanceBase_DumpToggledAnims, ToggledAnimNames) == 0x000000, "Member 'AnimInstanceBase_DumpToggledAnims::ToggledAnimNames' has a wrong offset!");

// Function man.AnimInstanceBase.GetFacing
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetFacing final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetFacing) == 0x000004, "Wrong alignment on AnimInstanceBase_GetFacing");
static_assert(sizeof(AnimInstanceBase_GetFacing) == 0x000004, "Wrong size on AnimInstanceBase_GetFacing");
static_assert(offsetof(AnimInstanceBase_GetFacing, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetFacing::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetFacingTargetAngle
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetFacingTargetAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetFacingTargetAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_GetFacingTargetAngle");
static_assert(sizeof(AnimInstanceBase_GetFacingTargetAngle) == 0x000004, "Wrong size on AnimInstanceBase_GetFacingTargetAngle");
static_assert(offsetof(AnimInstanceBase_GetFacingTargetAngle, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetFacingTargetAngle::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetGroundDistance
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetGroundDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetGroundDistance) == 0x000004, "Wrong alignment on AnimInstanceBase_GetGroundDistance");
static_assert(sizeof(AnimInstanceBase_GetGroundDistance) == 0x000004, "Wrong size on AnimInstanceBase_GetGroundDistance");
static_assert(offsetof(AnimInstanceBase_GetGroundDistance, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetGroundDistance::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetHeroCharacter
// 0x0008 (0x0008 - 0x0000)
struct AnimInstanceBase_GetHeroCharacter final
{
public:
	class ACharacterBase*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetHeroCharacter) == 0x000008, "Wrong alignment on AnimInstanceBase_GetHeroCharacter");
static_assert(sizeof(AnimInstanceBase_GetHeroCharacter) == 0x000008, "Wrong size on AnimInstanceBase_GetHeroCharacter");
static_assert(offsetof(AnimInstanceBase_GetHeroCharacter, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetHeroCharacter::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetHeroDistance
// 0x000C (0x000C - 0x0000)
struct AnimInstanceBase_GetHeroDistance final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetHeroDistance) == 0x000004, "Wrong alignment on AnimInstanceBase_GetHeroDistance");
static_assert(sizeof(AnimInstanceBase_GetHeroDistance) == 0x00000C, "Wrong size on AnimInstanceBase_GetHeroDistance");
static_assert(offsetof(AnimInstanceBase_GetHeroDistance, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetHeroDistance::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetHeroLookAngle
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetHeroLookAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetHeroLookAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_GetHeroLookAngle");
static_assert(sizeof(AnimInstanceBase_GetHeroLookAngle) == 0x000004, "Wrong size on AnimInstanceBase_GetHeroLookAngle");
static_assert(offsetof(AnimInstanceBase_GetHeroLookAngle, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetHeroLookAngle::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetJumpDistance
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetJumpDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetJumpDistance) == 0x000004, "Wrong alignment on AnimInstanceBase_GetJumpDistance");
static_assert(sizeof(AnimInstanceBase_GetJumpDistance) == 0x000004, "Wrong size on AnimInstanceBase_GetJumpDistance");
static_assert(offsetof(AnimInstanceBase_GetJumpDistance, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetJumpDistance::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetJumpHeight
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetJumpHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetJumpHeight) == 0x000004, "Wrong alignment on AnimInstanceBase_GetJumpHeight");
static_assert(sizeof(AnimInstanceBase_GetJumpHeight) == 0x000004, "Wrong size on AnimInstanceBase_GetJumpHeight");
static_assert(offsetof(AnimInstanceBase_GetJumpHeight, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetJumpHeight::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetRandomAnimIndex
// 0x000C (0x000C - 0x0000)
struct AnimInstanceBase_GetRandomAnimIndex final
{
public:
	int32                                         CurrentIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIndex;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetRandomAnimIndex) == 0x000004, "Wrong alignment on AnimInstanceBase_GetRandomAnimIndex");
static_assert(sizeof(AnimInstanceBase_GetRandomAnimIndex) == 0x00000C, "Wrong size on AnimInstanceBase_GetRandomAnimIndex");
static_assert(offsetof(AnimInstanceBase_GetRandomAnimIndex, CurrentIndex) == 0x000000, "Member 'AnimInstanceBase_GetRandomAnimIndex::CurrentIndex' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRandomAnimIndex, MaxIndex) == 0x000004, "Member 'AnimInstanceBase_GetRandomAnimIndex::MaxIndex' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRandomAnimIndex, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_GetRandomAnimIndex::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetRotatorDeltaAngle
// 0x001C (0x001C - 0x0000)
struct AnimInstanceBase_GetRotatorDeltaAngle final
{
public:
	struct FRotator                               PrevRotation;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetRotatorDeltaAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_GetRotatorDeltaAngle");
static_assert(sizeof(AnimInstanceBase_GetRotatorDeltaAngle) == 0x00001C, "Wrong size on AnimInstanceBase_GetRotatorDeltaAngle");
static_assert(offsetof(AnimInstanceBase_GetRotatorDeltaAngle, PrevRotation) == 0x000000, "Member 'AnimInstanceBase_GetRotatorDeltaAngle::PrevRotation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRotatorDeltaAngle, Rotation) == 0x00000C, "Member 'AnimInstanceBase_GetRotatorDeltaAngle::Rotation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetRotatorDeltaAngle, ReturnValue) == 0x000018, "Member 'AnimInstanceBase_GetRotatorDeltaAngle::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetSmoothValue
// 0x000C (0x000C - 0x0000)
struct AnimInstanceBase_GetSmoothValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetSmoothValue) == 0x000004, "Wrong alignment on AnimInstanceBase_GetSmoothValue");
static_assert(sizeof(AnimInstanceBase_GetSmoothValue) == 0x00000C, "Wrong size on AnimInstanceBase_GetSmoothValue");
static_assert(offsetof(AnimInstanceBase_GetSmoothValue, Value) == 0x000000, "Member 'AnimInstanceBase_GetSmoothValue::Value' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSmoothValue, Range) == 0x000004, "Member 'AnimInstanceBase_GetSmoothValue::Range' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetSmoothValue, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_GetSmoothValue::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetTrackIndex
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_GetTrackIndex final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRawData;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_GetTrackIndex) == 0x000008, "Wrong alignment on AnimInstanceBase_GetTrackIndex");
static_assert(sizeof(AnimInstanceBase_GetTrackIndex) == 0x000018, "Wrong size on AnimInstanceBase_GetTrackIndex");
static_assert(offsetof(AnimInstanceBase_GetTrackIndex, AnimSequence) == 0x000000, "Member 'AnimInstanceBase_GetTrackIndex::AnimSequence' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetTrackIndex, BoneIndex) == 0x000008, "Member 'AnimInstanceBase_GetTrackIndex::BoneIndex' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetTrackIndex, UseRawData) == 0x00000C, "Member 'AnimInstanceBase_GetTrackIndex::UseRawData' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_GetTrackIndex, ReturnValue) == 0x000010, "Member 'AnimInstanceBase_GetTrackIndex::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetTurnAngle
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetTurnAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetTurnAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_GetTurnAngle");
static_assert(sizeof(AnimInstanceBase_GetTurnAngle) == 0x000004, "Wrong size on AnimInstanceBase_GetTurnAngle");
static_assert(offsetof(AnimInstanceBase_GetTurnAngle, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetTurnAngle::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.GetTurnTargetAngle
// 0x0004 (0x0004 - 0x0000)
struct AnimInstanceBase_GetTurnTargetAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_GetTurnTargetAngle) == 0x000004, "Wrong alignment on AnimInstanceBase_GetTurnTargetAngle");
static_assert(sizeof(AnimInstanceBase_GetTurnTargetAngle) == 0x000004, "Wrong size on AnimInstanceBase_GetTurnTargetAngle");
static_assert(offsetof(AnimInstanceBase_GetTurnTargetAngle, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_GetTurnTargetAngle::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.HasAnim
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_HasAnim final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_HasAnim) == 0x000008, "Wrong alignment on AnimInstanceBase_HasAnim");
static_assert(sizeof(AnimInstanceBase_HasAnim) == 0x000010, "Wrong size on AnimInstanceBase_HasAnim");
static_assert(offsetof(AnimInstanceBase_HasAnim, AnimID) == 0x000000, "Member 'AnimInstanceBase_HasAnim::AnimID' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_HasAnim, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_HasAnim::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsActorHiddenInGame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsActorHiddenInGame) == 0x000001, "Wrong alignment on AnimInstanceBase_IsActorHiddenInGame");
static_assert(sizeof(AnimInstanceBase_IsActorHiddenInGame) == 0x000001, "Wrong size on AnimInstanceBase_IsActorHiddenInGame");
static_assert(offsetof(AnimInstanceBase_IsActorHiddenInGame, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsActorHiddenInGame::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsAnimSequenceMirrored
// 0x0010 (0x0010 - 0x0000)
struct AnimInstanceBase_IsAnimSequenceMirrored final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_IsAnimSequenceMirrored) == 0x000008, "Wrong alignment on AnimInstanceBase_IsAnimSequenceMirrored");
static_assert(sizeof(AnimInstanceBase_IsAnimSequenceMirrored) == 0x000010, "Wrong size on AnimInstanceBase_IsAnimSequenceMirrored");
static_assert(offsetof(AnimInstanceBase_IsAnimSequenceMirrored, AnimSequence) == 0x000000, "Member 'AnimInstanceBase_IsAnimSequenceMirrored::AnimSequence' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_IsAnimSequenceMirrored, ReturnValue) == 0x000008, "Member 'AnimInstanceBase_IsAnimSequenceMirrored::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsAnyAnimToggled
// 0x0018 (0x0018 - 0x0000)
struct AnimInstanceBase_IsAnyAnimToggled final
{
public:
	TArray<class UAnimID*>                        AnimIDs;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_IsAnyAnimToggled) == 0x000008, "Wrong alignment on AnimInstanceBase_IsAnyAnimToggled");
static_assert(sizeof(AnimInstanceBase_IsAnyAnimToggled) == 0x000018, "Wrong size on AnimInstanceBase_IsAnyAnimToggled");
static_assert(offsetof(AnimInstanceBase_IsAnyAnimToggled, AnimIDs) == 0x000000, "Member 'AnimInstanceBase_IsAnyAnimToggled::AnimIDs' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_IsAnyAnimToggled, ReturnValue) == 0x000010, "Member 'AnimInstanceBase_IsAnyAnimToggled::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsLevelSequenceCombatMode
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsLevelSequenceCombatMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsLevelSequenceCombatMode) == 0x000001, "Wrong alignment on AnimInstanceBase_IsLevelSequenceCombatMode");
static_assert(sizeof(AnimInstanceBase_IsLevelSequenceCombatMode) == 0x000001, "Wrong size on AnimInstanceBase_IsLevelSequenceCombatMode");
static_assert(offsetof(AnimInstanceBase_IsLevelSequenceCombatMode, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsLevelSequenceCombatMode::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsLevelSequenceMirrored
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsLevelSequenceMirrored final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsLevelSequenceMirrored) == 0x000001, "Wrong alignment on AnimInstanceBase_IsLevelSequenceMirrored");
static_assert(sizeof(AnimInstanceBase_IsLevelSequenceMirrored) == 0x000001, "Wrong size on AnimInstanceBase_IsLevelSequenceMirrored");
static_assert(offsetof(AnimInstanceBase_IsLevelSequenceMirrored, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsLevelSequenceMirrored::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsLevelSequencePlaying
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsLevelSequencePlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsLevelSequencePlaying) == 0x000001, "Wrong alignment on AnimInstanceBase_IsLevelSequencePlaying");
static_assert(sizeof(AnimInstanceBase_IsLevelSequencePlaying) == 0x000001, "Wrong size on AnimInstanceBase_IsLevelSequencePlaying");
static_assert(offsetof(AnimInstanceBase_IsLevelSequencePlaying, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsLevelSequencePlaying::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsTurnedInside
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsTurnedInside final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsTurnedInside) == 0x000001, "Wrong alignment on AnimInstanceBase_IsTurnedInside");
static_assert(sizeof(AnimInstanceBase_IsTurnedInside) == 0x000001, "Wrong size on AnimInstanceBase_IsTurnedInside");
static_assert(offsetof(AnimInstanceBase_IsTurnedInside, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsTurnedInside::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.IsTurning
// 0x0001 (0x0001 - 0x0000)
struct AnimInstanceBase_IsTurning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstanceBase_IsTurning) == 0x000001, "Wrong alignment on AnimInstanceBase_IsTurning");
static_assert(sizeof(AnimInstanceBase_IsTurning) == 0x000001, "Wrong size on AnimInstanceBase_IsTurning");
static_assert(offsetof(AnimInstanceBase_IsTurning, ReturnValue) == 0x000000, "Member 'AnimInstanceBase_IsTurning::ReturnValue' has a wrong offset!");

// Function man.AnimInstanceBase.TraceGround
// 0x0038 (0x0038 - 0x0000)
struct AnimInstanceBase_TraceGround final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceLocation;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceStart;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstanceBase_TraceGround) == 0x000008, "Wrong alignment on AnimInstanceBase_TraceGround");
static_assert(sizeof(AnimInstanceBase_TraceGround) == 0x000038, "Wrong size on AnimInstanceBase_TraceGround");
static_assert(offsetof(AnimInstanceBase_TraceGround, Character) == 0x000000, "Member 'AnimInstanceBase_TraceGround::Character' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, TraceLocation) == 0x000008, "Member 'AnimInstanceBase_TraceGround::TraceLocation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, TraceStart) == 0x000014, "Member 'AnimInstanceBase_TraceGround::TraceStart' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, TraceEnd) == 0x000018, "Member 'AnimInstanceBase_TraceGround::TraceEnd' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, HitLocation) == 0x00001C, "Member 'AnimInstanceBase_TraceGround::HitLocation' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, HitNormal) == 0x000028, "Member 'AnimInstanceBase_TraceGround::HitNormal' has a wrong offset!");
static_assert(offsetof(AnimInstanceBase_TraceGround, ReturnValue) == 0x000034, "Member 'AnimInstanceBase_TraceGround::ReturnValue' has a wrong offset!");

// Function man.CCCogsAnimInstance.UpdateCogs
// 0x0004 (0x0004 - 0x0000)
struct CCCogsAnimInstance_UpdateCogs final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCogsAnimInstance_UpdateCogs) == 0x000004, "Wrong alignment on CCCogsAnimInstance_UpdateCogs");
static_assert(sizeof(CCCogsAnimInstance_UpdateCogs) == 0x000004, "Wrong size on CCCogsAnimInstance_UpdateCogs");
static_assert(offsetof(CCCogsAnimInstance_UpdateCogs, DeltaSeconds) == 0x000000, "Member 'CCCogsAnimInstance_UpdateCogs::DeltaSeconds' has a wrong offset!");

// Function man.LimitedEntropicTearImplement.OnPostDamage
// 0x02D8 (0x02D8 - 0x0000)
struct LimitedEntropicTearImplement_OnPostDamage final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitedEntropicTearImplement_OnPostDamage) == 0x000008, "Wrong alignment on LimitedEntropicTearImplement_OnPostDamage");
static_assert(sizeof(LimitedEntropicTearImplement_OnPostDamage) == 0x0002D8, "Wrong size on LimitedEntropicTearImplement_OnPostDamage");
static_assert(offsetof(LimitedEntropicTearImplement_OnPostDamage, Param) == 0x000000, "Member 'LimitedEntropicTearImplement_OnPostDamage::Param' has a wrong offset!");

// Function man.LimitedEntropicTearImplement.TriggerOnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap) == 0x000008, "Wrong alignment on LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap");
static_assert(sizeof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap) == 0x0000A8, "Wrong size on LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'LimitedEntropicTearImplement_TriggerOnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function man.LimitedEntropicTearImplement.TriggerOnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct LimitedEntropicTearImplement_TriggerOnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap) == 0x000008, "Wrong alignment on LimitedEntropicTearImplement_TriggerOnComponentEndOverlap");
static_assert(sizeof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap) == 0x000020, "Wrong size on LimitedEntropicTearImplement_TriggerOnComponentEndOverlap");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'LimitedEntropicTearImplement_TriggerOnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap, OtherActor) == 0x000008, "Member 'LimitedEntropicTearImplement_TriggerOnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap, OtherComp) == 0x000010, "Member 'LimitedEntropicTearImplement_TriggerOnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitedEntropicTearImplement_TriggerOnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'LimitedEntropicTearImplement_TriggerOnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.AIAggroStartAbility.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct AIAggroStartAbility_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAggroStartAbility_OnPostDamaged) == 0x000008, "Wrong alignment on AIAggroStartAbility_OnPostDamaged");
static_assert(sizeof(AIAggroStartAbility_OnPostDamaged) == 0x0002D8, "Wrong size on AIAggroStartAbility_OnPostDamaged");
static_assert(offsetof(AIAggroStartAbility_OnPostDamaged, Param) == 0x000000, "Member 'AIAggroStartAbility_OnPostDamaged::Param' has a wrong offset!");

// Function man.PushableObject.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct PushableObject_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PushableObject_OnBeginOverlap) == 0x000008, "Wrong alignment on PushableObject_OnBeginOverlap");
static_assert(sizeof(PushableObject_OnBeginOverlap) == 0x0000A8, "Wrong size on PushableObject_OnBeginOverlap");
static_assert(offsetof(PushableObject_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'PushableObject_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PushableObject_OnBeginOverlap, OtherActor) == 0x000008, "Member 'PushableObject_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(PushableObject_OnBeginOverlap, OtherComp) == 0x000010, "Member 'PushableObject_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PushableObject_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'PushableObject_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(PushableObject_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'PushableObject_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(PushableObject_OnBeginOverlap, SweepResult) == 0x000020, "Member 'PushableObject_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function man.PushableObject.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct PushableObject_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PushableObject_OnEndOverlap) == 0x000008, "Wrong alignment on PushableObject_OnEndOverlap");
static_assert(sizeof(PushableObject_OnEndOverlap) == 0x000020, "Wrong size on PushableObject_OnEndOverlap");
static_assert(offsetof(PushableObject_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'PushableObject_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PushableObject_OnEndOverlap, OtherActor) == 0x000008, "Member 'PushableObject_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(PushableObject_OnEndOverlap, OtherComp) == 0x000010, "Member 'PushableObject_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PushableObject_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'PushableObject_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.DoorEnterAbility.OnTeleport
// 0x000C (0x000C - 0x0000)
struct DoorEnterAbility_OnTeleport final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DoorEnterAbility_OnTeleport) == 0x000004, "Wrong alignment on DoorEnterAbility_OnTeleport");
static_assert(sizeof(DoorEnterAbility_OnTeleport) == 0x00000C, "Wrong size on DoorEnterAbility_OnTeleport");
static_assert(offsetof(DoorEnterAbility_OnTeleport, NewLocation) == 0x000000, "Member 'DoorEnterAbility_OnTeleport::NewLocation' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.GetInventorySlot
// 0x0008 (0x0008 - 0x0000)
struct CharacterWinFilterSlotUserWidget_GetInventorySlot final
{
public:
	class UInventorySlot*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_GetInventorySlot) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_GetInventorySlot");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_GetInventorySlot) == 0x000008, "Wrong size on CharacterWinFilterSlotUserWidget_GetInventorySlot");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_GetInventorySlot, ReturnValue) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_GetInventorySlot::ReturnValue' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnPermanentEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InPermanentEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged) == 0x000010, "Wrong size on CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged, InPermanentEnchantIcons) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnPermanentEnchantIconsChanged::InPermanentEnchantIcons' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetCountdown
// 0x0020 (0x0020 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetCountdown final
{
public:
	float                                         ElapsedCooldownPercent;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimeLeft;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetCountdown) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetCountdown");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetCountdown) == 0x000020, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetCountdown");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetCountdown, ElapsedCooldownPercent) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetCountdown::ElapsedCooldownPercent' has a wrong offset!");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetCountdown, TimeLeft) == 0x000008, "Member 'CharacterWinFilterSlotUserWidget_OnSetCountdown::TimeLeft' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetEnabled");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetEnabled");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetEquippedItemMode
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode final
{
public:
	bool                                          bInEquippedItemMode;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode, bInEquippedItemMode) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetEquippedItemMode::bInEquippedItemMode' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetItemIcon
// 0x0008 (0x0008 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetItemIcon final
{
public:
	class UTexture2D*                             ItemIcon;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetItemIcon");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetItemIcon");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetItemIcon, ItemIcon) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetItemIcon::ItemIcon' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetLocked
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetLocked final
{
public:
	bool                                          bInLocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetLocked) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetLocked");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetLocked) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetLocked");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetLocked, bInLocked) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetLocked::bInLocked' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetSelected
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetSelected final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetSelected");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetSelected");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetSelected, bInSelected) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetSelected::bInSelected' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetSlotNameText
// 0x0018 (0x0018 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetSlotNameText final
{
public:
	class FText                                   SlotNameText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetSlotNameText) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetSlotNameText");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetSlotNameText) == 0x000018, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetSlotNameText");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetSlotNameText, SlotNameText) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetSlotNameText::SlotNameText' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetTransmogSlot
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetTransmogSlot final
{
public:
	bool                                          bInTransmogSlot;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetTransmogSlot) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetTransmogSlot");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetTransmogSlot) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetTransmogSlot");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetTransmogSlot, bInTransmogSlot) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetTransmogSlot::bInTransmogSlot' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetTwoHandedLocked
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked final
{
public:
	bool                                          bInTwoHandedLocked;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked, bInTwoHandedLocked) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetTwoHandedLocked::bInTwoHandedLocked' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetUnavailable
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetUnavailable final
{
public:
	bool                                          bInUnavailable;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetUnavailable) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetUnavailable");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetUnavailable) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetUnavailable");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetUnavailable, bInUnavailable) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetUnavailable::bInUnavailable' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnSetVisible
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnSetVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnSetVisible");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnSetVisible");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnSetVisible, bInVisible) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnSetVisible::bInVisible' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnStackNumChanged
// 0x0008 (0x0008 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnStackNumChanged final
{
public:
	int32                                         InStackNum;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsStackable;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShadowMode;                                       // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnStackNumChanged) == 0x000004, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnStackNumChanged");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnStackNumChanged) == 0x000008, "Wrong size on CharacterWinFilterSlotUserWidget_OnStackNumChanged");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnStackNumChanged, InStackNum) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnStackNumChanged::InStackNum' has a wrong offset!");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnStackNumChanged, bInIsStackable) == 0x000004, "Member 'CharacterWinFilterSlotUserWidget_OnStackNumChanged::bInIsStackable' has a wrong offset!");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnStackNumChanged, bShadowMode) == 0x000005, "Member 'CharacterWinFilterSlotUserWidget_OnStackNumChanged::bShadowMode' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnTemporaryEnchantIconsChanged
// 0x0010 (0x0010 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged final
{
public:
	TArray<class UTexture2D*>                     InTemporaryEnchantIcons;                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000008, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged) == 0x000010, "Wrong size on CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged, InTemporaryEnchantIcons) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnTemporaryEnchantIconsChanged::InTemporaryEnchantIcons' has a wrong offset!");

// Function man.CharacterWinFilterSlotUserWidget.OnToggleNewItemWarning
// 0x0001 (0x0001 - 0x0000)
struct CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong alignment on CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning");
static_assert(sizeof(CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong size on CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning");
static_assert(offsetof(CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning, bInVisible) == 0x000000, "Member 'CharacterWinFilterSlotUserWidget_OnToggleNewItemWarning::bInVisible' has a wrong offset!");

// Function man.InteractableActor.OnActorOverlapWithAvatarEnd
// 0x0010 (0x0010 - 0x0000)
struct InteractableActor_OnActorOverlapWithAvatarEnd final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableActor_OnActorOverlapWithAvatarEnd) == 0x000008, "Wrong alignment on InteractableActor_OnActorOverlapWithAvatarEnd");
static_assert(sizeof(InteractableActor_OnActorOverlapWithAvatarEnd) == 0x000010, "Wrong size on InteractableActor_OnActorOverlapWithAvatarEnd");
static_assert(offsetof(InteractableActor_OnActorOverlapWithAvatarEnd, OverlappedActor) == 0x000000, "Member 'InteractableActor_OnActorOverlapWithAvatarEnd::OverlappedActor' has a wrong offset!");
static_assert(offsetof(InteractableActor_OnActorOverlapWithAvatarEnd, OtherActor) == 0x000008, "Member 'InteractableActor_OnActorOverlapWithAvatarEnd::OtherActor' has a wrong offset!");

// Function man.InteractableActor.OnActorOverlapWithAvatarStart
// 0x0010 (0x0010 - 0x0000)
struct InteractableActor_OnActorOverlapWithAvatarStart final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableActor_OnActorOverlapWithAvatarStart) == 0x000008, "Wrong alignment on InteractableActor_OnActorOverlapWithAvatarStart");
static_assert(sizeof(InteractableActor_OnActorOverlapWithAvatarStart) == 0x000010, "Wrong size on InteractableActor_OnActorOverlapWithAvatarStart");
static_assert(offsetof(InteractableActor_OnActorOverlapWithAvatarStart, OverlappedActor) == 0x000000, "Member 'InteractableActor_OnActorOverlapWithAvatarStart::OverlappedActor' has a wrong offset!");
static_assert(offsetof(InteractableActor_OnActorOverlapWithAvatarStart, OtherActor) == 0x000008, "Member 'InteractableActor_OnActorOverlapWithAvatarStart::OtherActor' has a wrong offset!");

// Function man.KingPriestVoidAI.OnBeginPlatformVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct KingPriestVoidAI_OnBeginPlatformVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidAI_OnBeginPlatformVolumeOverlap) == 0x000008, "Wrong alignment on KingPriestVoidAI_OnBeginPlatformVolumeOverlap");
static_assert(sizeof(KingPriestVoidAI_OnBeginPlatformVolumeOverlap) == 0x000010, "Wrong size on KingPriestVoidAI_OnBeginPlatformVolumeOverlap");
static_assert(offsetof(KingPriestVoidAI_OnBeginPlatformVolumeOverlap, OverlappedActor) == 0x000000, "Member 'KingPriestVoidAI_OnBeginPlatformVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(KingPriestVoidAI_OnBeginPlatformVolumeOverlap, OtherActor) == 0x000008, "Member 'KingPriestVoidAI_OnBeginPlatformVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.KingPriestVoidAI.OnEndPlatformVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct KingPriestVoidAI_OnEndPlatformVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidAI_OnEndPlatformVolumeOverlap) == 0x000008, "Wrong alignment on KingPriestVoidAI_OnEndPlatformVolumeOverlap");
static_assert(sizeof(KingPriestVoidAI_OnEndPlatformVolumeOverlap) == 0x000010, "Wrong size on KingPriestVoidAI_OnEndPlatformVolumeOverlap");
static_assert(offsetof(KingPriestVoidAI_OnEndPlatformVolumeOverlap, OverlappedActor) == 0x000000, "Member 'KingPriestVoidAI_OnEndPlatformVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(KingPriestVoidAI_OnEndPlatformVolumeOverlap, OtherActor) == 0x000008, "Member 'KingPriestVoidAI_OnEndPlatformVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.ChaoticTouchPassive.AbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct ChaoticTouchPassive_AbilityEnd final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticTouchPassive_AbilityEnd) == 0x000008, "Wrong alignment on ChaoticTouchPassive_AbilityEnd");
static_assert(sizeof(ChaoticTouchPassive_AbilityEnd) == 0x000008, "Wrong size on ChaoticTouchPassive_AbilityEnd");
static_assert(offsetof(ChaoticTouchPassive_AbilityEnd, Ability) == 0x000000, "Member 'ChaoticTouchPassive_AbilityEnd::Ability' has a wrong offset!");

// Function man.ChaoticTouchPassive.ChaosTriggered
// 0x0008 (0x0008 - 0x0000)
struct ChaoticTouchPassive_ChaosTriggered final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticTouchPassive_ChaosTriggered) == 0x000008, "Wrong alignment on ChaoticTouchPassive_ChaosTriggered");
static_assert(sizeof(ChaoticTouchPassive_ChaosTriggered) == 0x000008, "Wrong size on ChaoticTouchPassive_ChaosTriggered");
static_assert(offsetof(ChaoticTouchPassive_ChaosTriggered, Ability) == 0x000000, "Member 'ChaoticTouchPassive_ChaosTriggered::Ability' has a wrong offset!");

// Function man.ChaoticTouchPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ChaoticTouchPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticTouchPassive_DamageDealt) == 0x000008, "Wrong alignment on ChaoticTouchPassive_DamageDealt");
static_assert(sizeof(ChaoticTouchPassive_DamageDealt) == 0x0002D8, "Wrong size on ChaoticTouchPassive_DamageDealt");
static_assert(offsetof(ChaoticTouchPassive_DamageDealt, Param) == 0x000000, "Member 'ChaoticTouchPassive_DamageDealt::Param' has a wrong offset!");

// Function man.AirAttackAbility.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct AirAttackAbility_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AirAttackAbility_OnPreDamageCaused) == 0x000008, "Wrong alignment on AirAttackAbility_OnPreDamageCaused");
static_assert(sizeof(AirAttackAbility_OnPreDamageCaused) == 0x0002D8, "Wrong size on AirAttackAbility_OnPreDamageCaused");
static_assert(offsetof(AirAttackAbility_OnPreDamageCaused, Param) == 0x000000, "Member 'AirAttackAbility_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.DreadscytheAbility.GetCurrentRadius
// 0x0004 (0x0004 - 0x0000)
struct DreadscytheAbility_GetCurrentRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreadscytheAbility_GetCurrentRadius) == 0x000004, "Wrong alignment on DreadscytheAbility_GetCurrentRadius");
static_assert(sizeof(DreadscytheAbility_GetCurrentRadius) == 0x000004, "Wrong size on DreadscytheAbility_GetCurrentRadius");
static_assert(offsetof(DreadscytheAbility_GetCurrentRadius, ReturnValue) == 0x000000, "Member 'DreadscytheAbility_GetCurrentRadius::ReturnValue' has a wrong offset!");

// Function man.DreadscytheAbility.GetCurrentWidth
// 0x0004 (0x0004 - 0x0000)
struct DreadscytheAbility_GetCurrentWidth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreadscytheAbility_GetCurrentWidth) == 0x000004, "Wrong alignment on DreadscytheAbility_GetCurrentWidth");
static_assert(sizeof(DreadscytheAbility_GetCurrentWidth) == 0x000004, "Wrong size on DreadscytheAbility_GetCurrentWidth");
static_assert(offsetof(DreadscytheAbility_GetCurrentWidth, ReturnValue) == 0x000000, "Member 'DreadscytheAbility_GetCurrentWidth::ReturnValue' has a wrong offset!");

// Function man.DreadscytheAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DreadscytheAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreadscytheAbility_PreDamageDealt) == 0x000008, "Wrong alignment on DreadscytheAbility_PreDamageDealt");
static_assert(sizeof(DreadscytheAbility_PreDamageDealt) == 0x0002D8, "Wrong size on DreadscytheAbility_PreDamageDealt");
static_assert(offsetof(DreadscytheAbility_PreDamageDealt, Param) == 0x000000, "Member 'DreadscytheAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.CheckPointActivateAbility.OnCheckPointTravel
// 0x0008 (0x0008 - 0x0000)
struct CheckPointActivateAbility_OnCheckPointTravel final
{
public:
	class UCheckpointData*                        CheckpointData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheckPointActivateAbility_OnCheckPointTravel) == 0x000008, "Wrong alignment on CheckPointActivateAbility_OnCheckPointTravel");
static_assert(sizeof(CheckPointActivateAbility_OnCheckPointTravel) == 0x000008, "Wrong size on CheckPointActivateAbility_OnCheckPointTravel");
static_assert(offsetof(CheckPointActivateAbility_OnCheckPointTravel, CheckpointData) == 0x000000, "Member 'CheckPointActivateAbility_OnCheckPointTravel::CheckpointData' has a wrong offset!");

// Function man.CheckPointActivateAbility.OnEntityKilledWithRebirth
// 0x0008 (0x0008 - 0x0000)
struct CheckPointActivateAbility_OnEntityKilledWithRebirth final
{
public:
	class AActor*                                 KilledActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheckPointActivateAbility_OnEntityKilledWithRebirth) == 0x000008, "Wrong alignment on CheckPointActivateAbility_OnEntityKilledWithRebirth");
static_assert(sizeof(CheckPointActivateAbility_OnEntityKilledWithRebirth) == 0x000008, "Wrong size on CheckPointActivateAbility_OnEntityKilledWithRebirth");
static_assert(offsetof(CheckPointActivateAbility_OnEntityKilledWithRebirth, KilledActor) == 0x000000, "Member 'CheckPointActivateAbility_OnEntityKilledWithRebirth::KilledActor' has a wrong offset!");

// Function man.CheckPointActivateAbility.OnHudMessage
// 0x0001 (0x0001 - 0x0000)
struct CheckPointActivateAbility_OnHudMessage final
{
public:
	EHudMessage                                   Msg;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheckPointActivateAbility_OnHudMessage) == 0x000001, "Wrong alignment on CheckPointActivateAbility_OnHudMessage");
static_assert(sizeof(CheckPointActivateAbility_OnHudMessage) == 0x000001, "Wrong size on CheckPointActivateAbility_OnHudMessage");
static_assert(offsetof(CheckPointActivateAbility_OnHudMessage, Msg) == 0x000000, "Member 'CheckPointActivateAbility_OnHudMessage::Msg' has a wrong offset!");

// Function man.PersistentHeroData.GetAreaManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetAreaManager final
{
public:
	class UManAreaManager*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetAreaManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetAreaManager");
static_assert(sizeof(PersistentHeroData_GetAreaManager) == 0x000008, "Wrong size on PersistentHeroData_GetAreaManager");
static_assert(offsetof(PersistentHeroData_GetAreaManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetAreaManager::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetConversationManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetConversationManager final
{
public:
	class UManConversationManager*                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetConversationManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetConversationManager");
static_assert(sizeof(PersistentHeroData_GetConversationManager) == 0x000008, "Wrong size on PersistentHeroData_GetConversationManager");
static_assert(offsetof(PersistentHeroData_GetConversationManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetConversationManager::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetHeroAbilitiesData
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetHeroAbilitiesData final
{
public:
	class UHeroAbilitiesData*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetHeroAbilitiesData) == 0x000008, "Wrong alignment on PersistentHeroData_GetHeroAbilitiesData");
static_assert(sizeof(PersistentHeroData_GetHeroAbilitiesData) == 0x000008, "Wrong size on PersistentHeroData_GetHeroAbilitiesData");
static_assert(offsetof(PersistentHeroData_GetHeroAbilitiesData, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetHeroAbilitiesData::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetHeroInventory
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetHeroInventory final
{
public:
	class UInventory*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetHeroInventory) == 0x000008, "Wrong alignment on PersistentHeroData_GetHeroInventory");
static_assert(sizeof(PersistentHeroData_GetHeroInventory) == 0x000008, "Wrong size on PersistentHeroData_GetHeroInventory");
static_assert(offsetof(PersistentHeroData_GetHeroInventory, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetHeroInventory::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetMapManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetMapManager final
{
public:
	class UMapManager*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetMapManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetMapManager");
static_assert(sizeof(PersistentHeroData_GetMapManager) == 0x000008, "Wrong size on PersistentHeroData_GetMapManager");
static_assert(offsetof(PersistentHeroData_GetMapManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetMapManager::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetQuestManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetQuestManager final
{
public:
	class UManQuestManager*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetQuestManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetQuestManager");
static_assert(sizeof(PersistentHeroData_GetQuestManager) == 0x000008, "Wrong size on PersistentHeroData_GetQuestManager");
static_assert(offsetof(PersistentHeroData_GetQuestManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetQuestManager::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetSkillTreeManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetSkillTreeManager final
{
public:
	class USkillTreeManager*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetSkillTreeManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetSkillTreeManager");
static_assert(sizeof(PersistentHeroData_GetSkillTreeManager) == 0x000008, "Wrong size on PersistentHeroData_GetSkillTreeManager");
static_assert(offsetof(PersistentHeroData_GetSkillTreeManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetSkillTreeManager::ReturnValue' has a wrong offset!");

// Function man.PersistentHeroData.GetVendorManager
// 0x0008 (0x0008 - 0x0000)
struct PersistentHeroData_GetVendorManager final
{
public:
	class UVendorManager*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistentHeroData_GetVendorManager) == 0x000008, "Wrong alignment on PersistentHeroData_GetVendorManager");
static_assert(sizeof(PersistentHeroData_GetVendorManager) == 0x000008, "Wrong size on PersistentHeroData_GetVendorManager");
static_assert(offsetof(PersistentHeroData_GetVendorManager, ReturnValue) == 0x000000, "Member 'PersistentHeroData_GetVendorManager::ReturnValue' has a wrong offset!");

// Function man.BountyBoardDetailsUserWidget.OnSetAccepted
// 0x0001 (0x0001 - 0x0000)
struct BountyBoardDetailsUserWidget_OnSetAccepted final
{
public:
	bool                                          bAccepted;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BountyBoardDetailsUserWidget_OnSetAccepted) == 0x000001, "Wrong alignment on BountyBoardDetailsUserWidget_OnSetAccepted");
static_assert(sizeof(BountyBoardDetailsUserWidget_OnSetAccepted) == 0x000001, "Wrong size on BountyBoardDetailsUserWidget_OnSetAccepted");
static_assert(offsetof(BountyBoardDetailsUserWidget_OnSetAccepted, bAccepted) == 0x000000, "Member 'BountyBoardDetailsUserWidget_OnSetAccepted::bAccepted' has a wrong offset!");

// Function man.BountyBoardDetailsUserWidget.OnSetDetailsText
// 0x0018 (0x0018 - 0x0000)
struct BountyBoardDetailsUserWidget_OnSetDetailsText final
{
public:
	class FText                                   DetailsText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BountyBoardDetailsUserWidget_OnSetDetailsText) == 0x000008, "Wrong alignment on BountyBoardDetailsUserWidget_OnSetDetailsText");
static_assert(sizeof(BountyBoardDetailsUserWidget_OnSetDetailsText) == 0x000018, "Wrong size on BountyBoardDetailsUserWidget_OnSetDetailsText");
static_assert(offsetof(BountyBoardDetailsUserWidget_OnSetDetailsText, DetailsText) == 0x000000, "Member 'BountyBoardDetailsUserWidget_OnSetDetailsText::DetailsText' has a wrong offset!");

// Function man.WhispersAbility.GetTargetEnemy
// 0x0008 (0x0008 - 0x0000)
struct WhispersAbility_GetTargetEnemy final
{
public:
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WhispersAbility_GetTargetEnemy) == 0x000008, "Wrong alignment on WhispersAbility_GetTargetEnemy");
static_assert(sizeof(WhispersAbility_GetTargetEnemy) == 0x000008, "Wrong size on WhispersAbility_GetTargetEnemy");
static_assert(offsetof(WhispersAbility_GetTargetEnemy, ReturnValue) == 0x000000, "Member 'WhispersAbility_GetTargetEnemy::ReturnValue' has a wrong offset!");

// Function man.WhispersAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct WhispersAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WhispersAbility_PostDamageDealt) == 0x000008, "Wrong alignment on WhispersAbility_PostDamageDealt");
static_assert(sizeof(WhispersAbility_PostDamageDealt) == 0x0002D8, "Wrong size on WhispersAbility_PostDamageDealt");
static_assert(offsetof(WhispersAbility_PostDamageDealt, Param) == 0x000000, "Member 'WhispersAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.BloodStainBuildupPassive.GetBloodStainRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct BloodStainBuildupPassive_GetBloodStainRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodStainBuildupPassive_GetBloodStainRemainingTime) == 0x000004, "Wrong alignment on BloodStainBuildupPassive_GetBloodStainRemainingTime");
static_assert(sizeof(BloodStainBuildupPassive_GetBloodStainRemainingTime) == 0x000004, "Wrong size on BloodStainBuildupPassive_GetBloodStainRemainingTime");
static_assert(offsetof(BloodStainBuildupPassive_GetBloodStainRemainingTime, ReturnValue) == 0x000000, "Member 'BloodStainBuildupPassive_GetBloodStainRemainingTime::ReturnValue' has a wrong offset!");

// Function man.BloodStainBuildupPassive.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct BloodStainBuildupPassive_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodStainBuildupPassive_OnPostDamageDone) == 0x000008, "Wrong alignment on BloodStainBuildupPassive_OnPostDamageDone");
static_assert(sizeof(BloodStainBuildupPassive_OnPostDamageDone) == 0x0002D8, "Wrong size on BloodStainBuildupPassive_OnPostDamageDone");
static_assert(offsetof(BloodStainBuildupPassive_OnPostDamageDone, DamageParams) == 0x000000, "Member 'BloodStainBuildupPassive_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.BloodStainBuildupPassive.OnPostDamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct BloodStainBuildupPassive_OnPostDamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodStainBuildupPassive_OnPostDamageTaken) == 0x000008, "Wrong alignment on BloodStainBuildupPassive_OnPostDamageTaken");
static_assert(sizeof(BloodStainBuildupPassive_OnPostDamageTaken) == 0x0002D8, "Wrong size on BloodStainBuildupPassive_OnPostDamageTaken");
static_assert(offsetof(BloodStainBuildupPassive_OnPostDamageTaken, DamageParams) == 0x000000, "Member 'BloodStainBuildupPassive_OnPostDamageTaken::DamageParams' has a wrong offset!");

// Function man.CameraBlocker.EnableBlocking
// 0x0001 (0x0001 - 0x0000)
struct CameraBlocker_EnableBlocking final
{
public:
	bool                                          Blocking;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraBlocker_EnableBlocking) == 0x000001, "Wrong alignment on CameraBlocker_EnableBlocking");
static_assert(sizeof(CameraBlocker_EnableBlocking) == 0x000001, "Wrong size on CameraBlocker_EnableBlocking");
static_assert(offsetof(CameraBlocker_EnableBlocking, Blocking) == 0x000000, "Member 'CameraBlocker_EnableBlocking::Blocking' has a wrong offset!");

// Function man.HUDNotificationUserWidget.OnSetData
// 0x0048 (0x0048 - 0x0000)
struct HUDNotificationUserWidget_OnSetData final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDescription;                                     // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             InIcon;                                            // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InNumber;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemAbility*                           InItemAbility;                                     // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDNotificationUserWidget_OnSetData) == 0x000008, "Wrong alignment on HUDNotificationUserWidget_OnSetData");
static_assert(sizeof(HUDNotificationUserWidget_OnSetData) == 0x000048, "Wrong size on HUDNotificationUserWidget_OnSetData");
static_assert(offsetof(HUDNotificationUserWidget_OnSetData, InName) == 0x000000, "Member 'HUDNotificationUserWidget_OnSetData::InName' has a wrong offset!");
static_assert(offsetof(HUDNotificationUserWidget_OnSetData, InDescription) == 0x000018, "Member 'HUDNotificationUserWidget_OnSetData::InDescription' has a wrong offset!");
static_assert(offsetof(HUDNotificationUserWidget_OnSetData, InIcon) == 0x000030, "Member 'HUDNotificationUserWidget_OnSetData::InIcon' has a wrong offset!");
static_assert(offsetof(HUDNotificationUserWidget_OnSetData, InNumber) == 0x000038, "Member 'HUDNotificationUserWidget_OnSetData::InNumber' has a wrong offset!");
static_assert(offsetof(HUDNotificationUserWidget_OnSetData, InItemAbility) == 0x000040, "Member 'HUDNotificationUserWidget_OnSetData::InItemAbility' has a wrong offset!");

// Function man.HUDNotificationUserWidget.OnSetNumber
// 0x0004 (0x0004 - 0x0000)
struct HUDNotificationUserWidget_OnSetNumber final
{
public:
	int32                                         InNumber;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDNotificationUserWidget_OnSetNumber) == 0x000004, "Wrong alignment on HUDNotificationUserWidget_OnSetNumber");
static_assert(sizeof(HUDNotificationUserWidget_OnSetNumber) == 0x000004, "Wrong size on HUDNotificationUserWidget_OnSetNumber");
static_assert(offsetof(HUDNotificationUserWidget_OnSetNumber, InNumber) == 0x000000, "Member 'HUDNotificationUserWidget_OnSetNumber::InNumber' has a wrong offset!");

// Function man.ManWidgetComponent.OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct ManWidgetComponent_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManWidgetComponent_OnPreDamaged) == 0x000008, "Wrong alignment on ManWidgetComponent_OnPreDamaged");
static_assert(sizeof(ManWidgetComponent_OnPreDamaged) == 0x0002D8, "Wrong size on ManWidgetComponent_OnPreDamaged");
static_assert(offsetof(ManWidgetComponent_OnPreDamaged, Param) == 0x000000, "Member 'ManWidgetComponent_OnPreDamaged::Param' has a wrong offset!");

// Function man.HPBarWidgetComponent.ExecutePostHealthChanged
// 0x0008 (0x0008 - 0x0000)
struct HPBarWidgetComponent_ExecutePostHealthChanged final
{
public:
	float                                         CurrentHealth;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HPBarWidgetComponent_ExecutePostHealthChanged) == 0x000004, "Wrong alignment on HPBarWidgetComponent_ExecutePostHealthChanged");
static_assert(sizeof(HPBarWidgetComponent_ExecutePostHealthChanged) == 0x000008, "Wrong size on HPBarWidgetComponent_ExecutePostHealthChanged");
static_assert(offsetof(HPBarWidgetComponent_ExecutePostHealthChanged, CurrentHealth) == 0x000000, "Member 'HPBarWidgetComponent_ExecutePostHealthChanged::CurrentHealth' has a wrong offset!");
static_assert(offsetof(HPBarWidgetComponent_ExecutePostHealthChanged, MaxHealth) == 0x000004, "Member 'HPBarWidgetComponent_ExecutePostHealthChanged::MaxHealth' has a wrong offset!");

// Function man.HPBarWidgetComponent.ExecutePostMaxHealthChanged
// 0x0008 (0x0008 - 0x0000)
struct HPBarWidgetComponent_ExecutePostMaxHealthChanged final
{
public:
	float                                         CurrentHealth;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HPBarWidgetComponent_ExecutePostMaxHealthChanged) == 0x000004, "Wrong alignment on HPBarWidgetComponent_ExecutePostMaxHealthChanged");
static_assert(sizeof(HPBarWidgetComponent_ExecutePostMaxHealthChanged) == 0x000008, "Wrong size on HPBarWidgetComponent_ExecutePostMaxHealthChanged");
static_assert(offsetof(HPBarWidgetComponent_ExecutePostMaxHealthChanged, CurrentHealth) == 0x000000, "Member 'HPBarWidgetComponent_ExecutePostMaxHealthChanged::CurrentHealth' has a wrong offset!");
static_assert(offsetof(HPBarWidgetComponent_ExecutePostMaxHealthChanged, MaxHealth) == 0x000004, "Member 'HPBarWidgetComponent_ExecutePostMaxHealthChanged::MaxHealth' has a wrong offset!");

// Function man.HPBarWidgetComponent.IsEliteEnemy
// 0x0001 (0x0001 - 0x0000)
struct HPBarWidgetComponent_IsEliteEnemy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HPBarWidgetComponent_IsEliteEnemy) == 0x000001, "Wrong alignment on HPBarWidgetComponent_IsEliteEnemy");
static_assert(sizeof(HPBarWidgetComponent_IsEliteEnemy) == 0x000001, "Wrong size on HPBarWidgetComponent_IsEliteEnemy");
static_assert(offsetof(HPBarWidgetComponent_IsEliteEnemy, ReturnValue) == 0x000000, "Member 'HPBarWidgetComponent_IsEliteEnemy::ReturnValue' has a wrong offset!");

// Function man.HPBarWidgetComponent.OnHealthChanged
// 0x0008 (0x0008 - 0x0000)
struct HPBarWidgetComponent_OnHealthChanged final
{
public:
	float                                         preHealth;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         newHealth;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HPBarWidgetComponent_OnHealthChanged) == 0x000004, "Wrong alignment on HPBarWidgetComponent_OnHealthChanged");
static_assert(sizeof(HPBarWidgetComponent_OnHealthChanged) == 0x000008, "Wrong size on HPBarWidgetComponent_OnHealthChanged");
static_assert(offsetof(HPBarWidgetComponent_OnHealthChanged, preHealth) == 0x000000, "Member 'HPBarWidgetComponent_OnHealthChanged::preHealth' has a wrong offset!");
static_assert(offsetof(HPBarWidgetComponent_OnHealthChanged, newHealth) == 0x000004, "Member 'HPBarWidgetComponent_OnHealthChanged::newHealth' has a wrong offset!");

// Function man.HPBarWidgetComponent.OnMaxHealthChanged
// 0x0010 (0x0010 - 0x0000)
struct HPBarWidgetComponent_OnMaxHealthChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HPBarWidgetComponent_OnMaxHealthChanged) == 0x000008, "Wrong alignment on HPBarWidgetComponent_OnMaxHealthChanged");
static_assert(sizeof(HPBarWidgetComponent_OnMaxHealthChanged) == 0x000010, "Wrong size on HPBarWidgetComponent_OnMaxHealthChanged");
static_assert(offsetof(HPBarWidgetComponent_OnMaxHealthChanged, attribute) == 0x000000, "Member 'HPBarWidgetComponent_OnMaxHealthChanged::attribute' has a wrong offset!");
static_assert(offsetof(HPBarWidgetComponent_OnMaxHealthChanged, preValue) == 0x000008, "Member 'HPBarWidgetComponent_OnMaxHealthChanged::preValue' has a wrong offset!");

// Function man.BrawlerAnimInstance.ComputeEnterSideDoor
// 0x0004 (0x0004 - 0x0000)
struct BrawlerAnimInstance_ComputeEnterSideDoor final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_ComputeEnterSideDoor) == 0x000004, "Wrong alignment on BrawlerAnimInstance_ComputeEnterSideDoor");
static_assert(sizeof(BrawlerAnimInstance_ComputeEnterSideDoor) == 0x000004, "Wrong size on BrawlerAnimInstance_ComputeEnterSideDoor");
static_assert(offsetof(BrawlerAnimInstance_ComputeEnterSideDoor, DeltaSeconds) == 0x000000, "Member 'BrawlerAnimInstance_ComputeEnterSideDoor::DeltaSeconds' has a wrong offset!");

// Function man.BrawlerAnimInstance.DumpCombatModeInfo
// 0x0010 (0x0010 - 0x0000)
struct BrawlerAnimInstance_DumpCombatModeInfo final
{
public:
	class FString                                 CombatModeInfo;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_DumpCombatModeInfo) == 0x000008, "Wrong alignment on BrawlerAnimInstance_DumpCombatModeInfo");
static_assert(sizeof(BrawlerAnimInstance_DumpCombatModeInfo) == 0x000010, "Wrong size on BrawlerAnimInstance_DumpCombatModeInfo");
static_assert(offsetof(BrawlerAnimInstance_DumpCombatModeInfo, CombatModeInfo) == 0x000000, "Member 'BrawlerAnimInstance_DumpCombatModeInfo::CombatModeInfo' has a wrong offset!");

// Function man.BrawlerAnimInstance.EnableGrapplingHook
// 0x0001 (0x0001 - 0x0000)
struct BrawlerAnimInstance_EnableGrapplingHook final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_EnableGrapplingHook) == 0x000001, "Wrong alignment on BrawlerAnimInstance_EnableGrapplingHook");
static_assert(sizeof(BrawlerAnimInstance_EnableGrapplingHook) == 0x000001, "Wrong size on BrawlerAnimInstance_EnableGrapplingHook");
static_assert(offsetof(BrawlerAnimInstance_EnableGrapplingHook, bEnable) == 0x000000, "Member 'BrawlerAnimInstance_EnableGrapplingHook::bEnable' has a wrong offset!");

// Function man.BrawlerAnimInstance.GetLeftArmDirection
// 0x000C (0x000C - 0x0000)
struct BrawlerAnimInstance_GetLeftArmDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_GetLeftArmDirection) == 0x000004, "Wrong alignment on BrawlerAnimInstance_GetLeftArmDirection");
static_assert(sizeof(BrawlerAnimInstance_GetLeftArmDirection) == 0x00000C, "Wrong size on BrawlerAnimInstance_GetLeftArmDirection");
static_assert(offsetof(BrawlerAnimInstance_GetLeftArmDirection, ReturnValue) == 0x000000, "Member 'BrawlerAnimInstance_GetLeftArmDirection::ReturnValue' has a wrong offset!");

// Function man.BrawlerAnimInstance.SetConversationLookTarget
// 0x0008 (0x0008 - 0x0000)
struct BrawlerAnimInstance_SetConversationLookTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_SetConversationLookTarget) == 0x000008, "Wrong alignment on BrawlerAnimInstance_SetConversationLookTarget");
static_assert(sizeof(BrawlerAnimInstance_SetConversationLookTarget) == 0x000008, "Wrong size on BrawlerAnimInstance_SetConversationLookTarget");
static_assert(offsetof(BrawlerAnimInstance_SetConversationLookTarget, TargetActor) == 0x000000, "Member 'BrawlerAnimInstance_SetConversationLookTarget::TargetActor' has a wrong offset!");

// Function man.BrawlerAnimInstance.SetGrapplingHookFootWallDistance
// 0x0004 (0x0004 - 0x0000)
struct BrawlerAnimInstance_SetGrapplingHookFootWallDistance final
{
public:
	float                                         FootWallDistance;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_SetGrapplingHookFootWallDistance) == 0x000004, "Wrong alignment on BrawlerAnimInstance_SetGrapplingHookFootWallDistance");
static_assert(sizeof(BrawlerAnimInstance_SetGrapplingHookFootWallDistance) == 0x000004, "Wrong size on BrawlerAnimInstance_SetGrapplingHookFootWallDistance");
static_assert(offsetof(BrawlerAnimInstance_SetGrapplingHookFootWallDistance, FootWallDistance) == 0x000000, "Member 'BrawlerAnimInstance_SetGrapplingHookFootWallDistance::FootWallDistance' has a wrong offset!");

// Function man.BrawlerAnimInstance.SetGrapplingHookPosition
// 0x000C (0x000C - 0x0000)
struct BrawlerAnimInstance_SetGrapplingHookPosition final
{
public:
	struct FVector                                TargetPosition;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_SetGrapplingHookPosition) == 0x000004, "Wrong alignment on BrawlerAnimInstance_SetGrapplingHookPosition");
static_assert(sizeof(BrawlerAnimInstance_SetGrapplingHookPosition) == 0x00000C, "Wrong size on BrawlerAnimInstance_SetGrapplingHookPosition");
static_assert(offsetof(BrawlerAnimInstance_SetGrapplingHookPosition, TargetPosition) == 0x000000, "Member 'BrawlerAnimInstance_SetGrapplingHookPosition::TargetPosition' has a wrong offset!");

// Function man.BrawlerAnimInstance.GetBlendDuration
// 0x0010 (0x0010 - 0x0000)
struct BrawlerAnimInstance_GetBlendDuration final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BrawlerAnimInstance_GetBlendDuration) == 0x000008, "Wrong alignment on BrawlerAnimInstance_GetBlendDuration");
static_assert(sizeof(BrawlerAnimInstance_GetBlendDuration) == 0x000010, "Wrong size on BrawlerAnimInstance_GetBlendDuration");
static_assert(offsetof(BrawlerAnimInstance_GetBlendDuration, AnimID) == 0x000000, "Member 'BrawlerAnimInstance_GetBlendDuration::AnimID' has a wrong offset!");
static_assert(offsetof(BrawlerAnimInstance_GetBlendDuration, ReturnValue) == 0x000008, "Member 'BrawlerAnimInstance_GetBlendDuration::ReturnValue' has a wrong offset!");

// Function man.BrawlerAnimInstance.IsLanding
// 0x0001 (0x0001 - 0x0000)
struct BrawlerAnimInstance_IsLanding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_IsLanding) == 0x000001, "Wrong alignment on BrawlerAnimInstance_IsLanding");
static_assert(sizeof(BrawlerAnimInstance_IsLanding) == 0x000001, "Wrong size on BrawlerAnimInstance_IsLanding");
static_assert(offsetof(BrawlerAnimInstance_IsLanding, ReturnValue) == 0x000000, "Member 'BrawlerAnimInstance_IsLanding::ReturnValue' has a wrong offset!");

// Function man.BrawlerAnimInstance.IsLeftWeaponInHand
// 0x0001 (0x0001 - 0x0000)
struct BrawlerAnimInstance_IsLeftWeaponInHand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_IsLeftWeaponInHand) == 0x000001, "Wrong alignment on BrawlerAnimInstance_IsLeftWeaponInHand");
static_assert(sizeof(BrawlerAnimInstance_IsLeftWeaponInHand) == 0x000001, "Wrong size on BrawlerAnimInstance_IsLeftWeaponInHand");
static_assert(offsetof(BrawlerAnimInstance_IsLeftWeaponInHand, ReturnValue) == 0x000000, "Member 'BrawlerAnimInstance_IsLeftWeaponInHand::ReturnValue' has a wrong offset!");

// Function man.BrawlerAnimInstance.IsRightWeaponInHand
// 0x0001 (0x0001 - 0x0000)
struct BrawlerAnimInstance_IsRightWeaponInHand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerAnimInstance_IsRightWeaponInHand) == 0x000001, "Wrong alignment on BrawlerAnimInstance_IsRightWeaponInHand");
static_assert(sizeof(BrawlerAnimInstance_IsRightWeaponInHand) == 0x000001, "Wrong size on BrawlerAnimInstance_IsRightWeaponInHand");
static_assert(offsetof(BrawlerAnimInstance_IsRightWeaponInHand, ReturnValue) == 0x000000, "Member 'BrawlerAnimInstance_IsRightWeaponInHand::ReturnValue' has a wrong offset!");

// Function man.ChaosShardAbility.IsEmpowerUnlocked
// 0x0001 (0x0001 - 0x0000)
struct ChaosShardAbility_IsEmpowerUnlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaosShardAbility_IsEmpowerUnlocked) == 0x000001, "Wrong alignment on ChaosShardAbility_IsEmpowerUnlocked");
static_assert(sizeof(ChaosShardAbility_IsEmpowerUnlocked) == 0x000001, "Wrong size on ChaosShardAbility_IsEmpowerUnlocked");
static_assert(offsetof(ChaosShardAbility_IsEmpowerUnlocked, ReturnValue) == 0x000000, "Member 'ChaosShardAbility_IsEmpowerUnlocked::ReturnValue' has a wrong offset!");

// Function man.ChaosShardAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ChaosShardAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaosShardAbility_PostDamageDealt) == 0x000008, "Wrong alignment on ChaosShardAbility_PostDamageDealt");
static_assert(sizeof(ChaosShardAbility_PostDamageDealt) == 0x0002D8, "Wrong size on ChaosShardAbility_PostDamageDealt");
static_assert(offsetof(ChaosShardAbility_PostDamageDealt, Param) == 0x000000, "Member 'ChaosShardAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.ChaosShardAbility.ResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct ChaosShardAbility_ResourceUsed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaosShardAbility_ResourceUsed) == 0x000008, "Wrong alignment on ChaosShardAbility_ResourceUsed");
static_assert(sizeof(ChaosShardAbility_ResourceUsed) == 0x000010, "Wrong size on ChaosShardAbility_ResourceUsed");
static_assert(offsetof(ChaosShardAbility_ResourceUsed, resource) == 0x000000, "Member 'ChaosShardAbility_ResourceUsed::resource' has a wrong offset!");
static_assert(offsetof(ChaosShardAbility_ResourceUsed, amount) == 0x000004, "Member 'ChaosShardAbility_ResourceUsed::amount' has a wrong offset!");
static_assert(offsetof(ChaosShardAbility_ResourceUsed, Ability) == 0x000008, "Member 'ChaosShardAbility_ResourceUsed::Ability' has a wrong offset!");

// Function man.AnimNotify_AkEventBase.BPGetEvent
// 0x0008 (0x0008 - 0x0000)
struct AnimNotify_AkEventBase_BPGetEvent final
{
public:
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_AkEventBase_BPGetEvent) == 0x000008, "Wrong alignment on AnimNotify_AkEventBase_BPGetEvent");
static_assert(sizeof(AnimNotify_AkEventBase_BPGetEvent) == 0x000008, "Wrong size on AnimNotify_AkEventBase_BPGetEvent");
static_assert(offsetof(AnimNotify_AkEventBase_BPGetEvent, ReturnValue) == 0x000000, "Member 'AnimNotify_AkEventBase_BPGetEvent::ReturnValue' has a wrong offset!");

// Function man.HUDQuickUseSlotUserWidget.OnSetCountdown
// 0x0020 (0x0020 - 0x0000)
struct HUDQuickUseSlotUserWidget_OnSetCountdown final
{
public:
	float                                         ElapsedCooldownPercent;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimeLeft;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDQuickUseSlotUserWidget_OnSetCountdown) == 0x000008, "Wrong alignment on HUDQuickUseSlotUserWidget_OnSetCountdown");
static_assert(sizeof(HUDQuickUseSlotUserWidget_OnSetCountdown) == 0x000020, "Wrong size on HUDQuickUseSlotUserWidget_OnSetCountdown");
static_assert(offsetof(HUDQuickUseSlotUserWidget_OnSetCountdown, ElapsedCooldownPercent) == 0x000000, "Member 'HUDQuickUseSlotUserWidget_OnSetCountdown::ElapsedCooldownPercent' has a wrong offset!");
static_assert(offsetof(HUDQuickUseSlotUserWidget_OnSetCountdown, TimeLeft) == 0x000008, "Member 'HUDQuickUseSlotUserWidget_OnSetCountdown::TimeLeft' has a wrong offset!");

// Function man.HUDQuickUseSlotUserWidget.OnSetQuickUseUsable
// 0x0001 (0x0001 - 0x0000)
struct HUDQuickUseSlotUserWidget_OnSetQuickUseUsable final
{
public:
	bool                                          bUsable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDQuickUseSlotUserWidget_OnSetQuickUseUsable) == 0x000001, "Wrong alignment on HUDQuickUseSlotUserWidget_OnSetQuickUseUsable");
static_assert(sizeof(HUDQuickUseSlotUserWidget_OnSetQuickUseUsable) == 0x000001, "Wrong size on HUDQuickUseSlotUserWidget_OnSetQuickUseUsable");
static_assert(offsetof(HUDQuickUseSlotUserWidget_OnSetQuickUseUsable, bUsable) == 0x000000, "Member 'HUDQuickUseSlotUserWidget_OnSetQuickUseUsable::bUsable' has a wrong offset!");

// Function man.HUDQuickUseSlotUserWidget.SetInventorySlot
// 0x0008 (0x0008 - 0x0000)
struct HUDQuickUseSlotUserWidget_SetInventorySlot final
{
public:
	class UInventorySlot*                         InInventorySlot;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDQuickUseSlotUserWidget_SetInventorySlot) == 0x000008, "Wrong alignment on HUDQuickUseSlotUserWidget_SetInventorySlot");
static_assert(sizeof(HUDQuickUseSlotUserWidget_SetInventorySlot) == 0x000008, "Wrong size on HUDQuickUseSlotUserWidget_SetInventorySlot");
static_assert(offsetof(HUDQuickUseSlotUserWidget_SetInventorySlot, InInventorySlot) == 0x000000, "Member 'HUDQuickUseSlotUserWidget_SetInventorySlot::InInventorySlot' has a wrong offset!");

// Function man.NoxiousFocus.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct NoxiousFocus_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NoxiousFocus_PostDamageDealt) == 0x000008, "Wrong alignment on NoxiousFocus_PostDamageDealt");
static_assert(sizeof(NoxiousFocus_PostDamageDealt) == 0x0002D8, "Wrong size on NoxiousFocus_PostDamageDealt");
static_assert(offsetof(NoxiousFocus_PostDamageDealt, Param) == 0x000000, "Member 'NoxiousFocus_PostDamageDealt::Param' has a wrong offset!");

// Function man.JumpPadImplement.TriggerOnComponentBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct JumpPadImplement_TriggerOnComponentBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(JumpPadImplement_TriggerOnComponentBeginOverlap) == 0x000008, "Wrong alignment on JumpPadImplement_TriggerOnComponentBeginOverlap");
static_assert(sizeof(JumpPadImplement_TriggerOnComponentBeginOverlap) == 0x0000A8, "Wrong size on JumpPadImplement_TriggerOnComponentBeginOverlap");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, OverlappedComponent) == 0x000000, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, OtherComp) == 0x000010, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, bFromSweep) == 0x00001C, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentBeginOverlap, SweepResult) == 0x000020, "Member 'JumpPadImplement_TriggerOnComponentBeginOverlap::SweepResult' has a wrong offset!");

// Function man.JumpPadImplement.TriggerOnComponentEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct JumpPadImplement_TriggerOnComponentEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(JumpPadImplement_TriggerOnComponentEndOverlap) == 0x000008, "Wrong alignment on JumpPadImplement_TriggerOnComponentEndOverlap");
static_assert(sizeof(JumpPadImplement_TriggerOnComponentEndOverlap) == 0x000020, "Wrong size on JumpPadImplement_TriggerOnComponentEndOverlap");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentEndOverlap, OverlappedComponent) == 0x000000, "Member 'JumpPadImplement_TriggerOnComponentEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentEndOverlap, OtherActor) == 0x000008, "Member 'JumpPadImplement_TriggerOnComponentEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentEndOverlap, OtherComp) == 0x000010, "Member 'JumpPadImplement_TriggerOnComponentEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(JumpPadImplement_TriggerOnComponentEndOverlap, OtherBodyIndex) == 0x000018, "Member 'JumpPadImplement_TriggerOnComponentEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.BurningBloodPassive.AbilityStart
// 0x0010 (0x0010 - 0x0000)
struct BurningBloodPassive_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BurningBloodPassive_AbilityStart) == 0x000008, "Wrong alignment on BurningBloodPassive_AbilityStart");
static_assert(sizeof(BurningBloodPassive_AbilityStart) == 0x000010, "Wrong size on BurningBloodPassive_AbilityStart");
static_assert(offsetof(BurningBloodPassive_AbilityStart, Ability) == 0x000000, "Member 'BurningBloodPassive_AbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(BurningBloodPassive_AbilityStart, bDesired) == 0x000008, "Member 'BurningBloodPassive_AbilityStart::bDesired' has a wrong offset!");

// Function man.BurningBloodPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct BurningBloodPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BurningBloodPassive_DamageDealt) == 0x000008, "Wrong alignment on BurningBloodPassive_DamageDealt");
static_assert(sizeof(BurningBloodPassive_DamageDealt) == 0x0002D8, "Wrong size on BurningBloodPassive_DamageDealt");
static_assert(offsetof(BurningBloodPassive_DamageDealt, Param) == 0x000000, "Member 'BurningBloodPassive_DamageDealt::Param' has a wrong offset!");

// Function man.BurningBloodPassive.PreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct BurningBloodPassive_PreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BurningBloodPassive_PreDamaged) == 0x000008, "Wrong alignment on BurningBloodPassive_PreDamaged");
static_assert(sizeof(BurningBloodPassive_PreDamaged) == 0x0002D8, "Wrong size on BurningBloodPassive_PreDamaged");
static_assert(offsetof(BurningBloodPassive_PreDamaged, Param) == 0x000000, "Member 'BurningBloodPassive_PreDamaged::Param' has a wrong offset!");

// Function man.InfoScreenUserWidget.GetLeftTextArray
// 0x0018 (0x0018 - 0x0000)
struct InfoScreenUserWidget_GetLeftTextArray final
{
public:
	int32                                         MaxElementNum;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfoScreenUserWidget_GetLeftTextArray) == 0x000008, "Wrong alignment on InfoScreenUserWidget_GetLeftTextArray");
static_assert(sizeof(InfoScreenUserWidget_GetLeftTextArray) == 0x000018, "Wrong size on InfoScreenUserWidget_GetLeftTextArray");
static_assert(offsetof(InfoScreenUserWidget_GetLeftTextArray, MaxElementNum) == 0x000000, "Member 'InfoScreenUserWidget_GetLeftTextArray::MaxElementNum' has a wrong offset!");
static_assert(offsetof(InfoScreenUserWidget_GetLeftTextArray, ReturnValue) == 0x000008, "Member 'InfoScreenUserWidget_GetLeftTextArray::ReturnValue' has a wrong offset!");

// Function man.InfoScreenUserWidget.GetRightTextArray
// 0x0018 (0x0018 - 0x0000)
struct InfoScreenUserWidget_GetRightTextArray final
{
public:
	int32                                         MaxElementNum;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftColumnNum;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfoScreenUserWidget_GetRightTextArray) == 0x000008, "Wrong alignment on InfoScreenUserWidget_GetRightTextArray");
static_assert(sizeof(InfoScreenUserWidget_GetRightTextArray) == 0x000018, "Wrong size on InfoScreenUserWidget_GetRightTextArray");
static_assert(offsetof(InfoScreenUserWidget_GetRightTextArray, MaxElementNum) == 0x000000, "Member 'InfoScreenUserWidget_GetRightTextArray::MaxElementNum' has a wrong offset!");
static_assert(offsetof(InfoScreenUserWidget_GetRightTextArray, LeftColumnNum) == 0x000004, "Member 'InfoScreenUserWidget_GetRightTextArray::LeftColumnNum' has a wrong offset!");
static_assert(offsetof(InfoScreenUserWidget_GetRightTextArray, ReturnValue) == 0x000008, "Member 'InfoScreenUserWidget_GetRightTextArray::ReturnValue' has a wrong offset!");

// Function man.InfoScreenUserWidget.OnSetData
// 0x0008 (0x0008 - 0x0000)
struct InfoScreenUserWidget_OnSetData final
{
public:
	class UInfoScreentDataAsset*                  InInfoScreenData;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InfoScreenUserWidget_OnSetData) == 0x000008, "Wrong alignment on InfoScreenUserWidget_OnSetData");
static_assert(sizeof(InfoScreenUserWidget_OnSetData) == 0x000008, "Wrong size on InfoScreenUserWidget_OnSetData");
static_assert(offsetof(InfoScreenUserWidget_OnSetData, InInfoScreenData) == 0x000000, "Member 'InfoScreenUserWidget_OnSetData::InInfoScreenData' has a wrong offset!");

// Function man.ArachnidAnimInstance.AddRopeImpulse
// 0x0004 (0x0004 - 0x0000)
struct ArachnidAnimInstance_AddRopeImpulse final
{
public:
	float                                         Impulse;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArachnidAnimInstance_AddRopeImpulse) == 0x000004, "Wrong alignment on ArachnidAnimInstance_AddRopeImpulse");
static_assert(sizeof(ArachnidAnimInstance_AddRopeImpulse) == 0x000004, "Wrong size on ArachnidAnimInstance_AddRopeImpulse");
static_assert(offsetof(ArachnidAnimInstance_AddRopeImpulse, Impulse) == 0x000000, "Member 'ArachnidAnimInstance_AddRopeImpulse::Impulse' has a wrong offset!");

// Function man.ArachnidAnimInstance.StartMove
// 0x0008 (0x0008 - 0x0000)
struct ArachnidAnimInstance_StartMove final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArachnidAnimInstance_StartMove) == 0x000008, "Wrong alignment on ArachnidAnimInstance_StartMove");
static_assert(sizeof(ArachnidAnimInstance_StartMove) == 0x000008, "Wrong size on ArachnidAnimInstance_StartMove");
static_assert(offsetof(ArachnidAnimInstance_StartMove, AnimSequence) == 0x000000, "Member 'ArachnidAnimInstance_StartMove::AnimSequence' has a wrong offset!");

// Function man.ArachnidAnimInstance.GetHeroLeanAngle
// 0x000C (0x000C - 0x0000)
struct ArachnidAnimInstance_GetHeroLeanAngle final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArachnidAnimInstance_GetHeroLeanAngle) == 0x000004, "Wrong alignment on ArachnidAnimInstance_GetHeroLeanAngle");
static_assert(sizeof(ArachnidAnimInstance_GetHeroLeanAngle) == 0x00000C, "Wrong size on ArachnidAnimInstance_GetHeroLeanAngle");
static_assert(offsetof(ArachnidAnimInstance_GetHeroLeanAngle, SocketName) == 0x000000, "Member 'ArachnidAnimInstance_GetHeroLeanAngle::SocketName' has a wrong offset!");
static_assert(offsetof(ArachnidAnimInstance_GetHeroLeanAngle, ReturnValue) == 0x000008, "Member 'ArachnidAnimInstance_GetHeroLeanAngle::ReturnValue' has a wrong offset!");

// Function man.ArmorBreakerPassive.PostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct ArmorBreakerPassive_PostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArmorBreakerPassive_PostDamageCaused) == 0x000008, "Wrong alignment on ArmorBreakerPassive_PostDamageCaused");
static_assert(sizeof(ArmorBreakerPassive_PostDamageCaused) == 0x0002D8, "Wrong size on ArmorBreakerPassive_PostDamageCaused");
static_assert(offsetof(ArmorBreakerPassive_PostDamageCaused, Param) == 0x000000, "Member 'ArmorBreakerPassive_PostDamageCaused::Param' has a wrong offset!");

// Function man.ArmorBreakerPassive.PostDamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct ArmorBreakerPassive_PostDamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArmorBreakerPassive_PostDamageReceived) == 0x000008, "Wrong alignment on ArmorBreakerPassive_PostDamageReceived");
static_assert(sizeof(ArmorBreakerPassive_PostDamageReceived) == 0x0002D8, "Wrong size on ArmorBreakerPassive_PostDamageReceived");
static_assert(offsetof(ArmorBreakerPassive_PostDamageReceived, Param) == 0x000000, "Member 'ArmorBreakerPassive_PostDamageReceived::Param' has a wrong offset!");

// Function man.ArtbookUserWidget.OnSetPage
// 0x0020 (0x0020 - 0x0000)
struct ArtbookUserWidget_OnSetPage final
{
public:
	class FText                                   InPageNumber;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InCurrentPage;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxPage;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArtbookUserWidget_OnSetPage) == 0x000008, "Wrong alignment on ArtbookUserWidget_OnSetPage");
static_assert(sizeof(ArtbookUserWidget_OnSetPage) == 0x000020, "Wrong size on ArtbookUserWidget_OnSetPage");
static_assert(offsetof(ArtbookUserWidget_OnSetPage, InPageNumber) == 0x000000, "Member 'ArtbookUserWidget_OnSetPage::InPageNumber' has a wrong offset!");
static_assert(offsetof(ArtbookUserWidget_OnSetPage, InCurrentPage) == 0x000018, "Member 'ArtbookUserWidget_OnSetPage::InCurrentPage' has a wrong offset!");
static_assert(offsetof(ArtbookUserWidget_OnSetPage, InMaxPage) == 0x00001C, "Member 'ArtbookUserWidget_OnSetPage::InMaxPage' has a wrong offset!");

// Function man.ArtbookUserWidget.SetPage
// 0x0004 (0x0004 - 0x0000)
struct ArtbookUserWidget_SetPage final
{
public:
	int32                                         InPageIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArtbookUserWidget_SetPage) == 0x000004, "Wrong alignment on ArtbookUserWidget_SetPage");
static_assert(sizeof(ArtbookUserWidget_SetPage) == 0x000004, "Wrong size on ArtbookUserWidget_SetPage");
static_assert(offsetof(ArtbookUserWidget_SetPage, InPageIndex) == 0x000000, "Member 'ArtbookUserWidget_SetPage::InPageIndex' has a wrong offset!");

// Function man.AttributeContainer.BPGetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct AttributeContainer_BPGetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_BPGetMaxHealth) == 0x000004, "Wrong alignment on AttributeContainer_BPGetMaxHealth");
static_assert(sizeof(AttributeContainer_BPGetMaxHealth) == 0x000004, "Wrong size on AttributeContainer_BPGetMaxHealth");
static_assert(offsetof(AttributeContainer_BPGetMaxHealth, ReturnValue) == 0x000000, "Member 'AttributeContainer_BPGetMaxHealth::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.BPHasEntityTag
// 0x000C (0x000C - 0x0000)
struct AttributeContainer_BPHasEntityTag final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_BPHasEntityTag) == 0x000004, "Wrong alignment on AttributeContainer_BPHasEntityTag");
static_assert(sizeof(AttributeContainer_BPHasEntityTag) == 0x00000C, "Wrong size on AttributeContainer_BPHasEntityTag");
static_assert(offsetof(AttributeContainer_BPHasEntityTag, TagName) == 0x000000, "Member 'AttributeContainer_BPHasEntityTag::TagName' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPHasEntityTag, ReturnValue) == 0x000008, "Member 'AttributeContainer_BPHasEntityTag::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.BPModifyAttribute
// 0x0018 (0x0018 - 0x0000)
struct AttributeContainer_BPModifyAttribute final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeModifier                     Modifier;                                          // 0x0004(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApply;                                            // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeContainer_BPModifyAttribute) == 0x000004, "Wrong alignment on AttributeContainer_BPModifyAttribute");
static_assert(sizeof(AttributeContainer_BPModifyAttribute) == 0x000018, "Wrong size on AttributeContainer_BPModifyAttribute");
static_assert(offsetof(AttributeContainer_BPModifyAttribute, attribute) == 0x000000, "Member 'AttributeContainer_BPModifyAttribute::attribute' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPModifyAttribute, Modifier) == 0x000004, "Member 'AttributeContainer_BPModifyAttribute::Modifier' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPModifyAttribute, bApply) == 0x000014, "Member 'AttributeContainer_BPModifyAttribute::bApply' has a wrong offset!");

// Function man.AttributeContainer.BPModifyAttributeByValue
// 0x000C (0x000C - 0x0000)
struct AttributeContainer_BPModifyAttributeByValue final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Add;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveMultiply;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_BPModifyAttributeByValue) == 0x000004, "Wrong alignment on AttributeContainer_BPModifyAttributeByValue");
static_assert(sizeof(AttributeContainer_BPModifyAttributeByValue) == 0x00000C, "Wrong size on AttributeContainer_BPModifyAttributeByValue");
static_assert(offsetof(AttributeContainer_BPModifyAttributeByValue, attribute) == 0x000000, "Member 'AttributeContainer_BPModifyAttributeByValue::attribute' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPModifyAttributeByValue, Add) == 0x000004, "Member 'AttributeContainer_BPModifyAttributeByValue::Add' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPModifyAttributeByValue, AdditiveMultiply) == 0x000008, "Member 'AttributeContainer_BPModifyAttributeByValue::AdditiveMultiply' has a wrong offset!");

// Function man.AttributeContainer.BPSetAttributeBaseValue
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_BPSetAttributeBaseValue final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_BPSetAttributeBaseValue) == 0x000004, "Wrong alignment on AttributeContainer_BPSetAttributeBaseValue");
static_assert(sizeof(AttributeContainer_BPSetAttributeBaseValue) == 0x000008, "Wrong size on AttributeContainer_BPSetAttributeBaseValue");
static_assert(offsetof(AttributeContainer_BPSetAttributeBaseValue, attribute) == 0x000000, "Member 'AttributeContainer_BPSetAttributeBaseValue::attribute' has a wrong offset!");
static_assert(offsetof(AttributeContainer_BPSetAttributeBaseValue, Value) == 0x000004, "Member 'AttributeContainer_BPSetAttributeBaseValue::Value' has a wrong offset!");

// Function man.AttributeContainer.GetAttributeValue
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_GetAttributeValue final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_GetAttributeValue) == 0x000004, "Wrong alignment on AttributeContainer_GetAttributeValue");
static_assert(sizeof(AttributeContainer_GetAttributeValue) == 0x000008, "Wrong size on AttributeContainer_GetAttributeValue");
static_assert(offsetof(AttributeContainer_GetAttributeValue, attribute) == 0x000000, "Member 'AttributeContainer_GetAttributeValue::attribute' has a wrong offset!");
static_assert(offsetof(AttributeContainer_GetAttributeValue, ReturnValue) == 0x000004, "Member 'AttributeContainer_GetAttributeValue::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.IsResourceLessThanPercent
// 0x000C (0x000C - 0x0000)
struct AttributeContainer_IsResourceLessThanPercent final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Percent;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeContainer_IsResourceLessThanPercent) == 0x000004, "Wrong alignment on AttributeContainer_IsResourceLessThanPercent");
static_assert(sizeof(AttributeContainer_IsResourceLessThanPercent) == 0x00000C, "Wrong size on AttributeContainer_IsResourceLessThanPercent");
static_assert(offsetof(AttributeContainer_IsResourceLessThanPercent, resource) == 0x000000, "Member 'AttributeContainer_IsResourceLessThanPercent::resource' has a wrong offset!");
static_assert(offsetof(AttributeContainer_IsResourceLessThanPercent, Percent) == 0x000004, "Member 'AttributeContainer_IsResourceLessThanPercent::Percent' has a wrong offset!");
static_assert(offsetof(AttributeContainer_IsResourceLessThanPercent, ReturnValue) == 0x000008, "Member 'AttributeContainer_IsResourceLessThanPercent::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.ModifyComboPointFractions
// 0x0004 (0x0004 - 0x0000)
struct AttributeContainer_ModifyComboPointFractions final
{
public:
	int32                                         Modif;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_ModifyComboPointFractions) == 0x000004, "Wrong alignment on AttributeContainer_ModifyComboPointFractions");
static_assert(sizeof(AttributeContainer_ModifyComboPointFractions) == 0x000004, "Wrong size on AttributeContainer_ModifyComboPointFractions");
static_assert(offsetof(AttributeContainer_ModifyComboPointFractions, Modif) == 0x000000, "Member 'AttributeContainer_ModifyComboPointFractions::Modif' has a wrong offset!");

// Function man.AttributeContainer.ModifyComboPoints
// 0x0010 (0x0010 - 0x0000)
struct AttributeContainer_ModifyComboPoints final
{
public:
	int32                                         Modif;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireEvent;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_ModifyComboPoints) == 0x000008, "Wrong alignment on AttributeContainer_ModifyComboPoints");
static_assert(sizeof(AttributeContainer_ModifyComboPoints) == 0x000010, "Wrong size on AttributeContainer_ModifyComboPoints");
static_assert(offsetof(AttributeContainer_ModifyComboPoints, Modif) == 0x000000, "Member 'AttributeContainer_ModifyComboPoints::Modif' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyComboPoints, bFireEvent) == 0x000004, "Member 'AttributeContainer_ModifyComboPoints::bFireEvent' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyComboPoints, SourceAbility) == 0x000008, "Member 'AttributeContainer_ModifyComboPoints::SourceAbility' has a wrong offset!");

// Function man.AttributeContainer.ModifyEnergy
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_ModifyEnergy final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_ModifyEnergy) == 0x000004, "Wrong alignment on AttributeContainer_ModifyEnergy");
static_assert(sizeof(AttributeContainer_ModifyEnergy) == 0x000008, "Wrong size on AttributeContainer_ModifyEnergy");
static_assert(offsetof(AttributeContainer_ModifyEnergy, Value) == 0x000000, "Member 'AttributeContainer_ModifyEnergy::Value' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyEnergy, ReturnValue) == 0x000004, "Member 'AttributeContainer_ModifyEnergy::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.ModifyEntropicEssence
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_ModifyEntropicEssence final
{
public:
	int32                                         Modification;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUINotif;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeContainer_ModifyEntropicEssence) == 0x000004, "Wrong alignment on AttributeContainer_ModifyEntropicEssence");
static_assert(sizeof(AttributeContainer_ModifyEntropicEssence) == 0x000008, "Wrong size on AttributeContainer_ModifyEntropicEssence");
static_assert(offsetof(AttributeContainer_ModifyEntropicEssence, Modification) == 0x000000, "Member 'AttributeContainer_ModifyEntropicEssence::Modification' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyEntropicEssence, bUINotif) == 0x000004, "Member 'AttributeContainer_ModifyEntropicEssence::bUINotif' has a wrong offset!");

// Function man.AttributeContainer.ModifyEssence
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_ModifyEssence final
{
public:
	int32                                         Modification;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUINotif;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyEssenceModifier;                             // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdatePlayerStatistics;                           // 0x0006(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeContainer_ModifyEssence) == 0x000004, "Wrong alignment on AttributeContainer_ModifyEssence");
static_assert(sizeof(AttributeContainer_ModifyEssence) == 0x000008, "Wrong size on AttributeContainer_ModifyEssence");
static_assert(offsetof(AttributeContainer_ModifyEssence, Modification) == 0x000000, "Member 'AttributeContainer_ModifyEssence::Modification' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyEssence, bUINotif) == 0x000004, "Member 'AttributeContainer_ModifyEssence::bUINotif' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyEssence, bApplyEssenceModifier) == 0x000005, "Member 'AttributeContainer_ModifyEssence::bApplyEssenceModifier' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyEssence, bUpdatePlayerStatistics) == 0x000006, "Member 'AttributeContainer_ModifyEssence::bUpdatePlayerStatistics' has a wrong offset!");

// Function man.AttributeContainer.ModifyRage
// 0x000C (0x000C - 0x0000)
struct AttributeContainer_ModifyRage final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerEvent;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_ModifyRage) == 0x000004, "Wrong alignment on AttributeContainer_ModifyRage");
static_assert(sizeof(AttributeContainer_ModifyRage) == 0x00000C, "Wrong size on AttributeContainer_ModifyRage");
static_assert(offsetof(AttributeContainer_ModifyRage, Value) == 0x000000, "Member 'AttributeContainer_ModifyRage::Value' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyRage, bTriggerEvent) == 0x000004, "Member 'AttributeContainer_ModifyRage::bTriggerEvent' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyRage, ReturnValue) == 0x000008, "Member 'AttributeContainer_ModifyRage::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.ModifyStamina
// 0x0008 (0x0008 - 0x0000)
struct AttributeContainer_ModifyStamina final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_ModifyStamina) == 0x000004, "Wrong alignment on AttributeContainer_ModifyStamina");
static_assert(sizeof(AttributeContainer_ModifyStamina) == 0x000008, "Wrong size on AttributeContainer_ModifyStamina");
static_assert(offsetof(AttributeContainer_ModifyStamina, Value) == 0x000000, "Member 'AttributeContainer_ModifyStamina::Value' has a wrong offset!");
static_assert(offsetof(AttributeContainer_ModifyStamina, ReturnValue) == 0x000004, "Member 'AttributeContainer_ModifyStamina::ReturnValue' has a wrong offset!");

// Function man.AttributeContainer.GetCharacterName
// 0x0020 (0x0020 - 0x0000)
struct AttributeContainer_GetCharacterName final
{
public:
	bool                                          bUIName;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContainer_GetCharacterName) == 0x000008, "Wrong alignment on AttributeContainer_GetCharacterName");
static_assert(sizeof(AttributeContainer_GetCharacterName) == 0x000020, "Wrong size on AttributeContainer_GetCharacterName");
static_assert(offsetof(AttributeContainer_GetCharacterName, bUIName) == 0x000000, "Member 'AttributeContainer_GetCharacterName::bUIName' has a wrong offset!");
static_assert(offsetof(AttributeContainer_GetCharacterName, ReturnValue) == 0x000008, "Member 'AttributeContainer_GetCharacterName::ReturnValue' has a wrong offset!");

// Function man.AutotesterAI.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct AutotesterAI_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutotesterAI_OnPreDamageCaused) == 0x000008, "Wrong alignment on AutotesterAI_OnPreDamageCaused");
static_assert(sizeof(AutotesterAI_OnPreDamageCaused) == 0x0002D8, "Wrong size on AutotesterAI_OnPreDamageCaused");
static_assert(offsetof(AutotesterAI_OnPreDamageCaused, Param) == 0x000000, "Member 'AutotesterAI_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.AutotesterAI.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct AutotesterAI_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutotesterAI_OnPreDamagedPriority) == 0x000008, "Wrong alignment on AutotesterAI_OnPreDamagedPriority");
static_assert(sizeof(AutotesterAI_OnPreDamagedPriority) == 0x0002D8, "Wrong size on AutotesterAI_OnPreDamagedPriority");
static_assert(offsetof(AutotesterAI_OnPreDamagedPriority, Param) == 0x000000, "Member 'AutotesterAI_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.AvatarOfFireAbility.OnAbilityStartEvent
// 0x0008 (0x0008 - 0x0000)
struct AvatarOfFireAbility_OnAbilityStartEvent final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarOfFireAbility_OnAbilityStartEvent) == 0x000008, "Wrong alignment on AvatarOfFireAbility_OnAbilityStartEvent");
static_assert(sizeof(AvatarOfFireAbility_OnAbilityStartEvent) == 0x000008, "Wrong size on AvatarOfFireAbility_OnAbilityStartEvent");
static_assert(offsetof(AvatarOfFireAbility_OnAbilityStartEvent, Ability) == 0x000000, "Member 'AvatarOfFireAbility_OnAbilityStartEvent::Ability' has a wrong offset!");

// Function man.AvatarOfFireAbility.StatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct AvatarOfFireAbility_StatusEffectCaused final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvatarOfFireAbility_StatusEffectCaused) == 0x000008, "Wrong alignment on AvatarOfFireAbility_StatusEffectCaused");
static_assert(sizeof(AvatarOfFireAbility_StatusEffectCaused) == 0x000018, "Wrong size on AvatarOfFireAbility_StatusEffectCaused");
static_assert(offsetof(AvatarOfFireAbility_StatusEffectCaused, TargetActor) == 0x000000, "Member 'AvatarOfFireAbility_StatusEffectCaused::TargetActor' has a wrong offset!");
static_assert(offsetof(AvatarOfFireAbility_StatusEffectCaused, Type) == 0x000008, "Member 'AvatarOfFireAbility_StatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(AvatarOfFireAbility_StatusEffectCaused, IsNewEffect) == 0x000009, "Member 'AvatarOfFireAbility_StatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(AvatarOfFireAbility_StatusEffectCaused, Instance) == 0x000010, "Member 'AvatarOfFireAbility_StatusEffectCaused::Instance' has a wrong offset!");

// Function man.BanditBruteBossAI.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct BanditBruteBossAI_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BanditBruteBossAI_OnPreDamagedPriority) == 0x000008, "Wrong alignment on BanditBruteBossAI_OnPreDamagedPriority");
static_assert(sizeof(BanditBruteBossAI_OnPreDamagedPriority) == 0x0002D8, "Wrong size on BanditBruteBossAI_OnPreDamagedPriority");
static_assert(offsetof(BanditBruteBossAI_OnPreDamagedPriority, Param) == 0x000000, "Member 'BanditBruteBossAI_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.BarricadeActor.BeginOverlap
// 0x0008 (0x0008 - 0x0000)
struct BarricadeActor_BeginOverlap final
{
public:
	class AEnemyCharacter*                        Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BarricadeActor_BeginOverlap) == 0x000008, "Wrong alignment on BarricadeActor_BeginOverlap");
static_assert(sizeof(BarricadeActor_BeginOverlap) == 0x000008, "Wrong size on BarricadeActor_BeginOverlap");
static_assert(offsetof(BarricadeActor_BeginOverlap, Enemy) == 0x000000, "Member 'BarricadeActor_BeginOverlap::Enemy' has a wrong offset!");

// Function man.BarricadeActor.BeginProjectileOverlap
// 0x0008 (0x0008 - 0x0000)
struct BarricadeActor_BeginProjectileOverlap final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BarricadeActor_BeginProjectileOverlap) == 0x000008, "Wrong alignment on BarricadeActor_BeginProjectileOverlap");
static_assert(sizeof(BarricadeActor_BeginProjectileOverlap) == 0x000008, "Wrong size on BarricadeActor_BeginProjectileOverlap");
static_assert(offsetof(BarricadeActor_BeginProjectileOverlap, Projectile) == 0x000000, "Member 'BarricadeActor_BeginProjectileOverlap::Projectile' has a wrong offset!");

// Function man.BarricadeActor.EndOverlap
// 0x0008 (0x0008 - 0x0000)
struct BarricadeActor_EndOverlap final
{
public:
	class AEnemyCharacter*                        Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BarricadeActor_EndOverlap) == 0x000008, "Wrong alignment on BarricadeActor_EndOverlap");
static_assert(sizeof(BarricadeActor_EndOverlap) == 0x000008, "Wrong size on BarricadeActor_EndOverlap");
static_assert(offsetof(BarricadeActor_EndOverlap, Enemy) == 0x000000, "Member 'BarricadeActor_EndOverlap::Enemy' has a wrong offset!");

// Function man.BarricadeActor.PreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct BarricadeActor_PreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BarricadeActor_PreDamaged) == 0x000008, "Wrong alignment on BarricadeActor_PreDamaged");
static_assert(sizeof(BarricadeActor_PreDamaged) == 0x0002D8, "Wrong size on BarricadeActor_PreDamaged");
static_assert(offsetof(BarricadeActor_PreDamaged, Param) == 0x000000, "Member 'BarricadeActor_PreDamaged::Param' has a wrong offset!");

// Function man.HeroShadowStepAbility.GetTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct HeroShadowStepAbility_GetTargetLocation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroShadowStepAbility_GetTargetLocation) == 0x000004, "Wrong alignment on HeroShadowStepAbility_GetTargetLocation");
static_assert(sizeof(HeroShadowStepAbility_GetTargetLocation) == 0x000010, "Wrong size on HeroShadowStepAbility_GetTargetLocation");
static_assert(offsetof(HeroShadowStepAbility_GetTargetLocation, TargetLocation) == 0x000000, "Member 'HeroShadowStepAbility_GetTargetLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(HeroShadowStepAbility_GetTargetLocation, ReturnValue) == 0x00000C, "Member 'HeroShadowStepAbility_GetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.BloodStainVisualEntity.BloodStainBuildupPostConstructionFinished
// 0x0020 (0x0020 - 0x0000)
struct BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished final
{
public:
	struct FVector                                DamagePosition;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplashRadius;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageTakenVFXDataAsset*               BloodSourceAsset;                                  // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished) == 0x000008, "Wrong alignment on BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished");
static_assert(sizeof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished) == 0x000020, "Wrong size on BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished");
static_assert(offsetof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished, DamagePosition) == 0x000000, "Member 'BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished::DamagePosition' has a wrong offset!");
static_assert(offsetof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished, SplashRadius) == 0x00000C, "Member 'BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished::SplashRadius' has a wrong offset!");
static_assert(offsetof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished, Stage) == 0x000010, "Member 'BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished::Stage' has a wrong offset!");
static_assert(offsetof(BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished, BloodSourceAsset) == 0x000018, "Member 'BloodStainVisualEntity_BloodStainBuildupPostConstructionFinished::BloodSourceAsset' has a wrong offset!");

// Function man.HeroBase.AbilityFourAxis
// 0x0004 (0x0004 - 0x0000)
struct HeroBase_AbilityFourAxis final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_AbilityFourAxis) == 0x000004, "Wrong alignment on HeroBase_AbilityFourAxis");
static_assert(sizeof(HeroBase_AbilityFourAxis) == 0x000004, "Wrong size on HeroBase_AbilityFourAxis");
static_assert(offsetof(HeroBase_AbilityFourAxis, Value) == 0x000000, "Member 'HeroBase_AbilityFourAxis::Value' has a wrong offset!");

// Function man.HeroBase.BPGetEntropyLantern
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_BPGetEntropyLantern final
{
public:
	class UEntropyLantern*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_BPGetEntropyLantern) == 0x000008, "Wrong alignment on HeroBase_BPGetEntropyLantern");
static_assert(sizeof(HeroBase_BPGetEntropyLantern) == 0x000008, "Wrong size on HeroBase_BPGetEntropyLantern");
static_assert(offsetof(HeroBase_BPGetEntropyLantern, ReturnValue) == 0x000000, "Member 'HeroBase_BPGetEntropyLantern::ReturnValue' has a wrong offset!");

// Function man.HeroBase.BPOnGrabpointGrabbed
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_BPOnGrabpointGrabbed final
{
public:
	class AGrabPoint*                             GrabPoint;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_BPOnGrabpointGrabbed) == 0x000008, "Wrong alignment on HeroBase_BPOnGrabpointGrabbed");
static_assert(sizeof(HeroBase_BPOnGrabpointGrabbed) == 0x000008, "Wrong size on HeroBase_BPOnGrabpointGrabbed");
static_assert(offsetof(HeroBase_BPOnGrabpointGrabbed, GrabPoint) == 0x000000, "Member 'HeroBase_BPOnGrabpointGrabbed::GrabPoint' has a wrong offset!");

// Function man.HeroBase.BPTeleportToLevel
// 0x0038 (0x0038 - 0x0000)
struct HeroBase_BPTeleportToLevel final
{
public:
	TSoftObjectPtr<class UWorld>                  LevelReference;                                    // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportTargetName;                                // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckpointData*                        TargetCheckpoint;                                  // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_BPTeleportToLevel) == 0x000008, "Wrong alignment on HeroBase_BPTeleportToLevel");
static_assert(sizeof(HeroBase_BPTeleportToLevel) == 0x000038, "Wrong size on HeroBase_BPTeleportToLevel");
static_assert(offsetof(HeroBase_BPTeleportToLevel, LevelReference) == 0x000000, "Member 'HeroBase_BPTeleportToLevel::LevelReference' has a wrong offset!");
static_assert(offsetof(HeroBase_BPTeleportToLevel, TeleportTargetName) == 0x000028, "Member 'HeroBase_BPTeleportToLevel::TeleportTargetName' has a wrong offset!");
static_assert(offsetof(HeroBase_BPTeleportToLevel, TargetCheckpoint) == 0x000030, "Member 'HeroBase_BPTeleportToLevel::TargetCheckpoint' has a wrong offset!");

// Function man.HeroBase.BPTeleportToLocation
// 0x0030 (0x0030 - 0x0000)
struct HeroBase_BPTeleportToLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipFadeOut;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnFadeInStarted;                                   // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFadeInFinished;                                  // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_BPTeleportToLocation) == 0x000004, "Wrong alignment on HeroBase_BPTeleportToLocation");
static_assert(sizeof(HeroBase_BPTeleportToLocation) == 0x000030, "Wrong size on HeroBase_BPTeleportToLocation");
static_assert(offsetof(HeroBase_BPTeleportToLocation, NewLocation) == 0x000000, "Member 'HeroBase_BPTeleportToLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(HeroBase_BPTeleportToLocation, bSkipFadeOut) == 0x00000C, "Member 'HeroBase_BPTeleportToLocation::bSkipFadeOut' has a wrong offset!");
static_assert(offsetof(HeroBase_BPTeleportToLocation, OnFadeInStarted) == 0x000010, "Member 'HeroBase_BPTeleportToLocation::OnFadeInStarted' has a wrong offset!");
static_assert(offsetof(HeroBase_BPTeleportToLocation, OnFadeInFinished) == 0x000020, "Member 'HeroBase_BPTeleportToLocation::OnFadeInFinished' has a wrong offset!");

// Function man.HeroBase.GetOffhandAbilitySlot
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_GetOffhandAbilitySlot final
{
public:
	class UAbilityBase*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_GetOffhandAbilitySlot) == 0x000008, "Wrong alignment on HeroBase_GetOffhandAbilitySlot");
static_assert(sizeof(HeroBase_GetOffhandAbilitySlot) == 0x000008, "Wrong size on HeroBase_GetOffhandAbilitySlot");
static_assert(offsetof(HeroBase_GetOffhandAbilitySlot, ReturnValue) == 0x000000, "Member 'HeroBase_GetOffhandAbilitySlot::ReturnValue' has a wrong offset!");

// Function man.HeroBase.InteractWithTarget
// 0x0010 (0x0010 - 0x0000)
struct HeroBase_InteractWithTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroBase_InteractWithTarget) == 0x000008, "Wrong alignment on HeroBase_InteractWithTarget");
static_assert(sizeof(HeroBase_InteractWithTarget) == 0x000010, "Wrong size on HeroBase_InteractWithTarget");
static_assert(offsetof(HeroBase_InteractWithTarget, TargetActor) == 0x000000, "Member 'HeroBase_InteractWithTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(HeroBase_InteractWithTarget, ReturnValue) == 0x000008, "Member 'HeroBase_InteractWithTarget::ReturnValue' has a wrong offset!");

// Function man.HeroBase.OnActorBeginOverlapHandler
// 0x0010 (0x0010 - 0x0000)
struct HeroBase_OnActorBeginOverlapHandler final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnActorBeginOverlapHandler) == 0x000008, "Wrong alignment on HeroBase_OnActorBeginOverlapHandler");
static_assert(sizeof(HeroBase_OnActorBeginOverlapHandler) == 0x000010, "Wrong size on HeroBase_OnActorBeginOverlapHandler");
static_assert(offsetof(HeroBase_OnActorBeginOverlapHandler, OverlappedActor) == 0x000000, "Member 'HeroBase_OnActorBeginOverlapHandler::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnActorBeginOverlapHandler, OtherActor) == 0x000008, "Member 'HeroBase_OnActorBeginOverlapHandler::OtherActor' has a wrong offset!");

// Function man.HeroBase.OnActorEndOverlapHandler
// 0x0010 (0x0010 - 0x0000)
struct HeroBase_OnActorEndOverlapHandler final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnActorEndOverlapHandler) == 0x000008, "Wrong alignment on HeroBase_OnActorEndOverlapHandler");
static_assert(sizeof(HeroBase_OnActorEndOverlapHandler) == 0x000010, "Wrong size on HeroBase_OnActorEndOverlapHandler");
static_assert(offsetof(HeroBase_OnActorEndOverlapHandler, OverlappedActor) == 0x000000, "Member 'HeroBase_OnActorEndOverlapHandler::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnActorEndOverlapHandler, OtherActor) == 0x000008, "Member 'HeroBase_OnActorEndOverlapHandler::OtherActor' has a wrong offset!");

// Function man.HeroBase.OnBeginOverlapVisualComponent
// 0x00A8 (0x00A8 - 0x0000)
struct HeroBase_OnBeginOverlapVisualComponent final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnBeginOverlapVisualComponent) == 0x000008, "Wrong alignment on HeroBase_OnBeginOverlapVisualComponent");
static_assert(sizeof(HeroBase_OnBeginOverlapVisualComponent) == 0x0000A8, "Wrong size on HeroBase_OnBeginOverlapVisualComponent");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, OverlappedComponent) == 0x000000, "Member 'HeroBase_OnBeginOverlapVisualComponent::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, OtherActor) == 0x000008, "Member 'HeroBase_OnBeginOverlapVisualComponent::OtherActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, OtherComp) == 0x000010, "Member 'HeroBase_OnBeginOverlapVisualComponent::OtherComp' has a wrong offset!");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, OtherBodyIndex) == 0x000018, "Member 'HeroBase_OnBeginOverlapVisualComponent::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, bFromSweep) == 0x00001C, "Member 'HeroBase_OnBeginOverlapVisualComponent::bFromSweep' has a wrong offset!");
static_assert(offsetof(HeroBase_OnBeginOverlapVisualComponent, SweepResult) == 0x000020, "Member 'HeroBase_OnBeginOverlapVisualComponent::SweepResult' has a wrong offset!");

// Function man.HeroBase.OnDeathEssencePickup
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_OnDeathEssencePickup final
{
public:
	class UAbilityBase*                           DeathEssenceAbility;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnDeathEssencePickup) == 0x000008, "Wrong alignment on HeroBase_OnDeathEssencePickup");
static_assert(sizeof(HeroBase_OnDeathEssencePickup) == 0x000008, "Wrong size on HeroBase_OnDeathEssencePickup");
static_assert(offsetof(HeroBase_OnDeathEssencePickup, DeathEssenceAbility) == 0x000000, "Member 'HeroBase_OnDeathEssencePickup::DeathEssenceAbility' has a wrong offset!");

// Function man.HeroBase.OnEndOverlapVisualComponent
// 0x0020 (0x0020 - 0x0000)
struct HeroBase_OnEndOverlapVisualComponent final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroBase_OnEndOverlapVisualComponent) == 0x000008, "Wrong alignment on HeroBase_OnEndOverlapVisualComponent");
static_assert(sizeof(HeroBase_OnEndOverlapVisualComponent) == 0x000020, "Wrong size on HeroBase_OnEndOverlapVisualComponent");
static_assert(offsetof(HeroBase_OnEndOverlapVisualComponent, OverlappedComponent) == 0x000000, "Member 'HeroBase_OnEndOverlapVisualComponent::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(HeroBase_OnEndOverlapVisualComponent, OtherActor) == 0x000008, "Member 'HeroBase_OnEndOverlapVisualComponent::OtherActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnEndOverlapVisualComponent, OtherComp) == 0x000010, "Member 'HeroBase_OnEndOverlapVisualComponent::OtherComp' has a wrong offset!");
static_assert(offsetof(HeroBase_OnEndOverlapVisualComponent, OtherBodyIndex) == 0x000018, "Member 'HeroBase_OnEndOverlapVisualComponent::OtherBodyIndex' has a wrong offset!");

// Function man.HeroBase.OnGrapplingHookStart
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_OnGrapplingHookStart final
{
public:
	class AActor*                                 GrapplingHook;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnGrapplingHookStart) == 0x000008, "Wrong alignment on HeroBase_OnGrapplingHookStart");
static_assert(sizeof(HeroBase_OnGrapplingHookStart) == 0x000008, "Wrong size on HeroBase_OnGrapplingHookStart");
static_assert(offsetof(HeroBase_OnGrapplingHookStart, GrapplingHook) == 0x000000, "Member 'HeroBase_OnGrapplingHookStart::GrapplingHook' has a wrong offset!");

// Function man.HeroBase.OnHealthChanged
// 0x0008 (0x0008 - 0x0000)
struct HeroBase_OnHealthChanged final
{
public:
	float                                         preHealth;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         newHealth;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnHealthChanged) == 0x000004, "Wrong alignment on HeroBase_OnHealthChanged");
static_assert(sizeof(HeroBase_OnHealthChanged) == 0x000008, "Wrong size on HeroBase_OnHealthChanged");
static_assert(offsetof(HeroBase_OnHealthChanged, preHealth) == 0x000000, "Member 'HeroBase_OnHealthChanged::preHealth' has a wrong offset!");
static_assert(offsetof(HeroBase_OnHealthChanged, newHealth) == 0x000004, "Member 'HeroBase_OnHealthChanged::newHealth' has a wrong offset!");

// Function man.HeroBase.OnOverlap
// 0x0010 (0x0010 - 0x0000)
struct HeroBase_OnOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnOverlap) == 0x000008, "Wrong alignment on HeroBase_OnOverlap");
static_assert(sizeof(HeroBase_OnOverlap) == 0x000010, "Wrong size on HeroBase_OnOverlap");
static_assert(offsetof(HeroBase_OnOverlap, OverlappedActor) == 0x000000, "Member 'HeroBase_OnOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnOverlap, OtherActor) == 0x000008, "Member 'HeroBase_OnOverlap::OtherActor' has a wrong offset!");

// Function man.HeroBase.OnOverlapEnd
// 0x0010 (0x0010 - 0x0000)
struct HeroBase_OnOverlapEnd final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_OnOverlapEnd) == 0x000008, "Wrong alignment on HeroBase_OnOverlapEnd");
static_assert(sizeof(HeroBase_OnOverlapEnd) == 0x000010, "Wrong size on HeroBase_OnOverlapEnd");
static_assert(offsetof(HeroBase_OnOverlapEnd, OverlappedActor) == 0x000000, "Member 'HeroBase_OnOverlapEnd::OverlappedActor' has a wrong offset!");
static_assert(offsetof(HeroBase_OnOverlapEnd, OtherActor) == 0x000008, "Member 'HeroBase_OnOverlapEnd::OtherActor' has a wrong offset!");

// Function man.HeroBase.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct HeroBase_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroBase_OnPropertyChanged) == 0x000004, "Wrong alignment on HeroBase_OnPropertyChanged");
static_assert(sizeof(HeroBase_OnPropertyChanged) == 0x000014, "Wrong size on HeroBase_OnPropertyChanged");
static_assert(offsetof(HeroBase_OnPropertyChanged, PropertyType) == 0x000000, "Member 'HeroBase_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(HeroBase_OnPropertyChanged, Value) == 0x000004, "Member 'HeroBase_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(HeroBase_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'HeroBase_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(HeroBase_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'HeroBase_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(HeroBase_OnPropertyChanged, bAnimate) == 0x000010, "Member 'HeroBase_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.HeroBase.PlayerCombatVOEvent
// 0x0001 (0x0001 - 0x0000)
struct HeroBase_PlayerCombatVOEvent final
{
public:
	bool                                          bTaunt;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_PlayerCombatVOEvent) == 0x000001, "Wrong alignment on HeroBase_PlayerCombatVOEvent");
static_assert(sizeof(HeroBase_PlayerCombatVOEvent) == 0x000001, "Wrong size on HeroBase_PlayerCombatVOEvent");
static_assert(offsetof(HeroBase_PlayerCombatVOEvent, bTaunt) == 0x000000, "Member 'HeroBase_PlayerCombatVOEvent::bTaunt' has a wrong offset!");

// Function man.HeroBase.ToggleChaosFactorBlocker
// 0x0001 (0x0001 - 0x0000)
struct HeroBase_ToggleChaosFactorBlocker final
{
public:
	bool                                          bDeactivate;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroBase_ToggleChaosFactorBlocker) == 0x000001, "Wrong alignment on HeroBase_ToggleChaosFactorBlocker");
static_assert(sizeof(HeroBase_ToggleChaosFactorBlocker) == 0x000001, "Wrong size on HeroBase_ToggleChaosFactorBlocker");
static_assert(offsetof(HeroBase_ToggleChaosFactorBlocker, bDeactivate) == 0x000000, "Member 'HeroBase_ToggleChaosFactorBlocker::bDeactivate' has a wrong offset!");

// Function man.BrawlerHero.GetListenerPosition
// 0x000C (0x000C - 0x0000)
struct BrawlerHero_GetListenerPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerHero_GetListenerPosition) == 0x000004, "Wrong alignment on BrawlerHero_GetListenerPosition");
static_assert(sizeof(BrawlerHero_GetListenerPosition) == 0x00000C, "Wrong size on BrawlerHero_GetListenerPosition");
static_assert(offsetof(BrawlerHero_GetListenerPosition, ReturnValue) == 0x000000, "Member 'BrawlerHero_GetListenerPosition::ReturnValue' has a wrong offset!");

// Function man.BrawlerHero.OnLevelSequencePaused
// 0x0001 (0x0001 - 0x0000)
struct BrawlerHero_OnLevelSequencePaused final
{
public:
	bool                                          bPaused;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerHero_OnLevelSequencePaused) == 0x000001, "Wrong alignment on BrawlerHero_OnLevelSequencePaused");
static_assert(sizeof(BrawlerHero_OnLevelSequencePaused) == 0x000001, "Wrong size on BrawlerHero_OnLevelSequencePaused");
static_assert(offsetof(BrawlerHero_OnLevelSequencePaused, bPaused) == 0x000000, "Member 'BrawlerHero_OnLevelSequencePaused::bPaused' has a wrong offset!");

// Function man.BrawlerHero.IsCameraUpsideDown
// 0x0001 (0x0001 - 0x0000)
struct BrawlerHero_IsCameraUpsideDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BrawlerHero_IsCameraUpsideDown) == 0x000001, "Wrong alignment on BrawlerHero_IsCameraUpsideDown");
static_assert(sizeof(BrawlerHero_IsCameraUpsideDown) == 0x000001, "Wrong size on BrawlerHero_IsCameraUpsideDown");
static_assert(offsetof(BrawlerHero_IsCameraUpsideDown, ReturnValue) == 0x000000, "Member 'BrawlerHero_IsCameraUpsideDown::ReturnValue' has a wrong offset!");

// Function man.CDryadAI.IsValidTeleportPos
// 0x0010 (0x0010 - 0x0000)
struct CDryadAI_IsValidTeleportPos final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOverride;                                      // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutValid;                                         // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CDryadAI_IsValidTeleportPos) == 0x000004, "Wrong alignment on CDryadAI_IsValidTeleportPos");
static_assert(sizeof(CDryadAI_IsValidTeleportPos) == 0x000010, "Wrong size on CDryadAI_IsValidTeleportPos");
static_assert(offsetof(CDryadAI_IsValidTeleportPos, Location) == 0x000000, "Member 'CDryadAI_IsValidTeleportPos::Location' has a wrong offset!");
static_assert(offsetof(CDryadAI_IsValidTeleportPos, bOutOverride) == 0x00000C, "Member 'CDryadAI_IsValidTeleportPos::bOutOverride' has a wrong offset!");
static_assert(offsetof(CDryadAI_IsValidTeleportPos, bOutValid) == 0x00000D, "Member 'CDryadAI_IsValidTeleportPos::bOutValid' has a wrong offset!");

// Function man.ChaoticOverchargePassive.OnChaos
// 0x0008 (0x0008 - 0x0000)
struct ChaoticOverchargePassive_OnChaos final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChaoticOverchargePassive_OnChaos) == 0x000008, "Wrong alignment on ChaoticOverchargePassive_OnChaos");
static_assert(sizeof(ChaoticOverchargePassive_OnChaos) == 0x000008, "Wrong size on ChaoticOverchargePassive_OnChaos");
static_assert(offsetof(ChaoticOverchargePassive_OnChaos, Ability) == 0x000000, "Member 'ChaoticOverchargePassive_OnChaos::Ability' has a wrong offset!");

// Function man.FuryOfTheElements.BPGetDamageTypeForVFX
// 0x0001 (0x0001 - 0x0000)
struct FuryOfTheElements_BPGetDamageTypeForVFX final
{
public:
	EDamageType                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FuryOfTheElements_BPGetDamageTypeForVFX) == 0x000001, "Wrong alignment on FuryOfTheElements_BPGetDamageTypeForVFX");
static_assert(sizeof(FuryOfTheElements_BPGetDamageTypeForVFX) == 0x000001, "Wrong size on FuryOfTheElements_BPGetDamageTypeForVFX");
static_assert(offsetof(FuryOfTheElements_BPGetDamageTypeForVFX, ReturnValue) == 0x000000, "Member 'FuryOfTheElements_BPGetDamageTypeForVFX::ReturnValue' has a wrong offset!");

// Function man.FuryOfTheElements.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct FuryOfTheElements_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FuryOfTheElements_OnPreDamageCaused) == 0x000008, "Wrong alignment on FuryOfTheElements_OnPreDamageCaused");
static_assert(sizeof(FuryOfTheElements_OnPreDamageCaused) == 0x0002D8, "Wrong size on FuryOfTheElements_OnPreDamageCaused");
static_assert(offsetof(FuryOfTheElements_OnPreDamageCaused, Param) == 0x000000, "Member 'FuryOfTheElements_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.FuryOfTheElements.OnResourcesConsumed
// 0x0008 (0x0008 - 0x0000)
struct FuryOfTheElements_OnResourcesConsumed final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FuryOfTheElements_OnResourcesConsumed) == 0x000008, "Wrong alignment on FuryOfTheElements_OnResourcesConsumed");
static_assert(sizeof(FuryOfTheElements_OnResourcesConsumed) == 0x000008, "Wrong size on FuryOfTheElements_OnResourcesConsumed");
static_assert(offsetof(FuryOfTheElements_OnResourcesConsumed, Ability) == 0x000000, "Member 'FuryOfTheElements_OnResourcesConsumed::Ability' has a wrong offset!");

// Function man.CharacterNameUserWidget.OnSetErrorText
// 0x0018 (0x0018 - 0x0000)
struct CharacterNameUserWidget_OnSetErrorText final
{
public:
	class FText                                   InErrorText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterNameUserWidget_OnSetErrorText) == 0x000008, "Wrong alignment on CharacterNameUserWidget_OnSetErrorText");
static_assert(sizeof(CharacterNameUserWidget_OnSetErrorText) == 0x000018, "Wrong size on CharacterNameUserWidget_OnSetErrorText");
static_assert(offsetof(CharacterNameUserWidget_OnSetErrorText, InErrorText) == 0x000000, "Member 'CharacterNameUserWidget_OnSetErrorText::InErrorText' has a wrong offset!");

// Function man.CharacterNameUserWidget.OnTextChanged
// 0x0018 (0x0018 - 0x0000)
struct CharacterNameUserWidget_OnTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterNameUserWidget_OnTextChanged) == 0x000008, "Wrong alignment on CharacterNameUserWidget_OnTextChanged");
static_assert(sizeof(CharacterNameUserWidget_OnTextChanged) == 0x000018, "Wrong size on CharacterNameUserWidget_OnTextChanged");
static_assert(offsetof(CharacterNameUserWidget_OnTextChanged, InText) == 0x000000, "Member 'CharacterNameUserWidget_OnTextChanged::InText' has a wrong offset!");

// Function man.CharacterNameUserWidget.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct CharacterNameUserWidget_OnTextCommitted final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterNameUserWidget_OnTextCommitted) == 0x000008, "Wrong alignment on CharacterNameUserWidget_OnTextCommitted");
static_assert(sizeof(CharacterNameUserWidget_OnTextCommitted) == 0x000020, "Wrong size on CharacterNameUserWidget_OnTextCommitted");
static_assert(offsetof(CharacterNameUserWidget_OnTextCommitted, InText) == 0x000000, "Member 'CharacterNameUserWidget_OnTextCommitted::InText' has a wrong offset!");
static_assert(offsetof(CharacterNameUserWidget_OnTextCommitted, CommitMethod) == 0x000018, "Member 'CharacterNameUserWidget_OnTextCommitted::CommitMethod' has a wrong offset!");

// Function man.CharacterScreenCapture2D.OnShutdown
// 0x0008 (0x0008 - 0x0000)
struct CharacterScreenCapture2D_OnShutdown final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterScreenCapture2D_OnShutdown) == 0x000008, "Wrong alignment on CharacterScreenCapture2D_OnShutdown");
static_assert(sizeof(CharacterScreenCapture2D_OnShutdown) == 0x000008, "Wrong size on CharacterScreenCapture2D_OnShutdown");
static_assert(offsetof(CharacterScreenCapture2D_OnShutdown, World) == 0x000000, "Member 'CharacterScreenCapture2D_OnShutdown::World' has a wrong offset!");

// Function man.PlayerStatsWindowUserWidget.OnSetHeroLevel
// 0x0018 (0x0018 - 0x0000)
struct PlayerStatsWindowUserWidget_OnSetHeroLevel final
{
public:
	class FText                                   LevelText;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerStatsWindowUserWidget_OnSetHeroLevel) == 0x000008, "Wrong alignment on PlayerStatsWindowUserWidget_OnSetHeroLevel");
static_assert(sizeof(PlayerStatsWindowUserWidget_OnSetHeroLevel) == 0x000018, "Wrong size on PlayerStatsWindowUserWidget_OnSetHeroLevel");
static_assert(offsetof(PlayerStatsWindowUserWidget_OnSetHeroLevel, LevelText) == 0x000000, "Member 'PlayerStatsWindowUserWidget_OnSetHeroLevel::LevelText' has a wrong offset!");

// Function man.PlayerStatsWindowUserWidget.OnSetXp
// 0x000C (0x000C - 0x0000)
struct PlayerStatsWindowUserWidget_OnSetXp final
{
public:
	float                                         PlayerCurrentXp;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerXpCurrentLevel;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerXpNextLevel;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerStatsWindowUserWidget_OnSetXp) == 0x000004, "Wrong alignment on PlayerStatsWindowUserWidget_OnSetXp");
static_assert(sizeof(PlayerStatsWindowUserWidget_OnSetXp) == 0x00000C, "Wrong size on PlayerStatsWindowUserWidget_OnSetXp");
static_assert(offsetof(PlayerStatsWindowUserWidget_OnSetXp, PlayerCurrentXp) == 0x000000, "Member 'PlayerStatsWindowUserWidget_OnSetXp::PlayerCurrentXp' has a wrong offset!");
static_assert(offsetof(PlayerStatsWindowUserWidget_OnSetXp, PlayerXpCurrentLevel) == 0x000004, "Member 'PlayerStatsWindowUserWidget_OnSetXp::PlayerXpCurrentLevel' has a wrong offset!");
static_assert(offsetof(PlayerStatsWindowUserWidget_OnSetXp, PlayerXpNextLevel) == 0x000008, "Member 'PlayerStatsWindowUserWidget_OnSetXp::PlayerXpNextLevel' has a wrong offset!");

// Function man.ChargeActiveAbility.GetCurrentShieldCharge
// 0x0004 (0x0004 - 0x0000)
struct ChargeActiveAbility_GetCurrentShieldCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeActiveAbility_GetCurrentShieldCharge) == 0x000004, "Wrong alignment on ChargeActiveAbility_GetCurrentShieldCharge");
static_assert(sizeof(ChargeActiveAbility_GetCurrentShieldCharge) == 0x000004, "Wrong size on ChargeActiveAbility_GetCurrentShieldCharge");
static_assert(offsetof(ChargeActiveAbility_GetCurrentShieldCharge, ReturnValue) == 0x000000, "Member 'ChargeActiveAbility_GetCurrentShieldCharge::ReturnValue' has a wrong offset!");

// Function man.ChargeActiveAbility.GetMaxShieldCharge
// 0x0004 (0x0004 - 0x0000)
struct ChargeActiveAbility_GetMaxShieldCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargeActiveAbility_GetMaxShieldCharge) == 0x000004, "Wrong alignment on ChargeActiveAbility_GetMaxShieldCharge");
static_assert(sizeof(ChargeActiveAbility_GetMaxShieldCharge) == 0x000004, "Wrong size on ChargeActiveAbility_GetMaxShieldCharge");
static_assert(offsetof(ChargeActiveAbility_GetMaxShieldCharge, ReturnValue) == 0x000000, "Member 'ChargeActiveAbility_GetMaxShieldCharge::ReturnValue' has a wrong offset!");

// Function man.ChargedProjectileShoot.GetCurrentChargedExtent
// 0x000C (0x000C - 0x0000)
struct ChargedProjectileShoot_GetCurrentChargedExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChargedProjectileShoot_GetCurrentChargedExtent) == 0x000004, "Wrong alignment on ChargedProjectileShoot_GetCurrentChargedExtent");
static_assert(sizeof(ChargedProjectileShoot_GetCurrentChargedExtent) == 0x00000C, "Wrong size on ChargedProjectileShoot_GetCurrentChargedExtent");
static_assert(offsetof(ChargedProjectileShoot_GetCurrentChargedExtent, ReturnValue) == 0x000000, "Member 'ChargedProjectileShoot_GetCurrentChargedExtent::ReturnValue' has a wrong offset!");

// Function man.WhirlwindAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct WhirlwindAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WhirlwindAbility_PostDamageDealt) == 0x000008, "Wrong alignment on WhirlwindAbility_PostDamageDealt");
static_assert(sizeof(WhirlwindAbility_PostDamageDealt) == 0x0002D8, "Wrong size on WhirlwindAbility_PostDamageDealt");
static_assert(offsetof(WhirlwindAbility_PostDamageDealt, Param) == 0x000000, "Member 'WhirlwindAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.WhirlwindAbility.PreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct WhirlwindAbility_PreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WhirlwindAbility_PreDamagedPriority) == 0x000008, "Wrong alignment on WhirlwindAbility_PreDamagedPriority");
static_assert(sizeof(WhirlwindAbility_PreDamagedPriority) == 0x0002D8, "Wrong size on WhirlwindAbility_PreDamagedPriority");
static_assert(offsetof(WhirlwindAbility_PreDamagedPriority, Param) == 0x000000, "Member 'WhirlwindAbility_PreDamagedPriority::Param' has a wrong offset!");

// Function man.DivineInterventionPassive.OnPreDamaged_DivineIntervention
// 0x02D8 (0x02D8 - 0x0000)
struct DivineInterventionPassive_OnPreDamaged_DivineIntervention final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineInterventionPassive_OnPreDamaged_DivineIntervention) == 0x000008, "Wrong alignment on DivineInterventionPassive_OnPreDamaged_DivineIntervention");
static_assert(sizeof(DivineInterventionPassive_OnPreDamaged_DivineIntervention) == 0x0002D8, "Wrong size on DivineInterventionPassive_OnPreDamaged_DivineIntervention");
static_assert(offsetof(DivineInterventionPassive_OnPreDamaged_DivineIntervention, Param) == 0x000000, "Member 'DivineInterventionPassive_OnPreDamaged_DivineIntervention::Param' has a wrong offset!");

// Function man.RiftChestActor.OnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct RiftChestActor_OnGameplayEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RiftChestActor_OnGameplayEvent) == 0x000008, "Wrong alignment on RiftChestActor_OnGameplayEvent");
static_assert(sizeof(RiftChestActor_OnGameplayEvent) == 0x000020, "Wrong size on RiftChestActor_OnGameplayEvent");
static_assert(offsetof(RiftChestActor_OnGameplayEvent, InAbilityController) == 0x000000, "Member 'RiftChestActor_OnGameplayEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(RiftChestActor_OnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'RiftChestActor_OnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(RiftChestActor_OnGameplayEvent, CustomName) == 0x000010, "Member 'RiftChestActor_OnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(RiftChestActor_OnGameplayEvent, paramActorSoul) == 0x000018, "Member 'RiftChestActor_OnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.CogAnimInstance.UpdateCogs
// 0x0008 (0x0008 - 0x0000)
struct CogAnimInstance_UpdateCogs final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeedUp;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CogAnimInstance_UpdateCogs) == 0x000004, "Wrong alignment on CogAnimInstance_UpdateCogs");
static_assert(sizeof(CogAnimInstance_UpdateCogs) == 0x000008, "Wrong size on CogAnimInstance_UpdateCogs");
static_assert(offsetof(CogAnimInstance_UpdateCogs, DeltaSeconds) == 0x000000, "Member 'CogAnimInstance_UpdateCogs::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(CogAnimInstance_UpdateCogs, bSpeedUp) == 0x000004, "Member 'CogAnimInstance_UpdateCogs::bSpeedUp' has a wrong offset!");

// Function man.CollectionUserWidget.OnSetCollectionCountText
// 0x0020 (0x0020 - 0x0000)
struct CollectionUserWidget_OnSetCollectionCountText final
{
public:
	class FText                                   InCollectionCountText;                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bChanged;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CollectionUserWidget_OnSetCollectionCountText) == 0x000008, "Wrong alignment on CollectionUserWidget_OnSetCollectionCountText");
static_assert(sizeof(CollectionUserWidget_OnSetCollectionCountText) == 0x000020, "Wrong size on CollectionUserWidget_OnSetCollectionCountText");
static_assert(offsetof(CollectionUserWidget_OnSetCollectionCountText, InCollectionCountText) == 0x000000, "Member 'CollectionUserWidget_OnSetCollectionCountText::InCollectionCountText' has a wrong offset!");
static_assert(offsetof(CollectionUserWidget_OnSetCollectionCountText, bChanged) == 0x000018, "Member 'CollectionUserWidget_OnSetCollectionCountText::bChanged' has a wrong offset!");

// Function man.CollectionUserWidget.OnUpdateDetailsPanel
// 0x0010 (0x0010 - 0x0000)
struct CollectionUserWidget_OnUpdateDetailsPanel final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CollectionUserWidget_OnUpdateDetailsPanel) == 0x000008, "Wrong alignment on CollectionUserWidget_OnUpdateDetailsPanel");
static_assert(sizeof(CollectionUserWidget_OnUpdateDetailsPanel) == 0x000010, "Wrong size on CollectionUserWidget_OnUpdateDetailsPanel");
static_assert(offsetof(CollectionUserWidget_OnUpdateDetailsPanel, ManItemSlotBase) == 0x000000, "Member 'CollectionUserWidget_OnUpdateDetailsPanel::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(CollectionUserWidget_OnUpdateDetailsPanel, bAnimate) == 0x000008, "Member 'CollectionUserWidget_OnUpdateDetailsPanel::bAnimate' has a wrong offset!");

// Function man.ManLocalPlayer.GetAbilityController
// 0x0008 (0x0008 - 0x0000)
struct ManLocalPlayer_GetAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLocalPlayer_GetAbilityController) == 0x000008, "Wrong alignment on ManLocalPlayer_GetAbilityController");
static_assert(sizeof(ManLocalPlayer_GetAbilityController) == 0x000008, "Wrong size on ManLocalPlayer_GetAbilityController");
static_assert(offsetof(ManLocalPlayer_GetAbilityController, ReturnValue) == 0x000000, "Member 'ManLocalPlayer_GetAbilityController::ReturnValue' has a wrong offset!");

// Function man.ManLocalPlayer.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct ManLocalPlayer_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLocalPlayer_GetAttributeContainer) == 0x000008, "Wrong alignment on ManLocalPlayer_GetAttributeContainer");
static_assert(sizeof(ManLocalPlayer_GetAttributeContainer) == 0x000008, "Wrong size on ManLocalPlayer_GetAttributeContainer");
static_assert(offsetof(ManLocalPlayer_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'ManLocalPlayer_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.ManLocalPlayer.IsMenuGame
// 0x0001 (0x0001 - 0x0000)
struct ManLocalPlayer_IsMenuGame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLocalPlayer_IsMenuGame) == 0x000001, "Wrong alignment on ManLocalPlayer_IsMenuGame");
static_assert(sizeof(ManLocalPlayer_IsMenuGame) == 0x000001, "Wrong size on ManLocalPlayer_IsMenuGame");
static_assert(offsetof(ManLocalPlayer_IsMenuGame, ReturnValue) == 0x000000, "Member 'ManLocalPlayer_IsMenuGame::ReturnValue' has a wrong offset!");

// Function man.ManLocalPlayer.OnShowSaveGameFailedDialogeWindowResult
// 0x0001 (0x0001 - 0x0000)
struct ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult) == 0x000001, "Wrong alignment on ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult");
static_assert(sizeof(ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult) == 0x000001, "Wrong size on ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult");
static_assert(offsetof(ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult, ButtonType) == 0x000000, "Member 'ManLocalPlayer_OnShowSaveGameFailedDialogeWindowResult::ButtonType' has a wrong offset!");

// Function man.LootTableItemEntry.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct LootTableItemEntry_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootTableItemEntry_GetEditorName) == 0x000008, "Wrong alignment on LootTableItemEntry_GetEditorName");
static_assert(sizeof(LootTableItemEntry_GetEditorName) == 0x000010, "Wrong size on LootTableItemEntry_GetEditorName");
static_assert(offsetof(LootTableItemEntry_GetEditorName, ReturnValue) == 0x000000, "Member 'LootTableItemEntry_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.MapObjectUserWidget.OnSetCheckpoint
// 0x0020 (0x0020 - 0x0000)
struct MapObjectUserWidget_OnSetCheckpoint final
{
public:
	bool                                          bCheckpoint;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckpointEnabled;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InDisplayName;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectUserWidget_OnSetCheckpoint) == 0x000008, "Wrong alignment on MapObjectUserWidget_OnSetCheckpoint");
static_assert(sizeof(MapObjectUserWidget_OnSetCheckpoint) == 0x000020, "Wrong size on MapObjectUserWidget_OnSetCheckpoint");
static_assert(offsetof(MapObjectUserWidget_OnSetCheckpoint, bCheckpoint) == 0x000000, "Member 'MapObjectUserWidget_OnSetCheckpoint::bCheckpoint' has a wrong offset!");
static_assert(offsetof(MapObjectUserWidget_OnSetCheckpoint, bCheckpointEnabled) == 0x000001, "Member 'MapObjectUserWidget_OnSetCheckpoint::bCheckpointEnabled' has a wrong offset!");
static_assert(offsetof(MapObjectUserWidget_OnSetCheckpoint, InDisplayName) == 0x000008, "Member 'MapObjectUserWidget_OnSetCheckpoint::InDisplayName' has a wrong offset!");

// Function man.MapObjectUserWidget.OnSetCheckpointNameVisible
// 0x0001 (0x0001 - 0x0000)
struct MapObjectUserWidget_OnSetCheckpointNameVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectUserWidget_OnSetCheckpointNameVisible) == 0x000001, "Wrong alignment on MapObjectUserWidget_OnSetCheckpointNameVisible");
static_assert(sizeof(MapObjectUserWidget_OnSetCheckpointNameVisible) == 0x000001, "Wrong size on MapObjectUserWidget_OnSetCheckpointNameVisible");
static_assert(offsetof(MapObjectUserWidget_OnSetCheckpointNameVisible, bInVisible) == 0x000000, "Member 'MapObjectUserWidget_OnSetCheckpointNameVisible::bInVisible' has a wrong offset!");

// Function man.MapObjectUserWidget.OnSetIcon
// 0x0010 (0x0010 - 0x0000)
struct MapObjectUserWidget_OnSetIcon final
{
public:
	class UTexture2D*                             InIcon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniMapGatewaySide                           InGatewaySide;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniMapGatewayState                          InGatewayState;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MapObjectUserWidget_OnSetIcon) == 0x000008, "Wrong alignment on MapObjectUserWidget_OnSetIcon");
static_assert(sizeof(MapObjectUserWidget_OnSetIcon) == 0x000010, "Wrong size on MapObjectUserWidget_OnSetIcon");
static_assert(offsetof(MapObjectUserWidget_OnSetIcon, InIcon) == 0x000000, "Member 'MapObjectUserWidget_OnSetIcon::InIcon' has a wrong offset!");
static_assert(offsetof(MapObjectUserWidget_OnSetIcon, InGatewaySide) == 0x000008, "Member 'MapObjectUserWidget_OnSetIcon::InGatewaySide' has a wrong offset!");
static_assert(offsetof(MapObjectUserWidget_OnSetIcon, InGatewayState) == 0x000009, "Member 'MapObjectUserWidget_OnSetIcon::InGatewayState' has a wrong offset!");

// Function man.MapObjectUserWidget.OnSetType
// 0x0001 (0x0001 - 0x0000)
struct MapObjectUserWidget_OnSetType final
{
public:
	EMapQuestObjectiveType                        InMapQuestObjectiveType;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectUserWidget_OnSetType) == 0x000001, "Wrong alignment on MapObjectUserWidget_OnSetType");
static_assert(sizeof(MapObjectUserWidget_OnSetType) == 0x000001, "Wrong size on MapObjectUserWidget_OnSetType");
static_assert(offsetof(MapObjectUserWidget_OnSetType, InMapQuestObjectiveType) == 0x000000, "Member 'MapObjectUserWidget_OnSetType::InMapQuestObjectiveType' has a wrong offset!");

// Function man.MapObjectUserWidget.IsCheckpoint
// 0x0001 (0x0001 - 0x0000)
struct MapObjectUserWidget_IsCheckpoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectUserWidget_IsCheckpoint) == 0x000001, "Wrong alignment on MapObjectUserWidget_IsCheckpoint");
static_assert(sizeof(MapObjectUserWidget_IsCheckpoint) == 0x000001, "Wrong size on MapObjectUserWidget_IsCheckpoint");
static_assert(offsetof(MapObjectUserWidget_IsCheckpoint, ReturnValue) == 0x000000, "Member 'MapObjectUserWidget_IsCheckpoint::ReturnValue' has a wrong offset!");

// Function man.MapObjectUserWidget.IsMarker
// 0x0001 (0x0001 - 0x0000)
struct MapObjectUserWidget_IsMarker final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectUserWidget_IsMarker) == 0x000001, "Wrong alignment on MapObjectUserWidget_IsMarker");
static_assert(sizeof(MapObjectUserWidget_IsMarker) == 0x000001, "Wrong size on MapObjectUserWidget_IsMarker");
static_assert(offsetof(MapObjectUserWidget_IsMarker, ReturnValue) == 0x000000, "Member 'MapObjectUserWidget_IsMarker::ReturnValue' has a wrong offset!");

// Function man.ControllerDisplayUserWidget.OnSetActive
// 0x0001 (0x0001 - 0x0000)
struct ControllerDisplayUserWidget_OnSetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControllerDisplayUserWidget_OnSetActive) == 0x000001, "Wrong alignment on ControllerDisplayUserWidget_OnSetActive");
static_assert(sizeof(ControllerDisplayUserWidget_OnSetActive) == 0x000001, "Wrong size on ControllerDisplayUserWidget_OnSetActive");
static_assert(offsetof(ControllerDisplayUserWidget_OnSetActive, bInIsActive) == 0x000000, "Member 'ControllerDisplayUserWidget_OnSetActive::bInIsActive' has a wrong offset!");

// Function man.ControllerDisplayUserWidget.OnSetInputDisplay
// 0x0003 (0x0003 - 0x0000)
struct ControllerDisplayUserWidget_OnSetInputDisplay final
{
public:
	EInputDisplay                                 InInputDisplay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 InControlDisplay;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControllerDisplayUserWidgetVisible;               // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControllerDisplayUserWidget_OnSetInputDisplay) == 0x000001, "Wrong alignment on ControllerDisplayUserWidget_OnSetInputDisplay");
static_assert(sizeof(ControllerDisplayUserWidget_OnSetInputDisplay) == 0x000003, "Wrong size on ControllerDisplayUserWidget_OnSetInputDisplay");
static_assert(offsetof(ControllerDisplayUserWidget_OnSetInputDisplay, InInputDisplay) == 0x000000, "Member 'ControllerDisplayUserWidget_OnSetInputDisplay::InInputDisplay' has a wrong offset!");
static_assert(offsetof(ControllerDisplayUserWidget_OnSetInputDisplay, InControlDisplay) == 0x000001, "Member 'ControllerDisplayUserWidget_OnSetInputDisplay::InControlDisplay' has a wrong offset!");
static_assert(offsetof(ControllerDisplayUserWidget_OnSetInputDisplay, bControllerDisplayUserWidgetVisible) == 0x000002, "Member 'ControllerDisplayUserWidget_OnSetInputDisplay::bControllerDisplayUserWidgetVisible' has a wrong offset!");

// Function man.ConversationBtnUserWidget.GetIconButtonType
// 0x0001 (0x0001 - 0x0000)
struct ConversationBtnUserWidget_GetIconButtonType final
{
public:
	EPrimalConversationResponseButtonType         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationBtnUserWidget_GetIconButtonType) == 0x000001, "Wrong alignment on ConversationBtnUserWidget_GetIconButtonType");
static_assert(sizeof(ConversationBtnUserWidget_GetIconButtonType) == 0x000001, "Wrong size on ConversationBtnUserWidget_GetIconButtonType");
static_assert(offsetof(ConversationBtnUserWidget_GetIconButtonType, ReturnValue) == 0x000000, "Member 'ConversationBtnUserWidget_GetIconButtonType::ReturnValue' has a wrong offset!");

// Function man.ConversationBtnUserWidget.OnSetBtnState
// 0x0001 (0x0001 - 0x0000)
struct ConversationBtnUserWidget_OnSetBtnState final
{
public:
	bool                                          bDisabled;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationBtnUserWidget_OnSetBtnState) == 0x000001, "Wrong alignment on ConversationBtnUserWidget_OnSetBtnState");
static_assert(sizeof(ConversationBtnUserWidget_OnSetBtnState) == 0x000001, "Wrong size on ConversationBtnUserWidget_OnSetBtnState");
static_assert(offsetof(ConversationBtnUserWidget_OnSetBtnState, bDisabled) == 0x000000, "Member 'ConversationBtnUserWidget_OnSetBtnState::bDisabled' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ConversationClearText
// 0x0008 (0x0008 - 0x0000)
struct ConversationFunctionLibrary_ConversationClearText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationFunctionLibrary_ConversationClearText) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ConversationClearText");
static_assert(sizeof(ConversationFunctionLibrary_ConversationClearText) == 0x000008, "Wrong size on ConversationFunctionLibrary_ConversationClearText");
static_assert(offsetof(ConversationFunctionLibrary_ConversationClearText, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ConversationClearText::WorldContextObject' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ConversationLevelChange
// 0x0040 (0x0040 - 0x0000)
struct ConversationFunctionLibrary_ConversationLevelChange final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LevelReference;                                    // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportTargetName;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckpointData*                        TargetCheckpoint;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationFunctionLibrary_ConversationLevelChange) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ConversationLevelChange");
static_assert(sizeof(ConversationFunctionLibrary_ConversationLevelChange) == 0x000040, "Wrong size on ConversationFunctionLibrary_ConversationLevelChange");
static_assert(offsetof(ConversationFunctionLibrary_ConversationLevelChange, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ConversationLevelChange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationLevelChange, LevelReference) == 0x000008, "Member 'ConversationFunctionLibrary_ConversationLevelChange::LevelReference' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationLevelChange, TeleportTargetName) == 0x000030, "Member 'ConversationFunctionLibrary_ConversationLevelChange::TeleportTargetName' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationLevelChange, TargetCheckpoint) == 0x000038, "Member 'ConversationFunctionLibrary_ConversationLevelChange::TargetCheckpoint' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ConversationTabButtonsEnabled
// 0x0010 (0x0010 - 0x0000)
struct ConversationFunctionLibrary_ConversationTabButtonsEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ConversationTabButtonsEnabled) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ConversationTabButtonsEnabled");
static_assert(sizeof(ConversationFunctionLibrary_ConversationTabButtonsEnabled) == 0x000010, "Wrong size on ConversationFunctionLibrary_ConversationTabButtonsEnabled");
static_assert(offsetof(ConversationFunctionLibrary_ConversationTabButtonsEnabled, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ConversationTabButtonsEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationTabButtonsEnabled, bEnabled) == 0x000008, "Member 'ConversationFunctionLibrary_ConversationTabButtonsEnabled::bEnabled' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ConversationTabButtonsVisible
// 0x0010 (0x0010 - 0x0000)
struct ConversationFunctionLibrary_ConversationTabButtonsVisible final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ConversationTabButtonsVisible) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ConversationTabButtonsVisible");
static_assert(sizeof(ConversationFunctionLibrary_ConversationTabButtonsVisible) == 0x000010, "Wrong size on ConversationFunctionLibrary_ConversationTabButtonsVisible");
static_assert(offsetof(ConversationFunctionLibrary_ConversationTabButtonsVisible, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ConversationTabButtonsVisible::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationTabButtonsVisible, bVisible) == 0x000008, "Member 'ConversationFunctionLibrary_ConversationTabButtonsVisible::bVisible' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ConversationUnlockCheckPoint
// 0x0018 (0x0018 - 0x0000)
struct ConversationFunctionLibrary_ConversationUnlockCheckPoint final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckpointData*                        UnlockCheckPoint;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetAsRespawn;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ConversationUnlockCheckPoint) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ConversationUnlockCheckPoint");
static_assert(sizeof(ConversationFunctionLibrary_ConversationUnlockCheckPoint) == 0x000018, "Wrong size on ConversationFunctionLibrary_ConversationUnlockCheckPoint");
static_assert(offsetof(ConversationFunctionLibrary_ConversationUnlockCheckPoint, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ConversationUnlockCheckPoint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationUnlockCheckPoint, UnlockCheckPoint) == 0x000008, "Member 'ConversationFunctionLibrary_ConversationUnlockCheckPoint::UnlockCheckPoint' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ConversationUnlockCheckPoint, bSetAsRespawn) == 0x000010, "Member 'ConversationFunctionLibrary_ConversationUnlockCheckPoint::bSetAsRespawn' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionaryGetBool
// 0x0018 (0x0018 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionaryGetBool final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutValue;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name_0;                                            // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionaryGetBool) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionaryGetBool");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionaryGetBool) == 0x000018, "Wrong size on ConversationFunctionLibrary_GlobalDictionaryGetBool");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetBool, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetBool::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetBool, OutValue) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetBool::OutValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetBool, Name_0) == 0x00000C, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetBool, ReturnValue) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetBool::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionaryGetFloat
// 0x0018 (0x0018 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionaryGetFloat final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionaryGetFloat) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionaryGetFloat");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionaryGetFloat) == 0x000018, "Wrong size on ConversationFunctionLibrary_GlobalDictionaryGetFloat");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetFloat, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetFloat, OutValue) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetFloat::OutValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetFloat, Name_0) == 0x00000C, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetFloat, ReturnValue) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetFloat::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionaryGetInt
// 0x0018 (0x0018 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionaryGetInt final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutValue;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionaryGetInt) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionaryGetInt");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionaryGetInt) == 0x000018, "Wrong size on ConversationFunctionLibrary_GlobalDictionaryGetInt");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetInt, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetInt, OutValue) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetInt::OutValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetInt, Name_0) == 0x00000C, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetInt::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetInt, ReturnValue) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetInt::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionaryGetString
// 0x0028 (0x0028 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionaryGetString final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutValue;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionaryGetString) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionaryGetString");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionaryGetString) == 0x000028, "Wrong size on ConversationFunctionLibrary_GlobalDictionaryGetString");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetString, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetString, OutValue) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetString::OutValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetString, Name_0) == 0x000018, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetString::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryGetString, ReturnValue) == 0x000020, "Member 'ConversationFunctionLibrary_GlobalDictionaryGetString::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionaryIsExists
// 0x0018 (0x0018 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionaryIsExists final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionaryIsExists) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionaryIsExists");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionaryIsExists) == 0x000018, "Wrong size on ConversationFunctionLibrary_GlobalDictionaryIsExists");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryIsExists, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionaryIsExists::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryIsExists, Name_0) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionaryIsExists::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionaryIsExists, ReturnValue) == 0x000010, "Member 'ConversationFunctionLibrary_GlobalDictionaryIsExists::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionarySetBool
// 0x0028 (0x0028 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionarySetBool final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValue;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionarySetBool) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionarySetBool");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionarySetBool) == 0x000028, "Wrong size on ConversationFunctionLibrary_GlobalDictionarySetBool");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetBool, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionarySetBool::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetBool, Name_0) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionarySetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetBool, InValue) == 0x000010, "Member 'ConversationFunctionLibrary_GlobalDictionarySetBool::InValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetBool, OnChanged) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionarySetBool::OnChanged' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetBool, ReturnValue) == 0x000024, "Member 'ConversationFunctionLibrary_GlobalDictionarySetBool::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionarySetFloat
// 0x0028 (0x0028 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionarySetFloat final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionarySetFloat) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionarySetFloat");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionarySetFloat) == 0x000028, "Wrong size on ConversationFunctionLibrary_GlobalDictionarySetFloat");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetFloat, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionarySetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetFloat, Name_0) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionarySetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetFloat, InValue) == 0x000010, "Member 'ConversationFunctionLibrary_GlobalDictionarySetFloat::InValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetFloat, OnChanged) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionarySetFloat::OnChanged' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetFloat, ReturnValue) == 0x000024, "Member 'ConversationFunctionLibrary_GlobalDictionarySetFloat::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionarySetInt
// 0x0028 (0x0028 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionarySetInt final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionarySetInt) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionarySetInt");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionarySetInt) == 0x000028, "Wrong size on ConversationFunctionLibrary_GlobalDictionarySetInt");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetInt, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionarySetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetInt, Name_0) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionarySetInt::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetInt, InValue) == 0x000010, "Member 'ConversationFunctionLibrary_GlobalDictionarySetInt::InValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetInt, OnChanged) == 0x000014, "Member 'ConversationFunctionLibrary_GlobalDictionarySetInt::OnChanged' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetInt, ReturnValue) == 0x000024, "Member 'ConversationFunctionLibrary_GlobalDictionarySetInt::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.GlobalDictionarySetString
// 0x0038 (0x0038 - 0x0000)
struct ConversationFunctionLibrary_GlobalDictionarySetString final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InValue;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_GlobalDictionarySetString) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_GlobalDictionarySetString");
static_assert(sizeof(ConversationFunctionLibrary_GlobalDictionarySetString) == 0x000038, "Wrong size on ConversationFunctionLibrary_GlobalDictionarySetString");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetString, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_GlobalDictionarySetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetString, Name_0) == 0x000008, "Member 'ConversationFunctionLibrary_GlobalDictionarySetString::Name_0' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetString, InValue) == 0x000010, "Member 'ConversationFunctionLibrary_GlobalDictionarySetString::InValue' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetString, OnChanged) == 0x000020, "Member 'ConversationFunctionLibrary_GlobalDictionarySetString::OnChanged' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_GlobalDictionarySetString, ReturnValue) == 0x000030, "Member 'ConversationFunctionLibrary_GlobalDictionarySetString::ReturnValue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ShowConversationOption
// 0x0030 (0x0030 - 0x0000)
struct ConversationFunctionLibrary_ShowConversationOption final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDialogueDataAsset*               DialogueDataAsset;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EPrimalConversationResponseButtonType         ButtonType;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrayedOut;                                        // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ShowConversationOption) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ShowConversationOption");
static_assert(sizeof(ConversationFunctionLibrary_ShowConversationOption) == 0x000030, "Wrong size on ConversationFunctionLibrary_ShowConversationOption");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationOption, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ShowConversationOption::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationOption, DialogueDataAsset) == 0x000008, "Member 'ConversationFunctionLibrary_ShowConversationOption::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationOption, LatentInfo) == 0x000010, "Member 'ConversationFunctionLibrary_ShowConversationOption::LatentInfo' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationOption, ButtonType) == 0x000028, "Member 'ConversationFunctionLibrary_ShowConversationOption::ButtonType' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationOption, bGrayedOut) == 0x000029, "Member 'ConversationFunctionLibrary_ShowConversationOption::bGrayedOut' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ShowConversationPortrait
// 0x0010 (0x0010 - 0x0000)
struct ConversationFunctionLibrary_ShowConversationPortrait final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimalConversationSpeaker*             Speaker;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationFunctionLibrary_ShowConversationPortrait) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ShowConversationPortrait");
static_assert(sizeof(ConversationFunctionLibrary_ShowConversationPortrait) == 0x000010, "Wrong size on ConversationFunctionLibrary_ShowConversationPortrait");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationPortrait, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ShowConversationPortrait::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationPortrait, Speaker) == 0x000008, "Member 'ConversationFunctionLibrary_ShowConversationPortrait::Speaker' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ShowConversationRandomText
// 0x0030 (0x0030 - 0x0000)
struct ConversationFunctionLibrary_ShowConversationRandomText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDialogueDataAsset*               DialogueDataAsset;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bInstantContinue;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ShowConversationRandomText) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ShowConversationRandomText");
static_assert(sizeof(ConversationFunctionLibrary_ShowConversationRandomText) == 0x000030, "Wrong size on ConversationFunctionLibrary_ShowConversationRandomText");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationRandomText, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ShowConversationRandomText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationRandomText, DialogueDataAsset) == 0x000008, "Member 'ConversationFunctionLibrary_ShowConversationRandomText::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationRandomText, LatentInfo) == 0x000010, "Member 'ConversationFunctionLibrary_ShowConversationRandomText::LatentInfo' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationRandomText, bInstantContinue) == 0x000028, "Member 'ConversationFunctionLibrary_ShowConversationRandomText::bInstantContinue' has a wrong offset!");

// Function man.ConversationFunctionLibrary.ShowConversationText
// 0x0030 (0x0030 - 0x0000)
struct ConversationFunctionLibrary_ShowConversationText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDialogueDataAsset*               DialogueDataAsset;                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bInstantContinue;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationFunctionLibrary_ShowConversationText) == 0x000008, "Wrong alignment on ConversationFunctionLibrary_ShowConversationText");
static_assert(sizeof(ConversationFunctionLibrary_ShowConversationText) == 0x000030, "Wrong size on ConversationFunctionLibrary_ShowConversationText");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationText, WorldContextObject) == 0x000000, "Member 'ConversationFunctionLibrary_ShowConversationText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationText, DialogueDataAsset) == 0x000008, "Member 'ConversationFunctionLibrary_ShowConversationText::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationText, LatentInfo) == 0x000010, "Member 'ConversationFunctionLibrary_ShowConversationText::LatentInfo' has a wrong offset!");
static_assert(offsetof(ConversationFunctionLibrary_ShowConversationText, bInstantContinue) == 0x000028, "Member 'ConversationFunctionLibrary_ShowConversationText::bInstantContinue' has a wrong offset!");

// Function man.ConversationInfo.BPOnStartConversation
// 0x0008 (0x0008 - 0x0000)
struct ConversationInfo_BPOnStartConversation final
{
public:
	class FName                                   ConversationName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationInfo_BPOnStartConversation) == 0x000004, "Wrong alignment on ConversationInfo_BPOnStartConversation");
static_assert(sizeof(ConversationInfo_BPOnStartConversation) == 0x000008, "Wrong size on ConversationInfo_BPOnStartConversation");
static_assert(offsetof(ConversationInfo_BPOnStartConversation, ConversationName) == 0x000000, "Member 'ConversationInfo_BPOnStartConversation::ConversationName' has a wrong offset!");

// Function man.SplinterSwarm.BPGetHitBoxExtent
// 0x000C (0x000C - 0x0000)
struct SplinterSwarm_BPGetHitBoxExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplinterSwarm_BPGetHitBoxExtent) == 0x000004, "Wrong alignment on SplinterSwarm_BPGetHitBoxExtent");
static_assert(sizeof(SplinterSwarm_BPGetHitBoxExtent) == 0x00000C, "Wrong size on SplinterSwarm_BPGetHitBoxExtent");
static_assert(offsetof(SplinterSwarm_BPGetHitBoxExtent, ReturnValue) == 0x000000, "Member 'SplinterSwarm_BPGetHitBoxExtent::ReturnValue' has a wrong offset!");

// Function man.SplinterSwarm.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SplinterSwarm_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplinterSwarm_OnPostDamageCaused) == 0x000008, "Wrong alignment on SplinterSwarm_OnPostDamageCaused");
static_assert(sizeof(SplinterSwarm_OnPostDamageCaused) == 0x0002D8, "Wrong size on SplinterSwarm_OnPostDamageCaused");
static_assert(offsetof(SplinterSwarm_OnPostDamageCaused, Param) == 0x000000, "Member 'SplinterSwarm_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.ConversationUserWidget.Continue
// 0x0004 (0x0004 - 0x0000)
struct ConversationUserWidget_Continue final
{
public:
	int32                                         ResponseIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_Continue) == 0x000004, "Wrong alignment on ConversationUserWidget_Continue");
static_assert(sizeof(ConversationUserWidget_Continue) == 0x000004, "Wrong size on ConversationUserWidget_Continue");
static_assert(offsetof(ConversationUserWidget_Continue, ResponseIndex) == 0x000000, "Member 'ConversationUserWidget_Continue::ResponseIndex' has a wrong offset!");

// Function man.ConversationUserWidget.OnConversationResponseClicked
// 0x0004 (0x0004 - 0x0000)
struct ConversationUserWidget_OnConversationResponseClicked final
{
public:
	int32                                         ResponseIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_OnConversationResponseClicked) == 0x000004, "Wrong alignment on ConversationUserWidget_OnConversationResponseClicked");
static_assert(sizeof(ConversationUserWidget_OnConversationResponseClicked) == 0x000004, "Wrong size on ConversationUserWidget_OnConversationResponseClicked");
static_assert(offsetof(ConversationUserWidget_OnConversationResponseClicked, ResponseIndex) == 0x000000, "Member 'ConversationUserWidget_OnConversationResponseClicked::ResponseIndex' has a wrong offset!");

// Function man.ConversationUserWidget.OnLineTextVisible
// 0x0010 (0x0010 - 0x0000)
struct ConversationUserWidget_OnLineTextVisible final
{
public:
	class FString                                 LineText;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_OnLineTextVisible) == 0x000008, "Wrong alignment on ConversationUserWidget_OnLineTextVisible");
static_assert(sizeof(ConversationUserWidget_OnLineTextVisible) == 0x000010, "Wrong size on ConversationUserWidget_OnLineTextVisible");
static_assert(offsetof(ConversationUserWidget_OnLineTextVisible, LineText) == 0x000000, "Member 'ConversationUserWidget_OnLineTextVisible::LineText' has a wrong offset!");

// Function man.ConversationUserWidget.OnSetConversation
// 0x0050 (0x0050 - 0x0000)
struct ConversationUserWidget_OnSetConversation final
{
public:
	class FText                                   SpeakerText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   FormattedSpeakerText;                              // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   LineIDText;                                        // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ConversationUserWidget_OnSetConversation) == 0x000008, "Wrong alignment on ConversationUserWidget_OnSetConversation");
static_assert(sizeof(ConversationUserWidget_OnSetConversation) == 0x000050, "Wrong size on ConversationUserWidget_OnSetConversation");
static_assert(offsetof(ConversationUserWidget_OnSetConversation, SpeakerText) == 0x000000, "Member 'ConversationUserWidget_OnSetConversation::SpeakerText' has a wrong offset!");
static_assert(offsetof(ConversationUserWidget_OnSetConversation, FormattedSpeakerText) == 0x000018, "Member 'ConversationUserWidget_OnSetConversation::FormattedSpeakerText' has a wrong offset!");
static_assert(offsetof(ConversationUserWidget_OnSetConversation, LineIDText) == 0x000030, "Member 'ConversationUserWidget_OnSetConversation::LineIDText' has a wrong offset!");
static_assert(offsetof(ConversationUserWidget_OnSetConversation, bSkippable) == 0x000048, "Member 'ConversationUserWidget_OnSetConversation::bSkippable' has a wrong offset!");

// Function man.ConversationUserWidget.OnSetOpacity
// 0x0004 (0x0004 - 0x0000)
struct ConversationUserWidget_OnSetOpacity final
{
public:
	float                                         Opacity;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_OnSetOpacity) == 0x000004, "Wrong alignment on ConversationUserWidget_OnSetOpacity");
static_assert(sizeof(ConversationUserWidget_OnSetOpacity) == 0x000004, "Wrong size on ConversationUserWidget_OnSetOpacity");
static_assert(offsetof(ConversationUserWidget_OnSetOpacity, Opacity) == 0x000000, "Member 'ConversationUserWidget_OnSetOpacity::Opacity' has a wrong offset!");

// Function man.ConversationUserWidget.OnShowSlot
// 0x0050 (0x0050 - 0x0000)
struct ConversationUserWidget_OnShowSlot final
{
public:
	struct FConversationSpeakerInfo               SpeakerInfo;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_OnShowSlot) == 0x000008, "Wrong alignment on ConversationUserWidget_OnShowSlot");
static_assert(sizeof(ConversationUserWidget_OnShowSlot) == 0x000050, "Wrong size on ConversationUserWidget_OnShowSlot");
static_assert(offsetof(ConversationUserWidget_OnShowSlot, SpeakerInfo) == 0x000000, "Member 'ConversationUserWidget_OnShowSlot::SpeakerInfo' has a wrong offset!");

// Function man.ConversationUserWidget.OnSubtitleEnable
// 0x0001 (0x0001 - 0x0000)
struct ConversationUserWidget_OnSubtitleEnable final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_OnSubtitleEnable) == 0x000001, "Wrong alignment on ConversationUserWidget_OnSubtitleEnable");
static_assert(sizeof(ConversationUserWidget_OnSubtitleEnable) == 0x000001, "Wrong size on ConversationUserWidget_OnSubtitleEnable");
static_assert(offsetof(ConversationUserWidget_OnSubtitleEnable, bInEnabled) == 0x000000, "Member 'ConversationUserWidget_OnSubtitleEnable::bInEnabled' has a wrong offset!");

// Function man.ConversationUserWidget.SetDialogOptionsVisible
// 0x0001 (0x0001 - 0x0000)
struct ConversationUserWidget_SetDialogOptionsVisible final
{
public:
	bool                                          bInDialogOptionsVisible;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_SetDialogOptionsVisible) == 0x000001, "Wrong alignment on ConversationUserWidget_SetDialogOptionsVisible");
static_assert(sizeof(ConversationUserWidget_SetDialogOptionsVisible) == 0x000001, "Wrong size on ConversationUserWidget_SetDialogOptionsVisible");
static_assert(offsetof(ConversationUserWidget_SetDialogOptionsVisible, bInDialogOptionsVisible) == 0x000000, "Member 'ConversationUserWidget_SetDialogOptionsVisible::bInDialogOptionsVisible' has a wrong offset!");

// Function man.ConversationUserWidget.GetResponseButtons
// 0x0010 (0x0010 - 0x0000)
struct ConversationUserWidget_GetResponseButtons final
{
public:
	TArray<class UConversationBtnUserWidget*>     ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_GetResponseButtons) == 0x000008, "Wrong alignment on ConversationUserWidget_GetResponseButtons");
static_assert(sizeof(ConversationUserWidget_GetResponseButtons) == 0x000010, "Wrong size on ConversationUserWidget_GetResponseButtons");
static_assert(offsetof(ConversationUserWidget_GetResponseButtons, ReturnValue) == 0x000000, "Member 'ConversationUserWidget_GetResponseButtons::ReturnValue' has a wrong offset!");

// Function man.ConversationUserWidget.IsDialogOptionsVisible
// 0x0001 (0x0001 - 0x0000)
struct ConversationUserWidget_IsDialogOptionsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConversationUserWidget_IsDialogOptionsVisible) == 0x000001, "Wrong alignment on ConversationUserWidget_IsDialogOptionsVisible");
static_assert(sizeof(ConversationUserWidget_IsDialogOptionsVisible) == 0x000001, "Wrong size on ConversationUserWidget_IsDialogOptionsVisible");
static_assert(offsetof(ConversationUserWidget_IsDialogOptionsVisible, ReturnValue) == 0x000000, "Member 'ConversationUserWidget_IsDialogOptionsVisible::ReturnValue' has a wrong offset!");

// Function man.VortexActor.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct VortexActor_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VortexActor_OnPostDamageDone) == 0x000008, "Wrong alignment on VortexActor_OnPostDamageDone");
static_assert(sizeof(VortexActor_OnPostDamageDone) == 0x0002D8, "Wrong size on VortexActor_OnPostDamageDone");
static_assert(offsetof(VortexActor_OnPostDamageDone, DamageParams) == 0x000000, "Member 'VortexActor_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.CorrosiveAgent.StatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct CorrosiveAgent_StatusEffectCaused final
{
public:
	class AActor*                                 ToTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CorrosiveAgent_StatusEffectCaused) == 0x000008, "Wrong alignment on CorrosiveAgent_StatusEffectCaused");
static_assert(sizeof(CorrosiveAgent_StatusEffectCaused) == 0x000018, "Wrong size on CorrosiveAgent_StatusEffectCaused");
static_assert(offsetof(CorrosiveAgent_StatusEffectCaused, ToTarget) == 0x000000, "Member 'CorrosiveAgent_StatusEffectCaused::ToTarget' has a wrong offset!");
static_assert(offsetof(CorrosiveAgent_StatusEffectCaused, Type) == 0x000008, "Member 'CorrosiveAgent_StatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(CorrosiveAgent_StatusEffectCaused, IsNewEffect) == 0x000009, "Member 'CorrosiveAgent_StatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(CorrosiveAgent_StatusEffectCaused, Instance) == 0x000010, "Member 'CorrosiveAgent_StatusEffectCaused::Instance' has a wrong offset!");

// Function man.CreateCharacterSelUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterSelUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterSelUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on CreateCharacterSelUserWidget_OnSetEnabled");
static_assert(sizeof(CreateCharacterSelUserWidget_OnSetEnabled) == 0x000001, "Wrong size on CreateCharacterSelUserWidget_OnSetEnabled");
static_assert(offsetof(CreateCharacterSelUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'CreateCharacterSelUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.CreateCharacterSelUserWidget.OnSetFocusAnim
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterSelUserWidget_OnSetFocusAnim final
{
public:
	bool                                          bInFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterSelUserWidget_OnSetFocusAnim) == 0x000001, "Wrong alignment on CreateCharacterSelUserWidget_OnSetFocusAnim");
static_assert(sizeof(CreateCharacterSelUserWidget_OnSetFocusAnim) == 0x000001, "Wrong size on CreateCharacterSelUserWidget_OnSetFocusAnim");
static_assert(offsetof(CreateCharacterSelUserWidget_OnSetFocusAnim, bInFocused) == 0x000000, "Member 'CreateCharacterSelUserWidget_OnSetFocusAnim::bInFocused' has a wrong offset!");

// Function man.CreateCharacterSelUserWidget.OnSetOptionsArray
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterSelUserWidget_OnSetOptionsArray final
{
public:
	TArray<class FText>                           InOptions;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InSelectedIndex;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterSelUserWidget_OnSetOptionsArray) == 0x000008, "Wrong alignment on CreateCharacterSelUserWidget_OnSetOptionsArray");
static_assert(sizeof(CreateCharacterSelUserWidget_OnSetOptionsArray) == 0x000018, "Wrong size on CreateCharacterSelUserWidget_OnSetOptionsArray");
static_assert(offsetof(CreateCharacterSelUserWidget_OnSetOptionsArray, InOptions) == 0x000000, "Member 'CreateCharacterSelUserWidget_OnSetOptionsArray::InOptions' has a wrong offset!");
static_assert(offsetof(CreateCharacterSelUserWidget_OnSetOptionsArray, InSelectedIndex) == 0x000010, "Member 'CreateCharacterSelUserWidget_OnSetOptionsArray::InSelectedIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeFaceIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeFaceIndex final
{
public:
	int32                                         InFaceIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeFaceIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeFaceIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeFaceIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeFaceIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeFaceIndex, InFaceIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeFaceIndex::InFaceIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeFaceIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeFaceIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeGender
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_ChangeGender final
{
public:
	bool                                          bInMale;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_ChangeGender) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_ChangeGender");
static_assert(sizeof(CreateCharacterUserWidget_ChangeGender) == 0x000001, "Wrong size on CreateCharacterUserWidget_ChangeGender");
static_assert(offsetof(CreateCharacterUserWidget_ChangeGender, bInMale) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeGender::bInMale' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeHairColorIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeHairColorIndex final
{
public:
	int32                                         InHairColorIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeHairColorIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeHairColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeHairColorIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeHairColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeHairColorIndex, InHairColorIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeHairColorIndex::InHairColorIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeHairColorIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeHairColorIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeHairStyleIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeHairStyleIndex final
{
public:
	int32                                         InHairStyleIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeHairStyleIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeHairStyleIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeHairStyleIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeHairStyleIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeHairStyleIndex, InHairStyleIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeHairStyleIndex::InHairStyleIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeHairStyleIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeHairStyleIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeSkinColorIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeSkinColorIndex final
{
public:
	int32                                         InSkinColorIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeSkinColorIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeSkinColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeSkinColorIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeSkinColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeSkinColorIndex, InSkinColorIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeSkinColorIndex::InSkinColorIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeSkinColorIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeSkinColorIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeTattooIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeTattooIndex final
{
public:
	int32                                         InTattooIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeTattooIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeTattooIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeTattooIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeTattooIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeTattooIndex, InTattooIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeTattooIndex::InTattooIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeTattooIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeTattooIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.ChangeVoiceIndex
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_ChangeVoiceIndex final
{
public:
	int32                                         InVoiceIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_ChangeVoiceIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_ChangeVoiceIndex");
static_assert(sizeof(CreateCharacterUserWidget_ChangeVoiceIndex) == 0x000008, "Wrong size on CreateCharacterUserWidget_ChangeVoiceIndex");
static_assert(offsetof(CreateCharacterUserWidget_ChangeVoiceIndex, InVoiceIndex) == 0x000000, "Member 'CreateCharacterUserWidget_ChangeVoiceIndex::InVoiceIndex' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_ChangeVoiceIndex, bChangeByUser) == 0x000004, "Member 'CreateCharacterUserWidget_ChangeVoiceIndex::bChangeByUser' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeFaceIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeFaceIndex final
{
public:
	int32                                         InFaceIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeFaceIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeFaceIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeFaceIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeFaceIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeFaceIndex, InFaceIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeFaceIndex::InFaceIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeGender
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnChangeGender final
{
public:
	bool                                          bInMale;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeGender) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnChangeGender");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeGender) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnChangeGender");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeGender, bInMale) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeGender::bInMale' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeHairColorIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeHairColorIndex final
{
public:
	int32                                         InHairColorIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeHairColorIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeHairColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeHairColorIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeHairColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeHairColorIndex, InHairColorIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeHairColorIndex::InHairColorIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeHairStyleIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeHairStyleIndex final
{
public:
	int32                                         InHairStyleIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeHairStyleIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeHairStyleIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeHairStyleIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeHairStyleIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeHairStyleIndex, InHairStyleIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeHairStyleIndex::InHairStyleIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeSkinColorIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeSkinColorIndex final
{
public:
	int32                                         InSkinColorIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeSkinColorIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeSkinColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeSkinColorIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeSkinColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeSkinColorIndex, InSkinColorIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeSkinColorIndex::InSkinColorIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeTattooIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeTattooIndex final
{
public:
	int32                                         InTattooIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeTattooIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeTattooIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeTattooIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeTattooIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeTattooIndex, InTattooIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeTattooIndex::InTattooIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnChangeVoiceIndex
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_OnChangeVoiceIndex final
{
public:
	int32                                         InVoiceIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnChangeVoiceIndex) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_OnChangeVoiceIndex");
static_assert(sizeof(CreateCharacterUserWidget_OnChangeVoiceIndex) == 0x000004, "Wrong size on CreateCharacterUserWidget_OnChangeVoiceIndex");
static_assert(offsetof(CreateCharacterUserWidget_OnChangeVoiceIndex, InVoiceIndex) == 0x000000, "Member 'CreateCharacterUserWidget_OnChangeVoiceIndex::InVoiceIndex' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnDialogueBackToMainMenuResult
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnDialogueBackToMainMenuResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnDialogueBackToMainMenuResult) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnDialogueBackToMainMenuResult");
static_assert(sizeof(CreateCharacterUserWidget_OnDialogueBackToMainMenuResult) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnDialogueBackToMainMenuResult");
static_assert(offsetof(CreateCharacterUserWidget_OnDialogueBackToMainMenuResult, ButtonType) == 0x000000, "Member 'CreateCharacterUserWidget_OnDialogueBackToMainMenuResult::ButtonType' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnIntroCinematicFinished
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_OnIntroCinematicFinished final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnIntroCinematicFinished) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_OnIntroCinematicFinished");
static_assert(sizeof(CreateCharacterUserWidget_OnIntroCinematicFinished) == 0x000008, "Wrong size on CreateCharacterUserWidget_OnIntroCinematicFinished");
static_assert(offsetof(CreateCharacterUserWidget_OnIntroCinematicFinished, ManUserWidgetBase) == 0x000000, "Member 'CreateCharacterUserWidget_OnIntroCinematicFinished::ManUserWidgetBase' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnPlayerMonologueCinematicFinished
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished");
static_assert(sizeof(CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished) == 0x000008, "Wrong size on CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished");
static_assert(offsetof(CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished, ManUserWidgetBase) == 0x000000, "Member 'CreateCharacterUserWidget_OnPlayerMonologueCinematicFinished::ManUserWidgetBase' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnSetCharacterName
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_OnSetCharacterName final
{
public:
	class FText                                   InCharacterName;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnSetCharacterName) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_OnSetCharacterName");
static_assert(sizeof(CreateCharacterUserWidget_OnSetCharacterName) == 0x000018, "Wrong size on CreateCharacterUserWidget_OnSetCharacterName");
static_assert(offsetof(CreateCharacterUserWidget_OnSetCharacterName, InCharacterName) == 0x000000, "Member 'CreateCharacterUserWidget_OnSetCharacterName::InCharacterName' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnSetCustomizeView
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnSetCustomizeView final
{
public:
	bool                                          bInCustomizeView;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnSetCustomizeView) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnSetCustomizeView");
static_assert(sizeof(CreateCharacterUserWidget_OnSetCustomizeView) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnSetCustomizeView");
static_assert(offsetof(CreateCharacterUserWidget_OnSetCustomizeView, bInCustomizeView) == 0x000000, "Member 'CreateCharacterUserWidget_OnSetCustomizeView::bInCustomizeView' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnSetFinalView
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnSetFinalView final
{
public:
	bool                                          bInFinalView;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnSetFinalView) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnSetFinalView");
static_assert(sizeof(CreateCharacterUserWidget_OnSetFinalView) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnSetFinalView");
static_assert(offsetof(CreateCharacterUserWidget_OnSetFinalView, bInFinalView) == 0x000000, "Member 'CreateCharacterUserWidget_OnSetFinalView::bInFinalView' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnShowSkillTooltipByMouse
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnShowSkillTooltipByMouse final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnShowSkillTooltipByMouse) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnShowSkillTooltipByMouse");
static_assert(sizeof(CreateCharacterUserWidget_OnShowSkillTooltipByMouse) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnShowSkillTooltipByMouse");
static_assert(offsetof(CreateCharacterUserWidget_OnShowSkillTooltipByMouse, bInVisible) == 0x000000, "Member 'CreateCharacterUserWidget_OnShowSkillTooltipByMouse::bInVisible' has a wrong offset!");

// Function man.CreateCharacterUserWidget.OnStartGameSaveInProgress
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_OnStartGameSaveInProgress final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_OnStartGameSaveInProgress) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_OnStartGameSaveInProgress");
static_assert(sizeof(CreateCharacterUserWidget_OnStartGameSaveInProgress) == 0x000001, "Wrong size on CreateCharacterUserWidget_OnStartGameSaveInProgress");
static_assert(offsetof(CreateCharacterUserWidget_OnStartGameSaveInProgress, bStart) == 0x000000, "Member 'CreateCharacterUserWidget_OnStartGameSaveInProgress::bStart' has a wrong offset!");

// Function man.CreateCharacterUserWidget.PlayVoiceAkPostEventCallback
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_PlayVoiceAkPostEventCallback final
{
public:
	EAkCallbackType                               CallbackType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        CallbackInfo;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_PlayVoiceAkPostEventCallback) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_PlayVoiceAkPostEventCallback");
static_assert(sizeof(CreateCharacterUserWidget_PlayVoiceAkPostEventCallback) == 0x000010, "Wrong size on CreateCharacterUserWidget_PlayVoiceAkPostEventCallback");
static_assert(offsetof(CreateCharacterUserWidget_PlayVoiceAkPostEventCallback, CallbackType) == 0x000000, "Member 'CreateCharacterUserWidget_PlayVoiceAkPostEventCallback::CallbackType' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_PlayVoiceAkPostEventCallback, CallbackInfo) == 0x000008, "Member 'CreateCharacterUserWidget_PlayVoiceAkPostEventCallback::CallbackInfo' has a wrong offset!");

// Function man.CreateCharacterUserWidget.RefreshCharacterParams
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_RefreshCharacterParams final
{
public:
	bool                                          bChangeClass;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_RefreshCharacterParams) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_RefreshCharacterParams");
static_assert(sizeof(CreateCharacterUserWidget_RefreshCharacterParams) == 0x000001, "Wrong size on CreateCharacterUserWidget_RefreshCharacterParams");
static_assert(offsetof(CreateCharacterUserWidget_RefreshCharacterParams, bChangeClass) == 0x000000, "Member 'CreateCharacterUserWidget_RefreshCharacterParams::bChangeClass' has a wrong offset!");

// Function man.CreateCharacterUserWidget.SetCustomizeView
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_SetCustomizeView final
{
public:
	bool                                          bInCustomizeView;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_SetCustomizeView) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_SetCustomizeView");
static_assert(sizeof(CreateCharacterUserWidget_SetCustomizeView) == 0x000001, "Wrong size on CreateCharacterUserWidget_SetCustomizeView");
static_assert(offsetof(CreateCharacterUserWidget_SetCustomizeView, bInCustomizeView) == 0x000000, "Member 'CreateCharacterUserWidget_SetCustomizeView::bInCustomizeView' has a wrong offset!");

// Function man.CreateCharacterUserWidget.SetFinalView
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_SetFinalView final
{
public:
	bool                                          bInFinalView;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_SetFinalView) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_SetFinalView");
static_assert(sizeof(CreateCharacterUserWidget_SetFinalView) == 0x000001, "Wrong size on CreateCharacterUserWidget_SetFinalView");
static_assert(offsetof(CreateCharacterUserWidget_SetFinalView, bInFinalView) == 0x000000, "Member 'CreateCharacterUserWidget_SetFinalView::bInFinalView' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetCharacterClassName
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_GetCharacterClassName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetCharacterClassName) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetCharacterClassName");
static_assert(sizeof(CreateCharacterUserWidget_GetCharacterClassName) == 0x000018, "Wrong size on CreateCharacterUserWidget_GetCharacterClassName");
static_assert(offsetof(CreateCharacterUserWidget_GetCharacterClassName, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetCharacterClassName::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetCharacterDescription
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_GetCharacterDescription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetCharacterDescription) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetCharacterDescription");
static_assert(sizeof(CreateCharacterUserWidget_GetCharacterDescription) == 0x000018, "Wrong size on CreateCharacterUserWidget_GetCharacterDescription");
static_assert(offsetof(CreateCharacterUserWidget_GetCharacterDescription, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetCharacterDescription::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetComboPoint
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetComboPoint final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetComboPoint) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetComboPoint");
static_assert(sizeof(CreateCharacterUserWidget_GetComboPoint) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetComboPoint");
static_assert(offsetof(CreateCharacterUserWidget_GetComboPoint, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetComboPoint::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultFaceIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultFaceIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultFaceIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultFaceIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultFaceIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultFaceIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultFaceIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultFaceIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultFaceIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultFaceIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultHairColorIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultHairColorIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultHairColorIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultHairColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultHairColorIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultHairColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultHairColorIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultHairColorIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultHairColorIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultHairColorIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultHairStyleIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultHairStyleIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultHairStyleIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultHairStyleIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultHairStyleIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultHairStyleIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultHairStyleIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultHairStyleIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultHairStyleIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultHairStyleIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultSkinColorIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultSkinColorIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultSkinColorIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultSkinColorIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultSkinColorIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultSkinColorIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultSkinColorIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultSkinColorIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultSkinColorIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultSkinColorIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultTattooIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultTattooIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultTattooIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultTattooIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultTattooIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultTattooIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultTattooIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultTattooIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultTattooIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultTattooIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetDefaultVoiceIndex
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetDefaultVoiceIndex final
{
public:
	class UCharacterCustomization*                CharacterCustomization;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CreateCharacterUserWidget_GetDefaultVoiceIndex) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetDefaultVoiceIndex");
static_assert(sizeof(CreateCharacterUserWidget_GetDefaultVoiceIndex) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetDefaultVoiceIndex");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultVoiceIndex, CharacterCustomization) == 0x000000, "Member 'CreateCharacterUserWidget_GetDefaultVoiceIndex::CharacterCustomization' has a wrong offset!");
static_assert(offsetof(CreateCharacterUserWidget_GetDefaultVoiceIndex, ReturnValue) == 0x000008, "Member 'CreateCharacterUserWidget_GetDefaultVoiceIndex::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetEnergy
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetEnergy final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetEnergy) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetEnergy");
static_assert(sizeof(CreateCharacterUserWidget_GetEnergy) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetEnergy");
static_assert(offsetof(CreateCharacterUserWidget_GetEnergy, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetEnergy::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetEquipLoad
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetEquipLoad final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetEquipLoad) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetEquipLoad");
static_assert(sizeof(CreateCharacterUserWidget_GetEquipLoad) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetEquipLoad");
static_assert(offsetof(CreateCharacterUserWidget_GetEquipLoad, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetEquipLoad::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetFaceTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetFaceTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetFaceTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetFaceTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetFaceTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetFaceTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetFaceTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetFaceTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetHairColorIcons
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetHairColorIcons final
{
public:
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetHairColorIcons) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetHairColorIcons");
static_assert(sizeof(CreateCharacterUserWidget_GetHairColorIcons) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetHairColorIcons");
static_assert(offsetof(CreateCharacterUserWidget_GetHairColorIcons, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetHairColorIcons::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetHairColorTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetHairColorTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetHairColorTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetHairColorTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetHairColorTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetHairColorTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetHairColorTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetHairColorTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetHairStyleTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetHairStyleTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetHairStyleTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetHairStyleTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetHairStyleTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetHairStyleTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetHairStyleTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetHairStyleTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetHealth) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetHealth");
static_assert(sizeof(CreateCharacterUserWidget_GetHealth) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetHealth");
static_assert(offsetof(CreateCharacterUserWidget_GetHealth, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetHealth::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetMagicalDamage
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetMagicalDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetMagicalDamage) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetMagicalDamage");
static_assert(sizeof(CreateCharacterUserWidget_GetMagicalDamage) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetMagicalDamage");
static_assert(offsetof(CreateCharacterUserWidget_GetMagicalDamage, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetMagicalDamage::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetMobility
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetMobility final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetMobility) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetMobility");
static_assert(sizeof(CreateCharacterUserWidget_GetMobility) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetMobility");
static_assert(offsetof(CreateCharacterUserWidget_GetMobility, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetMobility::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetPhysicalDamage
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetPhysicalDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetPhysicalDamage) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetPhysicalDamage");
static_assert(sizeof(CreateCharacterUserWidget_GetPhysicalDamage) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetPhysicalDamage");
static_assert(offsetof(CreateCharacterUserWidget_GetPhysicalDamage, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetPhysicalDamage::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetRage
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetRage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetRage) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetRage");
static_assert(sizeof(CreateCharacterUserWidget_GetRage) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetRage");
static_assert(offsetof(CreateCharacterUserWidget_GetRage, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetRage::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetRange
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetRange) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetRange");
static_assert(sizeof(CreateCharacterUserWidget_GetRange) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetRange");
static_assert(offsetof(CreateCharacterUserWidget_GetRange, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetRange::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkillClass
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_GetSkillClass final
{
public:
	TSubclassOf<class UAbilityBase>               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkillClass) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkillClass");
static_assert(sizeof(CreateCharacterUserWidget_GetSkillClass) == 0x000008, "Wrong size on CreateCharacterUserWidget_GetSkillClass");
static_assert(offsetof(CreateCharacterUserWidget_GetSkillClass, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkillClass::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkillCost
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_GetSkillCost final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkillCost) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkillCost");
static_assert(sizeof(CreateCharacterUserWidget_GetSkillCost) == 0x000018, "Wrong size on CreateCharacterUserWidget_GetSkillCost");
static_assert(offsetof(CreateCharacterUserWidget_GetSkillCost, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkillCost::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkillDescription
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_GetSkillDescription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkillDescription) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkillDescription");
static_assert(sizeof(CreateCharacterUserWidget_GetSkillDescription) == 0x000018, "Wrong size on CreateCharacterUserWidget_GetSkillDescription");
static_assert(offsetof(CreateCharacterUserWidget_GetSkillDescription, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkillDescription::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkillIcon
// 0x0008 (0x0008 - 0x0000)
struct CreateCharacterUserWidget_GetSkillIcon final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkillIcon) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkillIcon");
static_assert(sizeof(CreateCharacterUserWidget_GetSkillIcon) == 0x000008, "Wrong size on CreateCharacterUserWidget_GetSkillIcon");
static_assert(offsetof(CreateCharacterUserWidget_GetSkillIcon, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkillIcon::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkillName
// 0x0018 (0x0018 - 0x0000)
struct CreateCharacterUserWidget_GetSkillName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkillName) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkillName");
static_assert(sizeof(CreateCharacterUserWidget_GetSkillName) == 0x000018, "Wrong size on CreateCharacterUserWidget_GetSkillName");
static_assert(offsetof(CreateCharacterUserWidget_GetSkillName, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkillName::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkinColorIcons
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetSkinColorIcons final
{
public:
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkinColorIcons) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkinColorIcons");
static_assert(sizeof(CreateCharacterUserWidget_GetSkinColorIcons) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetSkinColorIcons");
static_assert(offsetof(CreateCharacterUserWidget_GetSkinColorIcons, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkinColorIcons::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSkinColorTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetSkinColorTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSkinColorTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetSkinColorTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetSkinColorTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetSkinColorTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetSkinColorTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSkinColorTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetStamina
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetStamina final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetStamina) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetStamina");
static_assert(sizeof(CreateCharacterUserWidget_GetStamina) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetStamina");
static_assert(offsetof(CreateCharacterUserWidget_GetStamina, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetStamina::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetSustain
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetSustain final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetSustain) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetSustain");
static_assert(sizeof(CreateCharacterUserWidget_GetSustain) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetSustain");
static_assert(offsetof(CreateCharacterUserWidget_GetSustain, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetSustain::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetTattooTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetTattooTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetTattooTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetTattooTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetTattooTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetTattooTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetTattooTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetTattooTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetToughness
// 0x0004 (0x0004 - 0x0000)
struct CreateCharacterUserWidget_GetToughness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetToughness) == 0x000004, "Wrong alignment on CreateCharacterUserWidget_GetToughness");
static_assert(sizeof(CreateCharacterUserWidget_GetToughness) == 0x000004, "Wrong size on CreateCharacterUserWidget_GetToughness");
static_assert(offsetof(CreateCharacterUserWidget_GetToughness, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetToughness::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.GetVoiceTexts
// 0x0010 (0x0010 - 0x0000)
struct CreateCharacterUserWidget_GetVoiceTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_GetVoiceTexts) == 0x000008, "Wrong alignment on CreateCharacterUserWidget_GetVoiceTexts");
static_assert(sizeof(CreateCharacterUserWidget_GetVoiceTexts) == 0x000010, "Wrong size on CreateCharacterUserWidget_GetVoiceTexts");
static_assert(offsetof(CreateCharacterUserWidget_GetVoiceTexts, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_GetVoiceTexts::ReturnValue' has a wrong offset!");

// Function man.CreateCharacterUserWidget.IsValidCharacterName
// 0x0001 (0x0001 - 0x0000)
struct CreateCharacterUserWidget_IsValidCharacterName final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateCharacterUserWidget_IsValidCharacterName) == 0x000001, "Wrong alignment on CreateCharacterUserWidget_IsValidCharacterName");
static_assert(sizeof(CreateCharacterUserWidget_IsValidCharacterName) == 0x000001, "Wrong size on CreateCharacterUserWidget_IsValidCharacterName");
static_assert(offsetof(CreateCharacterUserWidget_IsValidCharacterName, ReturnValue) == 0x000000, "Member 'CreateCharacterUserWidget_IsValidCharacterName::ReturnValue' has a wrong offset!");

// Function man.OptionsControlsUserWidget.SetSwapLeftAndRightSticks
// 0x0004 (0x0004 - 0x0000)
struct OptionsControlsUserWidget_SetSwapLeftAndRightSticks final
{
public:
	int32                                         NewSwapLeftAndRightSticks;                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsControlsUserWidget_SetSwapLeftAndRightSticks) == 0x000004, "Wrong alignment on OptionsControlsUserWidget_SetSwapLeftAndRightSticks");
static_assert(sizeof(OptionsControlsUserWidget_SetSwapLeftAndRightSticks) == 0x000004, "Wrong size on OptionsControlsUserWidget_SetSwapLeftAndRightSticks");
static_assert(offsetof(OptionsControlsUserWidget_SetSwapLeftAndRightSticks, NewSwapLeftAndRightSticks) == 0x000000, "Member 'OptionsControlsUserWidget_SetSwapLeftAndRightSticks::NewSwapLeftAndRightSticks' has a wrong offset!");

// Function man.OptionsControlsUserWidget.SetXAxis
// 0x0004 (0x0004 - 0x0000)
struct OptionsControlsUserWidget_SetXAxis final
{
public:
	int32                                         NewXAxis;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsControlsUserWidget_SetXAxis) == 0x000004, "Wrong alignment on OptionsControlsUserWidget_SetXAxis");
static_assert(sizeof(OptionsControlsUserWidget_SetXAxis) == 0x000004, "Wrong size on OptionsControlsUserWidget_SetXAxis");
static_assert(offsetof(OptionsControlsUserWidget_SetXAxis, NewXAxis) == 0x000000, "Member 'OptionsControlsUserWidget_SetXAxis::NewXAxis' has a wrong offset!");

// Function man.OptionsControlsUserWidget.SetYAxis
// 0x0004 (0x0004 - 0x0000)
struct OptionsControlsUserWidget_SetYAxis final
{
public:
	int32                                         NewYAxis;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsControlsUserWidget_SetYAxis) == 0x000004, "Wrong alignment on OptionsControlsUserWidget_SetYAxis");
static_assert(sizeof(OptionsControlsUserWidget_SetYAxis) == 0x000004, "Wrong size on OptionsControlsUserWidget_SetYAxis");
static_assert(offsetof(OptionsControlsUserWidget_SetYAxis, NewYAxis) == 0x000000, "Member 'OptionsControlsUserWidget_SetYAxis::NewYAxis' has a wrong offset!");

// Function man.CreditsObjectUserWidget.OnSetText
// 0x0048 (0x0048 - 0x0000)
struct CreditsObjectUserWidget_OnSetText final
{
public:
	class FText                                   InLeftText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InCenterText;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InRightText;                                       // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreditsObjectUserWidget_OnSetText) == 0x000008, "Wrong alignment on CreditsObjectUserWidget_OnSetText");
static_assert(sizeof(CreditsObjectUserWidget_OnSetText) == 0x000048, "Wrong size on CreditsObjectUserWidget_OnSetText");
static_assert(offsetof(CreditsObjectUserWidget_OnSetText, InLeftText) == 0x000000, "Member 'CreditsObjectUserWidget_OnSetText::InLeftText' has a wrong offset!");
static_assert(offsetof(CreditsObjectUserWidget_OnSetText, InCenterText) == 0x000018, "Member 'CreditsObjectUserWidget_OnSetText::InCenterText' has a wrong offset!");
static_assert(offsetof(CreditsObjectUserWidget_OnSetText, InRightText) == 0x000030, "Member 'CreditsObjectUserWidget_OnSetText::InRightText' has a wrong offset!");

// Function man.CreditsUserWidget.GetScrollSpeed
// 0x0004 (0x0004 - 0x0000)
struct CreditsUserWidget_GetScrollSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreditsUserWidget_GetScrollSpeed) == 0x000004, "Wrong alignment on CreditsUserWidget_GetScrollSpeed");
static_assert(sizeof(CreditsUserWidget_GetScrollSpeed) == 0x000004, "Wrong size on CreditsUserWidget_GetScrollSpeed");
static_assert(offsetof(CreditsUserWidget_GetScrollSpeed, ReturnValue) == 0x000000, "Member 'CreditsUserWidget_GetScrollSpeed::ReturnValue' has a wrong offset!");

// Function man.CreditsUserWidget.SetScrollSpeed
// 0x0001 (0x0001 - 0x0000)
struct CreditsUserWidget_SetScrollSpeed final
{
public:
	ECreditsScroolSpeed                           InCreditsScroolSpeed;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreditsUserWidget_SetScrollSpeed) == 0x000001, "Wrong alignment on CreditsUserWidget_SetScrollSpeed");
static_assert(sizeof(CreditsUserWidget_SetScrollSpeed) == 0x000001, "Wrong size on CreditsUserWidget_SetScrollSpeed");
static_assert(offsetof(CreditsUserWidget_SetScrollSpeed, InCreditsScroolSpeed) == 0x000000, "Member 'CreditsUserWidget_SetScrollSpeed::InCreditsScroolSpeed' has a wrong offset!");

// Function man.CritterRatAbility.TriggerOnComponentBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct CritterRatAbility_TriggerOnComponentBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CritterRatAbility_TriggerOnComponentBeginOverlap) == 0x000008, "Wrong alignment on CritterRatAbility_TriggerOnComponentBeginOverlap");
static_assert(sizeof(CritterRatAbility_TriggerOnComponentBeginOverlap) == 0x000010, "Wrong size on CritterRatAbility_TriggerOnComponentBeginOverlap");
static_assert(offsetof(CritterRatAbility_TriggerOnComponentBeginOverlap, OverlappedActor) == 0x000000, "Member 'CritterRatAbility_TriggerOnComponentBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(CritterRatAbility_TriggerOnComponentBeginOverlap, OtherActor) == 0x000008, "Member 'CritterRatAbility_TriggerOnComponentBeginOverlap::OtherActor' has a wrong offset!");

// Function man.MarionetteAttackNeedleStrike.BPGetEndAngle
// 0x0004 (0x0004 - 0x0000)
struct MarionetteAttackNeedleStrike_BPGetEndAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarionetteAttackNeedleStrike_BPGetEndAngle) == 0x000004, "Wrong alignment on MarionetteAttackNeedleStrike_BPGetEndAngle");
static_assert(sizeof(MarionetteAttackNeedleStrike_BPGetEndAngle) == 0x000004, "Wrong size on MarionetteAttackNeedleStrike_BPGetEndAngle");
static_assert(offsetof(MarionetteAttackNeedleStrike_BPGetEndAngle, ReturnValue) == 0x000000, "Member 'MarionetteAttackNeedleStrike_BPGetEndAngle::ReturnValue' has a wrong offset!");

// Function man.MarionetteAttackNeedleStrike.BPGetStartAngle
// 0x0004 (0x0004 - 0x0000)
struct MarionetteAttackNeedleStrike_BPGetStartAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MarionetteAttackNeedleStrike_BPGetStartAngle) == 0x000004, "Wrong alignment on MarionetteAttackNeedleStrike_BPGetStartAngle");
static_assert(sizeof(MarionetteAttackNeedleStrike_BPGetStartAngle) == 0x000004, "Wrong size on MarionetteAttackNeedleStrike_BPGetStartAngle");
static_assert(offsetof(MarionetteAttackNeedleStrike_BPGetStartAngle, ReturnValue) == 0x000000, "Member 'MarionetteAttackNeedleStrike_BPGetStartAngle::ReturnValue' has a wrong offset!");

// Function man.CurseAbility.OnDamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct CurseAbility_OnDamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurseAbility_OnDamageTaken) == 0x000008, "Wrong alignment on CurseAbility_OnDamageTaken");
static_assert(sizeof(CurseAbility_OnDamageTaken) == 0x0002D8, "Wrong size on CurseAbility_OnDamageTaken");
static_assert(offsetof(CurseAbility_OnDamageTaken, DamageParams) == 0x000000, "Member 'CurseAbility_OnDamageTaken::DamageParams' has a wrong offset!");

// Function man.MiniMapActorComponent.GetGatewayState
// 0x0001 (0x0001 - 0x0000)
struct MiniMapActorComponent_GetGatewayState final
{
public:
	EMiniMapGatewayState                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniMapActorComponent_GetGatewayState) == 0x000001, "Wrong alignment on MiniMapActorComponent_GetGatewayState");
static_assert(sizeof(MiniMapActorComponent_GetGatewayState) == 0x000001, "Wrong size on MiniMapActorComponent_GetGatewayState");
static_assert(offsetof(MiniMapActorComponent_GetGatewayState, ReturnValue) == 0x000000, "Member 'MiniMapActorComponent_GetGatewayState::ReturnValue' has a wrong offset!");

// Function man.MiniMapActorComponent.GetMiniMapActorState
// 0x0001 (0x0001 - 0x0000)
struct MiniMapActorComponent_GetMiniMapActorState final
{
public:
	EMiniMapActorState                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MiniMapActorComponent_GetMiniMapActorState) == 0x000001, "Wrong alignment on MiniMapActorComponent_GetMiniMapActorState");
static_assert(sizeof(MiniMapActorComponent_GetMiniMapActorState) == 0x000001, "Wrong size on MiniMapActorComponent_GetMiniMapActorState");
static_assert(offsetof(MiniMapActorComponent_GetMiniMapActorState, ReturnValue) == 0x000000, "Member 'MiniMapActorComponent_GetMiniMapActorState::ReturnValue' has a wrong offset!");

// Function man.CutsceneCinematicUserWidget.IsResumeToGame
// 0x0001 (0x0001 - 0x0000)
struct CutsceneCinematicUserWidget_IsResumeToGame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneCinematicUserWidget_IsResumeToGame) == 0x000001, "Wrong alignment on CutsceneCinematicUserWidget_IsResumeToGame");
static_assert(sizeof(CutsceneCinematicUserWidget_IsResumeToGame) == 0x000001, "Wrong size on CutsceneCinematicUserWidget_IsResumeToGame");
static_assert(offsetof(CutsceneCinematicUserWidget_IsResumeToGame, ReturnValue) == 0x000000, "Member 'CutsceneCinematicUserWidget_IsResumeToGame::ReturnValue' has a wrong offset!");

// Function man.CutsceneCinematicUserWidget.OnPauseMenuHide
// 0x0008 (0x0008 - 0x0000)
struct CutsceneCinematicUserWidget_OnPauseMenuHide final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneCinematicUserWidget_OnPauseMenuHide) == 0x000008, "Wrong alignment on CutsceneCinematicUserWidget_OnPauseMenuHide");
static_assert(sizeof(CutsceneCinematicUserWidget_OnPauseMenuHide) == 0x000008, "Wrong size on CutsceneCinematicUserWidget_OnPauseMenuHide");
static_assert(offsetof(CutsceneCinematicUserWidget_OnPauseMenuHide, ManUserWidgetBase) == 0x000000, "Member 'CutsceneCinematicUserWidget_OnPauseMenuHide::ManUserWidgetBase' has a wrong offset!");

// Function man.CutsceneCinematicUserWidget.OnPlayVideo
// 0x0010 (0x0010 - 0x0000)
struct CutsceneCinematicUserWidget_OnPlayVideo final
{
public:
	class FString                                 VideoUrl;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CutsceneCinematicUserWidget_OnPlayVideo) == 0x000008, "Wrong alignment on CutsceneCinematicUserWidget_OnPlayVideo");
static_assert(sizeof(CutsceneCinematicUserWidget_OnPlayVideo) == 0x000010, "Wrong size on CutsceneCinematicUserWidget_OnPlayVideo");
static_assert(offsetof(CutsceneCinematicUserWidget_OnPlayVideo, VideoUrl) == 0x000000, "Member 'CutsceneCinematicUserWidget_OnPlayVideo::VideoUrl' has a wrong offset!");

// Function man.DamageMatrixAbility.OnAbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct DamageMatrixAbility_OnAbilityEnd final
{
public:
	class UAbilityBase*                           AbilityEnded;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageMatrixAbility_OnAbilityEnd) == 0x000008, "Wrong alignment on DamageMatrixAbility_OnAbilityEnd");
static_assert(sizeof(DamageMatrixAbility_OnAbilityEnd) == 0x000008, "Wrong size on DamageMatrixAbility_OnAbilityEnd");
static_assert(offsetof(DamageMatrixAbility_OnAbilityEnd, AbilityEnded) == 0x000000, "Member 'DamageMatrixAbility_OnAbilityEnd::AbilityEnded' has a wrong offset!");

// Function man.WasteNotPassive.ComboPointsChanged
// 0x0010 (0x0010 - 0x0000)
struct WasteNotPassive_ComboPointsChanged final
{
public:
	int32                                         Delta;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WasteNotPassive_ComboPointsChanged) == 0x000008, "Wrong alignment on WasteNotPassive_ComboPointsChanged");
static_assert(sizeof(WasteNotPassive_ComboPointsChanged) == 0x000010, "Wrong size on WasteNotPassive_ComboPointsChanged");
static_assert(offsetof(WasteNotPassive_ComboPointsChanged, Delta) == 0x000000, "Member 'WasteNotPassive_ComboPointsChanged::Delta' has a wrong offset!");
static_assert(offsetof(WasteNotPassive_ComboPointsChanged, SourceAbility) == 0x000008, "Member 'WasteNotPassive_ComboPointsChanged::SourceAbility' has a wrong offset!");

// Function man.ManVolumeComponent.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct ManVolumeComponent_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManVolumeComponent_OnBeginOverlap) == 0x000008, "Wrong alignment on ManVolumeComponent_OnBeginOverlap");
static_assert(sizeof(ManVolumeComponent_OnBeginOverlap) == 0x0000A8, "Wrong size on ManVolumeComponent_OnBeginOverlap");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'ManVolumeComponent_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, OtherActor) == 0x000008, "Member 'ManVolumeComponent_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, OtherComp) == 0x000010, "Member 'ManVolumeComponent_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'ManVolumeComponent_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'ManVolumeComponent_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnBeginOverlap, SweepResult) == 0x000020, "Member 'ManVolumeComponent_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function man.ManVolumeComponent.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct ManVolumeComponent_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManVolumeComponent_OnEndOverlap) == 0x000008, "Wrong alignment on ManVolumeComponent_OnEndOverlap");
static_assert(sizeof(ManVolumeComponent_OnEndOverlap) == 0x000020, "Wrong size on ManVolumeComponent_OnEndOverlap");
static_assert(offsetof(ManVolumeComponent_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'ManVolumeComponent_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnEndOverlap, OtherActor) == 0x000008, "Member 'ManVolumeComponent_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnEndOverlap, OtherComp) == 0x000010, "Member 'ManVolumeComponent_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(ManVolumeComponent_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'ManVolumeComponent_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.DamageVFXRelation.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct DamageVFXRelation_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageVFXRelation_GetEditorName) == 0x000008, "Wrong alignment on DamageVFXRelation_GetEditorName");
static_assert(sizeof(DamageVFXRelation_GetEditorName) == 0x000010, "Wrong size on DamageVFXRelation_GetEditorName");
static_assert(offsetof(DamageVFXRelation_GetEditorName, ReturnValue) == 0x000000, "Member 'DamageVFXRelation_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.DarkFissureActorAbility.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DarkFissureActorAbility_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFissureActorAbility_DamageDealt) == 0x000008, "Wrong alignment on DarkFissureActorAbility_DamageDealt");
static_assert(sizeof(DarkFissureActorAbility_DamageDealt) == 0x0002D8, "Wrong size on DarkFissureActorAbility_DamageDealt");
static_assert(offsetof(DarkFissureActorAbility_DamageDealt, Param) == 0x000000, "Member 'DarkFissureActorAbility_DamageDealt::Param' has a wrong offset!");

// Function man.DarkFissureActorAbility.GetAllGroundActors
// 0x0010 (0x0010 - 0x0000)
struct DarkFissureActorAbility_GetAllGroundActors final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFissureActorAbility_GetAllGroundActors) == 0x000008, "Wrong alignment on DarkFissureActorAbility_GetAllGroundActors");
static_assert(sizeof(DarkFissureActorAbility_GetAllGroundActors) == 0x000010, "Wrong size on DarkFissureActorAbility_GetAllGroundActors");
static_assert(offsetof(DarkFissureActorAbility_GetAllGroundActors, ReturnValue) == 0x000000, "Member 'DarkFissureActorAbility_GetAllGroundActors::ReturnValue' has a wrong offset!");

// Function man.DarkFissureActorAbility.IsChaosCast
// 0x0001 (0x0001 - 0x0000)
struct DarkFissureActorAbility_IsChaosCast final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFissureActorAbility_IsChaosCast) == 0x000001, "Wrong alignment on DarkFissureActorAbility_IsChaosCast");
static_assert(sizeof(DarkFissureActorAbility_IsChaosCast) == 0x000001, "Wrong size on DarkFissureActorAbility_IsChaosCast");
static_assert(offsetof(DarkFissureActorAbility_IsChaosCast, ReturnValue) == 0x000000, "Member 'DarkFissureActorAbility_IsChaosCast::ReturnValue' has a wrong offset!");

// Function man.DarkFissureActorAbility.RegisterHitbox
// 0x0010 (0x0010 - 0x0000)
struct DarkFissureActorAbility_RegisterHitbox final
{
public:
	class UHitBox*                                HitBox;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoxName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkFissureActorAbility_RegisterHitbox) == 0x000008, "Wrong alignment on DarkFissureActorAbility_RegisterHitbox");
static_assert(sizeof(DarkFissureActorAbility_RegisterHitbox) == 0x000010, "Wrong size on DarkFissureActorAbility_RegisterHitbox");
static_assert(offsetof(DarkFissureActorAbility_RegisterHitbox, HitBox) == 0x000000, "Member 'DarkFissureActorAbility_RegisterHitbox::HitBox' has a wrong offset!");
static_assert(offsetof(DarkFissureActorAbility_RegisterHitbox, HitBoxName) == 0x000008, "Member 'DarkFissureActorAbility_RegisterHitbox::HitBoxName' has a wrong offset!");

// Function man.DarkVenomPassive.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DarkVenomPassive_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkVenomPassive_PostDamageDealt) == 0x000008, "Wrong alignment on DarkVenomPassive_PostDamageDealt");
static_assert(sizeof(DarkVenomPassive_PostDamageDealt) == 0x0002D8, "Wrong size on DarkVenomPassive_PostDamageDealt");
static_assert(offsetof(DarkVenomPassive_PostDamageDealt, Param) == 0x000000, "Member 'DarkVenomPassive_PostDamageDealt::Param' has a wrong offset!");

// Function man.DarkVenomPassive.StatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct DarkVenomPassive_StatusEffectCaused final
{
public:
	class AActor*                                 ToTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DarkVenomPassive_StatusEffectCaused) == 0x000008, "Wrong alignment on DarkVenomPassive_StatusEffectCaused");
static_assert(sizeof(DarkVenomPassive_StatusEffectCaused) == 0x000018, "Wrong size on DarkVenomPassive_StatusEffectCaused");
static_assert(offsetof(DarkVenomPassive_StatusEffectCaused, ToTarget) == 0x000000, "Member 'DarkVenomPassive_StatusEffectCaused::ToTarget' has a wrong offset!");
static_assert(offsetof(DarkVenomPassive_StatusEffectCaused, Type) == 0x000008, "Member 'DarkVenomPassive_StatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(DarkVenomPassive_StatusEffectCaused, IsNewEffect) == 0x000009, "Member 'DarkVenomPassive_StatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(DarkVenomPassive_StatusEffectCaused, Instance) == 0x000010, "Member 'DarkVenomPassive_StatusEffectCaused::Instance' has a wrong offset!");

// Function man.LightTetherAbility.GetSourceLocation
// 0x000C (0x000C - 0x0000)
struct LightTetherAbility_GetSourceLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightTetherAbility_GetSourceLocation) == 0x000004, "Wrong alignment on LightTetherAbility_GetSourceLocation");
static_assert(sizeof(LightTetherAbility_GetSourceLocation) == 0x00000C, "Wrong size on LightTetherAbility_GetSourceLocation");
static_assert(offsetof(LightTetherAbility_GetSourceLocation, ReturnValue) == 0x000000, "Member 'LightTetherAbility_GetSourceLocation::ReturnValue' has a wrong offset!");

// Function man.LightTetherAbility.GetTargetLocation
// 0x000C (0x000C - 0x0000)
struct LightTetherAbility_GetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightTetherAbility_GetTargetLocation) == 0x000004, "Wrong alignment on LightTetherAbility_GetTargetLocation");
static_assert(sizeof(LightTetherAbility_GetTargetLocation) == 0x00000C, "Wrong size on LightTetherAbility_GetTargetLocation");
static_assert(offsetof(LightTetherAbility_GetTargetLocation, ReturnValue) == 0x000000, "Member 'LightTetherAbility_GetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.LightTetherAbility.HasLineOfSightToTarget
// 0x0001 (0x0001 - 0x0000)
struct LightTetherAbility_HasLineOfSightToTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightTetherAbility_HasLineOfSightToTarget) == 0x000001, "Wrong alignment on LightTetherAbility_HasLineOfSightToTarget");
static_assert(sizeof(LightTetherAbility_HasLineOfSightToTarget) == 0x000001, "Wrong size on LightTetherAbility_HasLineOfSightToTarget");
static_assert(offsetof(LightTetherAbility_HasLineOfSightToTarget, ReturnValue) == 0x000000, "Member 'LightTetherAbility_HasLineOfSightToTarget::ReturnValue' has a wrong offset!");

// Function man.DCPHealAbility.BPGetAllyTargetActor
// 0x0008 (0x0008 - 0x0000)
struct DCPHealAbility_BPGetAllyTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPHealAbility_BPGetAllyTargetActor) == 0x000008, "Wrong alignment on DCPHealAbility_BPGetAllyTargetActor");
static_assert(sizeof(DCPHealAbility_BPGetAllyTargetActor) == 0x000008, "Wrong size on DCPHealAbility_BPGetAllyTargetActor");
static_assert(offsetof(DCPHealAbility_BPGetAllyTargetActor, ReturnValue) == 0x000000, "Member 'DCPHealAbility_BPGetAllyTargetActor::ReturnValue' has a wrong offset!");

// Function man.DieToRespawnAbility.OnEntityTeleportPost
// 0x000C (0x000C - 0x0000)
struct DieToRespawnAbility_OnEntityTeleportPost final
{
public:
	struct FVector                                NewPosition;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DieToRespawnAbility_OnEntityTeleportPost) == 0x000004, "Wrong alignment on DieToRespawnAbility_OnEntityTeleportPost");
static_assert(sizeof(DieToRespawnAbility_OnEntityTeleportPost) == 0x00000C, "Wrong size on DieToRespawnAbility_OnEntityTeleportPost");
static_assert(offsetof(DieToRespawnAbility_OnEntityTeleportPost, NewPosition) == 0x000000, "Member 'DieToRespawnAbility_OnEntityTeleportPost::NewPosition' has a wrong offset!");

// Function man.VendorCraftUserWidget.OnCraftItem
// 0x0001 (0x0001 - 0x0000)
struct VendorCraftUserWidget_OnCraftItem final
{
public:
	bool                                          InLevelUp;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_OnCraftItem) == 0x000001, "Wrong alignment on VendorCraftUserWidget_OnCraftItem");
static_assert(sizeof(VendorCraftUserWidget_OnCraftItem) == 0x000001, "Wrong size on VendorCraftUserWidget_OnCraftItem");
static_assert(offsetof(VendorCraftUserWidget_OnCraftItem, InLevelUp) == 0x000000, "Member 'VendorCraftUserWidget_OnCraftItem::InLevelUp' has a wrong offset!");

// Function man.VendorCraftUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct VendorCraftUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on VendorCraftUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(VendorCraftUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on VendorCraftUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(VendorCraftUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'VendorCraftUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(VendorCraftUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'VendorCraftUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.VendorCraftUserWidget.GetCraftItemCalculatedXPText
// 0x0018 (0x0018 - 0x0000)
struct VendorCraftUserWidget_GetCraftItemCalculatedXPText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_GetCraftItemCalculatedXPText) == 0x000008, "Wrong alignment on VendorCraftUserWidget_GetCraftItemCalculatedXPText");
static_assert(sizeof(VendorCraftUserWidget_GetCraftItemCalculatedXPText) == 0x000018, "Wrong size on VendorCraftUserWidget_GetCraftItemCalculatedXPText");
static_assert(offsetof(VendorCraftUserWidget_GetCraftItemCalculatedXPText, ReturnValue) == 0x000000, "Member 'VendorCraftUserWidget_GetCraftItemCalculatedXPText::ReturnValue' has a wrong offset!");

// Function man.VendorCraftUserWidget.GetCraftItemCalculatedXPValue
// 0x0004 (0x0004 - 0x0000)
struct VendorCraftUserWidget_GetCraftItemCalculatedXPValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_GetCraftItemCalculatedXPValue) == 0x000004, "Wrong alignment on VendorCraftUserWidget_GetCraftItemCalculatedXPValue");
static_assert(sizeof(VendorCraftUserWidget_GetCraftItemCalculatedXPValue) == 0x000004, "Wrong size on VendorCraftUserWidget_GetCraftItemCalculatedXPValue");
static_assert(offsetof(VendorCraftUserWidget_GetCraftItemCalculatedXPValue, ReturnValue) == 0x000000, "Member 'VendorCraftUserWidget_GetCraftItemCalculatedXPValue::ReturnValue' has a wrong offset!");

// Function man.VendorCraftUserWidget.GetItemRequiredLevelText
// 0x0020 (0x0020 - 0x0000)
struct VendorCraftUserWidget_GetItemRequiredLevelText final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_GetItemRequiredLevelText) == 0x000008, "Wrong alignment on VendorCraftUserWidget_GetItemRequiredLevelText");
static_assert(sizeof(VendorCraftUserWidget_GetItemRequiredLevelText) == 0x000020, "Wrong size on VendorCraftUserWidget_GetItemRequiredLevelText");
static_assert(offsetof(VendorCraftUserWidget_GetItemRequiredLevelText, ManItemSlotBase) == 0x000000, "Member 'VendorCraftUserWidget_GetItemRequiredLevelText::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(VendorCraftUserWidget_GetItemRequiredLevelText, ReturnValue) == 0x000008, "Member 'VendorCraftUserWidget_GetItemRequiredLevelText::ReturnValue' has a wrong offset!");

// Function man.VendorCraftUserWidget.HasGearFilter
// 0x0001 (0x0001 - 0x0000)
struct VendorCraftUserWidget_HasGearFilter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftUserWidget_HasGearFilter) == 0x000001, "Wrong alignment on VendorCraftUserWidget_HasGearFilter");
static_assert(sizeof(VendorCraftUserWidget_HasGearFilter) == 0x000001, "Wrong size on VendorCraftUserWidget_HasGearFilter");
static_assert(offsetof(VendorCraftUserWidget_HasGearFilter, ReturnValue) == 0x000000, "Member 'VendorCraftUserWidget_HasGearFilter::ReturnValue' has a wrong offset!");

// Function man.DeathScreenUserWidget.IsEntropyDeath
// 0x0001 (0x0001 - 0x0000)
struct DeathScreenUserWidget_IsEntropyDeath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathScreenUserWidget_IsEntropyDeath) == 0x000001, "Wrong alignment on DeathScreenUserWidget_IsEntropyDeath");
static_assert(sizeof(DeathScreenUserWidget_IsEntropyDeath) == 0x000001, "Wrong size on DeathScreenUserWidget_IsEntropyDeath");
static_assert(offsetof(DeathScreenUserWidget_IsEntropyDeath, ReturnValue) == 0x000000, "Member 'DeathScreenUserWidget_IsEntropyDeath::ReturnValue' has a wrong offset!");

// Function man.WaveOfLightProjectile.HeroAbilityStart
// 0x0010 (0x0010 - 0x0000)
struct WaveOfLightProjectile_HeroAbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WaveOfLightProjectile_HeroAbilityStart) == 0x000008, "Wrong alignment on WaveOfLightProjectile_HeroAbilityStart");
static_assert(sizeof(WaveOfLightProjectile_HeroAbilityStart) == 0x000010, "Wrong size on WaveOfLightProjectile_HeroAbilityStart");
static_assert(offsetof(WaveOfLightProjectile_HeroAbilityStart, Ability) == 0x000000, "Member 'WaveOfLightProjectile_HeroAbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(WaveOfLightProjectile_HeroAbilityStart, bDesired) == 0x000008, "Member 'WaveOfLightProjectile_HeroAbilityStart::bDesired' has a wrong offset!");

// Function man.WaveOfLightProjectile.ParentAbilityCustomEvent
// 0x0008 (0x0008 - 0x0000)
struct WaveOfLightProjectile_ParentAbilityCustomEvent final
{
public:
	class FName                                   CustomName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WaveOfLightProjectile_ParentAbilityCustomEvent) == 0x000004, "Wrong alignment on WaveOfLightProjectile_ParentAbilityCustomEvent");
static_assert(sizeof(WaveOfLightProjectile_ParentAbilityCustomEvent) == 0x000008, "Wrong size on WaveOfLightProjectile_ParentAbilityCustomEvent");
static_assert(offsetof(WaveOfLightProjectile_ParentAbilityCustomEvent, CustomName) == 0x000000, "Member 'WaveOfLightProjectile_ParentAbilityCustomEvent::CustomName' has a wrong offset!");

// Function man.TutorialPromptVolume.ActorEnter
// 0x00A8 (0x00A8 - 0x0000)
struct TutorialPromptVolume_ActorEnter final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_ActorEnter) == 0x000008, "Wrong alignment on TutorialPromptVolume_ActorEnter");
static_assert(sizeof(TutorialPromptVolume_ActorEnter) == 0x0000A8, "Wrong size on TutorialPromptVolume_ActorEnter");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, OverlappedComponent) == 0x000000, "Member 'TutorialPromptVolume_ActorEnter::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, OtherActor) == 0x000008, "Member 'TutorialPromptVolume_ActorEnter::OtherActor' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, OtherComp) == 0x000010, "Member 'TutorialPromptVolume_ActorEnter::OtherComp' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, OtherBodyIndex) == 0x000018, "Member 'TutorialPromptVolume_ActorEnter::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, bFromSweep) == 0x00001C, "Member 'TutorialPromptVolume_ActorEnter::bFromSweep' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorEnter, SweepResult) == 0x000020, "Member 'TutorialPromptVolume_ActorEnter::SweepResult' has a wrong offset!");

// Function man.TutorialPromptVolume.ActorExit
// 0x0020 (0x0020 - 0x0000)
struct TutorialPromptVolume_ActorExit final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TutorialPromptVolume_ActorExit) == 0x000008, "Wrong alignment on TutorialPromptVolume_ActorExit");
static_assert(sizeof(TutorialPromptVolume_ActorExit) == 0x000020, "Wrong size on TutorialPromptVolume_ActorExit");
static_assert(offsetof(TutorialPromptVolume_ActorExit, OverlappedComponent) == 0x000000, "Member 'TutorialPromptVolume_ActorExit::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorExit, OtherActor) == 0x000008, "Member 'TutorialPromptVolume_ActorExit::OtherActor' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorExit, OtherComp) == 0x000010, "Member 'TutorialPromptVolume_ActorExit::OtherComp' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_ActorExit, OtherBodyIndex) == 0x000018, "Member 'TutorialPromptVolume_ActorExit::OtherBodyIndex' has a wrong offset!");

// Function man.TutorialPromptVolume.CheckPointTravel
// 0x0008 (0x0008 - 0x0000)
struct TutorialPromptVolume_CheckPointTravel final
{
public:
	class UCheckpointData*                        Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_CheckPointTravel) == 0x000008, "Wrong alignment on TutorialPromptVolume_CheckPointTravel");
static_assert(sizeof(TutorialPromptVolume_CheckPointTravel) == 0x000008, "Wrong size on TutorialPromptVolume_CheckPointTravel");
static_assert(offsetof(TutorialPromptVolume_CheckPointTravel, Data) == 0x000000, "Member 'TutorialPromptVolume_CheckPointTravel::Data' has a wrong offset!");

// Function man.TutorialPromptVolume.GoToLevel
// 0x0010 (0x0010 - 0x0000)
struct TutorialPromptVolume_GoToLevel final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_GoToLevel) == 0x000008, "Wrong alignment on TutorialPromptVolume_GoToLevel");
static_assert(sizeof(TutorialPromptVolume_GoToLevel) == 0x000010, "Wrong size on TutorialPromptVolume_GoToLevel");
static_assert(offsetof(TutorialPromptVolume_GoToLevel, LevelName) == 0x000000, "Member 'TutorialPromptVolume_GoToLevel::LevelName' has a wrong offset!");

// Function man.TutorialPromptVolume_LadderSlide.OnLadderSlideStart
// 0x0008 (0x0008 - 0x0000)
struct TutorialPromptVolume_LadderSlide_OnLadderSlideStart final
{
public:
	class AActorBase*                             LadderActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_LadderSlide_OnLadderSlideStart) == 0x000008, "Wrong alignment on TutorialPromptVolume_LadderSlide_OnLadderSlideStart");
static_assert(sizeof(TutorialPromptVolume_LadderSlide_OnLadderSlideStart) == 0x000008, "Wrong size on TutorialPromptVolume_LadderSlide_OnLadderSlideStart");
static_assert(offsetof(TutorialPromptVolume_LadderSlide_OnLadderSlideStart, LadderActor) == 0x000000, "Member 'TutorialPromptVolume_LadderSlide_OnLadderSlideStart::LadderActor' has a wrong offset!");

// Function man.DieOfChaosProjectile.DieStateChanged
// 0x0004 (0x0004 - 0x0000)
struct DieOfChaosProjectile_DieStateChanged final
{
public:
	int32                                         NewState;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DieOfChaosProjectile_DieStateChanged) == 0x000004, "Wrong alignment on DieOfChaosProjectile_DieStateChanged");
static_assert(sizeof(DieOfChaosProjectile_DieStateChanged) == 0x000004, "Wrong size on DieOfChaosProjectile_DieStateChanged");
static_assert(offsetof(DieOfChaosProjectile_DieStateChanged, NewState) == 0x000000, "Member 'DieOfChaosProjectile_DieStateChanged::NewState' has a wrong offset!");

// Function man.KingPriestVoidAttackEntropicCatharsis2.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation");
static_assert(sizeof(KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation");
static_assert(offsetof(KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidAttackEntropicCatharsis2_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.WildSeedProjectile.GetCurrentDamageRadius
// 0x0004 (0x0004 - 0x0000)
struct WildSeedProjectile_GetCurrentDamageRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WildSeedProjectile_GetCurrentDamageRadius) == 0x000004, "Wrong alignment on WildSeedProjectile_GetCurrentDamageRadius");
static_assert(sizeof(WildSeedProjectile_GetCurrentDamageRadius) == 0x000004, "Wrong size on WildSeedProjectile_GetCurrentDamageRadius");
static_assert(offsetof(WildSeedProjectile_GetCurrentDamageRadius, ReturnValue) == 0x000000, "Member 'WildSeedProjectile_GetCurrentDamageRadius::ReturnValue' has a wrong offset!");

// Function man.WildSeedProjectile.GetDetonateDamageRadius
// 0x0004 (0x0004 - 0x0000)
struct WildSeedProjectile_GetDetonateDamageRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WildSeedProjectile_GetDetonateDamageRadius) == 0x000004, "Wrong alignment on WildSeedProjectile_GetDetonateDamageRadius");
static_assert(sizeof(WildSeedProjectile_GetDetonateDamageRadius) == 0x000004, "Wrong size on WildSeedProjectile_GetDetonateDamageRadius");
static_assert(offsetof(WildSeedProjectile_GetDetonateDamageRadius, ReturnValue) == 0x000000, "Member 'WildSeedProjectile_GetDetonateDamageRadius::ReturnValue' has a wrong offset!");

// Function man.WildSeedProjectile.GetFullGrowthTime
// 0x0004 (0x0004 - 0x0000)
struct WildSeedProjectile_GetFullGrowthTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WildSeedProjectile_GetFullGrowthTime) == 0x000004, "Wrong alignment on WildSeedProjectile_GetFullGrowthTime");
static_assert(sizeof(WildSeedProjectile_GetFullGrowthTime) == 0x000004, "Wrong size on WildSeedProjectile_GetFullGrowthTime");
static_assert(offsetof(WildSeedProjectile_GetFullGrowthTime, ReturnValue) == 0x000000, "Member 'WildSeedProjectile_GetFullGrowthTime::ReturnValue' has a wrong offset!");

// Function man.RetreatBladeProjectile.PreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct RetreatBladeProjectile_PreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RetreatBladeProjectile_PreDamageCaused) == 0x000008, "Wrong alignment on RetreatBladeProjectile_PreDamageCaused");
static_assert(sizeof(RetreatBladeProjectile_PreDamageCaused) == 0x0002D8, "Wrong size on RetreatBladeProjectile_PreDamageCaused");
static_assert(offsetof(RetreatBladeProjectile_PreDamageCaused, Param) == 0x000000, "Member 'RetreatBladeProjectile_PreDamageCaused::Param' has a wrong offset!");

// Function man.TwinFangsProjectile.UseStaminaRegenBuff
// 0x0001 (0x0001 - 0x0000)
struct TwinFangsProjectile_UseStaminaRegenBuff final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwinFangsProjectile_UseStaminaRegenBuff) == 0x000001, "Wrong alignment on TwinFangsProjectile_UseStaminaRegenBuff");
static_assert(sizeof(TwinFangsProjectile_UseStaminaRegenBuff) == 0x000001, "Wrong size on TwinFangsProjectile_UseStaminaRegenBuff");
static_assert(offsetof(TwinFangsProjectile_UseStaminaRegenBuff, ReturnValue) == 0x000000, "Member 'TwinFangsProjectile_UseStaminaRegenBuff::ReturnValue' has a wrong offset!");

// Function man.NetherBladeProjectile.GetTargetEnemy
// 0x0008 (0x0008 - 0x0000)
struct NetherBladeProjectile_GetTargetEnemy final
{
public:
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetherBladeProjectile_GetTargetEnemy) == 0x000008, "Wrong alignment on NetherBladeProjectile_GetTargetEnemy");
static_assert(sizeof(NetherBladeProjectile_GetTargetEnemy) == 0x000008, "Wrong size on NetherBladeProjectile_GetTargetEnemy");
static_assert(offsetof(NetherBladeProjectile_GetTargetEnemy, ReturnValue) == 0x000000, "Member 'NetherBladeProjectile_GetTargetEnemy::ReturnValue' has a wrong offset!");

// Function man.NetherBladeProjectile.GetTargetRotation
// 0x000C (0x000C - 0x0000)
struct NetherBladeProjectile_GetTargetRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetherBladeProjectile_GetTargetRotation) == 0x000004, "Wrong alignment on NetherBladeProjectile_GetTargetRotation");
static_assert(sizeof(NetherBladeProjectile_GetTargetRotation) == 0x00000C, "Wrong size on NetherBladeProjectile_GetTargetRotation");
static_assert(offsetof(NetherBladeProjectile_GetTargetRotation, ReturnValue) == 0x000000, "Member 'NetherBladeProjectile_GetTargetRotation::ReturnValue' has a wrong offset!");

// Function man.FireBoltProjectile.PreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct FireBoltProjectile_PreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FireBoltProjectile_PreDamageCaused) == 0x000008, "Wrong alignment on FireBoltProjectile_PreDamageCaused");
static_assert(sizeof(FireBoltProjectile_PreDamageCaused) == 0x0002D8, "Wrong size on FireBoltProjectile_PreDamageCaused");
static_assert(offsetof(FireBoltProjectile_PreDamageCaused, Param) == 0x000000, "Member 'FireBoltProjectile_PreDamageCaused::Param' has a wrong offset!");

// Function man.DetonateToxinAbility.GetVESourceLocation
// 0x000C (0x000C - 0x0000)
struct DetonateToxinAbility_GetVESourceLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DetonateToxinAbility_GetVESourceLocation) == 0x000004, "Wrong alignment on DetonateToxinAbility_GetVESourceLocation");
static_assert(sizeof(DetonateToxinAbility_GetVESourceLocation) == 0x00000C, "Wrong size on DetonateToxinAbility_GetVESourceLocation");
static_assert(offsetof(DetonateToxinAbility_GetVESourceLocation, ReturnValue) == 0x000000, "Member 'DetonateToxinAbility_GetVESourceLocation::ReturnValue' has a wrong offset!");

// Function man.DetonateToxinAbility.GetVETarget
// 0x0008 (0x0008 - 0x0000)
struct DetonateToxinAbility_GetVETarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DetonateToxinAbility_GetVETarget) == 0x000008, "Wrong alignment on DetonateToxinAbility_GetVETarget");
static_assert(sizeof(DetonateToxinAbility_GetVETarget) == 0x000008, "Wrong size on DetonateToxinAbility_GetVETarget");
static_assert(offsetof(DetonateToxinAbility_GetVETarget, ReturnValue) == 0x000000, "Member 'DetonateToxinAbility_GetVETarget::ReturnValue' has a wrong offset!");

// Function man.DetonateToxinAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DetonateToxinAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DetonateToxinAbility_PreDamageDealt) == 0x000008, "Wrong alignment on DetonateToxinAbility_PreDamageDealt");
static_assert(sizeof(DetonateToxinAbility_PreDamageDealt) == 0x0002D8, "Wrong size on DetonateToxinAbility_PreDamageDealt");
static_assert(offsetof(DetonateToxinAbility_PreDamageDealt, Param) == 0x000000, "Member 'DetonateToxinAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.VendorUpgradeSlotUserWidget.OnHighlighted
// 0x0002 (0x0002 - 0x0000)
struct VendorUpgradeSlotUserWidget_OnHighlighted final
{
public:
	bool                                          bHighlighted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUpgradeSlotUserWidget_OnHighlighted) == 0x000001, "Wrong alignment on VendorUpgradeSlotUserWidget_OnHighlighted");
static_assert(sizeof(VendorUpgradeSlotUserWidget_OnHighlighted) == 0x000002, "Wrong size on VendorUpgradeSlotUserWidget_OnHighlighted");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnHighlighted, bHighlighted) == 0x000000, "Member 'VendorUpgradeSlotUserWidget_OnHighlighted::bHighlighted' has a wrong offset!");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnHighlighted, bAnimate) == 0x000001, "Member 'VendorUpgradeSlotUserWidget_OnHighlighted::bAnimate' has a wrong offset!");

// Function man.VendorUpgradeSlotUserWidget.OnSetSlot
// 0x0050 (0x0050 - 0x0000)
struct VendorUpgradeSlotUserWidget_OnSetSlot final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDescription;                                     // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InRequirements;                                    // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInUnlocked;                                       // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorUpgradeSlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on VendorUpgradeSlotUserWidget_OnSetSlot");
static_assert(sizeof(VendorUpgradeSlotUserWidget_OnSetSlot) == 0x000050, "Wrong size on VendorUpgradeSlotUserWidget_OnSetSlot");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnSetSlot, InName) == 0x000000, "Member 'VendorUpgradeSlotUserWidget_OnSetSlot::InName' has a wrong offset!");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnSetSlot, InDescription) == 0x000018, "Member 'VendorUpgradeSlotUserWidget_OnSetSlot::InDescription' has a wrong offset!");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnSetSlot, InRequirements) == 0x000030, "Member 'VendorUpgradeSlotUserWidget_OnSetSlot::InRequirements' has a wrong offset!");
static_assert(offsetof(VendorUpgradeSlotUserWidget_OnSetSlot, bInUnlocked) == 0x000048, "Member 'VendorUpgradeSlotUserWidget_OnSetSlot::bInUnlocked' has a wrong offset!");

// Function man.DialogueWindowUserWidget.CloseDialogue
// 0x0001 (0x0001 - 0x0000)
struct DialogueWindowUserWidget_CloseDialogue final
{
public:
	EDialogueButtonType                           DialogueButtonType;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DialogueWindowUserWidget_CloseDialogue) == 0x000001, "Wrong alignment on DialogueWindowUserWidget_CloseDialogue");
static_assert(sizeof(DialogueWindowUserWidget_CloseDialogue) == 0x000001, "Wrong size on DialogueWindowUserWidget_CloseDialogue");
static_assert(offsetof(DialogueWindowUserWidget_CloseDialogue, DialogueButtonType) == 0x000000, "Member 'DialogueWindowUserWidget_CloseDialogue::DialogueButtonType' has a wrong offset!");

// Function man.DialogueWindowUserWidget.OnDescriptionTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DialogueWindowUserWidget_OnDescriptionTextChanged final
{
public:
	class FText                                   Desciption;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DialogueWindowUserWidget_OnDescriptionTextChanged) == 0x000008, "Wrong alignment on DialogueWindowUserWidget_OnDescriptionTextChanged");
static_assert(sizeof(DialogueWindowUserWidget_OnDescriptionTextChanged) == 0x000018, "Wrong size on DialogueWindowUserWidget_OnDescriptionTextChanged");
static_assert(offsetof(DialogueWindowUserWidget_OnDescriptionTextChanged, Desciption) == 0x000000, "Member 'DialogueWindowUserWidget_OnDescriptionTextChanged::Desciption' has a wrong offset!");

// Function man.DialogueWindowUserWidget.OnSetData
// 0x0078 (0x0078 - 0x0000)
struct DialogueWindowUserWidget_OnSetData final
{
public:
	class FText                                   InTitle;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDesciption;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InBtnHotkeyAText;                                  // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InBtnHotkeyXText;                                  // 0x0048(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InBtnHotkeyBText;                                  // 0x0060(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DialogueWindowUserWidget_OnSetData) == 0x000008, "Wrong alignment on DialogueWindowUserWidget_OnSetData");
static_assert(sizeof(DialogueWindowUserWidget_OnSetData) == 0x000078, "Wrong size on DialogueWindowUserWidget_OnSetData");
static_assert(offsetof(DialogueWindowUserWidget_OnSetData, InTitle) == 0x000000, "Member 'DialogueWindowUserWidget_OnSetData::InTitle' has a wrong offset!");
static_assert(offsetof(DialogueWindowUserWidget_OnSetData, InDesciption) == 0x000018, "Member 'DialogueWindowUserWidget_OnSetData::InDesciption' has a wrong offset!");
static_assert(offsetof(DialogueWindowUserWidget_OnSetData, InBtnHotkeyAText) == 0x000030, "Member 'DialogueWindowUserWidget_OnSetData::InBtnHotkeyAText' has a wrong offset!");
static_assert(offsetof(DialogueWindowUserWidget_OnSetData, InBtnHotkeyXText) == 0x000048, "Member 'DialogueWindowUserWidget_OnSetData::InBtnHotkeyXText' has a wrong offset!");
static_assert(offsetof(DialogueWindowUserWidget_OnSetData, InBtnHotkeyBText) == 0x000060, "Member 'DialogueWindowUserWidget_OnSetData::InBtnHotkeyBText' has a wrong offset!");

// Function man.DivineHammersProjectilePassive.ProjectileEvent
// 0x0018 (0x0018 - 0x0000)
struct DivineHammersProjectilePassive_ProjectileEvent final
{
public:
	EManProjectileEventType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                position;                                          // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineHammersProjectilePassive_ProjectileEvent) == 0x000008, "Wrong alignment on DivineHammersProjectilePassive_ProjectileEvent");
static_assert(sizeof(DivineHammersProjectilePassive_ProjectileEvent) == 0x000018, "Wrong size on DivineHammersProjectilePassive_ProjectileEvent");
static_assert(offsetof(DivineHammersProjectilePassive_ProjectileEvent, Type) == 0x000000, "Member 'DivineHammersProjectilePassive_ProjectileEvent::Type' has a wrong offset!");
static_assert(offsetof(DivineHammersProjectilePassive_ProjectileEvent, position) == 0x000004, "Member 'DivineHammersProjectilePassive_ProjectileEvent::position' has a wrong offset!");
static_assert(offsetof(DivineHammersProjectilePassive_ProjectileEvent, HitActor) == 0x000010, "Member 'DivineHammersProjectilePassive_ProjectileEvent::HitActor' has a wrong offset!");

// Function man.DivineWeaponAttackAbility.FamiliarAnimEvent
// 0x0018 (0x0018 - 0x0000)
struct DivineWeaponAttackAbility_FamiliarAnimEvent final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                Anim;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DivineWeaponAttackAbility_FamiliarAnimEvent) == 0x000008, "Wrong alignment on DivineWeaponAttackAbility_FamiliarAnimEvent");
static_assert(sizeof(DivineWeaponAttackAbility_FamiliarAnimEvent) == 0x000018, "Wrong size on DivineWeaponAttackAbility_FamiliarAnimEvent");
static_assert(offsetof(DivineWeaponAttackAbility_FamiliarAnimEvent, Ability) == 0x000000, "Member 'DivineWeaponAttackAbility_FamiliarAnimEvent::Ability' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_FamiliarAnimEvent, Anim) == 0x000008, "Member 'DivineWeaponAttackAbility_FamiliarAnimEvent::Anim' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_FamiliarAnimEvent, AnimEventType) == 0x000010, "Member 'DivineWeaponAttackAbility_FamiliarAnimEvent::AnimEventType' has a wrong offset!");

// Function man.DivineWeaponAttackAbility.OnDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct DivineWeaponAttackAbility_OnDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Params_0;                                          // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineWeaponAttackAbility_OnDamageDealt) == 0x000008, "Wrong alignment on DivineWeaponAttackAbility_OnDamageDealt");
static_assert(sizeof(DivineWeaponAttackAbility_OnDamageDealt) == 0x0002D8, "Wrong size on DivineWeaponAttackAbility_OnDamageDealt");
static_assert(offsetof(DivineWeaponAttackAbility_OnDamageDealt, Params_0) == 0x000000, "Member 'DivineWeaponAttackAbility_OnDamageDealt::Params_0' has a wrong offset!");

// Function man.DivineWeaponAttackAbility.OnGroupDamageDealt
// 0x0028 (0x0028 - 0x0000)
struct DivineWeaponAttackAbility_OnGroupDamageDealt final
{
public:
	int32                                         DamageGroupID;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageValue>                   DamageValues;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineWeaponAttackAbility_OnGroupDamageDealt) == 0x000008, "Wrong alignment on DivineWeaponAttackAbility_OnGroupDamageDealt");
static_assert(sizeof(DivineWeaponAttackAbility_OnGroupDamageDealt) == 0x000028, "Wrong size on DivineWeaponAttackAbility_OnGroupDamageDealt");
static_assert(offsetof(DivineWeaponAttackAbility_OnGroupDamageDealt, DamageGroupID) == 0x000000, "Member 'DivineWeaponAttackAbility_OnGroupDamageDealt::DamageGroupID' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_OnGroupDamageDealt, Source) == 0x000008, "Member 'DivineWeaponAttackAbility_OnGroupDamageDealt::Source' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_OnGroupDamageDealt, DamageTarget) == 0x000010, "Member 'DivineWeaponAttackAbility_OnGroupDamageDealt::DamageTarget' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_OnGroupDamageDealt, DamageValues) == 0x000018, "Member 'DivineWeaponAttackAbility_OnGroupDamageDealt::DamageValues' has a wrong offset!");

// Function man.DivineWeaponAttackAbility.OnHeroAbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct DivineWeaponAttackAbility_OnHeroAbilityEnded final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DivineWeaponAttackAbility_OnHeroAbilityEnded) == 0x000008, "Wrong alignment on DivineWeaponAttackAbility_OnHeroAbilityEnded");
static_assert(sizeof(DivineWeaponAttackAbility_OnHeroAbilityEnded) == 0x000008, "Wrong size on DivineWeaponAttackAbility_OnHeroAbilityEnded");
static_assert(offsetof(DivineWeaponAttackAbility_OnHeroAbilityEnded, Ability) == 0x000000, "Member 'DivineWeaponAttackAbility_OnHeroAbilityEnded::Ability' has a wrong offset!");

// Function man.DivineWeaponAttackAbility.OnHeroAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct DivineWeaponAttackAbility_OnHeroAbilityStarted final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Desired;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DivineWeaponAttackAbility_OnHeroAbilityStarted) == 0x000008, "Wrong alignment on DivineWeaponAttackAbility_OnHeroAbilityStarted");
static_assert(sizeof(DivineWeaponAttackAbility_OnHeroAbilityStarted) == 0x000010, "Wrong size on DivineWeaponAttackAbility_OnHeroAbilityStarted");
static_assert(offsetof(DivineWeaponAttackAbility_OnHeroAbilityStarted, Ability) == 0x000000, "Member 'DivineWeaponAttackAbility_OnHeroAbilityStarted::Ability' has a wrong offset!");
static_assert(offsetof(DivineWeaponAttackAbility_OnHeroAbilityStarted, Desired) == 0x000008, "Member 'DivineWeaponAttackAbility_OnHeroAbilityStarted::Desired' has a wrong offset!");

// Function man.VampireLordGrabAbility.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct VampireLordGrabAbility_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireLordGrabAbility_OnPreDamageCaused) == 0x000008, "Wrong alignment on VampireLordGrabAbility_OnPreDamageCaused");
static_assert(sizeof(VampireLordGrabAbility_OnPreDamageCaused) == 0x0002D8, "Wrong size on VampireLordGrabAbility_OnPreDamageCaused");
static_assert(offsetof(VampireLordGrabAbility_OnPreDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'VampireLordGrabAbility_OnPreDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.VampireLordChargeAbility.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct VampireLordChargeAbility_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VampireLordChargeAbility_IsCollideSignature) == 0x000008, "Wrong alignment on VampireLordChargeAbility_IsCollideSignature");
static_assert(sizeof(VampireLordChargeAbility_IsCollideSignature) == 0x000010, "Wrong size on VampireLordChargeAbility_IsCollideSignature");
static_assert(offsetof(VampireLordChargeAbility_IsCollideSignature, Actor) == 0x000000, "Member 'VampireLordChargeAbility_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(VampireLordChargeAbility_IsCollideSignature, bOverride) == 0x000008, "Member 'VampireLordChargeAbility_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(VampireLordChargeAbility_IsCollideSignature, bCollide) == 0x000009, "Member 'VampireLordChargeAbility_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.DefensiveStanceAbility.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct DefensiveStanceAbility_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefensiveStanceAbility_OnPreDamagedPriority) == 0x000008, "Wrong alignment on DefensiveStanceAbility_OnPreDamagedPriority");
static_assert(sizeof(DefensiveStanceAbility_OnPreDamagedPriority) == 0x0002D8, "Wrong size on DefensiveStanceAbility_OnPreDamagedPriority");
static_assert(offsetof(DefensiveStanceAbility_OnPreDamagedPriority, Param) == 0x000000, "Member 'DefensiveStanceAbility_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.OnSetCountdown
// 0x0020 (0x0020 - 0x0000)
struct VendorAlchemistSlotUserWidget_OnSetCountdown final
{
public:
	float                                         ElapsedCooldownPercent;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimeLeft;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistSlotUserWidget_OnSetCountdown) == 0x000008, "Wrong alignment on VendorAlchemistSlotUserWidget_OnSetCountdown");
static_assert(sizeof(VendorAlchemistSlotUserWidget_OnSetCountdown) == 0x000020, "Wrong size on VendorAlchemistSlotUserWidget_OnSetCountdown");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnSetCountdown, ElapsedCooldownPercent) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_OnSetCountdown::ElapsedCooldownPercent' has a wrong offset!");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnSetCountdown, TimeLeft) == 0x000008, "Member 'VendorAlchemistSlotUserWidget_OnSetCountdown::TimeLeft' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.OnSetSlot
// 0x0028 (0x0028 - 0x0000)
struct VendorAlchemistSlotUserWidget_OnSetSlot final
{
public:
	class FText                                   Name_0;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UTexture2D*                       Icon;                                              // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAkAudioEvent;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorAlchemistSlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on VendorAlchemistSlotUserWidget_OnSetSlot");
static_assert(sizeof(VendorAlchemistSlotUserWidget_OnSetSlot) == 0x000028, "Wrong size on VendorAlchemistSlotUserWidget_OnSetSlot");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnSetSlot, Name_0) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_OnSetSlot::Name_0' has a wrong offset!");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnSetSlot, Icon) == 0x000018, "Member 'VendorAlchemistSlotUserWidget_OnSetSlot::Icon' has a wrong offset!");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnSetSlot, bPlayAkAudioEvent) == 0x000020, "Member 'VendorAlchemistSlotUserWidget_OnSetSlot::bPlayAkAudioEvent' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.OnToggleCompleted
// 0x0001 (0x0001 - 0x0000)
struct VendorAlchemistSlotUserWidget_OnToggleCompleted final
{
public:
	bool                                          bCompleted;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistSlotUserWidget_OnToggleCompleted) == 0x000001, "Wrong alignment on VendorAlchemistSlotUserWidget_OnToggleCompleted");
static_assert(sizeof(VendorAlchemistSlotUserWidget_OnToggleCompleted) == 0x000001, "Wrong size on VendorAlchemistSlotUserWidget_OnToggleCompleted");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnToggleCompleted, bCompleted) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_OnToggleCompleted::bCompleted' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.OnToggleEquipState
// 0x0001 (0x0001 - 0x0000)
struct VendorAlchemistSlotUserWidget_OnToggleEquipState final
{
public:
	bool                                          bEquipState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistSlotUserWidget_OnToggleEquipState) == 0x000001, "Wrong alignment on VendorAlchemistSlotUserWidget_OnToggleEquipState");
static_assert(sizeof(VendorAlchemistSlotUserWidget_OnToggleEquipState) == 0x000001, "Wrong size on VendorAlchemistSlotUserWidget_OnToggleEquipState");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnToggleEquipState, bEquipState) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_OnToggleEquipState::bEquipState' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.OnToggleLocked
// 0x0020 (0x0020 - 0x0000)
struct VendorAlchemistSlotUserWidget_OnToggleLocked final
{
public:
	bool                                          bInLocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LockedLevel;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistSlotUserWidget_OnToggleLocked) == 0x000008, "Wrong alignment on VendorAlchemistSlotUserWidget_OnToggleLocked");
static_assert(sizeof(VendorAlchemistSlotUserWidget_OnToggleLocked) == 0x000020, "Wrong size on VendorAlchemistSlotUserWidget_OnToggleLocked");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnToggleLocked, bInLocked) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_OnToggleLocked::bInLocked' has a wrong offset!");
static_assert(offsetof(VendorAlchemistSlotUserWidget_OnToggleLocked, LockedLevel) == 0x000008, "Member 'VendorAlchemistSlotUserWidget_OnToggleLocked::LockedLevel' has a wrong offset!");

// Function man.VendorAlchemistSlotUserWidget.IsCompleted
// 0x0001 (0x0001 - 0x0000)
struct VendorAlchemistSlotUserWidget_IsCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistSlotUserWidget_IsCompleted) == 0x000001, "Wrong alignment on VendorAlchemistSlotUserWidget_IsCompleted");
static_assert(sizeof(VendorAlchemistSlotUserWidget_IsCompleted) == 0x000001, "Wrong size on VendorAlchemistSlotUserWidget_IsCompleted");
static_assert(offsetof(VendorAlchemistSlotUserWidget_IsCompleted, ReturnValue) == 0x000000, "Member 'VendorAlchemistSlotUserWidget_IsCompleted::ReturnValue' has a wrong offset!");

// Function man.VoidRatResurrectAbility.GetResurectTargets
// 0x0010 (0x0010 - 0x0000)
struct VoidRatResurrectAbility_GetResurectTargets final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidRatResurrectAbility_GetResurectTargets) == 0x000008, "Wrong alignment on VoidRatResurrectAbility_GetResurectTargets");
static_assert(sizeof(VoidRatResurrectAbility_GetResurectTargets) == 0x000010, "Wrong size on VoidRatResurrectAbility_GetResurectTargets");
static_assert(offsetof(VoidRatResurrectAbility_GetResurectTargets, ReturnValue) == 0x000000, "Member 'VoidRatResurrectAbility_GetResurectTargets::ReturnValue' has a wrong offset!");

// Function man.DynamicObstacleActor.BPSetCollision
// 0x0001 (0x0001 - 0x0000)
struct DynamicObstacleActor_BPSetCollision final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicObstacleActor_BPSetCollision) == 0x000001, "Wrong alignment on DynamicObstacleActor_BPSetCollision");
static_assert(sizeof(DynamicObstacleActor_BPSetCollision) == 0x000001, "Wrong size on DynamicObstacleActor_BPSetCollision");
static_assert(offsetof(DynamicObstacleActor_BPSetCollision, bEnabled) == 0x000000, "Member 'DynamicObstacleActor_BPSetCollision::bEnabled' has a wrong offset!");

// Function man.EnemyBlockerVolume.ManSetEnable
// 0x0001 (0x0001 - 0x0000)
struct EnemyBlockerVolume_ManSetEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemyBlockerVolume_ManSetEnable) == 0x000001, "Wrong alignment on EnemyBlockerVolume_ManSetEnable");
static_assert(sizeof(EnemyBlockerVolume_ManSetEnable) == 0x000001, "Wrong size on EnemyBlockerVolume_ManSetEnable");
static_assert(offsetof(EnemyBlockerVolume_ManSetEnable, bEnable) == 0x000000, "Member 'EnemyBlockerVolume_ManSetEnable::bEnable' has a wrong offset!");

// Function man.InquisitorLightBarrier.LightBarrier_OnDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct InquisitorLightBarrier_LightBarrier_OnDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorLightBarrier_LightBarrier_OnDamageDealt) == 0x000008, "Wrong alignment on InquisitorLightBarrier_LightBarrier_OnDamageDealt");
static_assert(sizeof(InquisitorLightBarrier_LightBarrier_OnDamageDealt) == 0x0002D8, "Wrong size on InquisitorLightBarrier_LightBarrier_OnDamageDealt");
static_assert(offsetof(InquisitorLightBarrier_LightBarrier_OnDamageDealt, Param) == 0x000000, "Member 'InquisitorLightBarrier_LightBarrier_OnDamageDealt::Param' has a wrong offset!");

// Function man.InquisitorLightBarrier.LightBarrier_OnPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct InquisitorLightBarrier_LightBarrier_OnPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorLightBarrier_LightBarrier_OnPreDamaged) == 0x000008, "Wrong alignment on InquisitorLightBarrier_LightBarrier_OnPreDamaged");
static_assert(sizeof(InquisitorLightBarrier_LightBarrier_OnPreDamaged) == 0x0002D8, "Wrong size on InquisitorLightBarrier_LightBarrier_OnPreDamaged");
static_assert(offsetof(InquisitorLightBarrier_LightBarrier_OnPreDamaged, Param) == 0x000000, "Member 'InquisitorLightBarrier_LightBarrier_OnPreDamaged::Param' has a wrong offset!");

// Function man.LuckyStreakPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct LuckyStreakPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LuckyStreakPassive_DamageDealt) == 0x000008, "Wrong alignment on LuckyStreakPassive_DamageDealt");
static_assert(sizeof(LuckyStreakPassive_DamageDealt) == 0x0002D8, "Wrong size on LuckyStreakPassive_DamageDealt");
static_assert(offsetof(LuckyStreakPassive_DamageDealt, Param) == 0x000000, "Member 'LuckyStreakPassive_DamageDealt::Param' has a wrong offset!");

// Function man.EntropicVacuumActor.DrainOnEnd
// 0x0008 (0x0008 - 0x0000)
struct EntropicVacuumActor_DrainOnEnd final
{
public:
	class AHeroBase*                              Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropicVacuumActor_DrainOnEnd) == 0x000008, "Wrong alignment on EntropicVacuumActor_DrainOnEnd");
static_assert(sizeof(EntropicVacuumActor_DrainOnEnd) == 0x000008, "Wrong size on EntropicVacuumActor_DrainOnEnd");
static_assert(offsetof(EntropicVacuumActor_DrainOnEnd, Hero) == 0x000000, "Member 'EntropicVacuumActor_DrainOnEnd::Hero' has a wrong offset!");

// Function man.EntropicVacuumActor.DrainOnStart
// 0x0008 (0x0008 - 0x0000)
struct EntropicVacuumActor_DrainOnStart final
{
public:
	class AHeroBase*                              Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropicVacuumActor_DrainOnStart) == 0x000008, "Wrong alignment on EntropicVacuumActor_DrainOnStart");
static_assert(sizeof(EntropicVacuumActor_DrainOnStart) == 0x000008, "Wrong size on EntropicVacuumActor_DrainOnStart");
static_assert(offsetof(EntropicVacuumActor_DrainOnStart, Hero) == 0x000000, "Member 'EntropicVacuumActor_DrainOnStart::Hero' has a wrong offset!");

// Function man.InspirationPassive.AbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct InspirationPassive_AbilityEnd final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InspirationPassive_AbilityEnd) == 0x000008, "Wrong alignment on InspirationPassive_AbilityEnd");
static_assert(sizeof(InspirationPassive_AbilityEnd) == 0x000008, "Wrong size on InspirationPassive_AbilityEnd");
static_assert(offsetof(InspirationPassive_AbilityEnd, Ability) == 0x000000, "Member 'InspirationPassive_AbilityEnd::Ability' has a wrong offset!");

// Function man.InspirationPassive.AbilityStart
// 0x0010 (0x0010 - 0x0000)
struct InspirationPassive_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InspirationPassive_AbilityStart) == 0x000008, "Wrong alignment on InspirationPassive_AbilityStart");
static_assert(sizeof(InspirationPassive_AbilityStart) == 0x000010, "Wrong size on InspirationPassive_AbilityStart");
static_assert(offsetof(InspirationPassive_AbilityStart, Ability) == 0x000000, "Member 'InspirationPassive_AbilityStart::Ability' has a wrong offset!");
static_assert(offsetof(InspirationPassive_AbilityStart, bDesired) == 0x000008, "Member 'InspirationPassive_AbilityStart::bDesired' has a wrong offset!");

// Function man.EntropyRiftExitQuestion.OnDialogueEntropyRiftLeave
// 0x0001 (0x0001 - 0x0000)
struct EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave) == 0x000001, "Wrong alignment on EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave");
static_assert(sizeof(EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave) == 0x000001, "Wrong size on EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave");
static_assert(offsetof(EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave, ButtonType) == 0x000000, "Member 'EntropyRiftExitQuestion_OnDialogueEntropyRiftLeave::ButtonType' has a wrong offset!");

// Function man.EntropyRiftImplement.OnBeginRiftVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct EntropyRiftImplement_OnBeginRiftVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyRiftImplement_OnBeginRiftVolumeOverlap) == 0x000008, "Wrong alignment on EntropyRiftImplement_OnBeginRiftVolumeOverlap");
static_assert(sizeof(EntropyRiftImplement_OnBeginRiftVolumeOverlap) == 0x000010, "Wrong size on EntropyRiftImplement_OnBeginRiftVolumeOverlap");
static_assert(offsetof(EntropyRiftImplement_OnBeginRiftVolumeOverlap, OverlappedActor) == 0x000000, "Member 'EntropyRiftImplement_OnBeginRiftVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(EntropyRiftImplement_OnBeginRiftVolumeOverlap, OtherActor) == 0x000008, "Member 'EntropyRiftImplement_OnBeginRiftVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.EntropyRiftMainControl.OnBeginRiftVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct EntropyRiftMainControl_OnBeginRiftVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyRiftMainControl_OnBeginRiftVolumeOverlap) == 0x000008, "Wrong alignment on EntropyRiftMainControl_OnBeginRiftVolumeOverlap");
static_assert(sizeof(EntropyRiftMainControl_OnBeginRiftVolumeOverlap) == 0x000010, "Wrong size on EntropyRiftMainControl_OnBeginRiftVolumeOverlap");
static_assert(offsetof(EntropyRiftMainControl_OnBeginRiftVolumeOverlap, OverlappedActor) == 0x000000, "Member 'EntropyRiftMainControl_OnBeginRiftVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(EntropyRiftMainControl_OnBeginRiftVolumeOverlap, OtherActor) == 0x000008, "Member 'EntropyRiftMainControl_OnBeginRiftVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.EntropyRiftMainControl.OnEndRiftVolumeOverlap
// 0x0010 (0x0010 - 0x0000)
struct EntropyRiftMainControl_OnEndRiftVolumeOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropyRiftMainControl_OnEndRiftVolumeOverlap) == 0x000008, "Wrong alignment on EntropyRiftMainControl_OnEndRiftVolumeOverlap");
static_assert(sizeof(EntropyRiftMainControl_OnEndRiftVolumeOverlap) == 0x000010, "Wrong size on EntropyRiftMainControl_OnEndRiftVolumeOverlap");
static_assert(offsetof(EntropyRiftMainControl_OnEndRiftVolumeOverlap, OverlappedActor) == 0x000000, "Member 'EntropyRiftMainControl_OnEndRiftVolumeOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(EntropyRiftMainControl_OnEndRiftVolumeOverlap, OtherActor) == 0x000008, "Member 'EntropyRiftMainControl_OnEndRiftVolumeOverlap::OtherActor' has a wrong offset!");

// Function man.EntropySpawnPortalAbility.BPGetSpawnedActor
// 0x0008 (0x0008 - 0x0000)
struct EntropySpawnPortalAbility_BPGetSpawnedActor final
{
public:
	class ACharacterBase*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntropySpawnPortalAbility_BPGetSpawnedActor) == 0x000008, "Wrong alignment on EntropySpawnPortalAbility_BPGetSpawnedActor");
static_assert(sizeof(EntropySpawnPortalAbility_BPGetSpawnedActor) == 0x000008, "Wrong size on EntropySpawnPortalAbility_BPGetSpawnedActor");
static_assert(offsetof(EntropySpawnPortalAbility_BPGetSpawnedActor, ReturnValue) == 0x000000, "Member 'EntropySpawnPortalAbility_BPGetSpawnedActor::ReturnValue' has a wrong offset!");

// Function man.EnvenomLatentDebuffPassive.StackNumChanged
// 0x0010 (0x0010 - 0x0000)
struct EnvenomLatentDebuffPassive_StackNumChanged final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevStackNum;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvenomLatentDebuffPassive_StackNumChanged) == 0x000008, "Wrong alignment on EnvenomLatentDebuffPassive_StackNumChanged");
static_assert(sizeof(EnvenomLatentDebuffPassive_StackNumChanged) == 0x000010, "Wrong size on EnvenomLatentDebuffPassive_StackNumChanged");
static_assert(offsetof(EnvenomLatentDebuffPassive_StackNumChanged, InAbility) == 0x000000, "Member 'EnvenomLatentDebuffPassive_StackNumChanged::InAbility' has a wrong offset!");
static_assert(offsetof(EnvenomLatentDebuffPassive_StackNumChanged, PrevStackNum) == 0x000008, "Member 'EnvenomLatentDebuffPassive_StackNumChanged::PrevStackNum' has a wrong offset!");

// Function man.LadderClimb.OnTeleport
// 0x000C (0x000C - 0x0000)
struct LadderClimb_OnTeleport final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LadderClimb_OnTeleport) == 0x000004, "Wrong alignment on LadderClimb_OnTeleport");
static_assert(sizeof(LadderClimb_OnTeleport) == 0x00000C, "Wrong size on LadderClimb_OnTeleport");
static_assert(offsetof(LadderClimb_OnTeleport, NewLocation) == 0x000000, "Member 'LadderClimb_OnTeleport::NewLocation' has a wrong offset!");

// Function man.LadderClimb.OnUserInput
// 0x0004 (0x0004 - 0x0000)
struct LadderClimb_OnUserInput final
{
public:
	int32                                         InputCommandNum;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LadderClimb_OnUserInput) == 0x000004, "Wrong alignment on LadderClimb_OnUserInput");
static_assert(sizeof(LadderClimb_OnUserInput) == 0x000004, "Wrong size on LadderClimb_OnUserInput");
static_assert(offsetof(LadderClimb_OnUserInput, InputCommandNum) == 0x000000, "Member 'LadderClimb_OnUserInput::InputCommandNum' has a wrong offset!");

// Function man.TeleportBackOnTriggerAbility.IsConnectionWarningActive
// 0x0001 (0x0001 - 0x0000)
struct TeleportBackOnTriggerAbility_IsConnectionWarningActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportBackOnTriggerAbility_IsConnectionWarningActive) == 0x000001, "Wrong alignment on TeleportBackOnTriggerAbility_IsConnectionWarningActive");
static_assert(sizeof(TeleportBackOnTriggerAbility_IsConnectionWarningActive) == 0x000001, "Wrong size on TeleportBackOnTriggerAbility_IsConnectionWarningActive");
static_assert(offsetof(TeleportBackOnTriggerAbility_IsConnectionWarningActive, ReturnValue) == 0x000000, "Member 'TeleportBackOnTriggerAbility_IsConnectionWarningActive::ReturnValue' has a wrong offset!");

// Function man.TeleportBackOnTriggerAbility.OnEntityKilledWithRebirth
// 0x0008 (0x0008 - 0x0000)
struct TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth final
{
public:
	class AActor*                                 KilledActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth) == 0x000008, "Wrong alignment on TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth");
static_assert(sizeof(TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth) == 0x000008, "Wrong size on TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth, KilledActor) == 0x000000, "Member 'TeleportBackOnTriggerAbility_OnEntityKilledWithRebirth::KilledActor' has a wrong offset!");

// Function man.TeleportBackOnTriggerAbility.OnHeroPreTravel
// 0x0020 (0x0020 - 0x0000)
struct TeleportBackOnTriggerAbility_OnHeroPreTravel final
{
public:
	class ALevelVisualVolume*                     SourceLevelVisualVolume;                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelVisualVolume*                     TargetLevelVisualVolume;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewPos;                                            // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeleportBackOnTriggerAbility_OnHeroPreTravel) == 0x000008, "Wrong alignment on TeleportBackOnTriggerAbility_OnHeroPreTravel");
static_assert(sizeof(TeleportBackOnTriggerAbility_OnHeroPreTravel) == 0x000020, "Wrong size on TeleportBackOnTriggerAbility_OnHeroPreTravel");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnHeroPreTravel, SourceLevelVisualVolume) == 0x000000, "Member 'TeleportBackOnTriggerAbility_OnHeroPreTravel::SourceLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnHeroPreTravel, TargetLevelVisualVolume) == 0x000008, "Member 'TeleportBackOnTriggerAbility_OnHeroPreTravel::TargetLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnHeroPreTravel, NewPos) == 0x000010, "Member 'TeleportBackOnTriggerAbility_OnHeroPreTravel::NewPos' has a wrong offset!");

// Function man.TeleportBackOnTriggerAbility.OnPostDamageDone
// 0x02D8 (0x02D8 - 0x0000)
struct TeleportBackOnTriggerAbility_OnPostDamageDone final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportBackOnTriggerAbility_OnPostDamageDone) == 0x000008, "Wrong alignment on TeleportBackOnTriggerAbility_OnPostDamageDone");
static_assert(sizeof(TeleportBackOnTriggerAbility_OnPostDamageDone) == 0x0002D8, "Wrong size on TeleportBackOnTriggerAbility_OnPostDamageDone");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnPostDamageDone, DamageParams) == 0x000000, "Member 'TeleportBackOnTriggerAbility_OnPostDamageDone::DamageParams' has a wrong offset!");

// Function man.TeleportBackOnTriggerAbility.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct TeleportBackOnTriggerAbility_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportBackOnTriggerAbility_OnPreDamageCaused) == 0x000008, "Wrong alignment on TeleportBackOnTriggerAbility_OnPreDamageCaused");
static_assert(sizeof(TeleportBackOnTriggerAbility_OnPreDamageCaused) == 0x0002D8, "Wrong size on TeleportBackOnTriggerAbility_OnPreDamageCaused");
static_assert(offsetof(TeleportBackOnTriggerAbility_OnPreDamageCaused, Param) == 0x000000, "Member 'TeleportBackOnTriggerAbility_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.LegalWindowUserWidget.ChangeLanguageIndex
// 0x0008 (0x0008 - 0x0000)
struct LegalWindowUserWidget_ChangeLanguageIndex final
{
public:
	int32                                         InLanguageIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeByUser;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LegalWindowUserWidget_ChangeLanguageIndex) == 0x000004, "Wrong alignment on LegalWindowUserWidget_ChangeLanguageIndex");
static_assert(sizeof(LegalWindowUserWidget_ChangeLanguageIndex) == 0x000008, "Wrong size on LegalWindowUserWidget_ChangeLanguageIndex");
static_assert(offsetof(LegalWindowUserWidget_ChangeLanguageIndex, InLanguageIndex) == 0x000000, "Member 'LegalWindowUserWidget_ChangeLanguageIndex::InLanguageIndex' has a wrong offset!");
static_assert(offsetof(LegalWindowUserWidget_ChangeLanguageIndex, bChangeByUser) == 0x000004, "Member 'LegalWindowUserWidget_ChangeLanguageIndex::bChangeByUser' has a wrong offset!");

// Function man.LegalWindowUserWidget.OnSetText
// 0x0018 (0x0018 - 0x0000)
struct LegalWindowUserWidget_OnSetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegalWindowUserWidget_OnSetText) == 0x000008, "Wrong alignment on LegalWindowUserWidget_OnSetText");
static_assert(sizeof(LegalWindowUserWidget_OnSetText) == 0x000018, "Wrong size on LegalWindowUserWidget_OnSetText");
static_assert(offsetof(LegalWindowUserWidget_OnSetText, InText) == 0x000000, "Member 'LegalWindowUserWidget_OnSetText::InText' has a wrong offset!");

// Function man.LegalWindowUserWidget.SetAgeIsOver16
// 0x0001 (0x0001 - 0x0000)
struct LegalWindowUserWidget_SetAgeIsOver16 final
{
public:
	bool                                          bInAgeIsOver16;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LegalWindowUserWidget_SetAgeIsOver16) == 0x000001, "Wrong alignment on LegalWindowUserWidget_SetAgeIsOver16");
static_assert(sizeof(LegalWindowUserWidget_SetAgeIsOver16) == 0x000001, "Wrong size on LegalWindowUserWidget_SetAgeIsOver16");
static_assert(offsetof(LegalWindowUserWidget_SetAgeIsOver16, bInAgeIsOver16) == 0x000000, "Member 'LegalWindowUserWidget_SetAgeIsOver16::bInAgeIsOver16' has a wrong offset!");

// Function man.UnstableTrail.AbilityEnded
// 0x0008 (0x0008 - 0x0000)
struct UnstableTrail_AbilityEnded final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnstableTrail_AbilityEnded) == 0x000008, "Wrong alignment on UnstableTrail_AbilityEnded");
static_assert(sizeof(UnstableTrail_AbilityEnded) == 0x000008, "Wrong size on UnstableTrail_AbilityEnded");
static_assert(offsetof(UnstableTrail_AbilityEnded, Ability) == 0x000000, "Member 'UnstableTrail_AbilityEnded::Ability' has a wrong offset!");

// Function man.UnstableTrail.AbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct UnstableTrail_AbilityStarted final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UnstableTrail_AbilityStarted) == 0x000008, "Wrong alignment on UnstableTrail_AbilityStarted");
static_assert(sizeof(UnstableTrail_AbilityStarted) == 0x000010, "Wrong size on UnstableTrail_AbilityStarted");
static_assert(offsetof(UnstableTrail_AbilityStarted, Ability) == 0x000000, "Member 'UnstableTrail_AbilityStarted::Ability' has a wrong offset!");
static_assert(offsetof(UnstableTrail_AbilityStarted, bDesired) == 0x000008, "Member 'UnstableTrail_AbilityStarted::bDesired' has a wrong offset!");

// Function man.ExecuteFollowupAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ExecuteFollowupAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExecuteFollowupAbility_PostDamageDealt) == 0x000008, "Wrong alignment on ExecuteFollowupAbility_PostDamageDealt");
static_assert(sizeof(ExecuteFollowupAbility_PostDamageDealt) == 0x0002D8, "Wrong size on ExecuteFollowupAbility_PostDamageDealt");
static_assert(offsetof(ExecuteFollowupAbility_PostDamageDealt, Param) == 0x000000, "Member 'ExecuteFollowupAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.ExplodingOrbActor.IsLastOrb
// 0x0001 (0x0001 - 0x0000)
struct ExplodingOrbActor_IsLastOrb final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplodingOrbActor_IsLastOrb) == 0x000001, "Wrong alignment on ExplodingOrbActor_IsLastOrb");
static_assert(sizeof(ExplodingOrbActor_IsLastOrb) == 0x000001, "Wrong size on ExplodingOrbActor_IsLastOrb");
static_assert(offsetof(ExplodingOrbActor_IsLastOrb, ReturnValue) == 0x000000, "Member 'ExplodingOrbActor_IsLastOrb::ReturnValue' has a wrong offset!");

// Function man.LevelTransitionVFX.SetVFXDuration
// 0x0004 (0x0004 - 0x0000)
struct LevelTransitionVFX_SetVFXDuration final
{
public:
	float                                         VFXDuration;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelTransitionVFX_SetVFXDuration) == 0x000004, "Wrong alignment on LevelTransitionVFX_SetVFXDuration");
static_assert(sizeof(LevelTransitionVFX_SetVFXDuration) == 0x000004, "Wrong size on LevelTransitionVFX_SetVFXDuration");
static_assert(offsetof(LevelTransitionVFX_SetVFXDuration, VFXDuration) == 0x000000, "Member 'LevelTransitionVFX_SetVFXDuration::VFXDuration' has a wrong offset!");

// Function man.LevelTransitionVFX.GetAbleControlCharacterBeforeFadeOutEndTime
// 0x0004 (0x0004 - 0x0000)
struct LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime) == 0x000004, "Wrong alignment on LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime");
static_assert(sizeof(LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime) == 0x000004, "Wrong size on LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime");
static_assert(offsetof(LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime, ReturnValue) == 0x000000, "Member 'LevelTransitionVFX_GetAbleControlCharacterBeforeFadeOutEndTime::ReturnValue' has a wrong offset!");

// Function man.FamiliarBase.OnFamiliarKilled
// 0x0010 (0x0010 - 0x0000)
struct FamiliarBase_OnFamiliarKilled final
{
public:
	class UObject*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     KillerAbilityController;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FamiliarBase_OnFamiliarKilled) == 0x000008, "Wrong alignment on FamiliarBase_OnFamiliarKilled");
static_assert(sizeof(FamiliarBase_OnFamiliarKilled) == 0x000010, "Wrong size on FamiliarBase_OnFamiliarKilled");
static_assert(offsetof(FamiliarBase_OnFamiliarKilled, Killer) == 0x000000, "Member 'FamiliarBase_OnFamiliarKilled::Killer' has a wrong offset!");
static_assert(offsetof(FamiliarBase_OnFamiliarKilled, KillerAbilityController) == 0x000008, "Member 'FamiliarBase_OnFamiliarKilled::KillerAbilityController' has a wrong offset!");

// Function man.FamiliarBase.OnFamiliarPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct FamiliarBase_OnFamiliarPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FamiliarBase_OnFamiliarPostDamageCaused) == 0x000008, "Wrong alignment on FamiliarBase_OnFamiliarPostDamageCaused");
static_assert(sizeof(FamiliarBase_OnFamiliarPostDamageCaused) == 0x0002D8, "Wrong size on FamiliarBase_OnFamiliarPostDamageCaused");
static_assert(offsetof(FamiliarBase_OnFamiliarPostDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'FamiliarBase_OnFamiliarPostDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.FamiliarBase.OnOwnerTeleported
// 0x000C (0x000C - 0x0000)
struct FamiliarBase_OnOwnerTeleported final
{
public:
	struct FVector                                TeleportPos;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FamiliarBase_OnOwnerTeleported) == 0x000004, "Wrong alignment on FamiliarBase_OnOwnerTeleported");
static_assert(sizeof(FamiliarBase_OnOwnerTeleported) == 0x00000C, "Wrong size on FamiliarBase_OnOwnerTeleported");
static_assert(offsetof(FamiliarBase_OnOwnerTeleported, TeleportPos) == 0x000000, "Member 'FamiliarBase_OnOwnerTeleported::TeleportPos' has a wrong offset!");

// Function man.FamiliarBase.OnTargetPositionReached
// 0x0001 (0x0001 - 0x0000)
struct FamiliarBase_OnTargetPositionReached final
{
public:
	bool                                          AirMoveInterrupted;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FamiliarBase_OnTargetPositionReached) == 0x000001, "Wrong alignment on FamiliarBase_OnTargetPositionReached");
static_assert(sizeof(FamiliarBase_OnTargetPositionReached) == 0x000001, "Wrong size on FamiliarBase_OnTargetPositionReached");
static_assert(offsetof(FamiliarBase_OnTargetPositionReached, AirMoveInterrupted) == 0x000000, "Member 'FamiliarBase_OnTargetPositionReached::AirMoveInterrupted' has a wrong offset!");

// Function man.FCP_ShieldAbility.BPGetAllyTargetActor
// 0x0008 (0x0008 - 0x0000)
struct FCP_ShieldAbility_BPGetAllyTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCP_ShieldAbility_BPGetAllyTargetActor) == 0x000008, "Wrong alignment on FCP_ShieldAbility_BPGetAllyTargetActor");
static_assert(sizeof(FCP_ShieldAbility_BPGetAllyTargetActor) == 0x000008, "Wrong size on FCP_ShieldAbility_BPGetAllyTargetActor");
static_assert(offsetof(FCP_ShieldAbility_BPGetAllyTargetActor, ReturnValue) == 0x000000, "Member 'FCP_ShieldAbility_BPGetAllyTargetActor::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.AddGodMode
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_AddGodMode final
{
public:
	bool                                          bWithUninterruptable;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_AddGodMode) == 0x000001, "Wrong alignment on MandragoraGameMode_AddGodMode");
static_assert(sizeof(MandragoraGameMode_AddGodMode) == 0x000001, "Wrong size on MandragoraGameMode_AddGodMode");
static_assert(offsetof(MandragoraGameMode_AddGodMode, bWithUninterruptable) == 0x000000, "Member 'MandragoraGameMode_AddGodMode::bWithUninterruptable' has a wrong offset!");

// Function man.MandragoraGameMode.BossMusicBlacklistHasActor
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_BossMusicBlacklistHasActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MandragoraGameMode_BossMusicBlacklistHasActor) == 0x000008, "Wrong alignment on MandragoraGameMode_BossMusicBlacklistHasActor");
static_assert(sizeof(MandragoraGameMode_BossMusicBlacklistHasActor) == 0x000010, "Wrong size on MandragoraGameMode_BossMusicBlacklistHasActor");
static_assert(offsetof(MandragoraGameMode_BossMusicBlacklistHasActor, Actor) == 0x000000, "Member 'MandragoraGameMode_BossMusicBlacklistHasActor::Actor' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_BossMusicBlacklistHasActor, ReturnValue) == 0x000008, "Member 'MandragoraGameMode_BossMusicBlacklistHasActor::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.BPGetCurrentBossFightClass
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_BPGetCurrentBossFightClass final
{
public:
	class UClass*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_BPGetCurrentBossFightClass) == 0x000008, "Wrong alignment on MandragoraGameMode_BPGetCurrentBossFightClass");
static_assert(sizeof(MandragoraGameMode_BPGetCurrentBossFightClass) == 0x000008, "Wrong size on MandragoraGameMode_BPGetCurrentBossFightClass");
static_assert(offsetof(MandragoraGameMode_BPGetCurrentBossFightClass, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_BPGetCurrentBossFightClass::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.BPGetEnemiesInCombat
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_BPGetEnemiesInCombat final
{
public:
	TArray<class ACharacterBase*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_BPGetEnemiesInCombat) == 0x000008, "Wrong alignment on MandragoraGameMode_BPGetEnemiesInCombat");
static_assert(sizeof(MandragoraGameMode_BPGetEnemiesInCombat) == 0x000010, "Wrong size on MandragoraGameMode_BPGetEnemiesInCombat");
static_assert(offsetof(MandragoraGameMode_BPGetEnemiesInCombat, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_BPGetEnemiesInCombat::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.BPGetGameTime
// 0x0004 (0x0004 - 0x0000)
struct MandragoraGameMode_BPGetGameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_BPGetGameTime) == 0x000004, "Wrong alignment on MandragoraGameMode_BPGetGameTime");
static_assert(sizeof(MandragoraGameMode_BPGetGameTime) == 0x000004, "Wrong size on MandragoraGameMode_BPGetGameTime");
static_assert(offsetof(MandragoraGameMode_BPGetGameTime, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_BPGetGameTime::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.BPStartBossFight
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_BPStartBossFight final
{
public:
	class ACharacter*                             BossFightStarter;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_BPStartBossFight) == 0x000008, "Wrong alignment on MandragoraGameMode_BPStartBossFight");
static_assert(sizeof(MandragoraGameMode_BPStartBossFight) == 0x000008, "Wrong size on MandragoraGameMode_BPStartBossFight");
static_assert(offsetof(MandragoraGameMode_BPStartBossFight, BossFightStarter) == 0x000000, "Member 'MandragoraGameMode_BPStartBossFight::BossFightStarter' has a wrong offset!");

// Function man.MandragoraGameMode.EndCutsceneMode
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_EndCutsceneMode final
{
public:
	bool                                          bFade;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimDuration;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_EndCutsceneMode) == 0x000008, "Wrong alignment on MandragoraGameMode_EndCutsceneMode");
static_assert(sizeof(MandragoraGameMode_EndCutsceneMode) == 0x000010, "Wrong size on MandragoraGameMode_EndCutsceneMode");
static_assert(offsetof(MandragoraGameMode_EndCutsceneMode, bFade) == 0x000000, "Member 'MandragoraGameMode_EndCutsceneMode::bFade' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_EndCutsceneMode, AnimDuration) == 0x000004, "Member 'MandragoraGameMode_EndCutsceneMode::AnimDuration' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_EndCutsceneMode, Object) == 0x000008, "Member 'MandragoraGameMode_EndCutsceneMode::Object' has a wrong offset!");

// Function man.MandragoraGameMode.GetActorByName
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_GetActorByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetActorByName) == 0x000008, "Wrong alignment on MandragoraGameMode_GetActorByName");
static_assert(sizeof(MandragoraGameMode_GetActorByName) == 0x000010, "Wrong size on MandragoraGameMode_GetActorByName");
static_assert(offsetof(MandragoraGameMode_GetActorByName, Name_0) == 0x000000, "Member 'MandragoraGameMode_GetActorByName::Name_0' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_GetActorByName, ReturnValue) == 0x000008, "Member 'MandragoraGameMode_GetActorByName::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.GetConversationManager
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_GetConversationManager final
{
public:
	class UManConversationManager*                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetConversationManager) == 0x000008, "Wrong alignment on MandragoraGameMode_GetConversationManager");
static_assert(sizeof(MandragoraGameMode_GetConversationManager) == 0x000008, "Wrong size on MandragoraGameMode_GetConversationManager");
static_assert(offsetof(MandragoraGameMode_GetConversationManager, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_GetConversationManager::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.GetCreationTemplate
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_GetCreationTemplate final
{
public:
	class UCharacterCreationTemplate*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetCreationTemplate) == 0x000008, "Wrong alignment on MandragoraGameMode_GetCreationTemplate");
static_assert(sizeof(MandragoraGameMode_GetCreationTemplate) == 0x000008, "Wrong size on MandragoraGameMode_GetCreationTemplate");
static_assert(offsetof(MandragoraGameMode_GetCreationTemplate, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_GetCreationTemplate::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.GetGameplayActorByName
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_GetGameplayActorByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetGameplayActorByName) == 0x000008, "Wrong alignment on MandragoraGameMode_GetGameplayActorByName");
static_assert(sizeof(MandragoraGameMode_GetGameplayActorByName) == 0x000010, "Wrong size on MandragoraGameMode_GetGameplayActorByName");
static_assert(offsetof(MandragoraGameMode_GetGameplayActorByName, Name_0) == 0x000000, "Member 'MandragoraGameMode_GetGameplayActorByName::Name_0' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_GetGameplayActorByName, ReturnValue) == 0x000008, "Member 'MandragoraGameMode_GetGameplayActorByName::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.GetPersistentHeroData
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_GetPersistentHeroData final
{
public:
	class UPersistentHeroData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetPersistentHeroData) == 0x000008, "Wrong alignment on MandragoraGameMode_GetPersistentHeroData");
static_assert(sizeof(MandragoraGameMode_GetPersistentHeroData) == 0x000008, "Wrong size on MandragoraGameMode_GetPersistentHeroData");
static_assert(offsetof(MandragoraGameMode_GetPersistentHeroData, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_GetPersistentHeroData::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.GetSurfaceTypeVolumeByPosition
// 0x0018 (0x0018 - 0x0000)
struct MandragoraGameMode_GetSurfaceTypeVolumeByPosition final
{
public:
	struct FVector                                WorldPosition;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASurfaceTypeVolume*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_GetSurfaceTypeVolumeByPosition) == 0x000008, "Wrong alignment on MandragoraGameMode_GetSurfaceTypeVolumeByPosition");
static_assert(sizeof(MandragoraGameMode_GetSurfaceTypeVolumeByPosition) == 0x000018, "Wrong size on MandragoraGameMode_GetSurfaceTypeVolumeByPosition");
static_assert(offsetof(MandragoraGameMode_GetSurfaceTypeVolumeByPosition, WorldPosition) == 0x000000, "Member 'MandragoraGameMode_GetSurfaceTypeVolumeByPosition::WorldPosition' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_GetSurfaceTypeVolumeByPosition, ReturnValue) == 0x000010, "Member 'MandragoraGameMode_GetSurfaceTypeVolumeByPosition::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.IsCaravanCheckPoint
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_IsCaravanCheckPoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_IsCaravanCheckPoint) == 0x000001, "Wrong alignment on MandragoraGameMode_IsCaravanCheckPoint");
static_assert(sizeof(MandragoraGameMode_IsCaravanCheckPoint) == 0x000001, "Wrong size on MandragoraGameMode_IsCaravanCheckPoint");
static_assert(offsetof(MandragoraGameMode_IsCaravanCheckPoint, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_IsCaravanCheckPoint::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.IsCheckPointTravelActive
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_IsCheckPointTravelActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_IsCheckPointTravelActive) == 0x000001, "Wrong alignment on MandragoraGameMode_IsCheckPointTravelActive");
static_assert(sizeof(MandragoraGameMode_IsCheckPointTravelActive) == 0x000001, "Wrong size on MandragoraGameMode_IsCheckPointTravelActive");
static_assert(offsetof(MandragoraGameMode_IsCheckPointTravelActive, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_IsCheckPointTravelActive::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.IsSkipCutsceneActive
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_IsSkipCutsceneActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_IsSkipCutsceneActive) == 0x000001, "Wrong alignment on MandragoraGameMode_IsSkipCutsceneActive");
static_assert(sizeof(MandragoraGameMode_IsSkipCutsceneActive) == 0x000001, "Wrong size on MandragoraGameMode_IsSkipCutsceneActive");
static_assert(offsetof(MandragoraGameMode_IsSkipCutsceneActive, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_IsSkipCutsceneActive::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.OnActorSpawnedDynamicWorld
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_OnActorSpawnedDynamicWorld final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_OnActorSpawnedDynamicWorld) == 0x000008, "Wrong alignment on MandragoraGameMode_OnActorSpawnedDynamicWorld");
static_assert(sizeof(MandragoraGameMode_OnActorSpawnedDynamicWorld) == 0x000008, "Wrong size on MandragoraGameMode_OnActorSpawnedDynamicWorld");
static_assert(offsetof(MandragoraGameMode_OnActorSpawnedDynamicWorld, Actor) == 0x000000, "Member 'MandragoraGameMode_OnActorSpawnedDynamicWorld::Actor' has a wrong offset!");

// Function man.MandragoraGameMode.OnActorSpawnedWorld
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_OnActorSpawnedWorld final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_OnActorSpawnedWorld) == 0x000008, "Wrong alignment on MandragoraGameMode_OnActorSpawnedWorld");
static_assert(sizeof(MandragoraGameMode_OnActorSpawnedWorld) == 0x000008, "Wrong size on MandragoraGameMode_OnActorSpawnedWorld");
static_assert(offsetof(MandragoraGameMode_OnActorSpawnedWorld, Actor) == 0x000000, "Member 'MandragoraGameMode_OnActorSpawnedWorld::Actor' has a wrong offset!");

// Function man.MandragoraGameMode.OnValidateDoOnceMan
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_OnValidateDoOnceMan final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_OnValidateDoOnceMan) == 0x000008, "Wrong alignment on MandragoraGameMode_OnValidateDoOnceMan");
static_assert(sizeof(MandragoraGameMode_OnValidateDoOnceMan) == 0x000010, "Wrong size on MandragoraGameMode_OnValidateDoOnceMan");
static_assert(offsetof(MandragoraGameMode_OnValidateDoOnceMan, Name_0) == 0x000000, "Member 'MandragoraGameMode_OnValidateDoOnceMan::Name_0' has a wrong offset!");

// Function man.MandragoraGameMode.OnWindowCloseRequested
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_OnWindowCloseRequested final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_OnWindowCloseRequested) == 0x000001, "Wrong alignment on MandragoraGameMode_OnWindowCloseRequested");
static_assert(sizeof(MandragoraGameMode_OnWindowCloseRequested) == 0x000001, "Wrong size on MandragoraGameMode_OnWindowCloseRequested");
static_assert(offsetof(MandragoraGameMode_OnWindowCloseRequested, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_OnWindowCloseRequested::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.PlayLevelSequence
// 0x0018 (0x0018 - 0x0000)
struct MandragoraGameMode_PlayLevelSequence final
{
public:
	class ULevelSequence*                         LevelSequence;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInDuration;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatMode;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MandragoraGameMode_PlayLevelSequence) == 0x000008, "Wrong alignment on MandragoraGameMode_PlayLevelSequence");
static_assert(sizeof(MandragoraGameMode_PlayLevelSequence) == 0x000018, "Wrong size on MandragoraGameMode_PlayLevelSequence");
static_assert(offsetof(MandragoraGameMode_PlayLevelSequence, LevelSequence) == 0x000000, "Member 'MandragoraGameMode_PlayLevelSequence::LevelSequence' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_PlayLevelSequence, BlendInDuration) == 0x000008, "Member 'MandragoraGameMode_PlayLevelSequence::BlendInDuration' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_PlayLevelSequence, BlendOutDuration) == 0x00000C, "Member 'MandragoraGameMode_PlayLevelSequence::BlendOutDuration' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_PlayLevelSequence, bCombatMode) == 0x000010, "Member 'MandragoraGameMode_PlayLevelSequence::bCombatMode' has a wrong offset!");

// Function man.MandragoraGameMode.RemoveGodMode
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_RemoveGodMode final
{
public:
	bool                                          bWithUninterruptable;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_RemoveGodMode) == 0x000001, "Wrong alignment on MandragoraGameMode_RemoveGodMode");
static_assert(sizeof(MandragoraGameMode_RemoveGodMode) == 0x000001, "Wrong size on MandragoraGameMode_RemoveGodMode");
static_assert(offsetof(MandragoraGameMode_RemoveGodMode, bWithUninterruptable) == 0x000000, "Member 'MandragoraGameMode_RemoveGodMode::bWithUninterruptable' has a wrong offset!");

// Function man.MandragoraGameMode.SetActiveEnemyModifiersTable
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_SetActiveEnemyModifiersTable final
{
public:
	class UEnemyModifiersTable*                   InEnemyModifiersTable;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_SetActiveEnemyModifiersTable) == 0x000008, "Wrong alignment on MandragoraGameMode_SetActiveEnemyModifiersTable");
static_assert(sizeof(MandragoraGameMode_SetActiveEnemyModifiersTable) == 0x000008, "Wrong size on MandragoraGameMode_SetActiveEnemyModifiersTable");
static_assert(offsetof(MandragoraGameMode_SetActiveEnemyModifiersTable, InEnemyModifiersTable) == 0x000000, "Member 'MandragoraGameMode_SetActiveEnemyModifiersTable::InEnemyModifiersTable' has a wrong offset!");

// Function man.MandragoraGameMode.SetForceLoadingScreen
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_SetForceLoadingScreen final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                DebugObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_SetForceLoadingScreen) == 0x000008, "Wrong alignment on MandragoraGameMode_SetForceLoadingScreen");
static_assert(sizeof(MandragoraGameMode_SetForceLoadingScreen) == 0x000010, "Wrong size on MandragoraGameMode_SetForceLoadingScreen");
static_assert(offsetof(MandragoraGameMode_SetForceLoadingScreen, bEnable) == 0x000000, "Member 'MandragoraGameMode_SetForceLoadingScreen::bEnable' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SetForceLoadingScreen, DebugObject) == 0x000008, "Member 'MandragoraGameMode_SetForceLoadingScreen::DebugObject' has a wrong offset!");

// Function man.MandragoraGameMode.SetLevelLootTable
// 0x0008 (0x0008 - 0x0000)
struct MandragoraGameMode_SetLevelLootTable final
{
public:
	class UManLootTable*                          InLootTable;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_SetLevelLootTable) == 0x000008, "Wrong alignment on MandragoraGameMode_SetLevelLootTable");
static_assert(sizeof(MandragoraGameMode_SetLevelLootTable) == 0x000008, "Wrong size on MandragoraGameMode_SetLevelLootTable");
static_assert(offsetof(MandragoraGameMode_SetLevelLootTable, InLootTable) == 0x000000, "Member 'MandragoraGameMode_SetLevelLootTable::InLootTable' has a wrong offset!");

// Function man.MandragoraGameMode.SetPanningAgentEnable
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_SetPanningAgentEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_SetPanningAgentEnable) == 0x000001, "Wrong alignment on MandragoraGameMode_SetPanningAgentEnable");
static_assert(sizeof(MandragoraGameMode_SetPanningAgentEnable) == 0x000001, "Wrong size on MandragoraGameMode_SetPanningAgentEnable");
static_assert(offsetof(MandragoraGameMode_SetPanningAgentEnable, bEnable) == 0x000000, "Member 'MandragoraGameMode_SetPanningAgentEnable::bEnable' has a wrong offset!");

// Function man.MandragoraGameMode.SpawnVisualEntity
// 0x0030 (0x0030 - 0x0000)
struct MandragoraGameMode_SpawnVisualEntity final
{
public:
	TSubclassOf<class AVisualEntity>              VisualEntityClass;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MandatoryAttachTarget;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachTarget                                 AttachTargetType;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachTargetName;                                  // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationSelector                             Rotation;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocAttachRule;                                     // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferredStart;                                    // 0x001E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAbilityBase>               AssociatedAbilityClass;                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVisualEntity*                          ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_SpawnVisualEntity) == 0x000008, "Wrong alignment on MandragoraGameMode_SpawnVisualEntity");
static_assert(sizeof(MandragoraGameMode_SpawnVisualEntity) == 0x000030, "Wrong size on MandragoraGameMode_SpawnVisualEntity");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, VisualEntityClass) == 0x000000, "Member 'MandragoraGameMode_SpawnVisualEntity::VisualEntityClass' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, MandatoryAttachTarget) == 0x000008, "Member 'MandragoraGameMode_SpawnVisualEntity::MandatoryAttachTarget' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, AttachTargetType) == 0x000010, "Member 'MandragoraGameMode_SpawnVisualEntity::AttachTargetType' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, AttachTargetName) == 0x000014, "Member 'MandragoraGameMode_SpawnVisualEntity::AttachTargetName' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, Rotation) == 0x00001C, "Member 'MandragoraGameMode_SpawnVisualEntity::Rotation' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, LocAttachRule) == 0x00001D, "Member 'MandragoraGameMode_SpawnVisualEntity::LocAttachRule' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, bDeferredStart) == 0x00001E, "Member 'MandragoraGameMode_SpawnVisualEntity::bDeferredStart' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, AssociatedAbilityClass) == 0x000020, "Member 'MandragoraGameMode_SpawnVisualEntity::AssociatedAbilityClass' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_SpawnVisualEntity, ReturnValue) == 0x000028, "Member 'MandragoraGameMode_SpawnVisualEntity::ReturnValue' has a wrong offset!");

// Function man.MandragoraGameMode.StartCutsceneMode
// 0x0010 (0x0010 - 0x0000)
struct MandragoraGameMode_StartCutsceneMode final
{
public:
	bool                                          bFade;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimDuration;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_StartCutsceneMode) == 0x000008, "Wrong alignment on MandragoraGameMode_StartCutsceneMode");
static_assert(sizeof(MandragoraGameMode_StartCutsceneMode) == 0x000010, "Wrong size on MandragoraGameMode_StartCutsceneMode");
static_assert(offsetof(MandragoraGameMode_StartCutsceneMode, bFade) == 0x000000, "Member 'MandragoraGameMode_StartCutsceneMode::bFade' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_StartCutsceneMode, bSkippable) == 0x000001, "Member 'MandragoraGameMode_StartCutsceneMode::bSkippable' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_StartCutsceneMode, AnimDuration) == 0x000004, "Member 'MandragoraGameMode_StartCutsceneMode::AnimDuration' has a wrong offset!");
static_assert(offsetof(MandragoraGameMode_StartCutsceneMode, Object) == 0x000008, "Member 'MandragoraGameMode_StartCutsceneMode::Object' has a wrong offset!");

// Function man.MandragoraGameMode.ToggleBossFightSaveLock
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_ToggleBossFightSaveLock final
{
public:
	bool                                          bToggle;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_ToggleBossFightSaveLock) == 0x000001, "Wrong alignment on MandragoraGameMode_ToggleBossFightSaveLock");
static_assert(sizeof(MandragoraGameMode_ToggleBossFightSaveLock) == 0x000001, "Wrong size on MandragoraGameMode_ToggleBossFightSaveLock");
static_assert(offsetof(MandragoraGameMode_ToggleBossFightSaveLock, bToggle) == 0x000000, "Member 'MandragoraGameMode_ToggleBossFightSaveLock::bToggle' has a wrong offset!");

// Function man.MandragoraGameMode.IsPanningAgentEnabled
// 0x0001 (0x0001 - 0x0000)
struct MandragoraGameMode_IsPanningAgentEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandragoraGameMode_IsPanningAgentEnabled) == 0x000001, "Wrong alignment on MandragoraGameMode_IsPanningAgentEnabled");
static_assert(sizeof(MandragoraGameMode_IsPanningAgentEnabled) == 0x000001, "Wrong size on MandragoraGameMode_IsPanningAgentEnabled");
static_assert(offsetof(MandragoraGameMode_IsPanningAgentEnabled, ReturnValue) == 0x000000, "Member 'MandragoraGameMode_IsPanningAgentEnabled::ReturnValue' has a wrong offset!");

// Function man.VLBeastAI.OnEndBossRoomOverlap
// 0x0010 (0x0010 - 0x0000)
struct VLBeastAI_OnEndBossRoomOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VLBeastAI_OnEndBossRoomOverlap) == 0x000008, "Wrong alignment on VLBeastAI_OnEndBossRoomOverlap");
static_assert(sizeof(VLBeastAI_OnEndBossRoomOverlap) == 0x000010, "Wrong size on VLBeastAI_OnEndBossRoomOverlap");
static_assert(offsetof(VLBeastAI_OnEndBossRoomOverlap, OverlappedActor) == 0x000000, "Member 'VLBeastAI_OnEndBossRoomOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(VLBeastAI_OnEndBossRoomOverlap, OtherActor) == 0x000008, "Member 'VLBeastAI_OnEndBossRoomOverlap::OtherActor' has a wrong offset!");

// Function man.VLBeastAI.OnTransformedEvent
// 0x0010 (0x0010 - 0x0000)
struct VLBeastAI_OnTransformedEvent final
{
public:
	class UAbilityController*                     Src;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Dest;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VLBeastAI_OnTransformedEvent) == 0x000008, "Wrong alignment on VLBeastAI_OnTransformedEvent");
static_assert(sizeof(VLBeastAI_OnTransformedEvent) == 0x000010, "Wrong size on VLBeastAI_OnTransformedEvent");
static_assert(offsetof(VLBeastAI_OnTransformedEvent, Src) == 0x000000, "Member 'VLBeastAI_OnTransformedEvent::Src' has a wrong offset!");
static_assert(offsetof(VLBeastAI_OnTransformedEvent, Dest) == 0x000008, "Member 'VLBeastAI_OnTransformedEvent::Dest' has a wrong offset!");

// Function man.FieryRushAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct FieryRushAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieryRushAbility_PostDamageDealt) == 0x000008, "Wrong alignment on FieryRushAbility_PostDamageDealt");
static_assert(sizeof(FieryRushAbility_PostDamageDealt) == 0x0002D8, "Wrong size on FieryRushAbility_PostDamageDealt");
static_assert(offsetof(FieryRushAbility_PostDamageDealt, Param) == 0x000000, "Member 'FieryRushAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.FieryRushAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct FieryRushAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FieryRushAbility_PreDamageDealt) == 0x000008, "Wrong alignment on FieryRushAbility_PreDamageDealt");
static_assert(sizeof(FieryRushAbility_PreDamageDealt) == 0x0002D8, "Wrong size on FieryRushAbility_PreDamageDealt");
static_assert(offsetof(FieryRushAbility_PreDamageDealt, Param) == 0x000000, "Member 'FieryRushAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.FinessePassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct FinessePassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FinessePassive_DamageDealt) == 0x000008, "Wrong alignment on FinessePassive_DamageDealt");
static_assert(sizeof(FinessePassive_DamageDealt) == 0x0002D8, "Wrong size on FinessePassive_DamageDealt");
static_assert(offsetof(FinessePassive_DamageDealt, Param) == 0x000000, "Member 'FinessePassive_DamageDealt::Param' has a wrong offset!");

// Function man.FinessePassive.DamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct FinessePassive_DamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FinessePassive_DamageReceived) == 0x000008, "Wrong alignment on FinessePassive_DamageReceived");
static_assert(sizeof(FinessePassive_DamageReceived) == 0x0002D8, "Wrong size on FinessePassive_DamageReceived");
static_assert(offsetof(FinessePassive_DamageReceived, Param) == 0x000000, "Member 'FinessePassive_DamageReceived::Param' has a wrong offset!");

// Function man.FireDemonAttackFirestarter.BPGetTargetLocations
// 0x0010 (0x0010 - 0x0000)
struct FireDemonAttackFirestarter_BPGetTargetLocations final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FireDemonAttackFirestarter_BPGetTargetLocations) == 0x000008, "Wrong alignment on FireDemonAttackFirestarter_BPGetTargetLocations");
static_assert(sizeof(FireDemonAttackFirestarter_BPGetTargetLocations) == 0x000010, "Wrong size on FireDemonAttackFirestarter_BPGetTargetLocations");
static_assert(offsetof(FireDemonAttackFirestarter_BPGetTargetLocations, ReturnValue) == 0x000000, "Member 'FireDemonAttackFirestarter_BPGetTargetLocations::ReturnValue' has a wrong offset!");

// Function man.FireDemonAttackFieryPillar.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct FireDemonAttackFieryPillar_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FireDemonAttackFieryPillar_BPGetTargetLocation) == 0x000004, "Wrong alignment on FireDemonAttackFieryPillar_BPGetTargetLocation");
static_assert(sizeof(FireDemonAttackFieryPillar_BPGetTargetLocation) == 0x00000C, "Wrong size on FireDemonAttackFieryPillar_BPGetTargetLocation");
static_assert(offsetof(FireDemonAttackFieryPillar_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'FireDemonAttackFieryPillar_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.InquisitorAI.InquisitorOnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct InquisitorAI_InquisitorOnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorAI_InquisitorOnPostDamaged) == 0x000008, "Wrong alignment on InquisitorAI_InquisitorOnPostDamaged");
static_assert(sizeof(InquisitorAI_InquisitorOnPostDamaged) == 0x0002D8, "Wrong size on InquisitorAI_InquisitorOnPostDamaged");
static_assert(offsetof(InquisitorAI_InquisitorOnPostDamaged, Param) == 0x000000, "Member 'InquisitorAI_InquisitorOnPostDamaged::Param' has a wrong offset!");

// Function man.InquisitorAI.OnHeroAbilityEnding
// 0x0008 (0x0008 - 0x0000)
struct InquisitorAI_OnHeroAbilityEnding final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorAI_OnHeroAbilityEnding) == 0x000008, "Wrong alignment on InquisitorAI_OnHeroAbilityEnding");
static_assert(sizeof(InquisitorAI_OnHeroAbilityEnding) == 0x000008, "Wrong size on InquisitorAI_OnHeroAbilityEnding");
static_assert(offsetof(InquisitorAI_OnHeroAbilityEnding, InAbility) == 0x000000, "Member 'InquisitorAI_OnHeroAbilityEnding::InAbility' has a wrong offset!");

// Function man.InquisitorAI.OnHeroAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct InquisitorAI_OnHeroAbilityStarted final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InquisitorAI_OnHeroAbilityStarted) == 0x000008, "Wrong alignment on InquisitorAI_OnHeroAbilityStarted");
static_assert(sizeof(InquisitorAI_OnHeroAbilityStarted) == 0x000010, "Wrong size on InquisitorAI_OnHeroAbilityStarted");
static_assert(offsetof(InquisitorAI_OnHeroAbilityStarted, InAbility) == 0x000000, "Member 'InquisitorAI_OnHeroAbilityStarted::InAbility' has a wrong offset!");
static_assert(offsetof(InquisitorAI_OnHeroAbilityStarted, bDesired) == 0x000008, "Member 'InquisitorAI_OnHeroAbilityStarted::bDesired' has a wrong offset!");

// Function man.InquisitorAI.OnOptionsWindowHide
// 0x0008 (0x0008 - 0x0000)
struct InquisitorAI_OnOptionsWindowHide final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorAI_OnOptionsWindowHide) == 0x000008, "Wrong alignment on InquisitorAI_OnOptionsWindowHide");
static_assert(sizeof(InquisitorAI_OnOptionsWindowHide) == 0x000008, "Wrong size on InquisitorAI_OnOptionsWindowHide");
static_assert(offsetof(InquisitorAI_OnOptionsWindowHide, ManUserWidgetBase) == 0x000000, "Member 'InquisitorAI_OnOptionsWindowHide::ManUserWidgetBase' has a wrong offset!");

// Function man.InquisitorAI.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct InquisitorAI_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InquisitorAI_OnPreDamageCaused) == 0x000008, "Wrong alignment on InquisitorAI_OnPreDamageCaused");
static_assert(sizeof(InquisitorAI_OnPreDamageCaused) == 0x0002D8, "Wrong size on InquisitorAI_OnPreDamageCaused");
static_assert(offsetof(InquisitorAI_OnPreDamageCaused, Param) == 0x000000, "Member 'InquisitorAI_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.RollAbility.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct RollAbility_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RollAbility_OnPreDamagedPriority) == 0x000008, "Wrong alignment on RollAbility_OnPreDamagedPriority");
static_assert(sizeof(RollAbility_OnPreDamagedPriority) == 0x0002D8, "Wrong size on RollAbility_OnPreDamagedPriority");
static_assert(offsetof(RollAbility_OnPreDamagedPriority, Param) == 0x000000, "Member 'RollAbility_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.FireDemonAttackCharge.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct FireDemonAttackCharge_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FireDemonAttackCharge_IsCollideSignature) == 0x000008, "Wrong alignment on FireDemonAttackCharge_IsCollideSignature");
static_assert(sizeof(FireDemonAttackCharge_IsCollideSignature) == 0x000010, "Wrong size on FireDemonAttackCharge_IsCollideSignature");
static_assert(offsetof(FireDemonAttackCharge_IsCollideSignature, Actor) == 0x000000, "Member 'FireDemonAttackCharge_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(FireDemonAttackCharge_IsCollideSignature, bOverride) == 0x000008, "Member 'FireDemonAttackCharge_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(FireDemonAttackCharge_IsCollideSignature, bCollide) == 0x000009, "Member 'FireDemonAttackCharge_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.KingPriestAttackPurgingRain.BPIsRainStartedOnLeftSide
// 0x0001 (0x0001 - 0x0000)
struct KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide) == 0x000001, "Wrong alignment on KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide");
static_assert(sizeof(KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide) == 0x000001, "Wrong size on KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide");
static_assert(offsetof(KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide, ReturnValue) == 0x000000, "Member 'KingPriestAttackPurgingRain_BPIsRainStartedOnLeftSide::ReturnValue' has a wrong offset!");

// Function man.FixHotkeyUserWidget.GetHotkeyNameText
// 0x0018 (0x0018 - 0x0000)
struct FixHotkeyUserWidget_GetHotkeyNameText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FixHotkeyUserWidget_GetHotkeyNameText) == 0x000008, "Wrong alignment on FixHotkeyUserWidget_GetHotkeyNameText");
static_assert(sizeof(FixHotkeyUserWidget_GetHotkeyNameText) == 0x000018, "Wrong size on FixHotkeyUserWidget_GetHotkeyNameText");
static_assert(offsetof(FixHotkeyUserWidget_GetHotkeyNameText, ReturnValue) == 0x000000, "Member 'FixHotkeyUserWidget_GetHotkeyNameText::ReturnValue' has a wrong offset!");

// Function man.FixHotkeyUserWidget.OnSetHotkeyNameText
// 0x0018 (0x0018 - 0x0000)
struct FixHotkeyUserWidget_OnSetHotkeyNameText final
{
public:
	class FText                                   InHotkeyNameText;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FixHotkeyUserWidget_OnSetHotkeyNameText) == 0x000008, "Wrong alignment on FixHotkeyUserWidget_OnSetHotkeyNameText");
static_assert(sizeof(FixHotkeyUserWidget_OnSetHotkeyNameText) == 0x000018, "Wrong size on FixHotkeyUserWidget_OnSetHotkeyNameText");
static_assert(offsetof(FixHotkeyUserWidget_OnSetHotkeyNameText, InHotkeyNameText) == 0x000000, "Member 'FixHotkeyUserWidget_OnSetHotkeyNameText::InHotkeyNameText' has a wrong offset!");

// Function man.SurfaceEffectTypeDataAsset.GetCustomVFXData
// 0x0010 (0x0010 - 0x0000)
struct SurfaceEffectTypeDataAsset_GetCustomVFXData final
{
public:
	class FName                                   CustomName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SurfaceEffectTypeDataAsset_GetCustomVFXData) == 0x000008, "Wrong alignment on SurfaceEffectTypeDataAsset_GetCustomVFXData");
static_assert(sizeof(SurfaceEffectTypeDataAsset_GetCustomVFXData) == 0x000010, "Wrong size on SurfaceEffectTypeDataAsset_GetCustomVFXData");
static_assert(offsetof(SurfaceEffectTypeDataAsset_GetCustomVFXData, CustomName) == 0x000000, "Member 'SurfaceEffectTypeDataAsset_GetCustomVFXData::CustomName' has a wrong offset!");
static_assert(offsetof(SurfaceEffectTypeDataAsset_GetCustomVFXData, ReturnValue) == 0x000008, "Member 'SurfaceEffectTypeDataAsset_GetCustomVFXData::ReturnValue' has a wrong offset!");

// Function man.SurfaceEffectTypeDataAsset.GetFootStepDataIdxForActorType
// 0x0010 (0x0010 - 0x0000)
struct SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType final
{
public:
	TSubclassOf<class AActor>                     InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType) == 0x000008, "Wrong alignment on SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType");
static_assert(sizeof(SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType) == 0x000010, "Wrong size on SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType");
static_assert(offsetof(SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType, InActor) == 0x000000, "Member 'SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType::InActor' has a wrong offset!");
static_assert(offsetof(SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType, ReturnValue) == 0x000008, "Member 'SurfaceEffectTypeDataAsset_GetFootStepDataIdxForActorType::ReturnValue' has a wrong offset!");

// Function man.ActorBaseModifiersNode.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct ActorBaseModifiersNode_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorBaseModifiersNode_GetEditorName) == 0x000008, "Wrong alignment on ActorBaseModifiersNode_GetEditorName");
static_assert(sizeof(ActorBaseModifiersNode_GetEditorName) == 0x000010, "Wrong size on ActorBaseModifiersNode_GetEditorName");
static_assert(offsetof(ActorBaseModifiersNode_GetEditorName, ReturnValue) == 0x000000, "Member 'ActorBaseModifiersNode_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.FlyComponent.GetTargetRef
// 0x0008 (0x0008 - 0x0000)
struct FlyComponent_GetTargetRef final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlyComponent_GetTargetRef) == 0x000008, "Wrong alignment on FlyComponent_GetTargetRef");
static_assert(sizeof(FlyComponent_GetTargetRef) == 0x000008, "Wrong size on FlyComponent_GetTargetRef");
static_assert(offsetof(FlyComponent_GetTargetRef, ReturnValue) == 0x000000, "Member 'FlyComponent_GetTargetRef::ReturnValue' has a wrong offset!");

// Function man.FlyComponent.SetInitialSpeed
// 0x0004 (0x0004 - 0x0000)
struct FlyComponent_SetInitialSpeed final
{
public:
	float                                         NewSpeed;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlyComponent_SetInitialSpeed) == 0x000004, "Wrong alignment on FlyComponent_SetInitialSpeed");
static_assert(sizeof(FlyComponent_SetInitialSpeed) == 0x000004, "Wrong size on FlyComponent_SetInitialSpeed");
static_assert(offsetof(FlyComponent_SetInitialSpeed, NewSpeed) == 0x000000, "Member 'FlyComponent_SetInitialSpeed::NewSpeed' has a wrong offset!");

// Function man.VendorItem.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct VendorItem_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorItem_GetEditorName) == 0x000008, "Wrong alignment on VendorItem_GetEditorName");
static_assert(sizeof(VendorItem_GetEditorName) == 0x000010, "Wrong size on VendorItem_GetEditorName");
static_assert(offsetof(VendorItem_GetEditorName, ReturnValue) == 0x000000, "Member 'VendorItem_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.FocalizedManaPassive.OnResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct FocalizedManaPassive_OnResourceUsed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FocalizedManaPassive_OnResourceUsed) == 0x000008, "Wrong alignment on FocalizedManaPassive_OnResourceUsed");
static_assert(sizeof(FocalizedManaPassive_OnResourceUsed) == 0x000010, "Wrong size on FocalizedManaPassive_OnResourceUsed");
static_assert(offsetof(FocalizedManaPassive_OnResourceUsed, resource) == 0x000000, "Member 'FocalizedManaPassive_OnResourceUsed::resource' has a wrong offset!");
static_assert(offsetof(FocalizedManaPassive_OnResourceUsed, amount) == 0x000004, "Member 'FocalizedManaPassive_OnResourceUsed::amount' has a wrong offset!");
static_assert(offsetof(FocalizedManaPassive_OnResourceUsed, Ability) == 0x000008, "Member 'FocalizedManaPassive_OnResourceUsed::Ability' has a wrong offset!");

// Function man.FocalizedManaPassive.OnStatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct FocalizedManaPassive_OnStatusEffectCaused final
{
public:
	class AActor*                                 To;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewEffect;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FocalizedManaPassive_OnStatusEffectCaused) == 0x000008, "Wrong alignment on FocalizedManaPassive_OnStatusEffectCaused");
static_assert(sizeof(FocalizedManaPassive_OnStatusEffectCaused) == 0x000018, "Wrong size on FocalizedManaPassive_OnStatusEffectCaused");
static_assert(offsetof(FocalizedManaPassive_OnStatusEffectCaused, To) == 0x000000, "Member 'FocalizedManaPassive_OnStatusEffectCaused::To' has a wrong offset!");
static_assert(offsetof(FocalizedManaPassive_OnStatusEffectCaused, StatusType) == 0x000008, "Member 'FocalizedManaPassive_OnStatusEffectCaused::StatusType' has a wrong offset!");
static_assert(offsetof(FocalizedManaPassive_OnStatusEffectCaused, NewEffect) == 0x000009, "Member 'FocalizedManaPassive_OnStatusEffectCaused::NewEffect' has a wrong offset!");
static_assert(offsetof(FocalizedManaPassive_OnStatusEffectCaused, Instance) == 0x000010, "Member 'FocalizedManaPassive_OnStatusEffectCaused::Instance' has a wrong offset!");

// Function man.FreeCamera.GetLocalPosition
// 0x000C (0x000C - 0x0000)
struct FreeCamera_GetLocalPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreeCamera_GetLocalPosition) == 0x000004, "Wrong alignment on FreeCamera_GetLocalPosition");
static_assert(sizeof(FreeCamera_GetLocalPosition) == 0x00000C, "Wrong size on FreeCamera_GetLocalPosition");
static_assert(offsetof(FreeCamera_GetLocalPosition, ReturnValue) == 0x000000, "Member 'FreeCamera_GetLocalPosition::ReturnValue' has a wrong offset!");

// Function man.FreeCamera.GetLocalRotation
// 0x000C (0x000C - 0x0000)
struct FreeCamera_GetLocalRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreeCamera_GetLocalRotation) == 0x000004, "Wrong alignment on FreeCamera_GetLocalRotation");
static_assert(sizeof(FreeCamera_GetLocalRotation) == 0x00000C, "Wrong size on FreeCamera_GetLocalRotation");
static_assert(offsetof(FreeCamera_GetLocalRotation, ReturnValue) == 0x000000, "Member 'FreeCamera_GetLocalRotation::ReturnValue' has a wrong offset!");

// Function man.FreeCamera.GetLocalTransform
// 0x0030 (0x0030 - 0x0000)
struct FreeCamera_GetLocalTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreeCamera_GetLocalTransform) == 0x000010, "Wrong alignment on FreeCamera_GetLocalTransform");
static_assert(sizeof(FreeCamera_GetLocalTransform) == 0x000030, "Wrong size on FreeCamera_GetLocalTransform");
static_assert(offsetof(FreeCamera_GetLocalTransform, ReturnValue) == 0x000000, "Member 'FreeCamera_GetLocalTransform::ReturnValue' has a wrong offset!");

// Function man.VendorPortraitsUserWidget.OnShowSlot
// 0x0008 (0x0008 - 0x0000)
struct VendorPortraitsUserWidget_OnShowSlot final
{
public:
	class UConversationPortraitUserWidget*        ConversationPortraitUserWidget;                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorPortraitsUserWidget_OnShowSlot) == 0x000008, "Wrong alignment on VendorPortraitsUserWidget_OnShowSlot");
static_assert(sizeof(VendorPortraitsUserWidget_OnShowSlot) == 0x000008, "Wrong size on VendorPortraitsUserWidget_OnShowSlot");
static_assert(offsetof(VendorPortraitsUserWidget_OnShowSlot, ConversationPortraitUserWidget) == 0x000000, "Member 'VendorPortraitsUserWidget_OnShowSlot::ConversationPortraitUserWidget' has a wrong offset!");

// Function man.FreecastPassive.AbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct FreecastPassive_AbilityEnd final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreecastPassive_AbilityEnd) == 0x000008, "Wrong alignment on FreecastPassive_AbilityEnd");
static_assert(sizeof(FreecastPassive_AbilityEnd) == 0x000008, "Wrong size on FreecastPassive_AbilityEnd");
static_assert(offsetof(FreecastPassive_AbilityEnd, Ability) == 0x000000, "Member 'FreecastPassive_AbilityEnd::Ability' has a wrong offset!");

// Function man.FreecastPassive.AbilityStart
// 0x0008 (0x0008 - 0x0000)
struct FreecastPassive_AbilityStart final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreecastPassive_AbilityStart) == 0x000008, "Wrong alignment on FreecastPassive_AbilityStart");
static_assert(sizeof(FreecastPassive_AbilityStart) == 0x000008, "Wrong size on FreecastPassive_AbilityStart");
static_assert(offsetof(FreecastPassive_AbilityStart, Ability) == 0x000000, "Member 'FreecastPassive_AbilityStart::Ability' has a wrong offset!");

// Function man.FreecastPassive.ResourceConsumed
// 0x0010 (0x0010 - 0x0000)
struct FreecastPassive_ResourceConsumed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FreecastPassive_ResourceConsumed) == 0x000008, "Wrong alignment on FreecastPassive_ResourceConsumed");
static_assert(sizeof(FreecastPassive_ResourceConsumed) == 0x000010, "Wrong size on FreecastPassive_ResourceConsumed");
static_assert(offsetof(FreecastPassive_ResourceConsumed, resource) == 0x000000, "Member 'FreecastPassive_ResourceConsumed::resource' has a wrong offset!");
static_assert(offsetof(FreecastPassive_ResourceConsumed, amount) == 0x000004, "Member 'FreecastPassive_ResourceConsumed::amount' has a wrong offset!");
static_assert(offsetof(FreecastPassive_ResourceConsumed, Ability) == 0x000008, "Member 'FreecastPassive_ResourceConsumed::Ability' has a wrong offset!");

// Function man.ManAudioTriggerVolume.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManAudioTriggerVolume_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAudioTriggerVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on ManAudioTriggerVolume_OnBeginOverlap");
static_assert(sizeof(ManAudioTriggerVolume_OnBeginOverlap) == 0x000010, "Wrong size on ManAudioTriggerVolume_OnBeginOverlap");
static_assert(offsetof(ManAudioTriggerVolume_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'ManAudioTriggerVolume_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManAudioTriggerVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'ManAudioTriggerVolume_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.ManAudioTriggerVolume.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManAudioTriggerVolume_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAudioTriggerVolume_OnEndOverlap) == 0x000008, "Wrong alignment on ManAudioTriggerVolume_OnEndOverlap");
static_assert(sizeof(ManAudioTriggerVolume_OnEndOverlap) == 0x000010, "Wrong size on ManAudioTriggerVolume_OnEndOverlap");
static_assert(offsetof(ManAudioTriggerVolume_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'ManAudioTriggerVolume_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManAudioTriggerVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'ManAudioTriggerVolume_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.FriendlyReminderPassive.StatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct FriendlyReminderPassive_StatusEffectCaused final
{
public:
	class AActor*                                 ToTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FriendlyReminderPassive_StatusEffectCaused) == 0x000008, "Wrong alignment on FriendlyReminderPassive_StatusEffectCaused");
static_assert(sizeof(FriendlyReminderPassive_StatusEffectCaused) == 0x000018, "Wrong size on FriendlyReminderPassive_StatusEffectCaused");
static_assert(offsetof(FriendlyReminderPassive_StatusEffectCaused, ToTarget) == 0x000000, "Member 'FriendlyReminderPassive_StatusEffectCaused::ToTarget' has a wrong offset!");
static_assert(offsetof(FriendlyReminderPassive_StatusEffectCaused, Type) == 0x000008, "Member 'FriendlyReminderPassive_StatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(FriendlyReminderPassive_StatusEffectCaused, IsNewEffect) == 0x000009, "Member 'FriendlyReminderPassive_StatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(FriendlyReminderPassive_StatusEffectCaused, Instance) == 0x000010, "Member 'FriendlyReminderPassive_StatusEffectCaused::Instance' has a wrong offset!");

// Function man.FrostMageAttackIceRupture.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct FrostMageAttackIceRupture_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrostMageAttackIceRupture_BPGetTargetLocation) == 0x000004, "Wrong alignment on FrostMageAttackIceRupture_BPGetTargetLocation");
static_assert(sizeof(FrostMageAttackIceRupture_BPGetTargetLocation) == 0x00000C, "Wrong size on FrostMageAttackIceRupture_BPGetTargetLocation");
static_assert(offsetof(FrostMageAttackIceRupture_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'FrostMageAttackIceRupture_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.SkillTreeConnectionUserWidget.GetNodeRegion
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeConnectionUserWidget_GetNodeRegion final
{
public:
	ECharacterClass                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeConnectionUserWidget_GetNodeRegion) == 0x000001, "Wrong alignment on SkillTreeConnectionUserWidget_GetNodeRegion");
static_assert(sizeof(SkillTreeConnectionUserWidget_GetNodeRegion) == 0x000001, "Wrong size on SkillTreeConnectionUserWidget_GetNodeRegion");
static_assert(offsetof(SkillTreeConnectionUserWidget_GetNodeRegion, ReturnValue) == 0x000000, "Member 'SkillTreeConnectionUserWidget_GetNodeRegion::ReturnValue' has a wrong offset!");

// Function man.ManCheatManager.MAN_AchievementAddProgress
// 0x0018 (0x0018 - 0x0000)
struct ManCheatManager_MAN_AchievementAddProgress final
{
public:
	class FString                                 AchievementID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progress;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManCheatManager_MAN_AchievementAddProgress) == 0x000008, "Wrong alignment on ManCheatManager_MAN_AchievementAddProgress");
static_assert(sizeof(ManCheatManager_MAN_AchievementAddProgress) == 0x000018, "Wrong size on ManCheatManager_MAN_AchievementAddProgress");
static_assert(offsetof(ManCheatManager_MAN_AchievementAddProgress, AchievementID) == 0x000000, "Member 'ManCheatManager_MAN_AchievementAddProgress::AchievementID' has a wrong offset!");
static_assert(offsetof(ManCheatManager_MAN_AchievementAddProgress, Progress) == 0x000010, "Member 'ManCheatManager_MAN_AchievementAddProgress::Progress' has a wrong offset!");

// Function man.ManCheatManager.MAN_AchievementSetFlag
// 0x0018 (0x0018 - 0x0000)
struct ManCheatManager_MAN_AchievementSetFlag final
{
public:
	class FString                                 AchievementID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flag;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManCheatManager_MAN_AchievementSetFlag) == 0x000008, "Wrong alignment on ManCheatManager_MAN_AchievementSetFlag");
static_assert(sizeof(ManCheatManager_MAN_AchievementSetFlag) == 0x000018, "Wrong size on ManCheatManager_MAN_AchievementSetFlag");
static_assert(offsetof(ManCheatManager_MAN_AchievementSetFlag, AchievementID) == 0x000000, "Member 'ManCheatManager_MAN_AchievementSetFlag::AchievementID' has a wrong offset!");
static_assert(offsetof(ManCheatManager_MAN_AchievementSetFlag, Flag) == 0x000010, "Member 'ManCheatManager_MAN_AchievementSetFlag::Flag' has a wrong offset!");

// Function man.ManCheatManager.MAN_AchievementShowProgress
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_AchievementShowProgress final
{
public:
	class FString                                 AchievementID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_AchievementShowProgress) == 0x000008, "Wrong alignment on ManCheatManager_MAN_AchievementShowProgress");
static_assert(sizeof(ManCheatManager_MAN_AchievementShowProgress) == 0x000010, "Wrong size on ManCheatManager_MAN_AchievementShowProgress");
static_assert(offsetof(ManCheatManager_MAN_AchievementShowProgress, AchievementID) == 0x000000, "Member 'ManCheatManager_MAN_AchievementShowProgress::AchievementID' has a wrong offset!");

// Function man.ManCheatManager.MAN_AchievementUnlock
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_AchievementUnlock final
{
public:
	class FString                                 AchievementID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_AchievementUnlock) == 0x000008, "Wrong alignment on ManCheatManager_MAN_AchievementUnlock");
static_assert(sizeof(ManCheatManager_MAN_AchievementUnlock) == 0x000010, "Wrong size on ManCheatManager_MAN_AchievementUnlock");
static_assert(offsetof(ManCheatManager_MAN_AchievementUnlock, AchievementID) == 0x000000, "Member 'ManCheatManager_MAN_AchievementUnlock::AchievementID' has a wrong offset!");

// Function man.ManCheatManager.MAN_ActorPerformanceAnalyze
// 0x0004 (0x0004 - 0x0000)
struct ManCheatManager_MAN_ActorPerformanceAnalyze final
{
public:
	int32                                         Frame;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_ActorPerformanceAnalyze) == 0x000004, "Wrong alignment on ManCheatManager_MAN_ActorPerformanceAnalyze");
static_assert(sizeof(ManCheatManager_MAN_ActorPerformanceAnalyze) == 0x000004, "Wrong size on ManCheatManager_MAN_ActorPerformanceAnalyze");
static_assert(offsetof(ManCheatManager_MAN_ActorPerformanceAnalyze, Frame) == 0x000000, "Member 'ManCheatManager_MAN_ActorPerformanceAnalyze::Frame' has a wrong offset!");

// Function man.ManCheatManager.MAN_CheatKillOnlyContain
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_CheatKillOnlyContain final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_CheatKillOnlyContain) == 0x000008, "Wrong alignment on ManCheatManager_MAN_CheatKillOnlyContain");
static_assert(sizeof(ManCheatManager_MAN_CheatKillOnlyContain) == 0x000010, "Wrong size on ManCheatManager_MAN_CheatKillOnlyContain");
static_assert(offsetof(ManCheatManager_MAN_CheatKillOnlyContain, Name_0) == 0x000000, "Member 'ManCheatManager_MAN_CheatKillOnlyContain::Name_0' has a wrong offset!");

// Function man.ManCheatManager.MAN_CheatKillSkipContain
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_CheatKillSkipContain final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_CheatKillSkipContain) == 0x000008, "Wrong alignment on ManCheatManager_MAN_CheatKillSkipContain");
static_assert(sizeof(ManCheatManager_MAN_CheatKillSkipContain) == 0x000010, "Wrong size on ManCheatManager_MAN_CheatKillSkipContain");
static_assert(offsetof(ManCheatManager_MAN_CheatKillSkipContain, Name_0) == 0x000000, "Member 'ManCheatManager_MAN_CheatKillSkipContain::Name_0' has a wrong offset!");

// Function man.ManCheatManager.MAN_CheatTeleport
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_CheatTeleport final
{
public:
	class FString                                 CheatTeleportName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_CheatTeleport) == 0x000008, "Wrong alignment on ManCheatManager_MAN_CheatTeleport");
static_assert(sizeof(ManCheatManager_MAN_CheatTeleport) == 0x000010, "Wrong size on ManCheatManager_MAN_CheatTeleport");
static_assert(offsetof(ManCheatManager_MAN_CheatTeleport, CheatTeleportName) == 0x000000, "Member 'ManCheatManager_MAN_CheatTeleport::CheatTeleportName' has a wrong offset!");

// Function man.ManCheatManager.MAN_ForceManShaderGenerateProcess
// 0x0008 (0x0008 - 0x0000)
struct ManCheatManager_MAN_ForceManShaderGenerateProcess final
{
public:
	int32                                         CurrentLevelMode;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleMode;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_ForceManShaderGenerateProcess) == 0x000004, "Wrong alignment on ManCheatManager_MAN_ForceManShaderGenerateProcess");
static_assert(sizeof(ManCheatManager_MAN_ForceManShaderGenerateProcess) == 0x000008, "Wrong size on ManCheatManager_MAN_ForceManShaderGenerateProcess");
static_assert(offsetof(ManCheatManager_MAN_ForceManShaderGenerateProcess, CurrentLevelMode) == 0x000000, "Member 'ManCheatManager_MAN_ForceManShaderGenerateProcess::CurrentLevelMode' has a wrong offset!");
static_assert(offsetof(ManCheatManager_MAN_ForceManShaderGenerateProcess, VisibleMode) == 0x000004, "Member 'ManCheatManager_MAN_ForceManShaderGenerateProcess::VisibleMode' has a wrong offset!");

// Function man.ManCheatManager.MAN_PlayCinematic
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_PlayCinematic final
{
public:
	class FString                                 CinematicAsset;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_PlayCinematic) == 0x000008, "Wrong alignment on ManCheatManager_MAN_PlayCinematic");
static_assert(sizeof(ManCheatManager_MAN_PlayCinematic) == 0x000010, "Wrong size on ManCheatManager_MAN_PlayCinematic");
static_assert(offsetof(ManCheatManager_MAN_PlayCinematic, CinematicAsset) == 0x000000, "Member 'ManCheatManager_MAN_PlayCinematic::CinematicAsset' has a wrong offset!");

// Function man.ManCheatManager.MAN_SetCustomCharacterSetupTemplate
// 0x0010 (0x0010 - 0x0000)
struct ManCheatManager_MAN_SetCustomCharacterSetupTemplate final
{
public:
	class FString                                 CustomCharacterSetupTemplate;                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_SetCustomCharacterSetupTemplate) == 0x000008, "Wrong alignment on ManCheatManager_MAN_SetCustomCharacterSetupTemplate");
static_assert(sizeof(ManCheatManager_MAN_SetCustomCharacterSetupTemplate) == 0x000010, "Wrong size on ManCheatManager_MAN_SetCustomCharacterSetupTemplate");
static_assert(offsetof(ManCheatManager_MAN_SetCustomCharacterSetupTemplate, CustomCharacterSetupTemplate) == 0x000000, "Member 'ManCheatManager_MAN_SetCustomCharacterSetupTemplate::CustomCharacterSetupTemplate' has a wrong offset!");

// Function man.ManCheatManager.MAN_SetHeroHP
// 0x0004 (0x0004 - 0x0000)
struct ManCheatManager_MAN_SetHeroHP final
{
public:
	float                                         HP;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_SetHeroHP) == 0x000004, "Wrong alignment on ManCheatManager_MAN_SetHeroHP");
static_assert(sizeof(ManCheatManager_MAN_SetHeroHP) == 0x000004, "Wrong size on ManCheatManager_MAN_SetHeroHP");
static_assert(offsetof(ManCheatManager_MAN_SetHeroHP, HP) == 0x000000, "Member 'ManCheatManager_MAN_SetHeroHP::HP' has a wrong offset!");

// Function man.ManCheatManager.MAN_SetHP
// 0x0004 (0x0004 - 0x0000)
struct ManCheatManager_MAN_SetHP final
{
public:
	float                                         HP;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_SetHP) == 0x000004, "Wrong alignment on ManCheatManager_MAN_SetHP");
static_assert(sizeof(ManCheatManager_MAN_SetHP) == 0x000004, "Wrong size on ManCheatManager_MAN_SetHP");
static_assert(offsetof(ManCheatManager_MAN_SetHP, HP) == 0x000000, "Member 'ManCheatManager_MAN_SetHP::HP' has a wrong offset!");

// Function man.ManCheatManager.MAN_SetSmallScreenZoomRate
// 0x0004 (0x0004 - 0x0000)
struct ManCheatManager_MAN_SetSmallScreenZoomRate final
{
public:
	float                                         SmallScreenZoomRate;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_SetSmallScreenZoomRate) == 0x000004, "Wrong alignment on ManCheatManager_MAN_SetSmallScreenZoomRate");
static_assert(sizeof(ManCheatManager_MAN_SetSmallScreenZoomRate) == 0x000004, "Wrong size on ManCheatManager_MAN_SetSmallScreenZoomRate");
static_assert(offsetof(ManCheatManager_MAN_SetSmallScreenZoomRate, SmallScreenZoomRate) == 0x000000, "Member 'ManCheatManager_MAN_SetSmallScreenZoomRate::SmallScreenZoomRate' has a wrong offset!");

// Function man.ManCheatManager.MAN_SetTalentPoint
// 0x0004 (0x0004 - 0x0000)
struct ManCheatManager_MAN_SetTalentPoint final
{
public:
	int32                                         NewPoint;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManCheatManager_MAN_SetTalentPoint) == 0x000004, "Wrong alignment on ManCheatManager_MAN_SetTalentPoint");
static_assert(sizeof(ManCheatManager_MAN_SetTalentPoint) == 0x000004, "Wrong size on ManCheatManager_MAN_SetTalentPoint");
static_assert(offsetof(ManCheatManager_MAN_SetTalentPoint, NewPoint) == 0x000000, "Member 'ManCheatManager_MAN_SetTalentPoint::NewPoint' has a wrong offset!");

// Function man.ManCheatManager.MAN_SpawnActor
// 0x0018 (0x0018 - 0x0000)
struct ManCheatManager_MAN_SpawnActor final
{
public:
	class FString                                 ActorName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManCheatManager_MAN_SpawnActor) == 0x000008, "Wrong alignment on ManCheatManager_MAN_SpawnActor");
static_assert(sizeof(ManCheatManager_MAN_SpawnActor) == 0x000018, "Wrong size on ManCheatManager_MAN_SpawnActor");
static_assert(offsetof(ManCheatManager_MAN_SpawnActor, ActorName) == 0x000000, "Member 'ManCheatManager_MAN_SpawnActor::ActorName' has a wrong offset!");
static_assert(offsetof(ManCheatManager_MAN_SpawnActor, Distance) == 0x000010, "Member 'ManCheatManager_MAN_SpawnActor::Distance' has a wrong offset!");

// Function man.FrostMageEntropicBlink.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct FrostMageEntropicBlink_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrostMageEntropicBlink_BPGetTeleportLocation) == 0x000004, "Wrong alignment on FrostMageEntropicBlink_BPGetTeleportLocation");
static_assert(sizeof(FrostMageEntropicBlink_BPGetTeleportLocation) == 0x00000C, "Wrong size on FrostMageEntropicBlink_BPGetTeleportLocation");
static_assert(offsetof(FrostMageEntropicBlink_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'FrostMageEntropicBlink_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.FrostMageEntropicBlinkToSpawnLocation.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation) == 0x000004, "Wrong alignment on FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation");
static_assert(sizeof(FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation) == 0x00000C, "Wrong size on FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation");
static_assert(offsetof(FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'FrostMageEntropicBlinkToSpawnLocation_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnGreyedOut
// 0x0001 (0x0001 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnGreyedOut final
{
public:
	bool                                          bInGreyedOut;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnGreyedOut) == 0x000001, "Wrong alignment on HUDBuffBarSlotUserWidget_OnGreyedOut");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnGreyedOut) == 0x000001, "Wrong size on HUDBuffBarSlotUserWidget_OnGreyedOut");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnGreyedOut, bInGreyedOut) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnGreyedOut::bInGreyedOut' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetCooldown
// 0x0004 (0x0004 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetCooldown final
{
public:
	float                                         InCooldown;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetCooldown) == 0x000004, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetCooldown");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetCooldown) == 0x000004, "Wrong size on HUDBuffBarSlotUserWidget_OnSetCooldown");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetCooldown, InCooldown) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetCooldown::InCooldown' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetHighlight
// 0x0001 (0x0001 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetHighlight final
{
public:
	bool                                          bInHighlight;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetHighlight) == 0x000001, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetHighlight");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetHighlight) == 0x000001, "Wrong size on HUDBuffBarSlotUserWidget_OnSetHighlight");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetHighlight, bInHighlight) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetHighlight::bInHighlight' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetIcon
// 0x0008 (0x0008 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetIcon final
{
public:
	const class UTexture2D*                       InBuffIcon;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetIcon) == 0x000008, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetIcon");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetIcon) == 0x000008, "Wrong size on HUDBuffBarSlotUserWidget_OnSetIcon");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetIcon, InBuffIcon) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetIcon::InBuffIcon' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetIconID
// 0x0004 (0x0004 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetIconID final
{
public:
	int32                                         InBuffIconID;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetIconID) == 0x000004, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetIconID");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetIconID) == 0x000004, "Wrong size on HUDBuffBarSlotUserWidget_OnSetIconID");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetIconID, InBuffIconID) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetIconID::InBuffIconID' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetInnerNumber
// 0x0004 (0x0004 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetInnerNumber final
{
public:
	int32                                         InInnerNumber;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetInnerNumber) == 0x000004, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetInnerNumber");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetInnerNumber) == 0x000004, "Wrong size on HUDBuffBarSlotUserWidget_OnSetInnerNumber");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetInnerNumber, InInnerNumber) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetInnerNumber::InInnerNumber' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetInnerNumberVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible final
{
public:
	bool                                          bInInnerNumberVisible;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible) == 0x000001, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible) == 0x000001, "Wrong size on HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible, bInInnerNumberVisible) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetInnerNumberVisible::bInInnerNumberVisible' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetMaxCooldown
// 0x0004 (0x0004 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetMaxCooldown final
{
public:
	float                                         InMaxCooldown;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetMaxCooldown) == 0x000004, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetMaxCooldown");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetMaxCooldown) == 0x000004, "Wrong size on HUDBuffBarSlotUserWidget_OnSetMaxCooldown");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetMaxCooldown, InMaxCooldown) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetMaxCooldown::InMaxCooldown' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetOuterNumber
// 0x0004 (0x0004 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetOuterNumber final
{
public:
	int32                                         InOuterNumber;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetOuterNumber) == 0x000004, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetOuterNumber");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetOuterNumber) == 0x000004, "Wrong size on HUDBuffBarSlotUserWidget_OnSetOuterNumber");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetOuterNumber, InOuterNumber) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetOuterNumber::InOuterNumber' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetOuterNumberVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible final
{
public:
	bool                                          bInOuterNumberVisible;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible) == 0x000001, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible) == 0x000001, "Wrong size on HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible, bInOuterNumberVisible) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetOuterNumberVisible::bInOuterNumberVisible' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetText
// 0x0018 (0x0018 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetText final
{
public:
	class FText                                   InBuffText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetText) == 0x000008, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetText");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetText) == 0x000018, "Wrong size on HUDBuffBarSlotUserWidget_OnSetText");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetText, InBuffText) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetText::InBuffText' has a wrong offset!");

// Function man.HUDBuffBarSlotUserWidget.OnSetType
// 0x0001 (0x0001 - 0x0000)
struct HUDBuffBarSlotUserWidget_OnSetType final
{
public:
	EBuffType                                     InBuffType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDBuffBarSlotUserWidget_OnSetType) == 0x000001, "Wrong alignment on HUDBuffBarSlotUserWidget_OnSetType");
static_assert(sizeof(HUDBuffBarSlotUserWidget_OnSetType) == 0x000001, "Wrong size on HUDBuffBarSlotUserWidget_OnSetType");
static_assert(offsetof(HUDBuffBarSlotUserWidget_OnSetType, InBuffType) == 0x000000, "Member 'HUDBuffBarSlotUserWidget_OnSetType::InBuffType' has a wrong offset!");

// Function man.GameCamera.GetCameraParamsForLevelSequencePlayer
// 0x0050 (0x0050 - 0x0000)
struct GameCamera_GetCameraParamsForLevelSequencePlayer final
{
public:
	class ACineCameraActor*                       CineCameraActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentFocalLength;                                // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameCamera_GetCameraParamsForLevelSequencePlayer) == 0x000010, "Wrong alignment on GameCamera_GetCameraParamsForLevelSequencePlayer");
static_assert(sizeof(GameCamera_GetCameraParamsForLevelSequencePlayer) == 0x000050, "Wrong size on GameCamera_GetCameraParamsForLevelSequencePlayer");
static_assert(offsetof(GameCamera_GetCameraParamsForLevelSequencePlayer, CineCameraActor) == 0x000000, "Member 'GameCamera_GetCameraParamsForLevelSequencePlayer::CineCameraActor' has a wrong offset!");
static_assert(offsetof(GameCamera_GetCameraParamsForLevelSequencePlayer, Transform) == 0x000010, "Member 'GameCamera_GetCameraParamsForLevelSequencePlayer::Transform' has a wrong offset!");
static_assert(offsetof(GameCamera_GetCameraParamsForLevelSequencePlayer, CurrentFocalLength) == 0x000040, "Member 'GameCamera_GetCameraParamsForLevelSequencePlayer::CurrentFocalLength' has a wrong offset!");

// Function man.GameCamera.OnCharacterWindowHide
// 0x0008 (0x0008 - 0x0000)
struct GameCamera_OnCharacterWindowHide final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_OnCharacterWindowHide) == 0x000008, "Wrong alignment on GameCamera_OnCharacterWindowHide");
static_assert(sizeof(GameCamera_OnCharacterWindowHide) == 0x000008, "Wrong size on GameCamera_OnCharacterWindowHide");
static_assert(offsetof(GameCamera_OnCharacterWindowHide, ManUserWidgetBase) == 0x000000, "Member 'GameCamera_OnCharacterWindowHide::ManUserWidgetBase' has a wrong offset!");

// Function man.GameCamera.OnCharacterWindowShow
// 0x0008 (0x0008 - 0x0000)
struct GameCamera_OnCharacterWindowShow final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_OnCharacterWindowShow) == 0x000008, "Wrong alignment on GameCamera_OnCharacterWindowShow");
static_assert(sizeof(GameCamera_OnCharacterWindowShow) == 0x000008, "Wrong size on GameCamera_OnCharacterWindowShow");
static_assert(offsetof(GameCamera_OnCharacterWindowShow, ManUserWidgetBase) == 0x000000, "Member 'GameCamera_OnCharacterWindowShow::ManUserWidgetBase' has a wrong offset!");

// Function man.GameCamera.ResetMotionBlurStrength
// 0x0004 (0x0004 - 0x0000)
struct GameCamera_ResetMotionBlurStrength final
{
public:
	float                                         BlendDuration;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_ResetMotionBlurStrength) == 0x000004, "Wrong alignment on GameCamera_ResetMotionBlurStrength");
static_assert(sizeof(GameCamera_ResetMotionBlurStrength) == 0x000004, "Wrong size on GameCamera_ResetMotionBlurStrength");
static_assert(offsetof(GameCamera_ResetMotionBlurStrength, BlendDuration) == 0x000000, "Member 'GameCamera_ResetMotionBlurStrength::BlendDuration' has a wrong offset!");

// Function man.GameCamera.SetMotionBlurStrength
// 0x0008 (0x0008 - 0x0000)
struct GameCamera_SetMotionBlurStrength final
{
public:
	float                                         MotionBlurAmount;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_SetMotionBlurStrength) == 0x000004, "Wrong alignment on GameCamera_SetMotionBlurStrength");
static_assert(sizeof(GameCamera_SetMotionBlurStrength) == 0x000008, "Wrong size on GameCamera_SetMotionBlurStrength");
static_assert(offsetof(GameCamera_SetMotionBlurStrength, MotionBlurAmount) == 0x000000, "Member 'GameCamera_SetMotionBlurStrength::MotionBlurAmount' has a wrong offset!");
static_assert(offsetof(GameCamera_SetMotionBlurStrength, BlendDuration) == 0x000004, "Member 'GameCamera_SetMotionBlurStrength::BlendDuration' has a wrong offset!");

// Function man.GameCamera.SetPlayerFocus
// 0x0001 (0x0001 - 0x0000)
struct GameCamera_SetPlayerFocus final
{
public:
	bool                                          NewPlayerFocus;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_SetPlayerFocus) == 0x000001, "Wrong alignment on GameCamera_SetPlayerFocus");
static_assert(sizeof(GameCamera_SetPlayerFocus) == 0x000001, "Wrong size on GameCamera_SetPlayerFocus");
static_assert(offsetof(GameCamera_SetPlayerFocus, NewPlayerFocus) == 0x000000, "Member 'GameCamera_SetPlayerFocus::NewPlayerFocus' has a wrong offset!");

// Function man.GameCamera.SetSequencePlaying
// 0x0001 (0x0001 - 0x0000)
struct GameCamera_SetSequencePlaying final
{
public:
	bool                                          NewSequencePlaying;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_SetSequencePlaying) == 0x000001, "Wrong alignment on GameCamera_SetSequencePlaying");
static_assert(sizeof(GameCamera_SetSequencePlaying) == 0x000001, "Wrong size on GameCamera_SetSequencePlaying");
static_assert(offsetof(GameCamera_SetSequencePlaying, NewSequencePlaying) == 0x000000, "Member 'GameCamera_SetSequencePlaying::NewSequencePlaying' has a wrong offset!");

// Function man.GameCamera.SetSmallScreenZoomRate
// 0x0004 (0x0004 - 0x0000)
struct GameCamera_SetSmallScreenZoomRate final
{
public:
	float                                         NewSmallScreenZoomRate;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_SetSmallScreenZoomRate) == 0x000004, "Wrong alignment on GameCamera_SetSmallScreenZoomRate");
static_assert(sizeof(GameCamera_SetSmallScreenZoomRate) == 0x000004, "Wrong size on GameCamera_SetSmallScreenZoomRate");
static_assert(offsetof(GameCamera_SetSmallScreenZoomRate, NewSmallScreenZoomRate) == 0x000000, "Member 'GameCamera_SetSmallScreenZoomRate::NewSmallScreenZoomRate' has a wrong offset!");

// Function man.GameCamera.UpdateByLevelSequencePlayerCamera
// 0x0008 (0x0008 - 0x0000)
struct GameCamera_UpdateByLevelSequencePlayerCamera final
{
public:
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_UpdateByLevelSequencePlayerCamera) == 0x000008, "Wrong alignment on GameCamera_UpdateByLevelSequencePlayerCamera");
static_assert(sizeof(GameCamera_UpdateByLevelSequencePlayerCamera) == 0x000008, "Wrong size on GameCamera_UpdateByLevelSequencePlayerCamera");
static_assert(offsetof(GameCamera_UpdateByLevelSequencePlayerCamera, LevelSequencePlayer) == 0x000000, "Member 'GameCamera_UpdateByLevelSequencePlayerCamera::LevelSequencePlayer' has a wrong offset!");

// Function man.GameCamera.DumpCameraCharacters
// 0x0010 (0x0010 - 0x0000)
struct GameCamera_DumpCameraCharacters final
{
public:
	TArray<class FString>                         CharacterNames;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_DumpCameraCharacters) == 0x000008, "Wrong alignment on GameCamera_DumpCameraCharacters");
static_assert(sizeof(GameCamera_DumpCameraCharacters) == 0x000010, "Wrong size on GameCamera_DumpCameraCharacters");
static_assert(offsetof(GameCamera_DumpCameraCharacters, CharacterNames) == 0x000000, "Member 'GameCamera_DumpCameraCharacters::CharacterNames' has a wrong offset!");

// Function man.GameCamera.GetListenerTransform
// 0x0030 (0x0030 - 0x0000)
struct GameCamera_GetListenerTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_GetListenerTransform) == 0x000010, "Wrong alignment on GameCamera_GetListenerTransform");
static_assert(sizeof(GameCamera_GetListenerTransform) == 0x000030, "Wrong size on GameCamera_GetListenerTransform");
static_assert(offsetof(GameCamera_GetListenerTransform, ReturnValue) == 0x000000, "Member 'GameCamera_GetListenerTransform::ReturnValue' has a wrong offset!");

// Function man.GameCamera.GetManualDistance
// 0x0004 (0x0004 - 0x0000)
struct GameCamera_GetManualDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_GetManualDistance) == 0x000004, "Wrong alignment on GameCamera_GetManualDistance");
static_assert(sizeof(GameCamera_GetManualDistance) == 0x000004, "Wrong size on GameCamera_GetManualDistance");
static_assert(offsetof(GameCamera_GetManualDistance, ReturnValue) == 0x000000, "Member 'GameCamera_GetManualDistance::ReturnValue' has a wrong offset!");

// Function man.GameCamera.GetVerticalDistance
// 0x0004 (0x0004 - 0x0000)
struct GameCamera_GetVerticalDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_GetVerticalDistance) == 0x000004, "Wrong alignment on GameCamera_GetVerticalDistance");
static_assert(sizeof(GameCamera_GetVerticalDistance) == 0x000004, "Wrong size on GameCamera_GetVerticalDistance");
static_assert(offsetof(GameCamera_GetVerticalDistance, ReturnValue) == 0x000000, "Member 'GameCamera_GetVerticalDistance::ReturnValue' has a wrong offset!");

// Function man.GameCamera.GetWorldTransform
// 0x0030 (0x0030 - 0x0000)
struct GameCamera_GetWorldTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_GetWorldTransform) == 0x000010, "Wrong alignment on GameCamera_GetWorldTransform");
static_assert(sizeof(GameCamera_GetWorldTransform) == 0x000030, "Wrong size on GameCamera_GetWorldTransform");
static_assert(offsetof(GameCamera_GetWorldTransform, ReturnValue) == 0x000000, "Member 'GameCamera_GetWorldTransform::ReturnValue' has a wrong offset!");

// Function man.GameCamera.IsSequencePlaying
// 0x0001 (0x0001 - 0x0000)
struct GameCamera_IsSequencePlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCamera_IsSequencePlaying) == 0x000001, "Wrong alignment on GameCamera_IsSequencePlaying");
static_assert(sizeof(GameCamera_IsSequencePlaying) == 0x000001, "Wrong size on GameCamera_IsSequencePlaying");
static_assert(offsetof(GameCamera_IsSequencePlaying, ReturnValue) == 0x000000, "Member 'GameCamera_IsSequencePlaying::ReturnValue' has a wrong offset!");

// Function man.RatingSystem_Glicko.AddMatch
// 0x0028 (0x0028 - 0x0000)
struct RatingSystem_Glicko_AddMatch final
{
public:
	TScriptInterface<class IRatingObjectInterface> Rating1;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IRatingObjectInterface> Rating2;                                           // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RatingSystem_Glicko_AddMatch) == 0x000008, "Wrong alignment on RatingSystem_Glicko_AddMatch");
static_assert(sizeof(RatingSystem_Glicko_AddMatch) == 0x000028, "Wrong size on RatingSystem_Glicko_AddMatch");
static_assert(offsetof(RatingSystem_Glicko_AddMatch, Rating1) == 0x000000, "Member 'RatingSystem_Glicko_AddMatch::Rating1' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_AddMatch, Rating2) == 0x000010, "Member 'RatingSystem_Glicko_AddMatch::Rating2' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_AddMatch, Result) == 0x000020, "Member 'RatingSystem_Glicko_AddMatch::Result' has a wrong offset!");

// Function man.RatingSystem_Glicko.CreateRatingObject
// 0x0010 (0x0010 - 0x0000)
struct RatingSystem_Glicko_CreateRatingObject final
{
public:
	TScriptInterface<class IRatingObjectInterface> ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystem_Glicko_CreateRatingObject) == 0x000008, "Wrong alignment on RatingSystem_Glicko_CreateRatingObject");
static_assert(sizeof(RatingSystem_Glicko_CreateRatingObject) == 0x000010, "Wrong size on RatingSystem_Glicko_CreateRatingObject");
static_assert(offsetof(RatingSystem_Glicko_CreateRatingObject, ReturnValue) == 0x000000, "Member 'RatingSystem_Glicko_CreateRatingObject::ReturnValue' has a wrong offset!");

// Function man.RatingSystem_Glicko.GetDSqr
// 0x0028 (0x0028 - 0x0000)
struct RatingSystem_Glicko_GetDSqr final
{
public:
	struct FPlayerRatingProcessInfo               PlayerRatingProcessInfo;                           // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RatingSystem_Glicko_GetDSqr) == 0x000008, "Wrong alignment on RatingSystem_Glicko_GetDSqr");
static_assert(sizeof(RatingSystem_Glicko_GetDSqr) == 0x000028, "Wrong size on RatingSystem_Glicko_GetDSqr");
static_assert(offsetof(RatingSystem_Glicko_GetDSqr, PlayerRatingProcessInfo) == 0x000000, "Member 'RatingSystem_Glicko_GetDSqr::PlayerRatingProcessInfo' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetDSqr, ReturnValue) == 0x000020, "Member 'RatingSystem_Glicko_GetDSqr::ReturnValue' has a wrong offset!");

// Function man.RatingSystem_Glicko.GetE
// 0x0014 (0x0014 - 0x0000)
struct RatingSystem_Glicko_GetE final
{
public:
	float                                         Score;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rating;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherRating;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherG;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystem_Glicko_GetE) == 0x000004, "Wrong alignment on RatingSystem_Glicko_GetE");
static_assert(sizeof(RatingSystem_Glicko_GetE) == 0x000014, "Wrong size on RatingSystem_Glicko_GetE");
static_assert(offsetof(RatingSystem_Glicko_GetE, Score) == 0x000000, "Member 'RatingSystem_Glicko_GetE::Score' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetE, Rating) == 0x000004, "Member 'RatingSystem_Glicko_GetE::Rating' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetE, OtherRating) == 0x000008, "Member 'RatingSystem_Glicko_GetE::OtherRating' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetE, OtherG) == 0x00000C, "Member 'RatingSystem_Glicko_GetE::OtherG' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetE, ReturnValue) == 0x000010, "Member 'RatingSystem_Glicko_GetE::ReturnValue' has a wrong offset!");

// Function man.RatingSystem_Glicko.GetG
// 0x0008 (0x0008 - 0x0000)
struct RatingSystem_Glicko_GetG final
{
public:
	float                                         RatingsDeviation;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystem_Glicko_GetG) == 0x000004, "Wrong alignment on RatingSystem_Glicko_GetG");
static_assert(sizeof(RatingSystem_Glicko_GetG) == 0x000008, "Wrong size on RatingSystem_Glicko_GetG");
static_assert(offsetof(RatingSystem_Glicko_GetG, RatingsDeviation) == 0x000000, "Member 'RatingSystem_Glicko_GetG::RatingsDeviation' has a wrong offset!");
static_assert(offsetof(RatingSystem_Glicko_GetG, ReturnValue) == 0x000004, "Member 'RatingSystem_Glicko_GetG::ReturnValue' has a wrong offset!");

// Function man.RatingSystem_Glicko.GetSettings
// 0x000C (0x000C - 0x0000)
struct RatingSystem_Glicko_GetSettings final
{
public:
	struct FRatingSystemSettings_Glicko           ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystem_Glicko_GetSettings) == 0x000004, "Wrong alignment on RatingSystem_Glicko_GetSettings");
static_assert(sizeof(RatingSystem_Glicko_GetSettings) == 0x00000C, "Wrong size on RatingSystem_Glicko_GetSettings");
static_assert(offsetof(RatingSystem_Glicko_GetSettings, ReturnValue) == 0x000000, "Member 'RatingSystem_Glicko_GetSettings::ReturnValue' has a wrong offset!");

// Function man.GatheringStormPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct GatheringStormPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GatheringStormPassive_DamageDealt) == 0x000008, "Wrong alignment on GatheringStormPassive_DamageDealt");
static_assert(sizeof(GatheringStormPassive_DamageDealt) == 0x0002D8, "Wrong size on GatheringStormPassive_DamageDealt");
static_assert(offsetof(GatheringStormPassive_DamageDealt, Param) == 0x000000, "Member 'GatheringStormPassive_DamageDealt::Param' has a wrong offset!");

// Function man.HUDUserWidget.AddedResourceAnimFinished
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_AddedResourceAnimFinished final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_AddedResourceAnimFinished) == 0x000001, "Wrong alignment on HUDUserWidget_AddedResourceAnimFinished");
static_assert(sizeof(HUDUserWidget_AddedResourceAnimFinished) == 0x000001, "Wrong size on HUDUserWidget_AddedResourceAnimFinished");
static_assert(offsetof(HUDUserWidget_AddedResourceAnimFinished, PropertyType) == 0x000000, "Member 'HUDUserWidget_AddedResourceAnimFinished::PropertyType' has a wrong offset!");

// Function man.HUDUserWidget.GetInteractProgress
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_GetInteractProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_GetInteractProgress) == 0x000004, "Wrong alignment on HUDUserWidget_GetInteractProgress");
static_assert(sizeof(HUDUserWidget_GetInteractProgress) == 0x000004, "Wrong size on HUDUserWidget_GetInteractProgress");
static_assert(offsetof(HUDUserWidget_GetInteractProgress, ReturnValue) == 0x000000, "Member 'HUDUserWidget_GetInteractProgress::ReturnValue' has a wrong offset!");

// Function man.HUDUserWidget.OnAddItemAbility
// 0x0010 (0x0010 - 0x0000)
struct HUDUserWidget_OnAddItemAbility final
{
public:
	class UItemAbility*                           Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnAddItemAbility) == 0x000008, "Wrong alignment on HUDUserWidget_OnAddItemAbility");
static_assert(sizeof(HUDUserWidget_OnAddItemAbility) == 0x000010, "Wrong size on HUDUserWidget_OnAddItemAbility");
static_assert(offsetof(HUDUserWidget_OnAddItemAbility, Item) == 0x000000, "Member 'HUDUserWidget_OnAddItemAbility::Item' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnAddItemAbility, Stack) == 0x000008, "Member 'HUDUserWidget_OnAddItemAbility::Stack' has a wrong offset!");

// Function man.HUDUserWidget.OnBossPreDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct HUDUserWidget_OnBossPreDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnBossPreDamaged) == 0x000008, "Wrong alignment on HUDUserWidget_OnBossPreDamaged");
static_assert(sizeof(HUDUserWidget_OnBossPreDamaged) == 0x0002D8, "Wrong size on HUDUserWidget_OnBossPreDamaged");
static_assert(offsetof(HUDUserWidget_OnBossPreDamaged, Param) == 0x000000, "Member 'HUDUserWidget_OnBossPreDamaged::Param' has a wrong offset!");

// Function man.HUDUserWidget.OnChangeItemSetIndex
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnChangeItemSetIndex final
{
public:
	int32                                         ItemSetIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnChangeItemSetIndex) == 0x000004, "Wrong alignment on HUDUserWidget_OnChangeItemSetIndex");
static_assert(sizeof(HUDUserWidget_OnChangeItemSetIndex) == 0x000008, "Wrong size on HUDUserWidget_OnChangeItemSetIndex");
static_assert(offsetof(HUDUserWidget_OnChangeItemSetIndex, ItemSetIndex) == 0x000000, "Member 'HUDUserWidget_OnChangeItemSetIndex::ItemSetIndex' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnChangeItemSetIndex, bAnimate) == 0x000004, "Member 'HUDUserWidget_OnChangeItemSetIndex::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.OnChangeSkillSetIndex
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnChangeSkillSetIndex final
{
public:
	int32                                         SkillSetIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnChangeSkillSetIndex) == 0x000004, "Wrong alignment on HUDUserWidget_OnChangeSkillSetIndex");
static_assert(sizeof(HUDUserWidget_OnChangeSkillSetIndex) == 0x000008, "Wrong size on HUDUserWidget_OnChangeSkillSetIndex");
static_assert(offsetof(HUDUserWidget_OnChangeSkillSetIndex, SkillSetIndex) == 0x000000, "Member 'HUDUserWidget_OnChangeSkillSetIndex::SkillSetIndex' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnChangeSkillSetIndex, bAnimate) == 0x000004, "Member 'HUDUserWidget_OnChangeSkillSetIndex::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.OnComboPointBarVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnComboPointBarVisible final
{
public:
	bool                                          bComboPointBarVisible;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnComboPointBarVisible) == 0x000001, "Wrong alignment on HUDUserWidget_OnComboPointBarVisible");
static_assert(sizeof(HUDUserWidget_OnComboPointBarVisible) == 0x000001, "Wrong size on HUDUserWidget_OnComboPointBarVisible");
static_assert(offsetof(HUDUserWidget_OnComboPointBarVisible, bComboPointBarVisible) == 0x000000, "Member 'HUDUserWidget_OnComboPointBarVisible::bComboPointBarVisible' has a wrong offset!");

// Function man.HUDUserWidget.OnEdgeScreenLowResourceFeedback
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_OnEdgeScreenLowResourceFeedback final
{
public:
	int32                                         InEdgeScreenLowResourceFeedback;                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnEdgeScreenLowResourceFeedback) == 0x000004, "Wrong alignment on HUDUserWidget_OnEdgeScreenLowResourceFeedback");
static_assert(sizeof(HUDUserWidget_OnEdgeScreenLowResourceFeedback) == 0x000004, "Wrong size on HUDUserWidget_OnEdgeScreenLowResourceFeedback");
static_assert(offsetof(HUDUserWidget_OnEdgeScreenLowResourceFeedback, InEdgeScreenLowResourceFeedback) == 0x000000, "Member 'HUDUserWidget_OnEdgeScreenLowResourceFeedback::InEdgeScreenLowResourceFeedback' has a wrong offset!");

// Function man.HUDUserWidget.OnEnergyBarVisibility
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnEnergyBarVisibility final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnEnergyBarVisibility) == 0x000001, "Wrong alignment on HUDUserWidget_OnEnergyBarVisibility");
static_assert(sizeof(HUDUserWidget_OnEnergyBarVisibility) == 0x000001, "Wrong size on HUDUserWidget_OnEnergyBarVisibility");
static_assert(offsetof(HUDUserWidget_OnEnergyBarVisibility, bInVisible) == 0x000000, "Member 'HUDUserWidget_OnEnergyBarVisibility::bInVisible' has a wrong offset!");

// Function man.HUDUserWidget.OnExtraAbilitySlotVisibility
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnExtraAbilitySlotVisibility final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnExtraAbilitySlotVisibility) == 0x000001, "Wrong alignment on HUDUserWidget_OnExtraAbilitySlotVisibility");
static_assert(sizeof(HUDUserWidget_OnExtraAbilitySlotVisibility) == 0x000001, "Wrong size on HUDUserWidget_OnExtraAbilitySlotVisibility");
static_assert(offsetof(HUDUserWidget_OnExtraAbilitySlotVisibility, bInVisible) == 0x000000, "Member 'HUDUserWidget_OnExtraAbilitySlotVisibility::bInVisible' has a wrong offset!");

// Function man.HUDUserWidget.OnHideHUDBar
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnHideHUDBar final
{
public:
	EHUDBarType                                   HUDBarType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnHideHUDBar) == 0x000001, "Wrong alignment on HUDUserWidget_OnHideHUDBar");
static_assert(sizeof(HUDUserWidget_OnHideHUDBar) == 0x000001, "Wrong size on HUDUserWidget_OnHideHUDBar");
static_assert(offsetof(HUDUserWidget_OnHideHUDBar, HUDBarType) == 0x000000, "Member 'HUDUserWidget_OnHideHUDBar::HUDBarType' has a wrong offset!");

// Function man.HUDUserWidget.OnHUDVisibility
// 0x0002 (0x0002 - 0x0000)
struct HUDUserWidget_OnHUDVisibility final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnHUDVisibility) == 0x000001, "Wrong alignment on HUDUserWidget_OnHUDVisibility");
static_assert(sizeof(HUDUserWidget_OnHUDVisibility) == 0x000002, "Wrong size on HUDUserWidget_OnHUDVisibility");
static_assert(offsetof(HUDUserWidget_OnHUDVisibility, bInVisible) == 0x000000, "Member 'HUDUserWidget_OnHUDVisibility::bInVisible' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnHUDVisibility, bAnimate) == 0x000001, "Member 'HUDUserWidget_OnHUDVisibility::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.OnInputRestrict
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnInputRestrict final
{
public:
	bool                                          bInInputRestrict;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnInputRestrict) == 0x000001, "Wrong alignment on HUDUserWidget_OnInputRestrict");
static_assert(sizeof(HUDUserWidget_OnInputRestrict) == 0x000001, "Wrong size on HUDUserWidget_OnInputRestrict");
static_assert(offsetof(HUDUserWidget_OnInputRestrict, bInInputRestrict) == 0x000000, "Member 'HUDUserWidget_OnInputRestrict::bInInputRestrict' has a wrong offset!");

// Function man.HUDUserWidget.OnLevelUpIndicator
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnLevelUpIndicator final
{
public:
	bool                                          bMatchHasStarted;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnLevelUpIndicator) == 0x000001, "Wrong alignment on HUDUserWidget_OnLevelUpIndicator");
static_assert(sizeof(HUDUserWidget_OnLevelUpIndicator) == 0x000001, "Wrong size on HUDUserWidget_OnLevelUpIndicator");
static_assert(offsetof(HUDUserWidget_OnLevelUpIndicator, bMatchHasStarted) == 0x000000, "Member 'HUDUserWidget_OnLevelUpIndicator::bMatchHasStarted' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestAdd
// 0x0010 (0x0010 - 0x0000)
struct HUDUserWidget_OnManQuestAdd final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuestPopupShowingDelayTime;                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnManQuestAdd) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestAdd");
static_assert(sizeof(HUDUserWidget_OnManQuestAdd) == 0x000010, "Wrong size on HUDUserWidget_OnManQuestAdd");
static_assert(offsetof(HUDUserWidget_OnManQuestAdd, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestAdd::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestAdd, Timeout) == 0x000008, "Member 'HUDUserWidget_OnManQuestAdd::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestAdd, QuestPopupShowingDelayTime) == 0x00000C, "Member 'HUDUserWidget_OnManQuestAdd::QuestPopupShowingDelayTime' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestComplete
// 0x0010 (0x0010 - 0x0000)
struct HUDUserWidget_OnManQuestComplete final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnManQuestComplete) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestComplete");
static_assert(sizeof(HUDUserWidget_OnManQuestComplete) == 0x000010, "Wrong size on HUDUserWidget_OnManQuestComplete");
static_assert(offsetof(HUDUserWidget_OnManQuestComplete, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestComplete::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestComplete, Timeout) == 0x000008, "Member 'HUDUserWidget_OnManQuestComplete::Timeout' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestObjectiveAdd
// 0x0020 (0x0020 - 0x0000)
struct HUDUserWidget_OnManQuestObjectiveAdd final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     CurrentQuestObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     NextQuestObject;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowQuestWindow;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnManQuestObjectiveAdd) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestObjectiveAdd");
static_assert(sizeof(HUDUserWidget_OnManQuestObjectiveAdd) == 0x000020, "Wrong size on HUDUserWidget_OnManQuestObjectiveAdd");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveAdd, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestObjectiveAdd::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveAdd, CurrentQuestObject) == 0x000008, "Member 'HUDUserWidget_OnManQuestObjectiveAdd::CurrentQuestObject' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveAdd, NextQuestObject) == 0x000010, "Member 'HUDUserWidget_OnManQuestObjectiveAdd::NextQuestObject' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveAdd, Timeout) == 0x000018, "Member 'HUDUserWidget_OnManQuestObjectiveAdd::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveAdd, bShowQuestWindow) == 0x00001C, "Member 'HUDUserWidget_OnManQuestObjectiveAdd::bShowQuestWindow' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestObjectiveComplete
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnManQuestObjectiveComplete final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ManQuestObject;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestCompleted;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnManQuestObjectiveComplete) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestObjectiveComplete");
static_assert(sizeof(HUDUserWidget_OnManQuestObjectiveComplete) == 0x000018, "Wrong size on HUDUserWidget_OnManQuestObjectiveComplete");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveComplete, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestObjectiveComplete::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveComplete, ManQuestObject) == 0x000008, "Member 'HUDUserWidget_OnManQuestObjectiveComplete::ManQuestObject' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveComplete, Timeout) == 0x000010, "Member 'HUDUserWidget_OnManQuestObjectiveComplete::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveComplete, bQuestCompleted) == 0x000014, "Member 'HUDUserWidget_OnManQuestObjectiveComplete::bQuestCompleted' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestObjectiveFailed
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnManQuestObjectiveFailed final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ManQuestObject;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnManQuestObjectiveFailed) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestObjectiveFailed");
static_assert(sizeof(HUDUserWidget_OnManQuestObjectiveFailed) == 0x000018, "Wrong size on HUDUserWidget_OnManQuestObjectiveFailed");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveFailed, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestObjectiveFailed::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveFailed, ManQuestObject) == 0x000008, "Member 'HUDUserWidget_OnManQuestObjectiveFailed::ManQuestObject' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveFailed, Timeout) == 0x000010, "Member 'HUDUserWidget_OnManQuestObjectiveFailed::Timeout' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestObjectiveUpdate
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnManQuestObjectiveUpdate final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ManQuestObject;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowQuestWindow;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnManQuestObjectiveUpdate) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestObjectiveUpdate");
static_assert(sizeof(HUDUserWidget_OnManQuestObjectiveUpdate) == 0x000018, "Wrong size on HUDUserWidget_OnManQuestObjectiveUpdate");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveUpdate, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestObjectiveUpdate::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveUpdate, ManQuestObject) == 0x000008, "Member 'HUDUserWidget_OnManQuestObjectiveUpdate::ManQuestObject' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveUpdate, Timeout) == 0x000010, "Member 'HUDUserWidget_OnManQuestObjectiveUpdate::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnManQuestObjectiveUpdate, bShowQuestWindow) == 0x000014, "Member 'HUDUserWidget_OnManQuestObjectiveUpdate::bShowQuestWindow' has a wrong offset!");

// Function man.HUDUserWidget.OnManQuestRemove
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnManQuestRemove final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnManQuestRemove) == 0x000008, "Wrong alignment on HUDUserWidget_OnManQuestRemove");
static_assert(sizeof(HUDUserWidget_OnManQuestRemove) == 0x000008, "Wrong size on HUDUserWidget_OnManQuestRemove");
static_assert(offsetof(HUDUserWidget_OnManQuestRemove, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnManQuestRemove::ManQuest' has a wrong offset!");

// Function man.HUDUserWidget.OnNewAreaDiscovered
// 0x0020 (0x0020 - 0x0000)
struct HUDUserWidget_OnNewAreaDiscovered final
{
public:
	class FText                                   NewAreaName;                                       // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnNewAreaDiscovered) == 0x000008, "Wrong alignment on HUDUserWidget_OnNewAreaDiscovered");
static_assert(sizeof(HUDUserWidget_OnNewAreaDiscovered) == 0x000020, "Wrong size on HUDUserWidget_OnNewAreaDiscovered");
static_assert(offsetof(HUDUserWidget_OnNewAreaDiscovered, NewAreaName) == 0x000000, "Member 'HUDUserWidget_OnNewAreaDiscovered::NewAreaName' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnNewAreaDiscovered, Timeout) == 0x000018, "Member 'HUDUserWidget_OnNewAreaDiscovered::Timeout' has a wrong offset!");

// Function man.HUDUserWidget.OnPlayRiftCombatStartAnim
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_OnPlayRiftCombatStartAnim final
{
public:
	int32                                         RiftID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnPlayRiftCombatStartAnim) == 0x000004, "Wrong alignment on HUDUserWidget_OnPlayRiftCombatStartAnim");
static_assert(sizeof(HUDUserWidget_OnPlayRiftCombatStartAnim) == 0x000004, "Wrong size on HUDUserWidget_OnPlayRiftCombatStartAnim");
static_assert(offsetof(HUDUserWidget_OnPlayRiftCombatStartAnim, RiftID) == 0x000000, "Member 'HUDUserWidget_OnPlayRiftCombatStartAnim::RiftID' has a wrong offset!");

// Function man.HUDUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct HUDUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on HUDUserWidget_OnPropertyChanged");
static_assert(sizeof(HUDUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on HUDUserWidget_OnPropertyChanged");
static_assert(offsetof(HUDUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'HUDUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'HUDUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'HUDUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'HUDUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'HUDUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.OnQuestTrackingUpdated
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnQuestTrackingUpdated final
{
public:
	class UManQuest*                              ManQuestm;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UManQuestObjective*>             Objectives;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnQuestTrackingUpdated) == 0x000008, "Wrong alignment on HUDUserWidget_OnQuestTrackingUpdated");
static_assert(sizeof(HUDUserWidget_OnQuestTrackingUpdated) == 0x000018, "Wrong size on HUDUserWidget_OnQuestTrackingUpdated");
static_assert(offsetof(HUDUserWidget_OnQuestTrackingUpdated, ManQuestm) == 0x000000, "Member 'HUDUserWidget_OnQuestTrackingUpdated::ManQuestm' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnQuestTrackingUpdated, Objectives) == 0x000008, "Member 'HUDUserWidget_OnQuestTrackingUpdated::Objectives' has a wrong offset!");

// Function man.HUDUserWidget.OnRageBarVisibility
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnRageBarVisibility final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnRageBarVisibility) == 0x000001, "Wrong alignment on HUDUserWidget_OnRageBarVisibility");
static_assert(sizeof(HUDUserWidget_OnRageBarVisibility) == 0x000001, "Wrong size on HUDUserWidget_OnRageBarVisibility");
static_assert(offsetof(HUDUserWidget_OnRageBarVisibility, bInVisible) == 0x000000, "Member 'HUDUserWidget_OnRageBarVisibility::bInVisible' has a wrong offset!");

// Function man.HUDUserWidget.OnRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct HUDUserWidget_OnRemoveItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RemovedItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnRemoveItem) == 0x000008, "Wrong alignment on HUDUserWidget_OnRemoveItem");
static_assert(sizeof(HUDUserWidget_OnRemoveItem) == 0x000010, "Wrong size on HUDUserWidget_OnRemoveItem");
static_assert(offsetof(HUDUserWidget_OnRemoveItem, InventorySlot) == 0x000000, "Member 'HUDUserWidget_OnRemoveItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnRemoveItem, RemovedItem) == 0x000008, "Member 'HUDUserWidget_OnRemoveItem::RemovedItem' has a wrong offset!");

// Function man.HUDUserWidget.OnRemoveQuestNotification
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnRemoveQuestNotification final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnRemoveQuestNotification) == 0x000008, "Wrong alignment on HUDUserWidget_OnRemoveQuestNotification");
static_assert(sizeof(HUDUserWidget_OnRemoveQuestNotification) == 0x000008, "Wrong size on HUDUserWidget_OnRemoveQuestNotification");
static_assert(offsetof(HUDUserWidget_OnRemoveQuestNotification, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnRemoveQuestNotification::ManQuest' has a wrong offset!");

// Function man.HUDUserWidget.OnSetAbilitiesAndResourcesDownPosition
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition final
{
public:
	bool                                          bDownPosition;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition) == 0x000001, "Wrong alignment on HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition");
static_assert(sizeof(HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition) == 0x000001, "Wrong size on HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition");
static_assert(offsetof(HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition, bDownPosition) == 0x000000, "Member 'HUDUserWidget_OnSetAbilitiesAndResourcesDownPosition::bDownPosition' has a wrong offset!");

// Function man.HUDUserWidget.OnSetBossBar
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_OnSetBossBar final
{
public:
	EHUDBarType                                   HUDBarType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMiniBoss;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwoStageBossBar;                                  // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMandragora;                                       // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetBossBar) == 0x000001, "Wrong alignment on HUDUserWidget_OnSetBossBar");
static_assert(sizeof(HUDUserWidget_OnSetBossBar) == 0x000004, "Wrong size on HUDUserWidget_OnSetBossBar");
static_assert(offsetof(HUDUserWidget_OnSetBossBar, HUDBarType) == 0x000000, "Member 'HUDUserWidget_OnSetBossBar::HUDBarType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetBossBar, bMiniBoss) == 0x000001, "Member 'HUDUserWidget_OnSetBossBar::bMiniBoss' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetBossBar, bTwoStageBossBar) == 0x000002, "Member 'HUDUserWidget_OnSetBossBar::bTwoStageBossBar' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetBossBar, bMandragora) == 0x000003, "Member 'HUDUserWidget_OnSetBossBar::bMandragora' has a wrong offset!");

// Function man.HUDUserWidget.OnSetComboPoint
// 0x000C (0x000C - 0x0000)
struct HUDUserWidget_OnSetComboPoint final
{
public:
	int32                                         CurrentComboPointFraction;                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentComboPoint;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxComboPoint;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetComboPoint) == 0x000004, "Wrong alignment on HUDUserWidget_OnSetComboPoint");
static_assert(sizeof(HUDUserWidget_OnSetComboPoint) == 0x00000C, "Wrong size on HUDUserWidget_OnSetComboPoint");
static_assert(offsetof(HUDUserWidget_OnSetComboPoint, CurrentComboPointFraction) == 0x000000, "Member 'HUDUserWidget_OnSetComboPoint::CurrentComboPointFraction' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetComboPoint, CurrentComboPoint) == 0x000004, "Member 'HUDUserWidget_OnSetComboPoint::CurrentComboPoint' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetComboPoint, MaxComboPoint) == 0x000008, "Member 'HUDUserWidget_OnSetComboPoint::MaxComboPoint' has a wrong offset!");

// Function man.HUDUserWidget.OnSetFadeQuestTrackerBackgroundVisible
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible) == 0x000001, "Wrong alignment on HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible");
static_assert(sizeof(HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible) == 0x000001, "Wrong size on HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible");
static_assert(offsetof(HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible, bInVisible) == 0x000000, "Member 'HUDUserWidget_OnSetFadeQuestTrackerBackgroundVisible::bInVisible' has a wrong offset!");

// Function man.HUDUserWidget.OnSetHUDBar
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnSetHUDBar final
{
public:
	EHUDBarType                                   HUDBarType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentValue;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetHUDBar) == 0x000004, "Wrong alignment on HUDUserWidget_OnSetHUDBar");
static_assert(sizeof(HUDUserWidget_OnSetHUDBar) == 0x000008, "Wrong size on HUDUserWidget_OnSetHUDBar");
static_assert(offsetof(HUDUserWidget_OnSetHUDBar, HUDBarType) == 0x000000, "Member 'HUDUserWidget_OnSetHUDBar::HUDBarType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetHUDBar, CurrentValue) == 0x000004, "Member 'HUDUserWidget_OnSetHUDBar::CurrentValue' has a wrong offset!");

// Function man.HUDUserWidget.OnSetInteractMode
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnSetInteractMode final
{
public:
	bool                                          bInCanInteract;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetInteractMode) == 0x000001, "Wrong alignment on HUDUserWidget_OnSetInteractMode");
static_assert(sizeof(HUDUserWidget_OnSetInteractMode) == 0x000001, "Wrong size on HUDUserWidget_OnSetInteractMode");
static_assert(offsetof(HUDUserWidget_OnSetInteractMode, bInCanInteract) == 0x000000, "Member 'HUDUserWidget_OnSetInteractMode::bInCanInteract' has a wrong offset!");

// Function man.HUDUserWidget.OnSetLevelProgress
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_OnSetLevelProgress final
{
public:
	float                                         LevelProgress;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetLevelProgress) == 0x000004, "Wrong alignment on HUDUserWidget_OnSetLevelProgress");
static_assert(sizeof(HUDUserWidget_OnSetLevelProgress) == 0x000004, "Wrong size on HUDUserWidget_OnSetLevelProgress");
static_assert(offsetof(HUDUserWidget_OnSetLevelProgress, LevelProgress) == 0x000000, "Member 'HUDUserWidget_OnSetLevelProgress::LevelProgress' has a wrong offset!");

// Function man.HUDUserWidget.OnSetLevelPulseAnim
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnSetLevelPulseAnim final
{
public:
	bool                                          bPlay;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetLevelPulseAnim) == 0x000001, "Wrong alignment on HUDUserWidget_OnSetLevelPulseAnim");
static_assert(sizeof(HUDUserWidget_OnSetLevelPulseAnim) == 0x000001, "Wrong size on HUDUserWidget_OnSetLevelPulseAnim");
static_assert(offsetof(HUDUserWidget_OnSetLevelPulseAnim, bPlay) == 0x000000, "Member 'HUDUserWidget_OnSetLevelPulseAnim::bPlay' has a wrong offset!");

// Function man.HUDUserWidget.OnSetLightBarrier
// 0x000C (0x000C - 0x0000)
struct HUDUserWidget_OnSetLightBarrier final
{
public:
	EHUDBarType                                   HUDBarType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightBarrierCurrentValue;                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightBarrierMaxValue;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetLightBarrier) == 0x000004, "Wrong alignment on HUDUserWidget_OnSetLightBarrier");
static_assert(sizeof(HUDUserWidget_OnSetLightBarrier) == 0x00000C, "Wrong size on HUDUserWidget_OnSetLightBarrier");
static_assert(offsetof(HUDUserWidget_OnSetLightBarrier, HUDBarType) == 0x000000, "Member 'HUDUserWidget_OnSetLightBarrier::HUDBarType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetLightBarrier, LightBarrierCurrentValue) == 0x000004, "Member 'HUDUserWidget_OnSetLightBarrier::LightBarrierCurrentValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetLightBarrier, LightBarrierMaxValue) == 0x000008, "Member 'HUDUserWidget_OnSetLightBarrier::LightBarrierMaxValue' has a wrong offset!");

// Function man.HUDUserWidget.OnSetWarningText
// 0x0020 (0x0020 - 0x0000)
struct HUDUserWidget_OnSetWarningText final
{
public:
	bool                                          bInShow;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InWarningText;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSetWarningText) == 0x000008, "Wrong alignment on HUDUserWidget_OnSetWarningText");
static_assert(sizeof(HUDUserWidget_OnSetWarningText) == 0x000020, "Wrong size on HUDUserWidget_OnSetWarningText");
static_assert(offsetof(HUDUserWidget_OnSetWarningText, bInShow) == 0x000000, "Member 'HUDUserWidget_OnSetWarningText::bInShow' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnSetWarningText, InWarningText) == 0x000008, "Member 'HUDUserWidget_OnSetWarningText::InWarningText' has a wrong offset!");

// Function man.HUDUserWidget.OnShowBestiaryUpdatedNotification
// 0x0004 (0x0004 - 0x0000)
struct HUDUserWidget_OnShowBestiaryUpdatedNotification final
{
public:
	float                                         Timeout;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnShowBestiaryUpdatedNotification) == 0x000004, "Wrong alignment on HUDUserWidget_OnShowBestiaryUpdatedNotification");
static_assert(sizeof(HUDUserWidget_OnShowBestiaryUpdatedNotification) == 0x000004, "Wrong size on HUDUserWidget_OnShowBestiaryUpdatedNotification");
static_assert(offsetof(HUDUserWidget_OnShowBestiaryUpdatedNotification, Timeout) == 0x000000, "Member 'HUDUserWidget_OnShowBestiaryUpdatedNotification::Timeout' has a wrong offset!");

// Function man.HUDUserWidget.OnShowHUDBar
// 0x0038 (0x0038 - 0x0000)
struct HUDUserWidget_OnShowHUDBar final
{
public:
	EHUDBarType                                   HUDBarType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HudBarTitle;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferencePointValue;                               // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthRatio;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnShowHUDBar) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowHUDBar");
static_assert(sizeof(HUDUserWidget_OnShowHUDBar) == 0x000038, "Wrong size on HUDUserWidget_OnShowHUDBar");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, HUDBarType) == 0x000000, "Member 'HUDUserWidget_OnShowHUDBar::HUDBarType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, HudBarTitle) == 0x000008, "Member 'HUDUserWidget_OnShowHUDBar::HudBarTitle' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, MinValue) == 0x000020, "Member 'HUDUserWidget_OnShowHUDBar::MinValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, MaxValue) == 0x000024, "Member 'HUDUserWidget_OnShowHUDBar::MaxValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, CurrentValue) == 0x000028, "Member 'HUDUserWidget_OnShowHUDBar::CurrentValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, ReferencePointValue) == 0x00002C, "Member 'HUDUserWidget_OnShowHUDBar::ReferencePointValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowHUDBar, LengthRatio) == 0x000030, "Member 'HUDUserWidget_OnShowHUDBar::LengthRatio' has a wrong offset!");

// Function man.HUDUserWidget.OnShowHUDPopup
// 0x0058 (0x0058 - 0x0000)
struct HUDUserWidget_OnShowHUDPopup final
{
public:
	struct FHUDPopupQueue                         HUDPopupQueue;                                     // 0x0000(0x0058)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnShowHUDPopup) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowHUDPopup");
static_assert(sizeof(HUDUserWidget_OnShowHUDPopup) == 0x000058, "Wrong size on HUDUserWidget_OnShowHUDPopup");
static_assert(offsetof(HUDUserWidget_OnShowHUDPopup, HUDPopupQueue) == 0x000000, "Member 'HUDUserWidget_OnShowHUDPopup::HUDPopupQueue' has a wrong offset!");

// Function man.HUDUserWidget.OnShowInteract
// 0x0020 (0x0020 - 0x0000)
struct HUDUserWidget_OnShowInteract final
{
public:
	class FText                                   InInteractText;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UAbilityBase*                           InAbilityBase;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnShowInteract) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowInteract");
static_assert(sizeof(HUDUserWidget_OnShowInteract) == 0x000020, "Wrong size on HUDUserWidget_OnShowInteract");
static_assert(offsetof(HUDUserWidget_OnShowInteract, InInteractText) == 0x000000, "Member 'HUDUserWidget_OnShowInteract::InInteractText' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowInteract, InAbilityBase) == 0x000018, "Member 'HUDUserWidget_OnShowInteract::InAbilityBase' has a wrong offset!");

// Function man.HUDUserWidget.OnShowPickupNotification
// 0x0058 (0x0058 - 0x0000)
struct HUDUserWidget_OnShowPickupNotification final
{
public:
	class UHUDNotificationUserWidget*             HUDNotificationUserWidget;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0020(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ItemAbility;                                       // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideNewItemTitle;                                 // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnShowPickupNotification) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowPickupNotification");
static_assert(sizeof(HUDUserWidget_OnShowPickupNotification) == 0x000058, "Wrong size on HUDUserWidget_OnShowPickupNotification");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, HUDNotificationUserWidget) == 0x000000, "Member 'HUDUserWidget_OnShowPickupNotification::HUDNotificationUserWidget' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, ItemName) == 0x000008, "Member 'HUDUserWidget_OnShowPickupNotification::ItemName' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, ItemDescription) == 0x000020, "Member 'HUDUserWidget_OnShowPickupNotification::ItemDescription' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, Icon) == 0x000038, "Member 'HUDUserWidget_OnShowPickupNotification::Icon' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, Timeout) == 0x000040, "Member 'HUDUserWidget_OnShowPickupNotification::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, Number) == 0x000044, "Member 'HUDUserWidget_OnShowPickupNotification::Number' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, ItemAbility) == 0x000048, "Member 'HUDUserWidget_OnShowPickupNotification::ItemAbility' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowPickupNotification, bHideNewItemTitle) == 0x000050, "Member 'HUDUserWidget_OnShowPickupNotification::bHideNewItemTitle' has a wrong offset!");

// Function man.HUDUserWidget.OnShowQuestNotification
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnShowQuestNotification final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UManQuestObjective*>             Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnShowQuestNotification) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowQuestNotification");
static_assert(sizeof(HUDUserWidget_OnShowQuestNotification) == 0x000018, "Wrong size on HUDUserWidget_OnShowQuestNotification");
static_assert(offsetof(HUDUserWidget_OnShowQuestNotification, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnShowQuestNotification::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowQuestNotification, Objectives) == 0x000008, "Member 'HUDUserWidget_OnShowQuestNotification::Objectives' has a wrong offset!");

// Function man.HUDUserWidget.OnShowUseItemNotification
// 0x0030 (0x0030 - 0x0000)
struct HUDUserWidget_OnShowUseItemNotification final
{
public:
	class UHUDNotificationUserWidget*             HUDNotificationUserWidget;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnShowUseItemNotification) == 0x000008, "Wrong alignment on HUDUserWidget_OnShowUseItemNotification");
static_assert(sizeof(HUDUserWidget_OnShowUseItemNotification) == 0x000030, "Wrong size on HUDUserWidget_OnShowUseItemNotification");
static_assert(offsetof(HUDUserWidget_OnShowUseItemNotification, HUDNotificationUserWidget) == 0x000000, "Member 'HUDUserWidget_OnShowUseItemNotification::HUDNotificationUserWidget' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowUseItemNotification, ItemName) == 0x000008, "Member 'HUDUserWidget_OnShowUseItemNotification::ItemName' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowUseItemNotification, Icon) == 0x000020, "Member 'HUDUserWidget_OnShowUseItemNotification::Icon' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowUseItemNotification, Timeout) == 0x000028, "Member 'HUDUserWidget_OnShowUseItemNotification::Timeout' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnShowUseItemNotification, Number) == 0x00002C, "Member 'HUDUserWidget_OnShowUseItemNotification::Number' has a wrong offset!");

// Function man.HUDUserWidget.OnSpecialMovementUlnocked
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnSpecialMovementUlnocked final
{
public:
	ESpecialMovementType                          SpecialMovementType;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnSpecialMovementUlnocked) == 0x000001, "Wrong alignment on HUDUserWidget_OnSpecialMovementUlnocked");
static_assert(sizeof(HUDUserWidget_OnSpecialMovementUlnocked) == 0x000001, "Wrong size on HUDUserWidget_OnSpecialMovementUlnocked");
static_assert(offsetof(HUDUserWidget_OnSpecialMovementUlnocked, SpecialMovementType) == 0x000000, "Member 'HUDUserWidget_OnSpecialMovementUlnocked::SpecialMovementType' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleAddedResource
// 0x000C (0x000C - 0x0000)
struct HUDUserWidget_OnToggleAddedResource final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowing;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_OnToggleAddedResource) == 0x000004, "Wrong alignment on HUDUserWidget_OnToggleAddedResource");
static_assert(sizeof(HUDUserWidget_OnToggleAddedResource) == 0x00000C, "Wrong size on HUDUserWidget_OnToggleAddedResource");
static_assert(offsetof(HUDUserWidget_OnToggleAddedResource, PropertyType) == 0x000000, "Member 'HUDUserWidget_OnToggleAddedResource::PropertyType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnToggleAddedResource, Value) == 0x000004, "Member 'HUDUserWidget_OnToggleAddedResource::Value' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnToggleAddedResource, bShowing) == 0x000008, "Member 'HUDUserWidget_OnToggleAddedResource::bShowing' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnToggleAddedResource, bAnimate) == 0x000009, "Member 'HUDUserWidget_OnToggleAddedResource::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleExtraLanternDrainEffect
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnToggleExtraLanternDrainEffect final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnToggleExtraLanternDrainEffect) == 0x000001, "Wrong alignment on HUDUserWidget_OnToggleExtraLanternDrainEffect");
static_assert(sizeof(HUDUserWidget_OnToggleExtraLanternDrainEffect) == 0x000001, "Wrong size on HUDUserWidget_OnToggleExtraLanternDrainEffect");
static_assert(offsetof(HUDUserWidget_OnToggleExtraLanternDrainEffect, bActive) == 0x000000, "Member 'HUDUserWidget_OnToggleExtraLanternDrainEffect::bActive' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleLowHPBarWarning
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnToggleLowHPBarWarning final
{
public:
	bool                                          bIsHPLow;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnToggleLowHPBarWarning) == 0x000001, "Wrong alignment on HUDUserWidget_OnToggleLowHPBarWarning");
static_assert(sizeof(HUDUserWidget_OnToggleLowHPBarWarning) == 0x000001, "Wrong size on HUDUserWidget_OnToggleLowHPBarWarning");
static_assert(offsetof(HUDUserWidget_OnToggleLowHPBarWarning, bIsHPLow) == 0x000000, "Member 'HUDUserWidget_OnToggleLowHPBarWarning::bIsHPLow' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleLowLifeAuraWarning
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnToggleLowLifeAuraWarning final
{
public:
	bool                                          bIsBelowZero;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnToggleLowLifeAuraWarning) == 0x000001, "Wrong alignment on HUDUserWidget_OnToggleLowLifeAuraWarning");
static_assert(sizeof(HUDUserWidget_OnToggleLowLifeAuraWarning) == 0x000001, "Wrong size on HUDUserWidget_OnToggleLowLifeAuraWarning");
static_assert(offsetof(HUDUserWidget_OnToggleLowLifeAuraWarning, bIsBelowZero) == 0x000000, "Member 'HUDUserWidget_OnToggleLowLifeAuraWarning::bIsBelowZero' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleResourceBarPosition
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_OnToggleResourceBarPosition final
{
public:
	bool                                          bDownPosition;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnToggleResourceBarPosition) == 0x000001, "Wrong alignment on HUDUserWidget_OnToggleResourceBarPosition");
static_assert(sizeof(HUDUserWidget_OnToggleResourceBarPosition) == 0x000001, "Wrong size on HUDUserWidget_OnToggleResourceBarPosition");
static_assert(offsetof(HUDUserWidget_OnToggleResourceBarPosition, bDownPosition) == 0x000000, "Member 'HUDUserWidget_OnToggleResourceBarPosition::bDownPosition' has a wrong offset!");

// Function man.HUDUserWidget.OnToggleSideEffectWarning
// 0x0003 (0x0003 - 0x0000)
struct HUDUserWidget_OnToggleSideEffectWarning final
{
public:
	EScreenSideEffect                             Effect;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESideEffectWarningType                        SideEffectWarningType;                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnToggleSideEffectWarning) == 0x000001, "Wrong alignment on HUDUserWidget_OnToggleSideEffectWarning");
static_assert(sizeof(HUDUserWidget_OnToggleSideEffectWarning) == 0x000003, "Wrong size on HUDUserWidget_OnToggleSideEffectWarning");
static_assert(offsetof(HUDUserWidget_OnToggleSideEffectWarning, Effect) == 0x000000, "Member 'HUDUserWidget_OnToggleSideEffectWarning::Effect' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnToggleSideEffectWarning, bActive) == 0x000001, "Member 'HUDUserWidget_OnToggleSideEffectWarning::bActive' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnToggleSideEffectWarning, SideEffectWarningType) == 0x000002, "Member 'HUDUserWidget_OnToggleSideEffectWarning::SideEffectWarningType' has a wrong offset!");

// Function man.HUDUserWidget.OnUpdateItem
// 0x0008 (0x0008 - 0x0000)
struct HUDUserWidget_OnUpdateItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnUpdateItem) == 0x000008, "Wrong alignment on HUDUserWidget_OnUpdateItem");
static_assert(sizeof(HUDUserWidget_OnUpdateItem) == 0x000008, "Wrong size on HUDUserWidget_OnUpdateItem");
static_assert(offsetof(HUDUserWidget_OnUpdateItem, InventorySlot) == 0x000000, "Member 'HUDUserWidget_OnUpdateItem::InventorySlot' has a wrong offset!");

// Function man.HUDUserWidget.OnUpdateQuestNotificationObjective
// 0x0018 (0x0018 - 0x0000)
struct HUDUserWidget_OnUpdateQuestNotificationObjective final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UManQuestObjective*>             Objectives;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_OnUpdateQuestNotificationObjective) == 0x000008, "Wrong alignment on HUDUserWidget_OnUpdateQuestNotificationObjective");
static_assert(sizeof(HUDUserWidget_OnUpdateQuestNotificationObjective) == 0x000018, "Wrong size on HUDUserWidget_OnUpdateQuestNotificationObjective");
static_assert(offsetof(HUDUserWidget_OnUpdateQuestNotificationObjective, ManQuest) == 0x000000, "Member 'HUDUserWidget_OnUpdateQuestNotificationObjective::ManQuest' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_OnUpdateQuestNotificationObjective, Objectives) == 0x000008, "Member 'HUDUserWidget_OnUpdateQuestNotificationObjective::Objectives' has a wrong offset!");

// Function man.HUDUserWidget.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct HUDUserWidget_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDUserWidget_PropertyChanged) == 0x000004, "Wrong alignment on HUDUserWidget_PropertyChanged");
static_assert(sizeof(HUDUserWidget_PropertyChanged) == 0x000014, "Wrong size on HUDUserWidget_PropertyChanged");
static_assert(offsetof(HUDUserWidget_PropertyChanged, PropertyType) == 0x000000, "Member 'HUDUserWidget_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_PropertyChanged, Value) == 0x000004, "Member 'HUDUserWidget_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'HUDUserWidget_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'HUDUserWidget_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_PropertyChanged, bAnimate) == 0x000010, "Member 'HUDUserWidget_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.HUDUserWidget.SetInteractAbility
// 0x0038 (0x0038 - 0x0000)
struct HUDUserWidget_SetInteractAbility final
{
public:
	class UAbilityBase*                           InInteractAbilityBase;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractParams                        ReturnValue;                                       // 0x0008(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_SetInteractAbility) == 0x000008, "Wrong alignment on HUDUserWidget_SetInteractAbility");
static_assert(sizeof(HUDUserWidget_SetInteractAbility) == 0x000038, "Wrong size on HUDUserWidget_SetInteractAbility");
static_assert(offsetof(HUDUserWidget_SetInteractAbility, InInteractAbilityBase) == 0x000000, "Member 'HUDUserWidget_SetInteractAbility::InInteractAbilityBase' has a wrong offset!");
static_assert(offsetof(HUDUserWidget_SetInteractAbility, ReturnValue) == 0x000008, "Member 'HUDUserWidget_SetInteractAbility::ReturnValue' has a wrong offset!");

// Function man.HUDUserWidget.CanInteractInCombat
// 0x0001 (0x0001 - 0x0000)
struct HUDUserWidget_CanInteractInCombat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDUserWidget_CanInteractInCombat) == 0x000001, "Wrong alignment on HUDUserWidget_CanInteractInCombat");
static_assert(sizeof(HUDUserWidget_CanInteractInCombat) == 0x000001, "Wrong size on HUDUserWidget_CanInteractInCombat");
static_assert(offsetof(HUDUserWidget_CanInteractInCombat, ReturnValue) == 0x000000, "Member 'HUDUserWidget_CanInteractInCombat::ReturnValue' has a wrong offset!");

// Function man.QuestWindowUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct QuestWindowUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestWindowUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on QuestWindowUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(QuestWindowUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on QuestWindowUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(QuestWindowUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'QuestWindowUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(QuestWindowUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'QuestWindowUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.QuestWindowUserWidget.OnRebuildQuestList
// 0x000C (0x000C - 0x0000)
struct QuestWindowUserWidget_OnRebuildQuestList final
{
public:
	int32                                         InVisibleActiveQuestNum;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InVisibleBountyQuestNum;                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InVisibleCompletedQuestNum;                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestWindowUserWidget_OnRebuildQuestList) == 0x000004, "Wrong alignment on QuestWindowUserWidget_OnRebuildQuestList");
static_assert(sizeof(QuestWindowUserWidget_OnRebuildQuestList) == 0x00000C, "Wrong size on QuestWindowUserWidget_OnRebuildQuestList");
static_assert(offsetof(QuestWindowUserWidget_OnRebuildQuestList, InVisibleActiveQuestNum) == 0x000000, "Member 'QuestWindowUserWidget_OnRebuildQuestList::InVisibleActiveQuestNum' has a wrong offset!");
static_assert(offsetof(QuestWindowUserWidget_OnRebuildQuestList, InVisibleBountyQuestNum) == 0x000004, "Member 'QuestWindowUserWidget_OnRebuildQuestList::InVisibleBountyQuestNum' has a wrong offset!");
static_assert(offsetof(QuestWindowUserWidget_OnRebuildQuestList, InVisibleCompletedQuestNum) == 0x000008, "Member 'QuestWindowUserWidget_OnRebuildQuestList::InVisibleCompletedQuestNum' has a wrong offset!");

// Function man.QuestWindowUserWidget.OnSetSelectedQuest
// 0x0020 (0x0020 - 0x0000)
struct QuestWindowUserWidget_OnSetSelectedQuest final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StoryText;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestWindowUserWidget_OnSetSelectedQuest) == 0x000008, "Wrong alignment on QuestWindowUserWidget_OnSetSelectedQuest");
static_assert(sizeof(QuestWindowUserWidget_OnSetSelectedQuest) == 0x000020, "Wrong size on QuestWindowUserWidget_OnSetSelectedQuest");
static_assert(offsetof(QuestWindowUserWidget_OnSetSelectedQuest, ManQuest) == 0x000000, "Member 'QuestWindowUserWidget_OnSetSelectedQuest::ManQuest' has a wrong offset!");
static_assert(offsetof(QuestWindowUserWidget_OnSetSelectedQuest, StoryText) == 0x000008, "Member 'QuestWindowUserWidget_OnSetSelectedQuest::StoryText' has a wrong offset!");

// Function man.EscapeJumpAbility.OnPostDamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct EscapeJumpAbility_OnPostDamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EscapeJumpAbility_OnPostDamageTaken) == 0x000008, "Wrong alignment on EscapeJumpAbility_OnPostDamageTaken");
static_assert(sizeof(EscapeJumpAbility_OnPostDamageTaken) == 0x0002D8, "Wrong size on EscapeJumpAbility_OnPostDamageTaken");
static_assert(offsetof(EscapeJumpAbility_OnPostDamageTaken, DamageParams) == 0x000000, "Member 'EscapeJumpAbility_OnPostDamageTaken::DamageParams' has a wrong offset!");

// Function man.GlideAbility.OnGlideEndRecoveryEnded
// 0x0008 (0x0008 - 0x0000)
struct GlideAbility_OnGlideEndRecoveryEnded final
{
public:
	class UAbilityBase*                           RecoveryAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlideAbility_OnGlideEndRecoveryEnded) == 0x000008, "Wrong alignment on GlideAbility_OnGlideEndRecoveryEnded");
static_assert(sizeof(GlideAbility_OnGlideEndRecoveryEnded) == 0x000008, "Wrong size on GlideAbility_OnGlideEndRecoveryEnded");
static_assert(offsetof(GlideAbility_OnGlideEndRecoveryEnded, RecoveryAbility) == 0x000000, "Member 'GlideAbility_OnGlideEndRecoveryEnded::RecoveryAbility' has a wrong offset!");

// Function man.KillingMachinePassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct KillingMachinePassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillingMachinePassive_DamageDealt) == 0x000008, "Wrong alignment on KillingMachinePassive_DamageDealt");
static_assert(sizeof(KillingMachinePassive_DamageDealt) == 0x0002D8, "Wrong size on KillingMachinePassive_DamageDealt");
static_assert(offsetof(KillingMachinePassive_DamageDealt, Param) == 0x000000, "Member 'KillingMachinePassive_DamageDealt::Param' has a wrong offset!");

// Function man.StaminaDrain.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct StaminaDrain_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaminaDrain_IsCollideSignature) == 0x000008, "Wrong alignment on StaminaDrain_IsCollideSignature");
static_assert(sizeof(StaminaDrain_IsCollideSignature) == 0x000010, "Wrong size on StaminaDrain_IsCollideSignature");
static_assert(offsetof(StaminaDrain_IsCollideSignature, Actor) == 0x000000, "Member 'StaminaDrain_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(StaminaDrain_IsCollideSignature, bOverride) == 0x000008, "Member 'StaminaDrain_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(StaminaDrain_IsCollideSignature, bCollide) == 0x000009, "Member 'StaminaDrain_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.GlossarySlotUserWidget.OnSetSeparatorVisible
// 0x0001 (0x0001 - 0x0000)
struct GlossarySlotUserWidget_OnSetSeparatorVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlossarySlotUserWidget_OnSetSeparatorVisible) == 0x000001, "Wrong alignment on GlossarySlotUserWidget_OnSetSeparatorVisible");
static_assert(sizeof(GlossarySlotUserWidget_OnSetSeparatorVisible) == 0x000001, "Wrong size on GlossarySlotUserWidget_OnSetSeparatorVisible");
static_assert(offsetof(GlossarySlotUserWidget_OnSetSeparatorVisible, bInVisible) == 0x000000, "Member 'GlossarySlotUserWidget_OnSetSeparatorVisible::bInVisible' has a wrong offset!");

// Function man.GlossarySlotUserWidget.OnSetSlot
// 0x0030 (0x0030 - 0x0000)
struct GlossarySlotUserWidget_OnSetSlot final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDescription;                                     // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlossarySlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on GlossarySlotUserWidget_OnSetSlot");
static_assert(sizeof(GlossarySlotUserWidget_OnSetSlot) == 0x000030, "Wrong size on GlossarySlotUserWidget_OnSetSlot");
static_assert(offsetof(GlossarySlotUserWidget_OnSetSlot, InName) == 0x000000, "Member 'GlossarySlotUserWidget_OnSetSlot::InName' has a wrong offset!");
static_assert(offsetof(GlossarySlotUserWidget_OnSetSlot, InDescription) == 0x000018, "Member 'GlossarySlotUserWidget_OnSetSlot::InDescription' has a wrong offset!");

// Function man.GlossaryUserWidget.OnMapShowing
// 0x0001 (0x0001 - 0x0000)
struct GlossaryUserWidget_OnMapShowing final
{
public:
	bool                                          bInMapShowing;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlossaryUserWidget_OnMapShowing) == 0x000001, "Wrong alignment on GlossaryUserWidget_OnMapShowing");
static_assert(sizeof(GlossaryUserWidget_OnMapShowing) == 0x000001, "Wrong size on GlossaryUserWidget_OnMapShowing");
static_assert(offsetof(GlossaryUserWidget_OnMapShowing, bInMapShowing) == 0x000000, "Member 'GlossaryUserWidget_OnMapShowing::bInMapShowing' has a wrong offset!");

// Function man.GlossaryUserWidget.OnPageReady
// 0x000C (0x000C - 0x0000)
struct GlossaryUserWidget_OnPageReady final
{
public:
	int32                                         InPageNumberLeft;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPageNumberRight;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRightPageEmpty;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GlossaryUserWidget_OnPageReady) == 0x000004, "Wrong alignment on GlossaryUserWidget_OnPageReady");
static_assert(sizeof(GlossaryUserWidget_OnPageReady) == 0x00000C, "Wrong size on GlossaryUserWidget_OnPageReady");
static_assert(offsetof(GlossaryUserWidget_OnPageReady, InPageNumberLeft) == 0x000000, "Member 'GlossaryUserWidget_OnPageReady::InPageNumberLeft' has a wrong offset!");
static_assert(offsetof(GlossaryUserWidget_OnPageReady, InPageNumberRight) == 0x000004, "Member 'GlossaryUserWidget_OnPageReady::InPageNumberRight' has a wrong offset!");
static_assert(offsetof(GlossaryUserWidget_OnPageReady, bInRightPageEmpty) == 0x000008, "Member 'GlossaryUserWidget_OnPageReady::bInRightPageEmpty' has a wrong offset!");

// Function man.GlossaryUserWidget.OnSetNextBtnState
// 0x0001 (0x0001 - 0x0000)
struct GlossaryUserWidget_OnSetNextBtnState final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlossaryUserWidget_OnSetNextBtnState) == 0x000001, "Wrong alignment on GlossaryUserWidget_OnSetNextBtnState");
static_assert(sizeof(GlossaryUserWidget_OnSetNextBtnState) == 0x000001, "Wrong size on GlossaryUserWidget_OnSetNextBtnState");
static_assert(offsetof(GlossaryUserWidget_OnSetNextBtnState, bInEnabled) == 0x000000, "Member 'GlossaryUserWidget_OnSetNextBtnState::bInEnabled' has a wrong offset!");

// Function man.GlossaryUserWidget.OnSetPrevBtnState
// 0x0001 (0x0001 - 0x0000)
struct GlossaryUserWidget_OnSetPrevBtnState final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GlossaryUserWidget_OnSetPrevBtnState) == 0x000001, "Wrong alignment on GlossaryUserWidget_OnSetPrevBtnState");
static_assert(sizeof(GlossaryUserWidget_OnSetPrevBtnState) == 0x000001, "Wrong size on GlossaryUserWidget_OnSetPrevBtnState");
static_assert(offsetof(GlossaryUserWidget_OnSetPrevBtnState, bInEnabled) == 0x000000, "Member 'GlossaryUserWidget_OnSetPrevBtnState::bInEnabled' has a wrong offset!");

// Function man.GrapplingHook.DamageTaken
// 0x02D8 (0x02D8 - 0x0000)
struct GrapplingHook_DamageTaken final
{
public:
	struct FPreDamagedEventParam                  DamageParams;                                      // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrapplingHook_DamageTaken) == 0x000008, "Wrong alignment on GrapplingHook_DamageTaken");
static_assert(sizeof(GrapplingHook_DamageTaken) == 0x0002D8, "Wrong size on GrapplingHook_DamageTaken");
static_assert(offsetof(GrapplingHook_DamageTaken, DamageParams) == 0x000000, "Member 'GrapplingHook_DamageTaken::DamageParams' has a wrong offset!");

// Function man.GrapplingHook.OnCollision
// 0x0010 (0x0010 - 0x0000)
struct GrapplingHook_OnCollision final
{
public:
	TArray<struct FHitResult>                     HitResult;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GrapplingHook_OnCollision) == 0x000008, "Wrong alignment on GrapplingHook_OnCollision");
static_assert(sizeof(GrapplingHook_OnCollision) == 0x000010, "Wrong size on GrapplingHook_OnCollision");
static_assert(offsetof(GrapplingHook_OnCollision, HitResult) == 0x000000, "Member 'GrapplingHook_OnCollision::HitResult' has a wrong offset!");

// Function man.ResonanceAbility.GetCurrentCharge
// 0x0004 (0x0004 - 0x0000)
struct ResonanceAbility_GetCurrentCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ResonanceAbility_GetCurrentCharge) == 0x000004, "Wrong alignment on ResonanceAbility_GetCurrentCharge");
static_assert(sizeof(ResonanceAbility_GetCurrentCharge) == 0x000004, "Wrong size on ResonanceAbility_GetCurrentCharge");
static_assert(offsetof(ResonanceAbility_GetCurrentCharge, ReturnValue) == 0x000000, "Member 'ResonanceAbility_GetCurrentCharge::ReturnValue' has a wrong offset!");

// Function man.ResonanceAbility.GetMaxCharge
// 0x0004 (0x0004 - 0x0000)
struct ResonanceAbility_GetMaxCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ResonanceAbility_GetMaxCharge) == 0x000004, "Wrong alignment on ResonanceAbility_GetMaxCharge");
static_assert(sizeof(ResonanceAbility_GetMaxCharge) == 0x000004, "Wrong size on ResonanceAbility_GetMaxCharge");
static_assert(offsetof(ResonanceAbility_GetMaxCharge, ReturnValue) == 0x000000, "Member 'ResonanceAbility_GetMaxCharge::ReturnValue' has a wrong offset!");

// Function man.ResonanceAbility.ResourceUsed
// 0x0010 (0x0010 - 0x0000)
struct ResonanceAbility_ResourceUsed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ResonanceAbility_ResourceUsed) == 0x000008, "Wrong alignment on ResonanceAbility_ResourceUsed");
static_assert(sizeof(ResonanceAbility_ResourceUsed) == 0x000010, "Wrong size on ResonanceAbility_ResourceUsed");
static_assert(offsetof(ResonanceAbility_ResourceUsed, resource) == 0x000000, "Member 'ResonanceAbility_ResourceUsed::resource' has a wrong offset!");
static_assert(offsetof(ResonanceAbility_ResourceUsed, amount) == 0x000004, "Member 'ResonanceAbility_ResourceUsed::amount' has a wrong offset!");
static_assert(offsetof(ResonanceAbility_ResourceUsed, Ability) == 0x000008, "Member 'ResonanceAbility_ResourceUsed::Ability' has a wrong offset!");

// Function man.RebirthAbility.OnPreGoToLevel
// 0x0010 (0x0010 - 0x0000)
struct RebirthAbility_OnPreGoToLevel final
{
public:
	class FString                                 StrLevelName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RebirthAbility_OnPreGoToLevel) == 0x000008, "Wrong alignment on RebirthAbility_OnPreGoToLevel");
static_assert(sizeof(RebirthAbility_OnPreGoToLevel) == 0x000010, "Wrong size on RebirthAbility_OnPreGoToLevel");
static_assert(offsetof(RebirthAbility_OnPreGoToLevel, StrLevelName) == 0x000000, "Member 'RebirthAbility_OnPreGoToLevel::StrLevelName' has a wrong offset!");

// Function man.GremlinShield.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct GremlinShield_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GremlinShield_OnPreDamagedPriority) == 0x000008, "Wrong alignment on GremlinShield_OnPreDamagedPriority");
static_assert(sizeof(GremlinShield_OnPreDamagedPriority) == 0x0002D8, "Wrong size on GremlinShield_OnPreDamagedPriority");
static_assert(offsetof(GremlinShield_OnPreDamagedPriority, Param) == 0x000000, "Member 'GremlinShield_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.VampireBeastSwoopAbility.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct VampireBeastSwoopAbility_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireBeastSwoopAbility_BPGetTargetLocation) == 0x000004, "Wrong alignment on VampireBeastSwoopAbility_BPGetTargetLocation");
static_assert(sizeof(VampireBeastSwoopAbility_BPGetTargetLocation) == 0x00000C, "Wrong size on VampireBeastSwoopAbility_BPGetTargetLocation");
static_assert(offsetof(VampireBeastSwoopAbility_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'VampireBeastSwoopAbility_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.GroundMove.IsRunSpeed
// 0x0001 (0x0001 - 0x0000)
struct GroundMove_IsRunSpeed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMove_IsRunSpeed) == 0x000001, "Wrong alignment on GroundMove_IsRunSpeed");
static_assert(sizeof(GroundMove_IsRunSpeed) == 0x000001, "Wrong size on GroundMove_IsRunSpeed");
static_assert(offsetof(GroundMove_IsRunSpeed, ReturnValue) == 0x000000, "Member 'GroundMove_IsRunSpeed::ReturnValue' has a wrong offset!");

// Function man.GroundMove.OnTeleportPost
// 0x000C (0x000C - 0x0000)
struct GroundMove_OnTeleportPost final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMove_OnTeleportPost) == 0x000004, "Wrong alignment on GroundMove_OnTeleportPost");
static_assert(sizeof(GroundMove_OnTeleportPost) == 0x00000C, "Wrong size on GroundMove_OnTeleportPost");
static_assert(offsetof(GroundMove_OnTeleportPost, NewLocation) == 0x000000, "Member 'GroundMove_OnTeleportPost::NewLocation' has a wrong offset!");

// Function man.GroundMove.OnTeleportPre
// 0x000C (0x000C - 0x0000)
struct GroundMove_OnTeleportPre final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMove_OnTeleportPre) == 0x000004, "Wrong alignment on GroundMove_OnTeleportPre");
static_assert(sizeof(GroundMove_OnTeleportPre) == 0x00000C, "Wrong size on GroundMove_OnTeleportPre");
static_assert(offsetof(GroundMove_OnTeleportPre, NewLocation) == 0x000000, "Member 'GroundMove_OnTeleportPre::NewLocation' has a wrong offset!");

// Function man.SetChangeAbility.OnRecoveryEnded
// 0x0008 (0x0008 - 0x0000)
struct SetChangeAbility_OnRecoveryEnded final
{
public:
	class UAbilityBase*                           RecoveryAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SetChangeAbility_OnRecoveryEnded) == 0x000008, "Wrong alignment on SetChangeAbility_OnRecoveryEnded");
static_assert(sizeof(SetChangeAbility_OnRecoveryEnded) == 0x000008, "Wrong size on SetChangeAbility_OnRecoveryEnded");
static_assert(offsetof(SetChangeAbility_OnRecoveryEnded, RecoveryAbility) == 0x000000, "Member 'SetChangeAbility_OnRecoveryEnded::RecoveryAbility' has a wrong offset!");

// Function man.GroundMovingAbilityActor.GetCurrentScale
// 0x0004 (0x0004 - 0x0000)
struct GroundMovingAbilityActor_GetCurrentScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_GetCurrentScale) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_GetCurrentScale");
static_assert(sizeof(GroundMovingAbilityActor_GetCurrentScale) == 0x000004, "Wrong size on GroundMovingAbilityActor_GetCurrentScale");
static_assert(offsetof(GroundMovingAbilityActor_GetCurrentScale, ReturnValue) == 0x000000, "Member 'GroundMovingAbilityActor_GetCurrentScale::ReturnValue' has a wrong offset!");

// Function man.GroundMovingAbilityActor.GetCurrentVelocity
// 0x0004 (0x0004 - 0x0000)
struct GroundMovingAbilityActor_GetCurrentVelocity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_GetCurrentVelocity) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_GetCurrentVelocity");
static_assert(sizeof(GroundMovingAbilityActor_GetCurrentVelocity) == 0x000004, "Wrong size on GroundMovingAbilityActor_GetCurrentVelocity");
static_assert(offsetof(GroundMovingAbilityActor_GetCurrentVelocity, ReturnValue) == 0x000000, "Member 'GroundMovingAbilityActor_GetCurrentVelocity::ReturnValue' has a wrong offset!");

// Function man.GroundMovingAbilityActor.GetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct GroundMovingAbilityActor_GetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_GetElapsedTime) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_GetElapsedTime");
static_assert(sizeof(GroundMovingAbilityActor_GetElapsedTime) == 0x000004, "Wrong size on GroundMovingAbilityActor_GetElapsedTime");
static_assert(offsetof(GroundMovingAbilityActor_GetElapsedTime, ReturnValue) == 0x000000, "Member 'GroundMovingAbilityActor_GetElapsedTime::ReturnValue' has a wrong offset!");

// Function man.GroundMovingAbilityActor.GetFloorNormal
// 0x0004 (0x0004 - 0x0000)
struct GroundMovingAbilityActor_GetFloorNormal final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_GetFloorNormal) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_GetFloorNormal");
static_assert(sizeof(GroundMovingAbilityActor_GetFloorNormal) == 0x000004, "Wrong size on GroundMovingAbilityActor_GetFloorNormal");
static_assert(offsetof(GroundMovingAbilityActor_GetFloorNormal, ReturnValue) == 0x000000, "Member 'GroundMovingAbilityActor_GetFloorNormal::ReturnValue' has a wrong offset!");

// Function man.GroundMovingAbilityActor.GetMaxVelocity
// 0x0008 (0x0008 - 0x0000)
struct GroundMovingAbilityActor_GetMaxVelocity final
{
public:
	bool                                          bOriginal;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_GetMaxVelocity) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_GetMaxVelocity");
static_assert(sizeof(GroundMovingAbilityActor_GetMaxVelocity) == 0x000008, "Wrong size on GroundMovingAbilityActor_GetMaxVelocity");
static_assert(offsetof(GroundMovingAbilityActor_GetMaxVelocity, bOriginal) == 0x000000, "Member 'GroundMovingAbilityActor_GetMaxVelocity::bOriginal' has a wrong offset!");
static_assert(offsetof(GroundMovingAbilityActor_GetMaxVelocity, ReturnValue) == 0x000004, "Member 'GroundMovingAbilityActor_GetMaxVelocity::ReturnValue' has a wrong offset!");

// Function man.GroundMovingAbilityActor.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct GroundMovingAbilityActor_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GroundMovingAbilityActor_IsCollideSignature) == 0x000008, "Wrong alignment on GroundMovingAbilityActor_IsCollideSignature");
static_assert(sizeof(GroundMovingAbilityActor_IsCollideSignature) == 0x000010, "Wrong size on GroundMovingAbilityActor_IsCollideSignature");
static_assert(offsetof(GroundMovingAbilityActor_IsCollideSignature, Actor) == 0x000000, "Member 'GroundMovingAbilityActor_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(GroundMovingAbilityActor_IsCollideSignature, bOverride) == 0x000008, "Member 'GroundMovingAbilityActor_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(GroundMovingAbilityActor_IsCollideSignature, bCollide) == 0x000009, "Member 'GroundMovingAbilityActor_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.GroundMovingAbilityActor.SetMaxVelocity
// 0x0004 (0x0004 - 0x0000)
struct GroundMovingAbilityActor_SetMaxVelocity final
{
public:
	float                                         newMaxSpeed;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GroundMovingAbilityActor_SetMaxVelocity) == 0x000004, "Wrong alignment on GroundMovingAbilityActor_SetMaxVelocity");
static_assert(sizeof(GroundMovingAbilityActor_SetMaxVelocity) == 0x000004, "Wrong size on GroundMovingAbilityActor_SetMaxVelocity");
static_assert(offsetof(GroundMovingAbilityActor_SetMaxVelocity, newMaxSpeed) == 0x000000, "Member 'GroundMovingAbilityActor_SetMaxVelocity::newMaxSpeed' has a wrong offset!");

// Function man.HealOnCritAbility.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct HealOnCritAbility_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HealOnCritAbility_OnPostDamageCaused) == 0x000008, "Wrong alignment on HealOnCritAbility_OnPostDamageCaused");
static_assert(sizeof(HealOnCritAbility_OnPostDamageCaused) == 0x0002D8, "Wrong size on HealOnCritAbility_OnPostDamageCaused");
static_assert(offsetof(HealOnCritAbility_OnPostDamageCaused, Param) == 0x000000, "Member 'HealOnCritAbility_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.HeavyAttackAbility.DealDamage
// 0x02D8 (0x02D8 - 0x0000)
struct HeavyAttackAbility_DealDamage final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavyAttackAbility_DealDamage) == 0x000008, "Wrong alignment on HeavyAttackAbility_DealDamage");
static_assert(sizeof(HeavyAttackAbility_DealDamage) == 0x0002D8, "Wrong size on HeavyAttackAbility_DealDamage");
static_assert(offsetof(HeavyAttackAbility_DealDamage, Param) == 0x000000, "Member 'HeavyAttackAbility_DealDamage::Param' has a wrong offset!");

// Function man.HeavyAttackAbility.GetChargePercent
// 0x0004 (0x0004 - 0x0000)
struct HeavyAttackAbility_GetChargePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeavyAttackAbility_GetChargePercent) == 0x000004, "Wrong alignment on HeavyAttackAbility_GetChargePercent");
static_assert(sizeof(HeavyAttackAbility_GetChargePercent) == 0x000004, "Wrong size on HeavyAttackAbility_GetChargePercent");
static_assert(offsetof(HeavyAttackAbility_GetChargePercent, ReturnValue) == 0x000000, "Member 'HeavyAttackAbility_GetChargePercent::ReturnValue' has a wrong offset!");

// Function man.HemorrhagePassive.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct HemorrhagePassive_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HemorrhagePassive_PreDamageDealt) == 0x000008, "Wrong alignment on HemorrhagePassive_PreDamageDealt");
static_assert(sizeof(HemorrhagePassive_PreDamageDealt) == 0x0002D8, "Wrong size on HemorrhagePassive_PreDamageDealt");
static_assert(offsetof(HemorrhagePassive_PreDamageDealt, Param) == 0x000000, "Member 'HemorrhagePassive_PreDamageDealt::Param' has a wrong offset!");

// Function man.HeroAbilitiesData.ActivateAbilityUpgrade
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_ActivateAbilityUpgrade final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_ActivateAbilityUpgrade) == 0x000008, "Wrong alignment on HeroAbilitiesData_ActivateAbilityUpgrade");
static_assert(sizeof(HeroAbilitiesData_ActivateAbilityUpgrade) == 0x000018, "Wrong size on HeroAbilitiesData_ActivateAbilityUpgrade");
static_assert(offsetof(HeroAbilitiesData_ActivateAbilityUpgrade, Ability) == 0x000000, "Member 'HeroAbilitiesData_ActivateAbilityUpgrade::Ability' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_ActivateAbilityUpgrade, UpgradeID) == 0x000008, "Member 'HeroAbilitiesData_ActivateAbilityUpgrade::UpgradeID' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_ActivateAbilityUpgrade, ReturnValue) == 0x000010, "Member 'HeroAbilitiesData_ActivateAbilityUpgrade::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetAbilityClassByIndex
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_GetAbilityClassByIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubSlotIndex;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetAbilityClassByIndex) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetAbilityClassByIndex");
static_assert(sizeof(HeroAbilitiesData_GetAbilityClassByIndex) == 0x000010, "Wrong size on HeroAbilitiesData_GetAbilityClassByIndex");
static_assert(offsetof(HeroAbilitiesData_GetAbilityClassByIndex, SlotIndex) == 0x000000, "Member 'HeroAbilitiesData_GetAbilityClassByIndex::SlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilityClassByIndex, SubSlotIndex) == 0x000004, "Member 'HeroAbilitiesData_GetAbilityClassByIndex::SubSlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilityClassByIndex, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetAbilityClassByIndex::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetAbilitySlotByIndex
// 0x0030 (0x0030 - 0x0000)
struct HeroAbilitiesData_GetAbilitySlotByIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHeroAbilitySlot                       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetAbilitySlotByIndex) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetAbilitySlotByIndex");
static_assert(sizeof(HeroAbilitiesData_GetAbilitySlotByIndex) == 0x000030, "Wrong size on HeroAbilitiesData_GetAbilitySlotByIndex");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotByIndex, SlotIndex) == 0x000000, "Member 'HeroAbilitiesData_GetAbilitySlotByIndex::SlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotByIndex, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetAbilitySlotByIndex::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetAbilitySlotIndexByAbility
// 0x0020 (0x0020 - 0x0000)
struct HeroAbilitiesData_GetAbilitySlotIndexByAbility final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveSubslot;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilitySlotIndexPair>          ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetAbilitySlotIndexByAbility) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetAbilitySlotIndexByAbility");
static_assert(sizeof(HeroAbilitiesData_GetAbilitySlotIndexByAbility) == 0x000020, "Wrong size on HeroAbilitiesData_GetAbilitySlotIndexByAbility");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotIndexByAbility, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_GetAbilitySlotIndexByAbility::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotIndexByAbility, bOnlyActiveSubslot) == 0x000008, "Member 'HeroAbilitiesData_GetAbilitySlotIndexByAbility::bOnlyActiveSubslot' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotIndexByAbility, ReturnValue) == 0x000010, "Member 'HeroAbilitiesData_GetAbilitySlotIndexByAbility::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetAbilitySlotIndexByAbilitySlot
// 0x0030 (0x0030 - 0x0000)
struct HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot final
{
public:
	struct FHeroAbilitySlot                       HeroAbilitySlot;                                   // 0x0000(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot");
static_assert(sizeof(HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot) == 0x000030, "Wrong size on HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot, HeroAbilitySlot) == 0x000000, "Member 'HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot::HeroAbilitySlot' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot, ReturnValue) == 0x000028, "Member 'HeroAbilitiesData_GetAbilitySlotIndexByAbilitySlot::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetAllHeroAbilities
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_GetAllHeroAbilities final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAbilityBase>>       ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetAllHeroAbilities) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetAllHeroAbilities");
static_assert(sizeof(HeroAbilitiesData_GetAllHeroAbilities) == 0x000018, "Wrong size on HeroAbilitiesData_GetAllHeroAbilities");
static_assert(offsetof(HeroAbilitiesData_GetAllHeroAbilities, bForce) == 0x000000, "Member 'HeroAbilitiesData_GetAllHeroAbilities::bForce' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetAllHeroAbilities, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetAllHeroAbilities::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetHeroCharacter
// 0x0008 (0x0008 - 0x0000)
struct HeroAbilitiesData_GetHeroCharacter final
{
public:
	class AHeroBase*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetHeroCharacter) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetHeroCharacter");
static_assert(sizeof(HeroAbilitiesData_GetHeroCharacter) == 0x000008, "Wrong size on HeroAbilitiesData_GetHeroCharacter");
static_assert(offsetof(HeroAbilitiesData_GetHeroCharacter, ReturnValue) == 0x000000, "Member 'HeroAbilitiesData_GetHeroCharacter::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetLatestPlayerAttackAbility
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_GetLatestPlayerAttackAbility final
{
public:
	bool                                          CheckInstigatedAbilities;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetLatestPlayerAttackAbility) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetLatestPlayerAttackAbility");
static_assert(sizeof(HeroAbilitiesData_GetLatestPlayerAttackAbility) == 0x000010, "Wrong size on HeroAbilitiesData_GetLatestPlayerAttackAbility");
static_assert(offsetof(HeroAbilitiesData_GetLatestPlayerAttackAbility, CheckInstigatedAbilities) == 0x000000, "Member 'HeroAbilitiesData_GetLatestPlayerAttackAbility::CheckInstigatedAbilities' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetLatestPlayerAttackAbility, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetLatestPlayerAttackAbility::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetRunningPlayerActiveAbilities
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_GetRunningPlayerActiveAbilities final
{
public:
	bool                                          CheckInstigatedAbilities;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAbilityBase*>                   ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetRunningPlayerActiveAbilities) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetRunningPlayerActiveAbilities");
static_assert(sizeof(HeroAbilitiesData_GetRunningPlayerActiveAbilities) == 0x000018, "Wrong size on HeroAbilitiesData_GetRunningPlayerActiveAbilities");
static_assert(offsetof(HeroAbilitiesData_GetRunningPlayerActiveAbilities, CheckInstigatedAbilities) == 0x000000, "Member 'HeroAbilitiesData_GetRunningPlayerActiveAbilities::CheckInstigatedAbilities' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetRunningPlayerActiveAbilities, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetRunningPlayerActiveAbilities::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetUnlockedAbilityTypeByName
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_GetUnlockedAbilityTypeByName final
{
public:
	class FName                                   InAbilityName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetUnlockedAbilityTypeByName) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetUnlockedAbilityTypeByName");
static_assert(sizeof(HeroAbilitiesData_GetUnlockedAbilityTypeByName) == 0x000010, "Wrong size on HeroAbilitiesData_GetUnlockedAbilityTypeByName");
static_assert(offsetof(HeroAbilitiesData_GetUnlockedAbilityTypeByName, InAbilityName) == 0x000000, "Member 'HeroAbilitiesData_GetUnlockedAbilityTypeByName::InAbilityName' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetUnlockedAbilityTypeByName, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetUnlockedAbilityTypeByName::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetUnlockedHeroAbilities
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_GetUnlockedHeroAbilities final
{
public:
	TArray<struct FUnlockedAbilityData>           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetUnlockedHeroAbilities) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetUnlockedHeroAbilities");
static_assert(sizeof(HeroAbilitiesData_GetUnlockedHeroAbilities) == 0x000010, "Wrong size on HeroAbilitiesData_GetUnlockedHeroAbilities");
static_assert(offsetof(HeroAbilitiesData_GetUnlockedHeroAbilities, ReturnValue) == 0x000000, "Member 'HeroAbilitiesData_GetUnlockedHeroAbilities::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.GetUnlockedUpgrades
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_GetUnlockedUpgrades final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_GetUnlockedUpgrades) == 0x000008, "Wrong alignment on HeroAbilitiesData_GetUnlockedUpgrades");
static_assert(sizeof(HeroAbilitiesData_GetUnlockedUpgrades) == 0x000018, "Wrong size on HeroAbilitiesData_GetUnlockedUpgrades");
static_assert(offsetof(HeroAbilitiesData_GetUnlockedUpgrades, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_GetUnlockedUpgrades::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_GetUnlockedUpgrades, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_GetUnlockedUpgrades::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsAbilitySlotable
// 0x0020 (0x0020 - 0x0000)
struct HeroAbilitiesData_IsAbilitySlotable final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubSlotIndex;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAbilitySlotQuery>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_IsAbilitySlotable) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsAbilitySlotable");
static_assert(sizeof(HeroAbilitiesData_IsAbilitySlotable) == 0x000020, "Wrong size on HeroAbilitiesData_IsAbilitySlotable");
static_assert(offsetof(HeroAbilitiesData_IsAbilitySlotable, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsAbilitySlotable::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilitySlotable, SlotIndex) == 0x000008, "Member 'HeroAbilitiesData_IsAbilitySlotable::SlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilitySlotable, SubSlotIndex) == 0x00000C, "Member 'HeroAbilitiesData_IsAbilitySlotable::SubSlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilitySlotable, ReturnValue) == 0x000010, "Member 'HeroAbilitiesData_IsAbilitySlotable::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsAbilityUnlockable
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_IsAbilityUnlockable final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_IsAbilityUnlockable) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsAbilityUnlockable");
static_assert(sizeof(HeroAbilitiesData_IsAbilityUnlockable) == 0x000010, "Wrong size on HeroAbilitiesData_IsAbilityUnlockable");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUnlockable, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsAbilityUnlockable::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUnlockable, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_IsAbilityUnlockable::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsAbilityUnlocked
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_IsAbilityUnlocked final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_IsAbilityUnlocked) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsAbilityUnlocked");
static_assert(sizeof(HeroAbilitiesData_IsAbilityUnlocked) == 0x000010, "Wrong size on HeroAbilitiesData_IsAbilityUnlocked");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUnlocked, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsAbilityUnlocked::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUnlocked, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_IsAbilityUnlocked::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsAbilityUpgradeUnlockable
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_IsAbilityUpgradeUnlockable final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCost;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_IsAbilityUpgradeUnlockable) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsAbilityUpgradeUnlockable");
static_assert(sizeof(HeroAbilitiesData_IsAbilityUpgradeUnlockable) == 0x000018, "Wrong size on HeroAbilitiesData_IsAbilityUpgradeUnlockable");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlockable, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlockable::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlockable, UpgradeID) == 0x000008, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlockable::UpgradeID' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlockable, bIgnoreCost) == 0x000010, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlockable::bIgnoreCost' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlockable, ReturnValue) == 0x000011, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlockable::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsAbilityUpgradeUnlocked
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_IsAbilityUpgradeUnlocked final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_IsAbilityUpgradeUnlocked) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsAbilityUpgradeUnlocked");
static_assert(sizeof(HeroAbilitiesData_IsAbilityUpgradeUnlocked) == 0x000018, "Wrong size on HeroAbilitiesData_IsAbilityUpgradeUnlocked");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlocked, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlocked::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlocked, UpgradeID) == 0x000008, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlocked::UpgradeID' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsAbilityUpgradeUnlocked, ReturnValue) == 0x000010, "Member 'HeroAbilitiesData_IsAbilityUpgradeUnlocked::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.IsInActiveSublot
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_IsInActiveSublot final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_IsInActiveSublot) == 0x000008, "Wrong alignment on HeroAbilitiesData_IsInActiveSublot");
static_assert(sizeof(HeroAbilitiesData_IsInActiveSublot) == 0x000010, "Wrong size on HeroAbilitiesData_IsInActiveSublot");
static_assert(offsetof(HeroAbilitiesData_IsInActiveSublot, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_IsInActiveSublot::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_IsInActiveSublot, ReturnValue) == 0x000008, "Member 'HeroAbilitiesData_IsInActiveSublot::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.RotateActiveSubSlots
// 0x0002 (0x0002 - 0x0000)
struct HeroAbilitiesData_RotateActiveSubSlots final
{
public:
	bool                                          bForward;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeroAbilitiesData_RotateActiveSubSlots) == 0x000001, "Wrong alignment on HeroAbilitiesData_RotateActiveSubSlots");
static_assert(sizeof(HeroAbilitiesData_RotateActiveSubSlots) == 0x000002, "Wrong size on HeroAbilitiesData_RotateActiveSubSlots");
static_assert(offsetof(HeroAbilitiesData_RotateActiveSubSlots, bForward) == 0x000000, "Member 'HeroAbilitiesData_RotateActiveSubSlots::bForward' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_RotateActiveSubSlots, ReturnValue) == 0x000001, "Member 'HeroAbilitiesData_RotateActiveSubSlots::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.SetAbilityToSlot
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_SetAbilityToSlot final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubSlotIndex;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUICall;                                           // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_SetAbilityToSlot) == 0x000008, "Wrong alignment on HeroAbilitiesData_SetAbilityToSlot");
static_assert(sizeof(HeroAbilitiesData_SetAbilityToSlot) == 0x000018, "Wrong size on HeroAbilitiesData_SetAbilityToSlot");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_SetAbilityToSlot::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, SlotIndex) == 0x000008, "Member 'HeroAbilitiesData_SetAbilityToSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, SubSlotIndex) == 0x00000C, "Member 'HeroAbilitiesData_SetAbilityToSlot::SubSlotIndex' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, bForce) == 0x000010, "Member 'HeroAbilitiesData_SetAbilityToSlot::bForce' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, bUICall) == 0x000011, "Member 'HeroAbilitiesData_SetAbilityToSlot::bUICall' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_SetAbilityToSlot, ReturnValue) == 0x000012, "Member 'HeroAbilitiesData_SetAbilityToSlot::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.UnlockAbility
// 0x0010 (0x0010 - 0x0000)
struct HeroAbilitiesData_UnlockAbility final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewAbility;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheat;                                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_UnlockAbility) == 0x000008, "Wrong alignment on HeroAbilitiesData_UnlockAbility");
static_assert(sizeof(HeroAbilitiesData_UnlockAbility) == 0x000010, "Wrong size on HeroAbilitiesData_UnlockAbility");
static_assert(offsetof(HeroAbilitiesData_UnlockAbility, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_UnlockAbility::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbility, bNewAbility) == 0x000008, "Member 'HeroAbilitiesData_UnlockAbility::bNewAbility' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbility, bCheat) == 0x000009, "Member 'HeroAbilitiesData_UnlockAbility::bCheat' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbility, ReturnValue) == 0x00000A, "Member 'HeroAbilitiesData_UnlockAbility::ReturnValue' has a wrong offset!");

// Function man.HeroAbilitiesData.UnlockAbilityUpgrade
// 0x0018 (0x0018 - 0x0000)
struct HeroAbilitiesData_UnlockAbilityUpgrade final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeID;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCost;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeroAbilitiesData_UnlockAbilityUpgrade) == 0x000008, "Wrong alignment on HeroAbilitiesData_UnlockAbilityUpgrade");
static_assert(sizeof(HeroAbilitiesData_UnlockAbilityUpgrade) == 0x000018, "Wrong size on HeroAbilitiesData_UnlockAbilityUpgrade");
static_assert(offsetof(HeroAbilitiesData_UnlockAbilityUpgrade, AbilityType) == 0x000000, "Member 'HeroAbilitiesData_UnlockAbilityUpgrade::AbilityType' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbilityUpgrade, UpgradeID) == 0x000008, "Member 'HeroAbilitiesData_UnlockAbilityUpgrade::UpgradeID' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbilityUpgrade, bIgnoreCost) == 0x000010, "Member 'HeroAbilitiesData_UnlockAbilityUpgrade::bIgnoreCost' has a wrong offset!");
static_assert(offsetof(HeroAbilitiesData_UnlockAbilityUpgrade, ReturnValue) == 0x000011, "Member 'HeroAbilitiesData_UnlockAbilityUpgrade::ReturnValue' has a wrong offset!");

// Function man.KingPriestVoidSelfProjection.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidSelfProjection_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidSelfProjection_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestVoidSelfProjection_BPGetTeleportLocation");
static_assert(sizeof(KingPriestVoidSelfProjection_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestVoidSelfProjection_BPGetTeleportLocation");
static_assert(offsetof(KingPriestVoidSelfProjection_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidSelfProjection_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.TentacleAI.TentacleOnAnimToggled
// 0x0010 (0x0010 - 0x0000)
struct TentacleAI_TentacleOnAnimToggled final
{
public:
	class UAnimID*                                Anim;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TentacleAI_TentacleOnAnimToggled) == 0x000008, "Wrong alignment on TentacleAI_TentacleOnAnimToggled");
static_assert(sizeof(TentacleAI_TentacleOnAnimToggled) == 0x000010, "Wrong size on TentacleAI_TentacleOnAnimToggled");
static_assert(offsetof(TentacleAI_TentacleOnAnimToggled, Anim) == 0x000000, "Member 'TentacleAI_TentacleOnAnimToggled::Anim' has a wrong offset!");
static_assert(offsetof(TentacleAI_TentacleOnAnimToggled, bStart) == 0x000008, "Member 'TentacleAI_TentacleOnAnimToggled::bStart' has a wrong offset!");

// Function man.ItemsCanvasPanel.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct ItemsCanvasPanel_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsCanvasPanel_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on ItemsCanvasPanel_OnFocusWidgetChangedEvent");
static_assert(sizeof(ItemsCanvasPanel_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on ItemsCanvasPanel_OnFocusWidgetChangedEvent");
static_assert(offsetof(ItemsCanvasPanel_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'ItemsCanvasPanel_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(ItemsCanvasPanel_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'ItemsCanvasPanel_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.ItemsCanvasPanel.OnUserScrolled
// 0x0004 (0x0004 - 0x0000)
struct ItemsCanvasPanel_OnUserScrolled final
{
public:
	float                                         CurrentOffset;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsCanvasPanel_OnUserScrolled) == 0x000004, "Wrong alignment on ItemsCanvasPanel_OnUserScrolled");
static_assert(sizeof(ItemsCanvasPanel_OnUserScrolled) == 0x000004, "Wrong size on ItemsCanvasPanel_OnUserScrolled");
static_assert(offsetof(ItemsCanvasPanel_OnUserScrolled, CurrentOffset) == 0x000000, "Member 'ItemsCanvasPanel_OnUserScrolled::CurrentOffset' has a wrong offset!");

// Function man.HitBox.BPGetScaledBoxExtent
// 0x000C (0x000C - 0x0000)
struct HitBox_BPGetScaledBoxExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitBox_BPGetScaledBoxExtent) == 0x000004, "Wrong alignment on HitBox_BPGetScaledBoxExtent");
static_assert(sizeof(HitBox_BPGetScaledBoxExtent) == 0x00000C, "Wrong size on HitBox_BPGetScaledBoxExtent");
static_assert(offsetof(HitBox_BPGetScaledBoxExtent, ReturnValue) == 0x000000, "Member 'HitBox_BPGetScaledBoxExtent::ReturnValue' has a wrong offset!");

// Function man.HitBox.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct HitBox_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitBox_OnBeginOverlap) == 0x000008, "Wrong alignment on HitBox_OnBeginOverlap");
static_assert(sizeof(HitBox_OnBeginOverlap) == 0x0000A8, "Wrong size on HitBox_OnBeginOverlap");
static_assert(offsetof(HitBox_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'HitBox_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(HitBox_OnBeginOverlap, OtherActor) == 0x000008, "Member 'HitBox_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HitBox_OnBeginOverlap, OtherComp) == 0x000010, "Member 'HitBox_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HitBox_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'HitBox_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(HitBox_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'HitBox_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(HitBox_OnBeginOverlap, SweepResult) == 0x000020, "Member 'HitBox_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function man.HitBox.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct HitBox_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitBox_OnEndOverlap) == 0x000008, "Wrong alignment on HitBox_OnEndOverlap");
static_assert(sizeof(HitBox_OnEndOverlap) == 0x000020, "Wrong size on HitBox_OnEndOverlap");
static_assert(offsetof(HitBox_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'HitBox_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(HitBox_OnEndOverlap, OtherActor) == 0x000008, "Member 'HitBox_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(HitBox_OnEndOverlap, OtherComp) == 0x000010, "Member 'HitBox_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(HitBox_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'HitBox_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetAbilityDescription
// 0x0040 (0x0040 - 0x0000)
struct ItemTooltipFunctionLibrary_GetAbilityDescription final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ColoredValueTag;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         InCharacterBase;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0028(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetAbilityDescription) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetAbilityDescription");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetAbilityDescription) == 0x000040, "Wrong size on ItemTooltipFunctionLibrary_GetAbilityDescription");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetAbilityDescription, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetAbilityDescription::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetAbilityDescription, AbilityClass) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetAbilityDescription::AbilityClass' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetAbilityDescription, ColoredValueTag) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetAbilityDescription::ColoredValueTag' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetAbilityDescription, InCharacterBase) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetAbilityDescription::InCharacterBase' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetAbilityDescription, ReturnValue) == 0x000028, "Member 'ItemTooltipFunctionLibrary_GetAbilityDescription::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetColonText
// 0x0038 (0x0038 - 0x0000)
struct ItemTooltipFunctionLibrary_GetColonText final
{
public:
	class FString                                 InPrefix;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InKey;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetColonText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetColonText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetColonText) == 0x000038, "Wrong size on ItemTooltipFunctionLibrary_GetColonText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetColonText, InPrefix) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetColonText::InPrefix' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetColonText, InKey) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetColonText::InKey' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetColonText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetColonText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetCooldownText
// 0x0028 (0x0028 - 0x0000)
struct ItemTooltipFunctionLibrary_GetCooldownText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftTimeInSecfloat;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowZeroNumber;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetCooldownText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetCooldownText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetCooldownText) == 0x000028, "Wrong size on ItemTooltipFunctionLibrary_GetCooldownText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetCooldownText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetCooldownText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetCooldownText, LeftTimeInSecfloat) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetCooldownText::LeftTimeInSecfloat' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetCooldownText, bShowZeroNumber) == 0x00000C, "Member 'ItemTooltipFunctionLibrary_GetCooldownText::bShowZeroNumber' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetCooldownText, ReturnValue) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetCooldownText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetFormattedDescriptionText
// 0x0048 (0x0048 - 0x0000)
struct ItemTooltipFunctionLibrary_GetFormattedDescriptionText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           AbilityBase;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class ACharacterBase*                         InCharacterBase;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetFormattedDescriptionText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText) == 0x000048, "Wrong size on ItemTooltipFunctionLibrary_GetFormattedDescriptionText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetFormattedDescriptionText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText, AbilityBase) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetFormattedDescriptionText::AbilityBase' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText, Description) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetFormattedDescriptionText::Description' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText, InCharacterBase) == 0x000028, "Member 'ItemTooltipFunctionLibrary_GetFormattedDescriptionText::InCharacterBase' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetFormattedDescriptionText, ReturnValue) == 0x000030, "Member 'ItemTooltipFunctionLibrary_GetFormattedDescriptionText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemAttributeText
// 0x0030 (0x0030 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemAttributeText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           EnchantItem;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemAttributeText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemAttributeText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemAttributeText) == 0x000030, "Wrong size on ItemTooltipFunctionLibrary_GetItemAttributeText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemAttributeText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemAttributeText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemAttributeText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemAttributeText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemAttributeText, ComparedItem) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemAttributeText::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemAttributeText, EnchantItem) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemAttributeText::EnchantItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemAttributeText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetItemAttributeText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemCategoryByItem
// 0x0040 (0x0040 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemCategoryByItem final
{
public:
	class UItemAbility*                           Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomItemCategory;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoldItem;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemCategory                          ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemCategoryByItem) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemCategoryByItem");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemCategoryByItem) == 0x000040, "Wrong size on ItemTooltipFunctionLibrary_GetItemCategoryByItem");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemCategoryByItem, Item) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemCategoryByItem::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemCategoryByItem, bCustomItemCategory) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemCategoryByItem::bCustomItemCategory' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemCategoryByItem, bSoldItem) == 0x000009, "Member 'ItemTooltipFunctionLibrary_GetItemCategoryByItem::bSoldItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemCategoryByItem, ReturnValue) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemCategoryByItem::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemDescriptionText
// 0x0038 (0x0038 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemDescriptionText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           EnchantItem;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemDescriptionText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemDescriptionText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemDescriptionText) == 0x000038, "Wrong size on ItemTooltipFunctionLibrary_GetItemDescriptionText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemDescriptionText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemDescriptionText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemDescriptionText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemDescriptionText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemDescriptionText, ComparedItem) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemDescriptionText::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemDescriptionText, EnchantItem) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemDescriptionText::EnchantItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemDescriptionText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetItemDescriptionText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemFlavorText
// 0x0028 (0x0028 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemFlavorText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemFlavorText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemFlavorText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemFlavorText) == 0x000028, "Wrong size on ItemTooltipFunctionLibrary_GetItemFlavorText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemFlavorText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemFlavorText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemFlavorText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemFlavorText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemFlavorText, ReturnValue) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemFlavorText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemLargeValueText
// 0x0030 (0x0030 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemLargeValueText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           EnchantItem;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemLargeValueText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemLargeValueText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemLargeValueText) == 0x000030, "Wrong size on ItemTooltipFunctionLibrary_GetItemLargeValueText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemLargeValueText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemLargeValueText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemLargeValueText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemLargeValueText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemLargeValueText, ComparedItem) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemLargeValueText::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemLargeValueText, EnchantItem) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemLargeValueText::EnchantItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemLargeValueText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetItemLargeValueText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemParamsText
// 0x0030 (0x0030 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemParamsText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           EnchantItem;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemParamsText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemParamsText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemParamsText) == 0x000030, "Wrong size on ItemTooltipFunctionLibrary_GetItemParamsText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemParamsText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemParamsText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemParamsText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemParamsText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemParamsText, ComparedItem) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemParamsText::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemParamsText, EnchantItem) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemParamsText::EnchantItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemParamsText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetItemParamsText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemRequirementText
// 0x0030 (0x0030 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemRequirementText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ItemAbility;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemRequirementText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemRequirementText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemRequirementText) == 0x000030, "Wrong size on ItemTooltipFunctionLibrary_GetItemRequirementText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemRequirementText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemRequirementText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemRequirementText, ManItemSlotBase) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemRequirementText::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemRequirementText, ItemAbility) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemRequirementText::ItemAbility' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemRequirementText, ReturnValue) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemRequirementText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemScalingText
// 0x0030 (0x0030 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemScalingText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           EnchantItem;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemScalingText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemScalingText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemScalingText) == 0x000030, "Wrong size on ItemTooltipFunctionLibrary_GetItemScalingText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemScalingText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemScalingText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemScalingText, Item) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemScalingText::Item' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemScalingText, ComparedItem) == 0x000010, "Member 'ItemTooltipFunctionLibrary_GetItemScalingText::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemScalingText, EnchantItem) == 0x000018, "Member 'ItemTooltipFunctionLibrary_GetItemScalingText::EnchantItem' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemScalingText, ReturnValue) == 0x000020, "Member 'ItemTooltipFunctionLibrary_GetItemScalingText::ReturnValue' has a wrong offset!");

// Function man.ItemTooltipFunctionLibrary.GetItemTypeText
// 0x0050 (0x0050 - 0x0000)
struct ItemTooltipFunctionLibrary_GetItemTypeText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemCategory                          ItemCategory;                                      // 0x0008(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipFunctionLibrary_GetItemTypeText) == 0x000008, "Wrong alignment on ItemTooltipFunctionLibrary_GetItemTypeText");
static_assert(sizeof(ItemTooltipFunctionLibrary_GetItemTypeText) == 0x000050, "Wrong size on ItemTooltipFunctionLibrary_GetItemTypeText");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemTypeText, WorldContextObject) == 0x000000, "Member 'ItemTooltipFunctionLibrary_GetItemTypeText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemTypeText, ItemCategory) == 0x000008, "Member 'ItemTooltipFunctionLibrary_GetItemTypeText::ItemCategory' has a wrong offset!");
static_assert(offsetof(ItemTooltipFunctionLibrary_GetItemTypeText, ReturnValue) == 0x000038, "Member 'ItemTooltipFunctionLibrary_GetItemTypeText::ReturnValue' has a wrong offset!");

// Function man.PressureShiftingPlatform.GameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct PressureShiftingPlatform_GameplayEvent final
{
public:
	class UAbilityController*                     AbilityController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PressureShiftingPlatform_GameplayEvent) == 0x000008, "Wrong alignment on PressureShiftingPlatform_GameplayEvent");
static_assert(sizeof(PressureShiftingPlatform_GameplayEvent) == 0x000020, "Wrong size on PressureShiftingPlatform_GameplayEvent");
static_assert(offsetof(PressureShiftingPlatform_GameplayEvent, AbilityController) == 0x000000, "Member 'PressureShiftingPlatform_GameplayEvent::AbilityController' has a wrong offset!");
static_assert(offsetof(PressureShiftingPlatform_GameplayEvent, _GameplayEventID) == 0x000008, "Member 'PressureShiftingPlatform_GameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(PressureShiftingPlatform_GameplayEvent, CustomName) == 0x000010, "Member 'PressureShiftingPlatform_GameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(PressureShiftingPlatform_GameplayEvent, paramActorSoul) == 0x000018, "Member 'PressureShiftingPlatform_GameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.HitReactionPassive.OnPoiseValueChanged
// 0x0010 (0x0010 - 0x0000)
struct HitReactionPassive_OnPoiseValueChanged final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeChangeDataInstance           preValue;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionPassive_OnPoiseValueChanged) == 0x000008, "Wrong alignment on HitReactionPassive_OnPoiseValueChanged");
static_assert(sizeof(HitReactionPassive_OnPoiseValueChanged) == 0x000010, "Wrong size on HitReactionPassive_OnPoiseValueChanged");
static_assert(offsetof(HitReactionPassive_OnPoiseValueChanged, attribute) == 0x000000, "Member 'HitReactionPassive_OnPoiseValueChanged::attribute' has a wrong offset!");
static_assert(offsetof(HitReactionPassive_OnPoiseValueChanged, preValue) == 0x000008, "Member 'HitReactionPassive_OnPoiseValueChanged::preValue' has a wrong offset!");

// Function man.LandFromHangingAbility.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct LandFromHangingAbility_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LandFromHangingAbility_BPGetTargetLocation) == 0x000004, "Wrong alignment on LandFromHangingAbility_BPGetTargetLocation");
static_assert(sizeof(LandFromHangingAbility_BPGetTargetLocation) == 0x00000C, "Wrong size on LandFromHangingAbility_BPGetTargetLocation");
static_assert(offsetof(LandFromHangingAbility_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'LandFromHangingAbility_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.SomeRestForTheWickedPassive.ComboPointsChanged
// 0x0010 (0x0010 - 0x0000)
struct SomeRestForTheWickedPassive_ComboPointsChanged final
{
public:
	int32                                         Delta;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityBase*                           SourceAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SomeRestForTheWickedPassive_ComboPointsChanged) == 0x000008, "Wrong alignment on SomeRestForTheWickedPassive_ComboPointsChanged");
static_assert(sizeof(SomeRestForTheWickedPassive_ComboPointsChanged) == 0x000010, "Wrong size on SomeRestForTheWickedPassive_ComboPointsChanged");
static_assert(offsetof(SomeRestForTheWickedPassive_ComboPointsChanged, Delta) == 0x000000, "Member 'SomeRestForTheWickedPassive_ComboPointsChanged::Delta' has a wrong offset!");
static_assert(offsetof(SomeRestForTheWickedPassive_ComboPointsChanged, SourceAbility) == 0x000008, "Member 'SomeRestForTheWickedPassive_ComboPointsChanged::SourceAbility' has a wrong offset!");

// Function man.HotkeyRichTextBlock.OnInputDisplayChanged
// 0x0002 (0x0002 - 0x0000)
struct HotkeyRichTextBlock_OnInputDisplayChanged final
{
public:
	EInputDisplay                                 InInputDisplay;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 InControlDisplay;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HotkeyRichTextBlock_OnInputDisplayChanged) == 0x000001, "Wrong alignment on HotkeyRichTextBlock_OnInputDisplayChanged");
static_assert(sizeof(HotkeyRichTextBlock_OnInputDisplayChanged) == 0x000002, "Wrong size on HotkeyRichTextBlock_OnInputDisplayChanged");
static_assert(offsetof(HotkeyRichTextBlock_OnInputDisplayChanged, InInputDisplay) == 0x000000, "Member 'HotkeyRichTextBlock_OnInputDisplayChanged::InInputDisplay' has a wrong offset!");
static_assert(offsetof(HotkeyRichTextBlock_OnInputDisplayChanged, InControlDisplay) == 0x000001, "Member 'HotkeyRichTextBlock_OnInputDisplayChanged::InControlDisplay' has a wrong offset!");

// Function man.HoundMasterAI.HoundReleaseEvent
// 0x0020 (0x0020 - 0x0000)
struct HoundMasterAI_HoundReleaseEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoundMasterAI_HoundReleaseEvent) == 0x000008, "Wrong alignment on HoundMasterAI_HoundReleaseEvent");
static_assert(sizeof(HoundMasterAI_HoundReleaseEvent) == 0x000020, "Wrong size on HoundMasterAI_HoundReleaseEvent");
static_assert(offsetof(HoundMasterAI_HoundReleaseEvent, InAbilityController) == 0x000000, "Member 'HoundMasterAI_HoundReleaseEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(HoundMasterAI_HoundReleaseEvent, _GameplayEventID) == 0x000008, "Member 'HoundMasterAI_HoundReleaseEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(HoundMasterAI_HoundReleaseEvent, CustomName) == 0x000010, "Member 'HoundMasterAI_HoundReleaseEvent::CustomName' has a wrong offset!");
static_assert(offsetof(HoundMasterAI_HoundReleaseEvent, paramActorSoul) == 0x000018, "Member 'HoundMasterAI_HoundReleaseEvent::paramActorSoul' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.IsResonanceAbility
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_IsResonanceAbility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_IsResonanceAbility) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_IsResonanceAbility");
static_assert(sizeof(HUDAbilitySlotUserWidget_IsResonanceAbility) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_IsResonanceAbility");
static_assert(offsetof(HUDAbilitySlotUserWidget_IsResonanceAbility, ReturnValue) == 0x000000, "Member 'HUDAbilitySlotUserWidget_IsResonanceAbility::ReturnValue' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnAbilityPressed
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnAbilityPressed final
{
public:
	bool                                          bInSingleUsed;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnAbilityPressed) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnAbilityPressed");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnAbilityPressed) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnAbilityPressed");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnAbilityPressed, bInSingleUsed) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnAbilityPressed::bInSingleUsed' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnAbilityReleased
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnAbilityReleased final
{
public:
	bool                                          bInSingleUsed;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnAbilityReleased) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnAbilityReleased");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnAbilityReleased) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnAbilityReleased");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnAbilityReleased, bInSingleUsed) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnAbilityReleased::bInSingleUsed' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnRefreshAbilityStates
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnRefreshAbilityStates final
{
public:
	bool                                          bInUsable;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnRefreshAbilityStates) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnRefreshAbilityStates");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnRefreshAbilityStates) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnRefreshAbilityStates");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnRefreshAbilityStates, bInUsable) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnRefreshAbilityStates::bInUsable' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbility
// 0x0018 (0x0018 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbility final
{
public:
	class UAbilityBase*                           AbilityType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCooldown;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   RelicType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbility) == 0x000008, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbility");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbility) == 0x000018, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbility");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbility, AbilityType) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbility::AbilityType' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbility, Cooldown) == 0x000008, "Member 'HUDAbilitySlotUserWidget_OnSetAbility::Cooldown' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbility, MaxCooldown) == 0x00000C, "Member 'HUDAbilitySlotUserWidget_OnSetAbility::MaxCooldown' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbility, RelicType) == 0x000010, "Member 'HUDAbilitySlotUserWidget_OnSetAbility::RelicType' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityChargePercentage
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage final
{
public:
	float                                         ChargePercentage;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage, ChargePercentage) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityChargePercentage::ChargePercentage' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityCooldown
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityCooldown final
{
public:
	float                                         CooldownRemain;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityCooldown) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityCooldown");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityCooldown) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityCooldown");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityCooldown, CooldownRemain) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityCooldown::CooldownRemain' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityCost
// 0x0060 (0x0060 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityCost final
{
public:
	class FText                                   EnergyCost;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   RageCost;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ComboPointCost;                                    // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   StaminaCost;                                       // 0x0048(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityCost) == 0x000008, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityCost");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityCost) == 0x000060, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityCost");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityCost, EnergyCost) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityCost::EnergyCost' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityCost, RageCost) == 0x000018, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityCost::RageCost' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityCost, ComboPointCost) == 0x000030, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityCost::ComboPointCost' has a wrong offset!");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityCost, StaminaCost) == 0x000048, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityCost::StaminaCost' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityDuration
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityDuration final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityDuration) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityDuration");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityDuration) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityDuration");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityDuration, Duration) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityDuration::Duration' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityExecuting
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityExecuting final
{
public:
	bool                                          bInExecuting;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityExecuting) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityExecuting");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityExecuting) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityExecuting");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityExecuting, bInExecuting) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityExecuting::bInExecuting' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityExtraEffect
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect final
{
public:
	bool                                          bInExtraEffect;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect, bInExtraEffect) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityExtraEffect::bInExtraEffect' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityReactivation
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityReactivation final
{
public:
	bool                                          bReactivation;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityReactivation) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityReactivation");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityReactivation) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityReactivation");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityReactivation, bReactivation) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityReactivation::bReactivation' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetAbilityUsable
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetAbilityUsable final
{
public:
	bool                                          bUsable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetAbilityUsable) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetAbilityUsable");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetAbilityUsable) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnSetAbilityUsable");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetAbilityUsable, bUsable) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetAbilityUsable::bUsable' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetHitStackNum
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetHitStackNum final
{
public:
	int32                                         ChargePercentage;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetHitStackNum) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetHitStackNum");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetHitStackNum) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetHitStackNum");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetHitStackNum, ChargePercentage) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetHitStackNum::ChargePercentage' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetRelicChargePercentage
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetRelicChargePercentage final
{
public:
	float                                         RelicChargePercentage;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetRelicChargePercentage) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetRelicChargePercentage");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetRelicChargePercentage) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetRelicChargePercentage");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetRelicChargePercentage, RelicChargePercentage) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetRelicChargePercentage::RelicChargePercentage' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnSetSetChargeCounter
// 0x0004 (0x0004 - 0x0000)
struct HUDAbilitySlotUserWidget_OnSetSetChargeCounter final
{
public:
	int32                                         InRemainingChargesNum;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnSetSetChargeCounter) == 0x000004, "Wrong alignment on HUDAbilitySlotUserWidget_OnSetSetChargeCounter");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnSetSetChargeCounter) == 0x000004, "Wrong size on HUDAbilitySlotUserWidget_OnSetSetChargeCounter");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnSetSetChargeCounter, InRemainingChargesNum) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnSetSetChargeCounter::InRemainingChargesNum' has a wrong offset!");

// Function man.HUDAbilitySlotUserWidget.OnShowFullChargeAnim
// 0x0001 (0x0001 - 0x0000)
struct HUDAbilitySlotUserWidget_OnShowFullChargeAnim final
{
public:
	bool                                          bInShowFullChargeAnim;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAbilitySlotUserWidget_OnShowFullChargeAnim) == 0x000001, "Wrong alignment on HUDAbilitySlotUserWidget_OnShowFullChargeAnim");
static_assert(sizeof(HUDAbilitySlotUserWidget_OnShowFullChargeAnim) == 0x000001, "Wrong size on HUDAbilitySlotUserWidget_OnShowFullChargeAnim");
static_assert(offsetof(HUDAbilitySlotUserWidget_OnShowFullChargeAnim, bInShowFullChargeAnim) == 0x000000, "Member 'HUDAbilitySlotUserWidget_OnShowFullChargeAnim::bInShowFullChargeAnim' has a wrong offset!");

// Function man.HUDPopupUserWidget.OnSetData
// 0x0058 (0x0058 - 0x0000)
struct HUDPopupUserWidget_OnSetData final
{
public:
	struct FHUDPopupQueue                         InHUDPopupQueue;                                   // 0x0000(0x0058)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDPopupUserWidget_OnSetData) == 0x000008, "Wrong alignment on HUDPopupUserWidget_OnSetData");
static_assert(sizeof(HUDPopupUserWidget_OnSetData) == 0x000058, "Wrong size on HUDPopupUserWidget_OnSetData");
static_assert(offsetof(HUDPopupUserWidget_OnSetData, InHUDPopupQueue) == 0x000000, "Member 'HUDPopupUserWidget_OnSetData::InHUDPopupQueue' has a wrong offset!");

// Function man.HUDQuickUseUserWidget.OnQuickUseChange
// 0x0038 (0x0038 - 0x0000)
struct HUDQuickUseUserWidget_OnQuickUseChange final
{
public:
	EQuickUseCommand                              InQuickUseCommand;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventorySlot*                         InActiveQuickUse;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventorySlot*>                 InNextQuickUseArray;                               // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UInventorySlot*>                 InPrevQuickUseArray;                               // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UInventorySlot*                         InUsedItem;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDQuickUseUserWidget_OnQuickUseChange) == 0x000008, "Wrong alignment on HUDQuickUseUserWidget_OnQuickUseChange");
static_assert(sizeof(HUDQuickUseUserWidget_OnQuickUseChange) == 0x000038, "Wrong size on HUDQuickUseUserWidget_OnQuickUseChange");
static_assert(offsetof(HUDQuickUseUserWidget_OnQuickUseChange, InQuickUseCommand) == 0x000000, "Member 'HUDQuickUseUserWidget_OnQuickUseChange::InQuickUseCommand' has a wrong offset!");
static_assert(offsetof(HUDQuickUseUserWidget_OnQuickUseChange, InActiveQuickUse) == 0x000008, "Member 'HUDQuickUseUserWidget_OnQuickUseChange::InActiveQuickUse' has a wrong offset!");
static_assert(offsetof(HUDQuickUseUserWidget_OnQuickUseChange, InNextQuickUseArray) == 0x000010, "Member 'HUDQuickUseUserWidget_OnQuickUseChange::InNextQuickUseArray' has a wrong offset!");
static_assert(offsetof(HUDQuickUseUserWidget_OnQuickUseChange, InPrevQuickUseArray) == 0x000020, "Member 'HUDQuickUseUserWidget_OnQuickUseChange::InPrevQuickUseArray' has a wrong offset!");
static_assert(offsetof(HUDQuickUseUserWidget_OnQuickUseChange, InUsedItem) == 0x000030, "Member 'HUDQuickUseUserWidget_OnQuickUseChange::InUsedItem' has a wrong offset!");

// Function man.HUDQuickUseUserWidget.OnUseQuickUseItem
// 0x0008 (0x0008 - 0x0000)
struct HUDQuickUseUserWidget_OnUseQuickUseItem final
{
public:
	class UInventorySlot*                         QuickUseItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDQuickUseUserWidget_OnUseQuickUseItem) == 0x000008, "Wrong alignment on HUDQuickUseUserWidget_OnUseQuickUseItem");
static_assert(sizeof(HUDQuickUseUserWidget_OnUseQuickUseItem) == 0x000008, "Wrong size on HUDQuickUseUserWidget_OnUseQuickUseItem");
static_assert(offsetof(HUDQuickUseUserWidget_OnUseQuickUseItem, QuickUseItem) == 0x000000, "Member 'HUDQuickUseUserWidget_OnUseQuickUseItem::QuickUseItem' has a wrong offset!");

// Function man.KezkaResurrectScene.ContinueGameplay
// 0x0030 (0x0030 - 0x0000)
struct KezkaResurrectScene_ContinueGameplay final
{
public:
	struct FTransform                             OlenTransform;                                     // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KezkaResurrectScene_ContinueGameplay) == 0x000010, "Wrong alignment on KezkaResurrectScene_ContinueGameplay");
static_assert(sizeof(KezkaResurrectScene_ContinueGameplay) == 0x000030, "Wrong size on KezkaResurrectScene_ContinueGameplay");
static_assert(offsetof(KezkaResurrectScene_ContinueGameplay, OlenTransform) == 0x000000, "Member 'KezkaResurrectScene_ContinueGameplay::OlenTransform' has a wrong offset!");

// Function man.KezkaResurrectScene.OnAnimEventBase_Target
// 0x0030 (0x0030 - 0x0000)
struct KezkaResurrectScene_OnAnimEventBase_Target final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KezkaResurrectScene_OnAnimEventBase_Target) == 0x000008, "Wrong alignment on KezkaResurrectScene_OnAnimEventBase_Target");
static_assert(sizeof(KezkaResurrectScene_OnAnimEventBase_Target) == 0x000030, "Wrong size on KezkaResurrectScene_OnAnimEventBase_Target");
static_assert(offsetof(KezkaResurrectScene_OnAnimEventBase_Target, AnimEventParam) == 0x000000, "Member 'KezkaResurrectScene_OnAnimEventBase_Target::AnimEventParam' has a wrong offset!");

// Function man.InteractTextUserWidget.BPShow
// 0x0018 (0x0018 - 0x0000)
struct InteractTextUserWidget_BPShow final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractTextUserWidget_BPShow) == 0x000008, "Wrong alignment on InteractTextUserWidget_BPShow");
static_assert(sizeof(InteractTextUserWidget_BPShow) == 0x000018, "Wrong size on InteractTextUserWidget_BPShow");
static_assert(offsetof(InteractTextUserWidget_BPShow, InText) == 0x000000, "Member 'InteractTextUserWidget_BPShow::InText' has a wrong offset!");

// Function man.InteractTextUserWidget.OnShow
// 0x0001 (0x0001 - 0x0000)
struct InteractTextUserWidget_OnShow final
{
public:
	bool                                          bDoubleInteractBtn;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractTextUserWidget_OnShow) == 0x000001, "Wrong alignment on InteractTextUserWidget_OnShow");
static_assert(sizeof(InteractTextUserWidget_OnShow) == 0x000001, "Wrong size on InteractTextUserWidget_OnShow");
static_assert(offsetof(InteractTextUserWidget_OnShow, bDoubleInteractBtn) == 0x000000, "Member 'InteractTextUserWidget_OnShow::bDoubleInteractBtn' has a wrong offset!");

// Function man.InventoryWindowUserWidget.BPSetFilter
// 0x0008 (0x0008 - 0x0000)
struct InventoryWindowUserWidget_BPSetFilter final
{
public:
	class UVendorFilterSlotUserWidget*            VendorFilterSlotUserWidget;                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryWindowUserWidget_BPSetFilter) == 0x000008, "Wrong alignment on InventoryWindowUserWidget_BPSetFilter");
static_assert(sizeof(InventoryWindowUserWidget_BPSetFilter) == 0x000008, "Wrong size on InventoryWindowUserWidget_BPSetFilter");
static_assert(offsetof(InventoryWindowUserWidget_BPSetFilter, VendorFilterSlotUserWidget) == 0x000000, "Member 'InventoryWindowUserWidget_BPSetFilter::VendorFilterSlotUserWidget' has a wrong offset!");

// Function man.ItemCategoryUserWidget.OnSetText
// 0x0018 (0x0018 - 0x0000)
struct ItemCategoryUserWidget_OnSetText final
{
public:
	class FText                                   CategoryText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemCategoryUserWidget_OnSetText) == 0x000008, "Wrong alignment on ItemCategoryUserWidget_OnSetText");
static_assert(sizeof(ItemCategoryUserWidget_OnSetText) == 0x000018, "Wrong size on ItemCategoryUserWidget_OnSetText");
static_assert(offsetof(ItemCategoryUserWidget_OnSetText, CategoryText) == 0x000000, "Member 'ItemCategoryUserWidget_OnSetText::CategoryText' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.GetItemAbility
// 0x0010 (0x0010 - 0x0000)
struct ItemsHandlerUserWidget_GetItemAbility final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_GetItemAbility) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_GetItemAbility");
static_assert(sizeof(ItemsHandlerUserWidget_GetItemAbility) == 0x000010, "Wrong size on ItemsHandlerUserWidget_GetItemAbility");
static_assert(offsetof(ItemsHandlerUserWidget_GetItemAbility, ManItemSlotBase) == 0x000000, "Member 'ItemsHandlerUserWidget_GetItemAbility::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_GetItemAbility, ReturnValue) == 0x000008, "Member 'ItemsHandlerUserWidget_GetItemAbility::ReturnValue' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnAddItem
// 0x0008 (0x0008 - 0x0000)
struct ItemsHandlerUserWidget_OnAddItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnAddItem) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnAddItem");
static_assert(sizeof(ItemsHandlerUserWidget_OnAddItem) == 0x000008, "Wrong size on ItemsHandlerUserWidget_OnAddItem");
static_assert(offsetof(ItemsHandlerUserWidget_OnAddItem, InventorySlot) == 0x000000, "Member 'ItemsHandlerUserWidget_OnAddItem::InventorySlot' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnApplyEnchant
// 0x0010 (0x0010 - 0x0000)
struct ItemsHandlerUserWidget_OnApplyEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnApplyEnchant) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnApplyEnchant");
static_assert(sizeof(ItemsHandlerUserWidget_OnApplyEnchant) == 0x000010, "Wrong size on ItemsHandlerUserWidget_OnApplyEnchant");
static_assert(offsetof(ItemsHandlerUserWidget_OnApplyEnchant, TargetItem) == 0x000000, "Member 'ItemsHandlerUserWidget_OnApplyEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_OnApplyEnchant, Enchant) == 0x000008, "Member 'ItemsHandlerUserWidget_OnApplyEnchant::Enchant' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnHideWindow
// 0x0008 (0x0008 - 0x0000)
struct ItemsHandlerUserWidget_OnHideWindow final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnHideWindow) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnHideWindow");
static_assert(sizeof(ItemsHandlerUserWidget_OnHideWindow) == 0x000008, "Wrong size on ItemsHandlerUserWidget_OnHideWindow");
static_assert(offsetof(ItemsHandlerUserWidget_OnHideWindow, ManUserWidgetBase) == 0x000000, "Member 'ItemsHandlerUserWidget_OnHideWindow::ManUserWidgetBase' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnInventorySlotFocused
// 0x0008 (0x0008 - 0x0000)
struct ItemsHandlerUserWidget_OnInventorySlotFocused final
{
public:
	class UInventorySlotUserWidget*               InventorySlotUserWidget;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnInventorySlotFocused) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnInventorySlotFocused");
static_assert(sizeof(ItemsHandlerUserWidget_OnInventorySlotFocused) == 0x000008, "Wrong size on ItemsHandlerUserWidget_OnInventorySlotFocused");
static_assert(offsetof(ItemsHandlerUserWidget_OnInventorySlotFocused, InventorySlotUserWidget) == 0x000000, "Member 'ItemsHandlerUserWidget_OnInventorySlotFocused::InventorySlotUserWidget' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnItemSlotChanged
// 0x0010 (0x0010 - 0x0000)
struct ItemsHandlerUserWidget_OnItemSlotChanged final
{
public:
	class UInventorySlot*                         SourceSlot;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlot*                         DestinationSlot;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnItemSlotChanged) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnItemSlotChanged");
static_assert(sizeof(ItemsHandlerUserWidget_OnItemSlotChanged) == 0x000010, "Wrong size on ItemsHandlerUserWidget_OnItemSlotChanged");
static_assert(offsetof(ItemsHandlerUserWidget_OnItemSlotChanged, SourceSlot) == 0x000000, "Member 'ItemsHandlerUserWidget_OnItemSlotChanged::SourceSlot' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_OnItemSlotChanged, DestinationSlot) == 0x000008, "Member 'ItemsHandlerUserWidget_OnItemSlotChanged::DestinationSlot' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnRemoveEnchant
// 0x0010 (0x0010 - 0x0000)
struct ItemsHandlerUserWidget_OnRemoveEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnRemoveEnchant) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnRemoveEnchant");
static_assert(sizeof(ItemsHandlerUserWidget_OnRemoveEnchant) == 0x000010, "Wrong size on ItemsHandlerUserWidget_OnRemoveEnchant");
static_assert(offsetof(ItemsHandlerUserWidget_OnRemoveEnchant, TargetItem) == 0x000000, "Member 'ItemsHandlerUserWidget_OnRemoveEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_OnRemoveEnchant, Enchant) == 0x000008, "Member 'ItemsHandlerUserWidget_OnRemoveEnchant::Enchant' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnRemoveItem
// 0x0010 (0x0010 - 0x0000)
struct ItemsHandlerUserWidget_OnRemoveItem final
{
public:
	class UInventorySlot*                         InventorySlot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RemovedItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnRemoveItem) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnRemoveItem");
static_assert(sizeof(ItemsHandlerUserWidget_OnRemoveItem) == 0x000010, "Wrong size on ItemsHandlerUserWidget_OnRemoveItem");
static_assert(offsetof(ItemsHandlerUserWidget_OnRemoveItem, InventorySlot) == 0x000000, "Member 'ItemsHandlerUserWidget_OnRemoveItem::InventorySlot' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_OnRemoveItem, RemovedItem) == 0x000008, "Member 'ItemsHandlerUserWidget_OnRemoveItem::RemovedItem' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnShowWindow
// 0x0008 (0x0008 - 0x0000)
struct ItemsHandlerUserWidget_OnShowWindow final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnShowWindow) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnShowWindow");
static_assert(sizeof(ItemsHandlerUserWidget_OnShowWindow) == 0x000008, "Wrong size on ItemsHandlerUserWidget_OnShowWindow");
static_assert(offsetof(ItemsHandlerUserWidget_OnShowWindow, ManUserWidgetBase) == 0x000000, "Member 'ItemsHandlerUserWidget_OnShowWindow::ManUserWidgetBase' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.OnSortChanged
// 0x0018 (0x0018 - 0x0000)
struct ItemsHandlerUserWidget_OnSortChanged final
{
public:
	class FText                                   SortName;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_OnSortChanged) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_OnSortChanged");
static_assert(sizeof(ItemsHandlerUserWidget_OnSortChanged) == 0x000018, "Wrong size on ItemsHandlerUserWidget_OnSortChanged");
static_assert(offsetof(ItemsHandlerUserWidget_OnSortChanged, SortName) == 0x000000, "Member 'ItemsHandlerUserWidget_OnSortChanged::SortName' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.UpdateDetailsPanel
// 0x0030 (0x0030 - 0x0000)
struct ItemsHandlerUserWidget_UpdateDetailsPanel final
{
public:
	class FText                                   ItemRequirementText;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UItemAbility*                           Item;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ComparedItem;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightTooltip;                                 // 0x002A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ItemsHandlerUserWidget_UpdateDetailsPanel) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_UpdateDetailsPanel");
static_assert(sizeof(ItemsHandlerUserWidget_UpdateDetailsPanel) == 0x000030, "Wrong size on ItemsHandlerUserWidget_UpdateDetailsPanel");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, ItemRequirementText) == 0x000000, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::ItemRequirementText' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, Item) == 0x000018, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::Item' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, ComparedItem) == 0x000020, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::ComparedItem' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, bEquipped) == 0x000028, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::bEquipped' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, bAnimate) == 0x000029, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::bAnimate' has a wrong offset!");
static_assert(offsetof(ItemsHandlerUserWidget_UpdateDetailsPanel, bHighlightTooltip) == 0x00002A, "Member 'ItemsHandlerUserWidget_UpdateDetailsPanel::bHighlightTooltip' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.GetFilteredItemsNum
// 0x0004 (0x0004 - 0x0000)
struct ItemsHandlerUserWidget_GetFilteredItemsNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_GetFilteredItemsNum) == 0x000004, "Wrong alignment on ItemsHandlerUserWidget_GetFilteredItemsNum");
static_assert(sizeof(ItemsHandlerUserWidget_GetFilteredItemsNum) == 0x000004, "Wrong size on ItemsHandlerUserWidget_GetFilteredItemsNum");
static_assert(offsetof(ItemsHandlerUserWidget_GetFilteredItemsNum, ReturnValue) == 0x000000, "Member 'ItemsHandlerUserWidget_GetFilteredItemsNum::ReturnValue' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.GetFocusedSlot
// 0x0008 (0x0008 - 0x0000)
struct ItemsHandlerUserWidget_GetFocusedSlot final
{
public:
	class UInventorySlotUserWidget*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_GetFocusedSlot) == 0x000008, "Wrong alignment on ItemsHandlerUserWidget_GetFocusedSlot");
static_assert(sizeof(ItemsHandlerUserWidget_GetFocusedSlot) == 0x000008, "Wrong size on ItemsHandlerUserWidget_GetFocusedSlot");
static_assert(offsetof(ItemsHandlerUserWidget_GetFocusedSlot, ReturnValue) == 0x000000, "Member 'ItemsHandlerUserWidget_GetFocusedSlot::ReturnValue' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.GetHeroEssenceResource
// 0x0004 (0x0004 - 0x0000)
struct ItemsHandlerUserWidget_GetHeroEssenceResource final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_GetHeroEssenceResource) == 0x000004, "Wrong alignment on ItemsHandlerUserWidget_GetHeroEssenceResource");
static_assert(sizeof(ItemsHandlerUserWidget_GetHeroEssenceResource) == 0x000004, "Wrong size on ItemsHandlerUserWidget_GetHeroEssenceResource");
static_assert(offsetof(ItemsHandlerUserWidget_GetHeroEssenceResource, ReturnValue) == 0x000000, "Member 'ItemsHandlerUserWidget_GetHeroEssenceResource::ReturnValue' has a wrong offset!");

// Function man.ItemsHandlerUserWidget.GetHeroGoldResource
// 0x0004 (0x0004 - 0x0000)
struct ItemsHandlerUserWidget_GetHeroGoldResource final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemsHandlerUserWidget_GetHeroGoldResource) == 0x000004, "Wrong alignment on ItemsHandlerUserWidget_GetHeroGoldResource");
static_assert(sizeof(ItemsHandlerUserWidget_GetHeroGoldResource) == 0x000004, "Wrong size on ItemsHandlerUserWidget_GetHeroGoldResource");
static_assert(offsetof(ItemsHandlerUserWidget_GetHeroGoldResource, ReturnValue) == 0x000000, "Member 'ItemsHandlerUserWidget_GetHeroGoldResource::ReturnValue' has a wrong offset!");

// Function man.KeyboardHotkeyUserWidget.GetHotkeyNameText
// 0x0018 (0x0018 - 0x0000)
struct KeyboardHotkeyUserWidget_GetHotkeyNameText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KeyboardHotkeyUserWidget_GetHotkeyNameText) == 0x000008, "Wrong alignment on KeyboardHotkeyUserWidget_GetHotkeyNameText");
static_assert(sizeof(KeyboardHotkeyUserWidget_GetHotkeyNameText) == 0x000018, "Wrong size on KeyboardHotkeyUserWidget_GetHotkeyNameText");
static_assert(offsetof(KeyboardHotkeyUserWidget_GetHotkeyNameText, ReturnValue) == 0x000000, "Member 'KeyboardHotkeyUserWidget_GetHotkeyNameText::ReturnValue' has a wrong offset!");

// Function man.KingPriestVoidEntropicLeap.BPGetExplosionLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidEntropicLeap_BPGetExplosionLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidEntropicLeap_BPGetExplosionLocation) == 0x000004, "Wrong alignment on KingPriestVoidEntropicLeap_BPGetExplosionLocation");
static_assert(sizeof(KingPriestVoidEntropicLeap_BPGetExplosionLocation) == 0x00000C, "Wrong size on KingPriestVoidEntropicLeap_BPGetExplosionLocation");
static_assert(offsetof(KingPriestVoidEntropicLeap_BPGetExplosionLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidEntropicLeap_BPGetExplosionLocation::ReturnValue' has a wrong offset!");

// Function man.KingPriestVoidEntropicLeap.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct KingPriestVoidEntropicLeap_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KingPriestVoidEntropicLeap_BPGetTeleportLocation) == 0x000004, "Wrong alignment on KingPriestVoidEntropicLeap_BPGetTeleportLocation");
static_assert(sizeof(KingPriestVoidEntropicLeap_BPGetTeleportLocation) == 0x00000C, "Wrong size on KingPriestVoidEntropicLeap_BPGetTeleportLocation");
static_assert(offsetof(KingPriestVoidEntropicLeap_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'KingPriestVoidEntropicLeap_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.LadderActorBase.SetTargetLocation
// 0x000C (0x000C - 0x0000)
struct LadderActorBase_SetTargetLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LadderActorBase_SetTargetLocation) == 0x000004, "Wrong alignment on LadderActorBase_SetTargetLocation");
static_assert(sizeof(LadderActorBase_SetTargetLocation) == 0x00000C, "Wrong size on LadderActorBase_SetTargetLocation");
static_assert(offsetof(LadderActorBase_SetTargetLocation, Location) == 0x000000, "Member 'LadderActorBase_SetTargetLocation::Location' has a wrong offset!");

// Function man.LadderActorBase.TeleportToLocation
// 0x000C (0x000C - 0x0000)
struct LadderActorBase_TeleportToLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LadderActorBase_TeleportToLocation) == 0x000004, "Wrong alignment on LadderActorBase_TeleportToLocation");
static_assert(sizeof(LadderActorBase_TeleportToLocation) == 0x00000C, "Wrong size on LadderActorBase_TeleportToLocation");
static_assert(offsetof(LadderActorBase_TeleportToLocation, Location) == 0x000000, "Member 'LadderActorBase_TeleportToLocation::Location' has a wrong offset!");

// Function man.LiftButtonAbility.LiftOnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct LiftButtonAbility_LiftOnGameplayEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LiftButtonAbility_LiftOnGameplayEvent) == 0x000008, "Wrong alignment on LiftButtonAbility_LiftOnGameplayEvent");
static_assert(sizeof(LiftButtonAbility_LiftOnGameplayEvent) == 0x000020, "Wrong size on LiftButtonAbility_LiftOnGameplayEvent");
static_assert(offsetof(LiftButtonAbility_LiftOnGameplayEvent, InAbilityController) == 0x000000, "Member 'LiftButtonAbility_LiftOnGameplayEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_LiftOnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'LiftButtonAbility_LiftOnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_LiftOnGameplayEvent, CustomName) == 0x000010, "Member 'LiftButtonAbility_LiftOnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_LiftOnGameplayEvent, paramActorSoul) == 0x000018, "Member 'LiftButtonAbility_LiftOnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.LiftButtonAbility.OnGameplayEvent
// 0x0020 (0x0020 - 0x0000)
struct LiftButtonAbility_OnGameplayEvent final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LiftButtonAbility_OnGameplayEvent) == 0x000008, "Wrong alignment on LiftButtonAbility_OnGameplayEvent");
static_assert(sizeof(LiftButtonAbility_OnGameplayEvent) == 0x000020, "Wrong size on LiftButtonAbility_OnGameplayEvent");
static_assert(offsetof(LiftButtonAbility_OnGameplayEvent, InAbilityController) == 0x000000, "Member 'LiftButtonAbility_OnGameplayEvent::InAbilityController' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_OnGameplayEvent, _GameplayEventID) == 0x000008, "Member 'LiftButtonAbility_OnGameplayEvent::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_OnGameplayEvent, CustomName) == 0x000010, "Member 'LiftButtonAbility_OnGameplayEvent::CustomName' has a wrong offset!");
static_assert(offsetof(LiftButtonAbility_OnGameplayEvent, paramActorSoul) == 0x000018, "Member 'LiftButtonAbility_OnGameplayEvent::paramActorSoul' has a wrong offset!");

// Function man.LoadGameSlotUserWidget.GetSlotID
// 0x0004 (0x0004 - 0x0000)
struct LoadGameSlotUserWidget_GetSlotID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameSlotUserWidget_GetSlotID) == 0x000004, "Wrong alignment on LoadGameSlotUserWidget_GetSlotID");
static_assert(sizeof(LoadGameSlotUserWidget_GetSlotID) == 0x000004, "Wrong size on LoadGameSlotUserWidget_GetSlotID");
static_assert(offsetof(LoadGameSlotUserWidget_GetSlotID, ReturnValue) == 0x000000, "Member 'LoadGameSlotUserWidget_GetSlotID::ReturnValue' has a wrong offset!");

// Function man.LoadGameSlotUserWidget.IsCanLoad
// 0x0001 (0x0001 - 0x0000)
struct LoadGameSlotUserWidget_IsCanLoad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameSlotUserWidget_IsCanLoad) == 0x000001, "Wrong alignment on LoadGameSlotUserWidget_IsCanLoad");
static_assert(sizeof(LoadGameSlotUserWidget_IsCanLoad) == 0x000001, "Wrong size on LoadGameSlotUserWidget_IsCanLoad");
static_assert(offsetof(LoadGameSlotUserWidget_IsCanLoad, ReturnValue) == 0x000000, "Member 'LoadGameSlotUserWidget_IsCanLoad::ReturnValue' has a wrong offset!");

// Function man.LoadGameSlotUserWidget.IsValidSlot
// 0x0001 (0x0001 - 0x0000)
struct LoadGameSlotUserWidget_IsValidSlot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameSlotUserWidget_IsValidSlot) == 0x000001, "Wrong alignment on LoadGameSlotUserWidget_IsValidSlot");
static_assert(sizeof(LoadGameSlotUserWidget_IsValidSlot) == 0x000001, "Wrong size on LoadGameSlotUserWidget_IsValidSlot");
static_assert(offsetof(LoadGameSlotUserWidget_IsValidSlot, ReturnValue) == 0x000000, "Member 'LoadGameSlotUserWidget_IsValidSlot::ReturnValue' has a wrong offset!");

// Function man.LoadGameSlotUserWidget.OnSetSlot
// 0x0080 (0x0080 - 0x0000)
struct LoadGameSlotUserWidget_OnSetSlot final
{
public:
	class FText                                   Name_0;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   LevelAndClass;                                     // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Location;                                          // 0x0030(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   TimeSpent;                                         // 0x0048(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   LastPlayed;                                        // 0x0060(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          InCompatible;                                      // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LoadGameSlotUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on LoadGameSlotUserWidget_OnSetSlot");
static_assert(sizeof(LoadGameSlotUserWidget_OnSetSlot) == 0x000080, "Wrong size on LoadGameSlotUserWidget_OnSetSlot");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, Name_0) == 0x000000, "Member 'LoadGameSlotUserWidget_OnSetSlot::Name_0' has a wrong offset!");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, LevelAndClass) == 0x000018, "Member 'LoadGameSlotUserWidget_OnSetSlot::LevelAndClass' has a wrong offset!");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, Location) == 0x000030, "Member 'LoadGameSlotUserWidget_OnSetSlot::Location' has a wrong offset!");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, TimeSpent) == 0x000048, "Member 'LoadGameSlotUserWidget_OnSetSlot::TimeSpent' has a wrong offset!");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, LastPlayed) == 0x000060, "Member 'LoadGameSlotUserWidget_OnSetSlot::LastPlayed' has a wrong offset!");
static_assert(offsetof(LoadGameSlotUserWidget_OnSetSlot, InCompatible) == 0x000078, "Member 'LoadGameSlotUserWidget_OnSetSlot::InCompatible' has a wrong offset!");

// Function man.VoidWitchNewMoon.BPGetStartLocation
// 0x000C (0x000C - 0x0000)
struct VoidWitchNewMoon_BPGetStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidWitchNewMoon_BPGetStartLocation) == 0x000004, "Wrong alignment on VoidWitchNewMoon_BPGetStartLocation");
static_assert(sizeof(VoidWitchNewMoon_BPGetStartLocation) == 0x00000C, "Wrong size on VoidWitchNewMoon_BPGetStartLocation");
static_assert(offsetof(VoidWitchNewMoon_BPGetStartLocation, ReturnValue) == 0x000000, "Member 'VoidWitchNewMoon_BPGetStartLocation::ReturnValue' has a wrong offset!");

// Function man.VoidWitchNewMoon.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct VoidWitchNewMoon_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidWitchNewMoon_BPGetTeleportLocation) == 0x000004, "Wrong alignment on VoidWitchNewMoon_BPGetTeleportLocation");
static_assert(sizeof(VoidWitchNewMoon_BPGetTeleportLocation) == 0x00000C, "Wrong size on VoidWitchNewMoon_BPGetTeleportLocation");
static_assert(offsetof(VoidWitchNewMoon_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'VoidWitchNewMoon_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.LoadGameUserWidget.OnDialogueDeleteSavedGameResult
// 0x0001 (0x0001 - 0x0000)
struct LoadGameUserWidget_OnDialogueDeleteSavedGameResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameUserWidget_OnDialogueDeleteSavedGameResult) == 0x000001, "Wrong alignment on LoadGameUserWidget_OnDialogueDeleteSavedGameResult");
static_assert(sizeof(LoadGameUserWidget_OnDialogueDeleteSavedGameResult) == 0x000001, "Wrong size on LoadGameUserWidget_OnDialogueDeleteSavedGameResult");
static_assert(offsetof(LoadGameUserWidget_OnDialogueDeleteSavedGameResult, ButtonType) == 0x000000, "Member 'LoadGameUserWidget_OnDialogueDeleteSavedGameResult::ButtonType' has a wrong offset!");

// Function man.LoadGameUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct LoadGameUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on LoadGameUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(LoadGameUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on LoadGameUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(LoadGameUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'LoadGameUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(LoadGameUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'LoadGameUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.LoadGameUserWidget.OnLoadGameMissingContent
// 0x0001 (0x0001 - 0x0000)
struct LoadGameUserWidget_OnLoadGameMissingContent final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadGameUserWidget_OnLoadGameMissingContent) == 0x000001, "Wrong alignment on LoadGameUserWidget_OnLoadGameMissingContent");
static_assert(sizeof(LoadGameUserWidget_OnLoadGameMissingContent) == 0x000001, "Wrong size on LoadGameUserWidget_OnLoadGameMissingContent");
static_assert(offsetof(LoadGameUserWidget_OnLoadGameMissingContent, ButtonType) == 0x000000, "Member 'LoadGameUserWidget_OnLoadGameMissingContent::ButtonType' has a wrong offset!");

// Function man.StaticElectricity.BPGetTargetEnemyForDamageVfx
// 0x0008 (0x0008 - 0x0000)
struct StaticElectricity_BPGetTargetEnemyForDamageVfx final
{
public:
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticElectricity_BPGetTargetEnemyForDamageVfx) == 0x000008, "Wrong alignment on StaticElectricity_BPGetTargetEnemyForDamageVfx");
static_assert(sizeof(StaticElectricity_BPGetTargetEnemyForDamageVfx) == 0x000008, "Wrong size on StaticElectricity_BPGetTargetEnemyForDamageVfx");
static_assert(offsetof(StaticElectricity_BPGetTargetEnemyForDamageVfx, ReturnValue) == 0x000000, "Member 'StaticElectricity_BPGetTargetEnemyForDamageVfx::ReturnValue' has a wrong offset!");

// Function man.StaticElectricity.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct StaticElectricity_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticElectricity_OnPostDamageCaused) == 0x000008, "Wrong alignment on StaticElectricity_OnPostDamageCaused");
static_assert(sizeof(StaticElectricity_OnPostDamageCaused) == 0x0002D8, "Wrong size on StaticElectricity_OnPostDamageCaused");
static_assert(offsetof(StaticElectricity_OnPostDamageCaused, Param) == 0x000000, "Member 'StaticElectricity_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.ManAchievements.AddFlagToProgress
// 0x000C (0x000C - 0x0000)
struct ManAchievements_AddFlagToProgress final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         iFlagBit;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAchievements_AddFlagToProgress) == 0x000004, "Wrong alignment on ManAchievements_AddFlagToProgress");
static_assert(sizeof(ManAchievements_AddFlagToProgress) == 0x00000C, "Wrong size on ManAchievements_AddFlagToProgress");
static_assert(offsetof(ManAchievements_AddFlagToProgress, AchievementID) == 0x000000, "Member 'ManAchievements_AddFlagToProgress::AchievementID' has a wrong offset!");
static_assert(offsetof(ManAchievements_AddFlagToProgress, iFlagBit) == 0x000008, "Member 'ManAchievements_AddFlagToProgress::iFlagBit' has a wrong offset!");

// Function man.ManAchievements.AddProgress
// 0x000C (0x000C - 0x0000)
struct ManAchievements_AddProgress final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         iProgress;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAchievements_AddProgress) == 0x000004, "Wrong alignment on ManAchievements_AddProgress");
static_assert(sizeof(ManAchievements_AddProgress) == 0x00000C, "Wrong size on ManAchievements_AddProgress");
static_assert(offsetof(ManAchievements_AddProgress, AchievementID) == 0x000000, "Member 'ManAchievements_AddProgress::AchievementID' has a wrong offset!");
static_assert(offsetof(ManAchievements_AddProgress, iProgress) == 0x000008, "Member 'ManAchievements_AddProgress::iProgress' has a wrong offset!");

// Function man.ManAchievements.GetProgress
// 0x000C (0x000C - 0x0000)
struct ManAchievements_GetProgress final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAchievements_GetProgress) == 0x000004, "Wrong alignment on ManAchievements_GetProgress");
static_assert(sizeof(ManAchievements_GetProgress) == 0x00000C, "Wrong size on ManAchievements_GetProgress");
static_assert(offsetof(ManAchievements_GetProgress, AchievementID) == 0x000000, "Member 'ManAchievements_GetProgress::AchievementID' has a wrong offset!");
static_assert(offsetof(ManAchievements_GetProgress, ReturnValue) == 0x000008, "Member 'ManAchievements_GetProgress::ReturnValue' has a wrong offset!");

// Function man.ManAchievements.IsUnlocked
// 0x000C (0x000C - 0x0000)
struct ManAchievements_IsUnlocked final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManAchievements_IsUnlocked) == 0x000004, "Wrong alignment on ManAchievements_IsUnlocked");
static_assert(sizeof(ManAchievements_IsUnlocked) == 0x00000C, "Wrong size on ManAchievements_IsUnlocked");
static_assert(offsetof(ManAchievements_IsUnlocked, AchievementID) == 0x000000, "Member 'ManAchievements_IsUnlocked::AchievementID' has a wrong offset!");
static_assert(offsetof(ManAchievements_IsUnlocked, ReturnValue) == 0x000008, "Member 'ManAchievements_IsUnlocked::ReturnValue' has a wrong offset!");

// Function man.ManAchievements.Unlock
// 0x000C (0x000C - 0x0000)
struct ManAchievements_Unlock final
{
public:
	class FName                                   AchievementID;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceWithStat;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManAchievements_Unlock) == 0x000004, "Wrong alignment on ManAchievements_Unlock");
static_assert(sizeof(ManAchievements_Unlock) == 0x00000C, "Wrong size on ManAchievements_Unlock");
static_assert(offsetof(ManAchievements_Unlock, AchievementID) == 0x000000, "Member 'ManAchievements_Unlock::AchievementID' has a wrong offset!");
static_assert(offsetof(ManAchievements_Unlock, ForceWithStat) == 0x000008, "Member 'ManAchievements_Unlock::ForceWithStat' has a wrong offset!");

// Function man.ManActivityFunctionLibrary.CompleteQuest
// 0x0010 (0x0010 - 0x0000)
struct ManActivityFunctionLibrary_CompleteQuest final
{
public:
	class AMandragoraGameMode*                    GameMode;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   questName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManActivityFunctionLibrary_CompleteQuest) == 0x000008, "Wrong alignment on ManActivityFunctionLibrary_CompleteQuest");
static_assert(sizeof(ManActivityFunctionLibrary_CompleteQuest) == 0x000010, "Wrong size on ManActivityFunctionLibrary_CompleteQuest");
static_assert(offsetof(ManActivityFunctionLibrary_CompleteQuest, GameMode) == 0x000000, "Member 'ManActivityFunctionLibrary_CompleteQuest::GameMode' has a wrong offset!");
static_assert(offsetof(ManActivityFunctionLibrary_CompleteQuest, questName) == 0x000008, "Member 'ManActivityFunctionLibrary_CompleteQuest::questName' has a wrong offset!");

// Function man.ManAudioManager.OnApplicationActivationStateChanged
// 0x0001 (0x0001 - 0x0000)
struct ManAudioManager_OnApplicationActivationStateChanged final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManAudioManager_OnApplicationActivationStateChanged) == 0x000001, "Wrong alignment on ManAudioManager_OnApplicationActivationStateChanged");
static_assert(sizeof(ManAudioManager_OnApplicationActivationStateChanged) == 0x000001, "Wrong size on ManAudioManager_OnApplicationActivationStateChanged");
static_assert(offsetof(ManAudioManager_OnApplicationActivationStateChanged, bIsFocused) == 0x000000, "Member 'ManAudioManager_OnApplicationActivationStateChanged::bIsFocused' has a wrong offset!");

// Function man.ManConversationManager.EvaluateConditionWithGlobalDictionary
// 0x0010 (0x0010 - 0x0000)
struct ManConversationManager_EvaluateConditionWithGlobalDictionary final
{
public:
	class UPrimalConversationConditionBase*       Codition;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_EvaluateConditionWithGlobalDictionary) == 0x000008, "Wrong alignment on ManConversationManager_EvaluateConditionWithGlobalDictionary");
static_assert(sizeof(ManConversationManager_EvaluateConditionWithGlobalDictionary) == 0x000010, "Wrong size on ManConversationManager_EvaluateConditionWithGlobalDictionary");
static_assert(offsetof(ManConversationManager_EvaluateConditionWithGlobalDictionary, Codition) == 0x000000, "Member 'ManConversationManager_EvaluateConditionWithGlobalDictionary::Codition' has a wrong offset!");
static_assert(offsetof(ManConversationManager_EvaluateConditionWithGlobalDictionary, ReturnValue) == 0x000008, "Member 'ManConversationManager_EvaluateConditionWithGlobalDictionary::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionarySetBool
// 0x0020 (0x0020 - 0x0000)
struct ManConversationManager_GlobalDictionarySetBool final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValue;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionarySetBool) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionarySetBool");
static_assert(sizeof(ManConversationManager_GlobalDictionarySetBool) == 0x000020, "Wrong size on ManConversationManager_GlobalDictionarySetBool");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetBool, Name_0) == 0x000000, "Member 'ManConversationManager_GlobalDictionarySetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetBool, InValue) == 0x000008, "Member 'ManConversationManager_GlobalDictionarySetBool::InValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetBool, OnChanged) == 0x00000C, "Member 'ManConversationManager_GlobalDictionarySetBool::OnChanged' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetBool, ReturnValue) == 0x00001C, "Member 'ManConversationManager_GlobalDictionarySetBool::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionarySetFloat
// 0x0020 (0x0020 - 0x0000)
struct ManConversationManager_GlobalDictionarySetFloat final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionarySetFloat) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionarySetFloat");
static_assert(sizeof(ManConversationManager_GlobalDictionarySetFloat) == 0x000020, "Wrong size on ManConversationManager_GlobalDictionarySetFloat");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetFloat, Name_0) == 0x000000, "Member 'ManConversationManager_GlobalDictionarySetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetFloat, InValue) == 0x000008, "Member 'ManConversationManager_GlobalDictionarySetFloat::InValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetFloat, OnChanged) == 0x00000C, "Member 'ManConversationManager_GlobalDictionarySetFloat::OnChanged' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetFloat, ReturnValue) == 0x00001C, "Member 'ManConversationManager_GlobalDictionarySetFloat::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionarySetInt
// 0x0020 (0x0020 - 0x0000)
struct ManConversationManager_GlobalDictionarySetInt final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionarySetInt) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionarySetInt");
static_assert(sizeof(ManConversationManager_GlobalDictionarySetInt) == 0x000020, "Wrong size on ManConversationManager_GlobalDictionarySetInt");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetInt, Name_0) == 0x000000, "Member 'ManConversationManager_GlobalDictionarySetInt::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetInt, InValue) == 0x000008, "Member 'ManConversationManager_GlobalDictionarySetInt::InValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetInt, OnChanged) == 0x00000C, "Member 'ManConversationManager_GlobalDictionarySetInt::OnChanged' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetInt, ReturnValue) == 0x00001C, "Member 'ManConversationManager_GlobalDictionarySetInt::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionarySetString
// 0x0030 (0x0030 - 0x0000)
struct ManConversationManager_GlobalDictionarySetString final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InValue;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName EntryKey)>         OnChanged;                                         // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionarySetString) == 0x000008, "Wrong alignment on ManConversationManager_GlobalDictionarySetString");
static_assert(sizeof(ManConversationManager_GlobalDictionarySetString) == 0x000030, "Wrong size on ManConversationManager_GlobalDictionarySetString");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetString, Name_0) == 0x000000, "Member 'ManConversationManager_GlobalDictionarySetString::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetString, InValue) == 0x000008, "Member 'ManConversationManager_GlobalDictionarySetString::InValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetString, OnChanged) == 0x000018, "Member 'ManConversationManager_GlobalDictionarySetString::OnChanged' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionarySetString, ReturnValue) == 0x000028, "Member 'ManConversationManager_GlobalDictionarySetString::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalEntryChangedHandler
// 0x0008 (0x0008 - 0x0000)
struct ManConversationManager_GlobalEntryChangedHandler final
{
public:
	class FName                                   EntryKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManConversationManager_GlobalEntryChangedHandler) == 0x000004, "Wrong alignment on ManConversationManager_GlobalEntryChangedHandler");
static_assert(sizeof(ManConversationManager_GlobalEntryChangedHandler) == 0x000008, "Wrong size on ManConversationManager_GlobalEntryChangedHandler");
static_assert(offsetof(ManConversationManager_GlobalEntryChangedHandler, EntryKey) == 0x000000, "Member 'ManConversationManager_GlobalEntryChangedHandler::EntryKey' has a wrong offset!");

// Function man.ManConversationManager.LocalDictionarySetBool
// 0x000C (0x000C - 0x0000)
struct ManConversationManager_LocalDictionarySetBool final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValue;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_LocalDictionarySetBool) == 0x000004, "Wrong alignment on ManConversationManager_LocalDictionarySetBool");
static_assert(sizeof(ManConversationManager_LocalDictionarySetBool) == 0x00000C, "Wrong size on ManConversationManager_LocalDictionarySetBool");
static_assert(offsetof(ManConversationManager_LocalDictionarySetBool, Name_0) == 0x000000, "Member 'ManConversationManager_LocalDictionarySetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_LocalDictionarySetBool, InValue) == 0x000008, "Member 'ManConversationManager_LocalDictionarySetBool::InValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_LocalDictionarySetBool, ReturnValue) == 0x000009, "Member 'ManConversationManager_LocalDictionarySetBool::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.OnPlayerContextGlobalChanged
// 0x0008 (0x0008 - 0x0000)
struct ManConversationManager_OnPlayerContextGlobalChanged final
{
public:
	class FName                                   GlobalEntryKey;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManConversationManager_OnPlayerContextGlobalChanged) == 0x000004, "Wrong alignment on ManConversationManager_OnPlayerContextGlobalChanged");
static_assert(sizeof(ManConversationManager_OnPlayerContextGlobalChanged) == 0x000008, "Wrong size on ManConversationManager_OnPlayerContextGlobalChanged");
static_assert(offsetof(ManConversationManager_OnPlayerContextGlobalChanged, GlobalEntryKey) == 0x000000, "Member 'ManConversationManager_OnPlayerContextGlobalChanged::GlobalEntryKey' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionaryGetBool
// 0x0010 (0x0010 - 0x0000)
struct ManConversationManager_GlobalDictionaryGetBool final
{
public:
	bool                                          OutValue;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name_0;                                            // 0x0004(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionaryGetBool) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionaryGetBool");
static_assert(sizeof(ManConversationManager_GlobalDictionaryGetBool) == 0x000010, "Wrong size on ManConversationManager_GlobalDictionaryGetBool");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetBool, OutValue) == 0x000000, "Member 'ManConversationManager_GlobalDictionaryGetBool::OutValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetBool, Name_0) == 0x000004, "Member 'ManConversationManager_GlobalDictionaryGetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetBool, ReturnValue) == 0x00000C, "Member 'ManConversationManager_GlobalDictionaryGetBool::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionaryGetFloat
// 0x0010 (0x0010 - 0x0000)
struct ManConversationManager_GlobalDictionaryGetFloat final
{
public:
	float                                         OutValue;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0004(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionaryGetFloat) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionaryGetFloat");
static_assert(sizeof(ManConversationManager_GlobalDictionaryGetFloat) == 0x000010, "Wrong size on ManConversationManager_GlobalDictionaryGetFloat");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetFloat, OutValue) == 0x000000, "Member 'ManConversationManager_GlobalDictionaryGetFloat::OutValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetFloat, Name_0) == 0x000004, "Member 'ManConversationManager_GlobalDictionaryGetFloat::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetFloat, ReturnValue) == 0x00000C, "Member 'ManConversationManager_GlobalDictionaryGetFloat::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionaryGetInt
// 0x0010 (0x0010 - 0x0000)
struct ManConversationManager_GlobalDictionaryGetInt final
{
public:
	int32                                         OutValue;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0004(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionaryGetInt) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionaryGetInt");
static_assert(sizeof(ManConversationManager_GlobalDictionaryGetInt) == 0x000010, "Wrong size on ManConversationManager_GlobalDictionaryGetInt");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetInt, OutValue) == 0x000000, "Member 'ManConversationManager_GlobalDictionaryGetInt::OutValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetInt, Name_0) == 0x000004, "Member 'ManConversationManager_GlobalDictionaryGetInt::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetInt, ReturnValue) == 0x00000C, "Member 'ManConversationManager_GlobalDictionaryGetInt::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionaryGetString
// 0x0020 (0x0020 - 0x0000)
struct ManConversationManager_GlobalDictionaryGetString final
{
public:
	class FString                                 OutValue;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionaryGetString) == 0x000008, "Wrong alignment on ManConversationManager_GlobalDictionaryGetString");
static_assert(sizeof(ManConversationManager_GlobalDictionaryGetString) == 0x000020, "Wrong size on ManConversationManager_GlobalDictionaryGetString");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetString, OutValue) == 0x000000, "Member 'ManConversationManager_GlobalDictionaryGetString::OutValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetString, Name_0) == 0x000010, "Member 'ManConversationManager_GlobalDictionaryGetString::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryGetString, ReturnValue) == 0x000018, "Member 'ManConversationManager_GlobalDictionaryGetString::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.GlobalDictionaryIsExists
// 0x000C (0x000C - 0x0000)
struct ManConversationManager_GlobalDictionaryIsExists final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_GlobalDictionaryIsExists) == 0x000004, "Wrong alignment on ManConversationManager_GlobalDictionaryIsExists");
static_assert(sizeof(ManConversationManager_GlobalDictionaryIsExists) == 0x00000C, "Wrong size on ManConversationManager_GlobalDictionaryIsExists");
static_assert(offsetof(ManConversationManager_GlobalDictionaryIsExists, Name_0) == 0x000000, "Member 'ManConversationManager_GlobalDictionaryIsExists::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_GlobalDictionaryIsExists, ReturnValue) == 0x000008, "Member 'ManConversationManager_GlobalDictionaryIsExists::ReturnValue' has a wrong offset!");

// Function man.ManConversationManager.LocalDictionaryGetBool
// 0x0010 (0x0010 - 0x0000)
struct ManConversationManager_LocalDictionaryGetBool final
{
public:
	bool                                          OutValue;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name_0;                                            // 0x0004(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManConversationManager_LocalDictionaryGetBool) == 0x000004, "Wrong alignment on ManConversationManager_LocalDictionaryGetBool");
static_assert(sizeof(ManConversationManager_LocalDictionaryGetBool) == 0x000010, "Wrong size on ManConversationManager_LocalDictionaryGetBool");
static_assert(offsetof(ManConversationManager_LocalDictionaryGetBool, OutValue) == 0x000000, "Member 'ManConversationManager_LocalDictionaryGetBool::OutValue' has a wrong offset!");
static_assert(offsetof(ManConversationManager_LocalDictionaryGetBool, Name_0) == 0x000004, "Member 'ManConversationManager_LocalDictionaryGetBool::Name_0' has a wrong offset!");
static_assert(offsetof(ManConversationManager_LocalDictionaryGetBool, ReturnValue) == 0x00000C, "Member 'ManConversationManager_LocalDictionaryGetBool::ReturnValue' has a wrong offset!");

// Function man.MandrakeFightImplement.OnLootActorPickedUp
// 0x0008 (0x0008 - 0x0000)
struct MandrakeFightImplement_OnLootActorPickedUp final
{
public:
	class AActor*                                 LootActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandrakeFightImplement_OnLootActorPickedUp) == 0x000008, "Wrong alignment on MandrakeFightImplement_OnLootActorPickedUp");
static_assert(sizeof(MandrakeFightImplement_OnLootActorPickedUp) == 0x000008, "Wrong size on MandrakeFightImplement_OnLootActorPickedUp");
static_assert(offsetof(MandrakeFightImplement_OnLootActorPickedUp, LootActor) == 0x000000, "Member 'MandrakeFightImplement_OnLootActorPickedUp::LootActor' has a wrong offset!");

// Function man.MandrakeFightImplement.OnLootActorSpawned
// 0x0008 (0x0008 - 0x0000)
struct MandrakeFightImplement_OnLootActorSpawned final
{
public:
	class AActor*                                 LootActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandrakeFightImplement_OnLootActorSpawned) == 0x000008, "Wrong alignment on MandrakeFightImplement_OnLootActorSpawned");
static_assert(sizeof(MandrakeFightImplement_OnLootActorSpawned) == 0x000008, "Wrong size on MandrakeFightImplement_OnLootActorSpawned");
static_assert(offsetof(MandrakeFightImplement_OnLootActorSpawned, LootActor) == 0x000000, "Member 'MandrakeFightImplement_OnLootActorSpawned::LootActor' has a wrong offset!");

// Function man.MandrakeFightImplement.OnTeleportEnded
// 0x0010 (0x0010 - 0x0000)
struct MandrakeFightImplement_OnTeleportEnded final
{
public:
	class ADoorActorBase*                         DoorActorBase;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         Character;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandrakeFightImplement_OnTeleportEnded) == 0x000008, "Wrong alignment on MandrakeFightImplement_OnTeleportEnded");
static_assert(sizeof(MandrakeFightImplement_OnTeleportEnded) == 0x000010, "Wrong size on MandrakeFightImplement_OnTeleportEnded");
static_assert(offsetof(MandrakeFightImplement_OnTeleportEnded, DoorActorBase) == 0x000000, "Member 'MandrakeFightImplement_OnTeleportEnded::DoorActorBase' has a wrong offset!");
static_assert(offsetof(MandrakeFightImplement_OnTeleportEnded, Character) == 0x000008, "Member 'MandrakeFightImplement_OnTeleportEnded::Character' has a wrong offset!");

// Function man.MandrakeFightImplement.OnTeleportStarted
// 0x0010 (0x0010 - 0x0000)
struct MandrakeFightImplement_OnTeleportStarted final
{
public:
	class ADoorActorBase*                         DoorActorBase;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         Character;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MandrakeFightImplement_OnTeleportStarted) == 0x000008, "Wrong alignment on MandrakeFightImplement_OnTeleportStarted");
static_assert(sizeof(MandrakeFightImplement_OnTeleportStarted) == 0x000010, "Wrong size on MandrakeFightImplement_OnTeleportStarted");
static_assert(offsetof(MandrakeFightImplement_OnTeleportStarted, DoorActorBase) == 0x000000, "Member 'MandrakeFightImplement_OnTeleportStarted::DoorActorBase' has a wrong offset!");
static_assert(offsetof(MandrakeFightImplement_OnTeleportStarted, Character) == 0x000008, "Member 'MandrakeFightImplement_OnTeleportStarted::Character' has a wrong offset!");

// Function man.ManEngineEventHandler.OnLevelLoadFadeOutBegin
// 0x0001 (0x0001 - 0x0000)
struct ManEngineEventHandler_OnLevelLoadFadeOutBegin final
{
public:
	bool                                          bQuick;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManEngineEventHandler_OnLevelLoadFadeOutBegin) == 0x000001, "Wrong alignment on ManEngineEventHandler_OnLevelLoadFadeOutBegin");
static_assert(sizeof(ManEngineEventHandler_OnLevelLoadFadeOutBegin) == 0x000001, "Wrong size on ManEngineEventHandler_OnLevelLoadFadeOutBegin");
static_assert(offsetof(ManEngineEventHandler_OnLevelLoadFadeOutBegin, bQuick) == 0x000000, "Member 'ManEngineEventHandler_OnLevelLoadFadeOutBegin::bQuick' has a wrong offset!");

// Function man.TwoHandedSettings.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct TwoHandedSettings_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwoHandedSettings_GetEditorName) == 0x000008, "Wrong alignment on TwoHandedSettings_GetEditorName");
static_assert(sizeof(TwoHandedSettings_GetEditorName) == 0x000010, "Wrong size on TwoHandedSettings_GetEditorName");
static_assert(offsetof(TwoHandedSettings_GetEditorName, ReturnValue) == 0x000000, "Member 'TwoHandedSettings_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.AddDisableEnemyAI
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_AddDisableEnemyAI final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_AddDisableEnemyAI) == 0x000008, "Wrong alignment on ManGameplayLibrary_AddDisableEnemyAI");
static_assert(sizeof(ManGameplayLibrary_AddDisableEnemyAI) == 0x000008, "Wrong size on ManGameplayLibrary_AddDisableEnemyAI");
static_assert(offsetof(ManGameplayLibrary_AddDisableEnemyAI, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_AddDisableEnemyAI::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.AutomationTestQuitGame
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_AutomationTestQuitGame final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_AutomationTestQuitGame) == 0x000008, "Wrong alignment on ManGameplayLibrary_AutomationTestQuitGame");
static_assert(sizeof(ManGameplayLibrary_AutomationTestQuitGame) == 0x000008, "Wrong size on ManGameplayLibrary_AutomationTestQuitGame");
static_assert(offsetof(ManGameplayLibrary_AutomationTestQuitGame, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_AutomationTestQuitGame::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.BPDebugMessage
// 0x0038 (0x0038 - 0x0000)
struct ManGameplayLibrary_BPDebugMessage final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugString;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DebugObject1;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DebugObject2;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DebugObject3;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DebugObject4;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_BPDebugMessage) == 0x000008, "Wrong alignment on ManGameplayLibrary_BPDebugMessage");
static_assert(sizeof(ManGameplayLibrary_BPDebugMessage) == 0x000038, "Wrong size on ManGameplayLibrary_BPDebugMessage");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_BPDebugMessage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, DebugString) == 0x000008, "Member 'ManGameplayLibrary_BPDebugMessage::DebugString' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, DebugObject1) == 0x000018, "Member 'ManGameplayLibrary_BPDebugMessage::DebugObject1' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, DebugObject2) == 0x000020, "Member 'ManGameplayLibrary_BPDebugMessage::DebugObject2' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, DebugObject3) == 0x000028, "Member 'ManGameplayLibrary_BPDebugMessage::DebugObject3' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPDebugMessage, DebugObject4) == 0x000030, "Member 'ManGameplayLibrary_BPDebugMessage::DebugObject4' has a wrong offset!");

// Function man.ManGameplayLibrary.BPGetObjectDebugName
// 0x0020 (0x0020 - 0x0000)
struct ManGameplayLibrary_BPGetObjectDebugName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DebugObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_BPGetObjectDebugName) == 0x000008, "Wrong alignment on ManGameplayLibrary_BPGetObjectDebugName");
static_assert(sizeof(ManGameplayLibrary_BPGetObjectDebugName) == 0x000020, "Wrong size on ManGameplayLibrary_BPGetObjectDebugName");
static_assert(offsetof(ManGameplayLibrary_BPGetObjectDebugName, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_BPGetObjectDebugName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPGetObjectDebugName, DebugObject) == 0x000008, "Member 'ManGameplayLibrary_BPGetObjectDebugName::DebugObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_BPGetObjectDebugName, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_BPGetObjectDebugName::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.CanCastClassSoft
// 0x0040 (0x0040 - 0x0000)
struct ManGameplayLibrary_CanCastClassSoft final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftPtr;                                           // 0x0010(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubclass;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_CanCastClassSoft) == 0x000008, "Wrong alignment on ManGameplayLibrary_CanCastClassSoft");
static_assert(sizeof(ManGameplayLibrary_CanCastClassSoft) == 0x000040, "Wrong size on ManGameplayLibrary_CanCastClassSoft");
static_assert(offsetof(ManGameplayLibrary_CanCastClassSoft, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_CanCastClassSoft::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastClassSoft, Class_0) == 0x000008, "Member 'ManGameplayLibrary_CanCastClassSoft::Class_0' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastClassSoft, SoftPtr) == 0x000010, "Member 'ManGameplayLibrary_CanCastClassSoft::SoftPtr' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastClassSoft, bSubclass) == 0x000038, "Member 'ManGameplayLibrary_CanCastClassSoft::bSubclass' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastClassSoft, ReturnValue) == 0x000039, "Member 'ManGameplayLibrary_CanCastClassSoft::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.CanCastObjectSoft
// 0x0040 (0x0040 - 0x0000)
struct ManGameplayLibrary_CanCastObjectSoft final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftPtr;                                           // 0x0010(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubclass;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_CanCastObjectSoft) == 0x000008, "Wrong alignment on ManGameplayLibrary_CanCastObjectSoft");
static_assert(sizeof(ManGameplayLibrary_CanCastObjectSoft) == 0x000040, "Wrong size on ManGameplayLibrary_CanCastObjectSoft");
static_assert(offsetof(ManGameplayLibrary_CanCastObjectSoft, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_CanCastObjectSoft::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastObjectSoft, Object) == 0x000008, "Member 'ManGameplayLibrary_CanCastObjectSoft::Object' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastObjectSoft, SoftPtr) == 0x000010, "Member 'ManGameplayLibrary_CanCastObjectSoft::SoftPtr' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastObjectSoft, bSubclass) == 0x000038, "Member 'ManGameplayLibrary_CanCastObjectSoft::bSubclass' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastObjectSoft, ReturnValue) == 0x000039, "Member 'ManGameplayLibrary_CanCastObjectSoft::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.CanCastSoft
// 0x0040 (0x0040 - 0x0000)
struct ManGameplayLibrary_CanCastSoft final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftPtr;                                           // 0x0010(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubclass;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_CanCastSoft) == 0x000008, "Wrong alignment on ManGameplayLibrary_CanCastSoft");
static_assert(sizeof(ManGameplayLibrary_CanCastSoft) == 0x000040, "Wrong size on ManGameplayLibrary_CanCastSoft");
static_assert(offsetof(ManGameplayLibrary_CanCastSoft, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_CanCastSoft::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastSoft, Object) == 0x000008, "Member 'ManGameplayLibrary_CanCastSoft::Object' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastSoft, SoftPtr) == 0x000010, "Member 'ManGameplayLibrary_CanCastSoft::SoftPtr' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastSoft, bSubclass) == 0x000038, "Member 'ManGameplayLibrary_CanCastSoft::bSubclass' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanCastSoft, ReturnValue) == 0x000039, "Member 'ManGameplayLibrary_CanCastSoft::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.CanStartCutscene
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_CanStartCutscene final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_CanStartCutscene) == 0x000008, "Wrong alignment on ManGameplayLibrary_CanStartCutscene");
static_assert(sizeof(ManGameplayLibrary_CanStartCutscene) == 0x000010, "Wrong size on ManGameplayLibrary_CanStartCutscene");
static_assert(offsetof(ManGameplayLibrary_CanStartCutscene, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_CanStartCutscene::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_CanStartCutscene, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_CanStartCutscene::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.DebugCrash
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_DebugCrash final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_DebugCrash) == 0x000008, "Wrong alignment on ManGameplayLibrary_DebugCrash");
static_assert(sizeof(ManGameplayLibrary_DebugCrash) == 0x000008, "Wrong size on ManGameplayLibrary_DebugCrash");
static_assert(offsetof(ManGameplayLibrary_DebugCrash, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_DebugCrash::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.GetClassName
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_GetClassName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_GetClassName) == 0x000008, "Wrong alignment on ManGameplayLibrary_GetClassName");
static_assert(sizeof(ManGameplayLibrary_GetClassName) == 0x000018, "Wrong size on ManGameplayLibrary_GetClassName");
static_assert(offsetof(ManGameplayLibrary_GetClassName, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_GetClassName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetClassName, Class_0) == 0x000008, "Member 'ManGameplayLibrary_GetClassName::Class_0' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetClassName, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_GetClassName::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.GetDemoMode
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_GetDemoMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDemoMode                                     ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_GetDemoMode) == 0x000008, "Wrong alignment on ManGameplayLibrary_GetDemoMode");
static_assert(sizeof(ManGameplayLibrary_GetDemoMode) == 0x000010, "Wrong size on ManGameplayLibrary_GetDemoMode");
static_assert(offsetof(ManGameplayLibrary_GetDemoMode, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_GetDemoMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetDemoMode, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_GetDemoMode::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.GetManGameMode
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_GetManGameMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_GetManGameMode) == 0x000008, "Wrong alignment on ManGameplayLibrary_GetManGameMode");
static_assert(sizeof(ManGameplayLibrary_GetManGameMode) == 0x000010, "Wrong size on ManGameplayLibrary_GetManGameMode");
static_assert(offsetof(ManGameplayLibrary_GetManGameMode, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_GetManGameMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetManGameMode, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_GetManGameMode::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.GetManSurfaceLandingAudioEvent
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_GetManSurfaceLandingAudioEvent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurfaceSamplingID                            SamplingID;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_GetManSurfaceLandingAudioEvent) == 0x000008, "Wrong alignment on ManGameplayLibrary_GetManSurfaceLandingAudioEvent");
static_assert(sizeof(ManGameplayLibrary_GetManSurfaceLandingAudioEvent) == 0x000018, "Wrong size on ManGameplayLibrary_GetManSurfaceLandingAudioEvent");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceLandingAudioEvent, TargetActor) == 0x000000, "Member 'ManGameplayLibrary_GetManSurfaceLandingAudioEvent::TargetActor' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceLandingAudioEvent, SamplingID) == 0x000008, "Member 'ManGameplayLibrary_GetManSurfaceLandingAudioEvent::SamplingID' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceLandingAudioEvent, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_GetManSurfaceLandingAudioEvent::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.GetManSurfaceType
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_GetManSurfaceType final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurfaceSamplingID                            SamplingID;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USurfaceEffectTypeDataAsset*            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_GetManSurfaceType) == 0x000008, "Wrong alignment on ManGameplayLibrary_GetManSurfaceType");
static_assert(sizeof(ManGameplayLibrary_GetManSurfaceType) == 0x000018, "Wrong size on ManGameplayLibrary_GetManSurfaceType");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceType, TargetActor) == 0x000000, "Member 'ManGameplayLibrary_GetManSurfaceType::TargetActor' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceType, SamplingID) == 0x000008, "Member 'ManGameplayLibrary_GetManSurfaceType::SamplingID' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_GetManSurfaceType, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_GetManSurfaceType::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.InterruptHero
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_InterruptHero final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyCommandQueue;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_InterruptHero) == 0x000008, "Wrong alignment on ManGameplayLibrary_InterruptHero");
static_assert(sizeof(ManGameplayLibrary_InterruptHero) == 0x000010, "Wrong size on ManGameplayLibrary_InterruptHero");
static_assert(offsetof(ManGameplayLibrary_InterruptHero, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_InterruptHero::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_InterruptHero, bEmptyCommandQueue) == 0x000008, "Member 'ManGameplayLibrary_InterruptHero::bEmptyCommandQueue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsAbilityUpgradeUnlocked
// 0x0020 (0x0020 - 0x0000)
struct ManGameplayLibrary_IsAbilityUpgradeUnlocked final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeID;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsAbilityUpgradeUnlocked) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsAbilityUpgradeUnlocked");
static_assert(sizeof(ManGameplayLibrary_IsAbilityUpgradeUnlocked) == 0x000020, "Wrong size on ManGameplayLibrary_IsAbilityUpgradeUnlocked");
static_assert(offsetof(ManGameplayLibrary_IsAbilityUpgradeUnlocked, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_IsAbilityUpgradeUnlocked::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsAbilityUpgradeUnlocked, AbilityType) == 0x000008, "Member 'ManGameplayLibrary_IsAbilityUpgradeUnlocked::AbilityType' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsAbilityUpgradeUnlocked, UpgradeID) == 0x000010, "Member 'ManGameplayLibrary_IsAbilityUpgradeUnlocked::UpgradeID' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsAbilityUpgradeUnlocked, ReturnValue) == 0x000018, "Member 'ManGameplayLibrary_IsAbilityUpgradeUnlocked::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsActorRespawner
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_IsActorRespawner final
{
public:
	const class UObject*                          InObject;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsActorRespawner) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsActorRespawner");
static_assert(sizeof(ManGameplayLibrary_IsActorRespawner) == 0x000010, "Wrong size on ManGameplayLibrary_IsActorRespawner");
static_assert(offsetof(ManGameplayLibrary_IsActorRespawner, InObject) == 0x000000, "Member 'ManGameplayLibrary_IsActorRespawner::InObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsActorRespawner, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_IsActorRespawner::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsCheatAutoComplete
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_IsCheatAutoComplete final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsCheatAutoComplete) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsCheatAutoComplete");
static_assert(sizeof(ManGameplayLibrary_IsCheatAutoComplete) == 0x000010, "Wrong size on ManGameplayLibrary_IsCheatAutoComplete");
static_assert(offsetof(ManGameplayLibrary_IsCheatAutoComplete, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_IsCheatAutoComplete::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsCheatAutoComplete, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_IsCheatAutoComplete::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsDebugDisableLevelStartCutscenes
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_IsDebugDisableLevelStartCutscenes final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsDebugDisableLevelStartCutscenes) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsDebugDisableLevelStartCutscenes");
static_assert(sizeof(ManGameplayLibrary_IsDebugDisableLevelStartCutscenes) == 0x000010, "Wrong size on ManGameplayLibrary_IsDebugDisableLevelStartCutscenes");
static_assert(offsetof(ManGameplayLibrary_IsDebugDisableLevelStartCutscenes, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_IsDebugDisableLevelStartCutscenes::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsDebugDisableLevelStartCutscenes, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_IsDebugDisableLevelStartCutscenes::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsInputRestrict
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_IsInputRestrict final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsInputRestrict) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsInputRestrict");
static_assert(sizeof(ManGameplayLibrary_IsInputRestrict) == 0x000010, "Wrong size on ManGameplayLibrary_IsInputRestrict");
static_assert(offsetof(ManGameplayLibrary_IsInputRestrict, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_IsInputRestrict::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsInputRestrict, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_IsInputRestrict::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsManCheatEnabled
// 0x0001 (0x0001 - 0x0000)
struct ManGameplayLibrary_IsManCheatEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_IsManCheatEnabled) == 0x000001, "Wrong alignment on ManGameplayLibrary_IsManCheatEnabled");
static_assert(sizeof(ManGameplayLibrary_IsManCheatEnabled) == 0x000001, "Wrong size on ManGameplayLibrary_IsManCheatEnabled");
static_assert(offsetof(ManGameplayLibrary_IsManCheatEnabled, ReturnValue) == 0x000000, "Member 'ManGameplayLibrary_IsManCheatEnabled::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.IsManGamePaused
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_IsManGamePaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_IsManGamePaused) == 0x000008, "Wrong alignment on ManGameplayLibrary_IsManGamePaused");
static_assert(sizeof(ManGameplayLibrary_IsManGamePaused) == 0x000010, "Wrong size on ManGameplayLibrary_IsManGamePaused");
static_assert(offsetof(ManGameplayLibrary_IsManGamePaused, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_IsManGamePaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_IsManGamePaused, ReturnValue) == 0x000008, "Member 'ManGameplayLibrary_IsManGamePaused::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.LearnDiagram
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_LearnDiagram final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               Diagram;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_LearnDiagram) == 0x000008, "Wrong alignment on ManGameplayLibrary_LearnDiagram");
static_assert(sizeof(ManGameplayLibrary_LearnDiagram) == 0x000018, "Wrong size on ManGameplayLibrary_LearnDiagram");
static_assert(offsetof(ManGameplayLibrary_LearnDiagram, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_LearnDiagram::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_LearnDiagram, Diagram) == 0x000008, "Member 'ManGameplayLibrary_LearnDiagram::Diagram' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_LearnDiagram, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_LearnDiagram::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.RecallCutsceneInventory
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_RecallCutsceneInventory final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_RecallCutsceneInventory) == 0x000008, "Wrong alignment on ManGameplayLibrary_RecallCutsceneInventory");
static_assert(sizeof(ManGameplayLibrary_RecallCutsceneInventory) == 0x000008, "Wrong size on ManGameplayLibrary_RecallCutsceneInventory");
static_assert(offsetof(ManGameplayLibrary_RecallCutsceneInventory, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_RecallCutsceneInventory::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.RejuvenateHero
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_RejuvenateHero final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_RejuvenateHero) == 0x000008, "Wrong alignment on ManGameplayLibrary_RejuvenateHero");
static_assert(sizeof(ManGameplayLibrary_RejuvenateHero) == 0x000008, "Wrong size on ManGameplayLibrary_RejuvenateHero");
static_assert(offsetof(ManGameplayLibrary_RejuvenateHero, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_RejuvenateHero::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.RemoveDisableEnemyAI
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_RemoveDisableEnemyAI final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_RemoveDisableEnemyAI) == 0x000008, "Wrong alignment on ManGameplayLibrary_RemoveDisableEnemyAI");
static_assert(sizeof(ManGameplayLibrary_RemoveDisableEnemyAI) == 0x000008, "Wrong size on ManGameplayLibrary_RemoveDisableEnemyAI");
static_assert(offsetof(ManGameplayLibrary_RemoveDisableEnemyAI, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_RemoveDisableEnemyAI::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.RequestAutoSave
// 0x0008 (0x0008 - 0x0000)
struct ManGameplayLibrary_RequestAutoSave final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_RequestAutoSave) == 0x000008, "Wrong alignment on ManGameplayLibrary_RequestAutoSave");
static_assert(sizeof(ManGameplayLibrary_RequestAutoSave) == 0x000008, "Wrong size on ManGameplayLibrary_RequestAutoSave");
static_assert(offsetof(ManGameplayLibrary_RequestAutoSave, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_RequestAutoSave::WorldContextObject' has a wrong offset!");

// Function man.ManGameplayLibrary.SetCheckPointTravelEnabled
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_SetCheckPointTravelEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckpointData*                        CheckpointData;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_SetCheckPointTravelEnabled) == 0x000008, "Wrong alignment on ManGameplayLibrary_SetCheckPointTravelEnabled");
static_assert(sizeof(ManGameplayLibrary_SetCheckPointTravelEnabled) == 0x000018, "Wrong size on ManGameplayLibrary_SetCheckPointTravelEnabled");
static_assert(offsetof(ManGameplayLibrary_SetCheckPointTravelEnabled, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_SetCheckPointTravelEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetCheckPointTravelEnabled, CheckpointData) == 0x000008, "Member 'ManGameplayLibrary_SetCheckPointTravelEnabled::CheckpointData' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetCheckPointTravelEnabled, bEnabled) == 0x000010, "Member 'ManGameplayLibrary_SetCheckPointTravelEnabled::bEnabled' has a wrong offset!");

// Function man.ManGameplayLibrary.SetCutsceneInventory
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_SetCutsceneInventory final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDefaultInventory>          NewInventory;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_SetCutsceneInventory) == 0x000008, "Wrong alignment on ManGameplayLibrary_SetCutsceneInventory");
static_assert(sizeof(ManGameplayLibrary_SetCutsceneInventory) == 0x000010, "Wrong size on ManGameplayLibrary_SetCutsceneInventory");
static_assert(offsetof(ManGameplayLibrary_SetCutsceneInventory, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_SetCutsceneInventory::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetCutsceneInventory, NewInventory) == 0x000008, "Member 'ManGameplayLibrary_SetCutsceneInventory::NewInventory' has a wrong offset!");

// Function man.ManGameplayLibrary.SetManGamePaused
// 0x0010 (0x0010 - 0x0000)
struct ManGameplayLibrary_SetManGamePaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_SetManGamePaused) == 0x000008, "Wrong alignment on ManGameplayLibrary_SetManGamePaused");
static_assert(sizeof(ManGameplayLibrary_SetManGamePaused) == 0x000010, "Wrong size on ManGameplayLibrary_SetManGamePaused");
static_assert(offsetof(ManGameplayLibrary_SetManGamePaused, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_SetManGamePaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetManGamePaused, bPaused) == 0x000008, "Member 'ManGameplayLibrary_SetManGamePaused::bPaused' has a wrong offset!");

// Function man.ManGameplayLibrary.SetShopTableItemVisibility
// 0x0020 (0x0020 - 0x0000)
struct ManGameplayLibrary_SetShopTableItemVisibility final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorShopTable*                       ShopTable;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               Item;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_SetShopTableItemVisibility) == 0x000008, "Wrong alignment on ManGameplayLibrary_SetShopTableItemVisibility");
static_assert(sizeof(ManGameplayLibrary_SetShopTableItemVisibility) == 0x000020, "Wrong size on ManGameplayLibrary_SetShopTableItemVisibility");
static_assert(offsetof(ManGameplayLibrary_SetShopTableItemVisibility, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_SetShopTableItemVisibility::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetShopTableItemVisibility, ShopTable) == 0x000008, "Member 'ManGameplayLibrary_SetShopTableItemVisibility::ShopTable' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetShopTableItemVisibility, Item) == 0x000010, "Member 'ManGameplayLibrary_SetShopTableItemVisibility::Item' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SetShopTableItemVisibility, bVisible) == 0x000018, "Member 'ManGameplayLibrary_SetShopTableItemVisibility::bVisible' has a wrong offset!");

// Function man.ManGameplayLibrary.SpawnEnemyCharacter
// 0x0060 (0x0060 - 0x0000)
struct ManGameplayLibrary_SpawnEnemyCharacter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEnemyCharacter>            EnemyClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AVolume*                                AggroVolume;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawn;                                          // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeleteUponWorldReset;                             // 0x0049(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_SpawnEnemyCharacter) == 0x000010, "Wrong alignment on ManGameplayLibrary_SpawnEnemyCharacter");
static_assert(sizeof(ManGameplayLibrary_SpawnEnemyCharacter) == 0x000060, "Wrong size on ManGameplayLibrary_SpawnEnemyCharacter");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, EnemyClass) == 0x000008, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::EnemyClass' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, SpawnTransform) == 0x000010, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::SpawnTransform' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, AggroVolume) == 0x000040, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::AggroVolume' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, bRespawn) == 0x000048, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::bRespawn' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, bDeleteUponWorldReset) == 0x000049, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::bDeleteUponWorldReset' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_SpawnEnemyCharacter, ReturnValue) == 0x000050, "Member 'ManGameplayLibrary_SpawnEnemyCharacter::ReturnValue' has a wrong offset!");

// Function man.ManGameplayLibrary.ToggleInputRestrict
// 0x0018 (0x0018 - 0x0000)
struct ManGameplayLibrary_ToggleInputRestrict final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UniqueName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbility;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInventory;                                        // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemSetChange;                                    // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillSetChange;                                   // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuickUse;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggle;                                           // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManGameplayLibrary_ToggleInputRestrict) == 0x000008, "Wrong alignment on ManGameplayLibrary_ToggleInputRestrict");
static_assert(sizeof(ManGameplayLibrary_ToggleInputRestrict) == 0x000018, "Wrong size on ManGameplayLibrary_ToggleInputRestrict");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, WorldContextObject) == 0x000000, "Member 'ManGameplayLibrary_ToggleInputRestrict::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, UniqueName) == 0x000008, "Member 'ManGameplayLibrary_ToggleInputRestrict::UniqueName' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bAbility) == 0x000010, "Member 'ManGameplayLibrary_ToggleInputRestrict::bAbility' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bInventory) == 0x000011, "Member 'ManGameplayLibrary_ToggleInputRestrict::bInventory' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bItemSetChange) == 0x000012, "Member 'ManGameplayLibrary_ToggleInputRestrict::bItemSetChange' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bSkillSetChange) == 0x000013, "Member 'ManGameplayLibrary_ToggleInputRestrict::bSkillSetChange' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bQuickUse) == 0x000014, "Member 'ManGameplayLibrary_ToggleInputRestrict::bQuickUse' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ToggleInputRestrict, bToggle) == 0x000015, "Member 'ManGameplayLibrary_ToggleInputRestrict::bToggle' has a wrong offset!");

// Function man.ManGameplayLibrary.ValidateManDoOnceAutogeneratedName
// 0x0020 (0x0020 - 0x0000)
struct ManGameplayLibrary_ValidateManDoOnceAutogeneratedName final
{
public:
	class FString                                 inString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManGameplayLibrary_ValidateManDoOnceAutogeneratedName) == 0x000008, "Wrong alignment on ManGameplayLibrary_ValidateManDoOnceAutogeneratedName");
static_assert(sizeof(ManGameplayLibrary_ValidateManDoOnceAutogeneratedName) == 0x000020, "Wrong size on ManGameplayLibrary_ValidateManDoOnceAutogeneratedName");
static_assert(offsetof(ManGameplayLibrary_ValidateManDoOnceAutogeneratedName, inString) == 0x000000, "Member 'ManGameplayLibrary_ValidateManDoOnceAutogeneratedName::inString' has a wrong offset!");
static_assert(offsetof(ManGameplayLibrary_ValidateManDoOnceAutogeneratedName, ReturnValue) == 0x000010, "Member 'ManGameplayLibrary_ValidateManDoOnceAutogeneratedName::ReturnValue' has a wrong offset!");

// Function man.WitchLanternUserWidget.AttributeChanged
// 0x0008 (0x0008 - 0x0000)
struct WitchLanternUserWidget_AttributeChanged final
{
public:
	EAttribute                                    AttributeType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternUserWidget_AttributeChanged) == 0x000004, "Wrong alignment on WitchLanternUserWidget_AttributeChanged");
static_assert(sizeof(WitchLanternUserWidget_AttributeChanged) == 0x000008, "Wrong size on WitchLanternUserWidget_AttributeChanged");
static_assert(offsetof(WitchLanternUserWidget_AttributeChanged, AttributeType) == 0x000000, "Member 'WitchLanternUserWidget_AttributeChanged::AttributeType' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_AttributeChanged, Value) == 0x000004, "Member 'WitchLanternUserWidget_AttributeChanged::Value' has a wrong offset!");

// Function man.WitchLanternUserWidget.OnPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct WitchLanternUserWidget_OnPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WitchLanternUserWidget_OnPropertyChanged) == 0x000004, "Wrong alignment on WitchLanternUserWidget_OnPropertyChanged");
static_assert(sizeof(WitchLanternUserWidget_OnPropertyChanged) == 0x000014, "Wrong size on WitchLanternUserWidget_OnPropertyChanged");
static_assert(offsetof(WitchLanternUserWidget_OnPropertyChanged, PropertyType) == 0x000000, "Member 'WitchLanternUserWidget_OnPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnPropertyChanged, Value) == 0x000004, "Member 'WitchLanternUserWidget_OnPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'WitchLanternUserWidget_OnPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'WitchLanternUserWidget_OnPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnPropertyChanged, bAnimate) == 0x000010, "Member 'WitchLanternUserWidget_OnPropertyChanged::bAnimate' has a wrong offset!");

// Function man.WitchLanternUserWidget.OnSetTooltipData
// 0x0068 (0x0068 - 0x0000)
struct WitchLanternUserWidget_OnSetTooltipData final
{
public:
	ESkillTreeNodeState                           SkillTreeNodeState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_0;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   CostText;                                          // 0x0038(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   WarningText;                                       // 0x0050(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternUserWidget_OnSetTooltipData) == 0x000008, "Wrong alignment on WitchLanternUserWidget_OnSetTooltipData");
static_assert(sizeof(WitchLanternUserWidget_OnSetTooltipData) == 0x000068, "Wrong size on WitchLanternUserWidget_OnSetTooltipData");
static_assert(offsetof(WitchLanternUserWidget_OnSetTooltipData, SkillTreeNodeState) == 0x000000, "Member 'WitchLanternUserWidget_OnSetTooltipData::SkillTreeNodeState' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnSetTooltipData, Name_0) == 0x000008, "Member 'WitchLanternUserWidget_OnSetTooltipData::Name_0' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnSetTooltipData, Description) == 0x000020, "Member 'WitchLanternUserWidget_OnSetTooltipData::Description' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnSetTooltipData, CostText) == 0x000038, "Member 'WitchLanternUserWidget_OnSetTooltipData::CostText' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_OnSetTooltipData, WarningText) == 0x000050, "Member 'WitchLanternUserWidget_OnSetTooltipData::WarningText' has a wrong offset!");

// Function man.WitchLanternUserWidget.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct WitchLanternUserWidget_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WitchLanternUserWidget_PropertyChanged) == 0x000004, "Wrong alignment on WitchLanternUserWidget_PropertyChanged");
static_assert(sizeof(WitchLanternUserWidget_PropertyChanged) == 0x000014, "Wrong size on WitchLanternUserWidget_PropertyChanged");
static_assert(offsetof(WitchLanternUserWidget_PropertyChanged, PropertyType) == 0x000000, "Member 'WitchLanternUserWidget_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_PropertyChanged, Value) == 0x000004, "Member 'WitchLanternUserWidget_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'WitchLanternUserWidget_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'WitchLanternUserWidget_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(WitchLanternUserWidget_PropertyChanged, bAnimate) == 0x000010, "Member 'WitchLanternUserWidget_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.ManLevelScriptActor.DebugStuff
// 0x0018 (0x0018 - 0x0000)
struct ManLevelScriptActor_DebugStuff final
{
public:
	class AManLevelScriptActor*                   ManLevelScriptActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 inString;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLevelScriptActor_DebugStuff) == 0x000008, "Wrong alignment on ManLevelScriptActor_DebugStuff");
static_assert(sizeof(ManLevelScriptActor_DebugStuff) == 0x000018, "Wrong size on ManLevelScriptActor_DebugStuff");
static_assert(offsetof(ManLevelScriptActor_DebugStuff, ManLevelScriptActor) == 0x000000, "Member 'ManLevelScriptActor_DebugStuff::ManLevelScriptActor' has a wrong offset!");
static_assert(offsetof(ManLevelScriptActor_DebugStuff, inString) == 0x000008, "Member 'ManLevelScriptActor_DebugStuff::inString' has a wrong offset!");

// Function man.ManLootActor.OnHeroPreTravel
// 0x0020 (0x0020 - 0x0000)
struct ManLootActor_OnHeroPreTravel final
{
public:
	class ALevelVisualVolume*                     SourceLevelVisualVolume;                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelVisualVolume*                     TargetLevelVisualVolume;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewPos;                                            // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManLootActor_OnHeroPreTravel) == 0x000008, "Wrong alignment on ManLootActor_OnHeroPreTravel");
static_assert(sizeof(ManLootActor_OnHeroPreTravel) == 0x000020, "Wrong size on ManLootActor_OnHeroPreTravel");
static_assert(offsetof(ManLootActor_OnHeroPreTravel, SourceLevelVisualVolume) == 0x000000, "Member 'ManLootActor_OnHeroPreTravel::SourceLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(ManLootActor_OnHeroPreTravel, TargetLevelVisualVolume) == 0x000008, "Member 'ManLootActor_OnHeroPreTravel::TargetLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(ManLootActor_OnHeroPreTravel, NewPos) == 0x000010, "Member 'ManLootActor_OnHeroPreTravel::NewPos' has a wrong offset!");

// Function man.ManLootActor.OnStaticObjectPostCollide
// 0x0010 (0x0010 - 0x0000)
struct ManLootActor_OnStaticObjectPostCollide final
{
public:
	TArray<struct FHitResult>                     HitResult;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLootActor_OnStaticObjectPostCollide) == 0x000008, "Wrong alignment on ManLootActor_OnStaticObjectPostCollide");
static_assert(sizeof(ManLootActor_OnStaticObjectPostCollide) == 0x000010, "Wrong size on ManLootActor_OnStaticObjectPostCollide");
static_assert(offsetof(ManLootActor_OnStaticObjectPostCollide, HitResult) == 0x000000, "Member 'ManLootActor_OnStaticObjectPostCollide::HitResult' has a wrong offset!");

// Function man.ManLootActor.ToggleInactive
// 0x0001 (0x0001 - 0x0000)
struct ManLootActor_ToggleInactive final
{
public:
	bool                                          bSetInactive;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManLootActor_ToggleInactive) == 0x000001, "Wrong alignment on ManLootActor_ToggleInactive");
static_assert(sizeof(ManLootActor_ToggleInactive) == 0x000001, "Wrong size on ManLootActor_ToggleInactive");
static_assert(offsetof(ManLootActor_ToggleInactive, bSetInactive) == 0x000000, "Member 'ManLootActor_ToggleInactive::bSetInactive' has a wrong offset!");

// Function man.LootTableList.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct LootTableList_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootTableList_GetEditorName) == 0x000008, "Wrong alignment on LootTableList_GetEditorName");
static_assert(sizeof(LootTableList_GetEditorName) == 0x000010, "Wrong size on LootTableList_GetEditorName");
static_assert(offsetof(LootTableList_GetEditorName, ReturnValue) == 0x000000, "Member 'LootTableList_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.EntityLootTable.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct EntityLootTable_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EntityLootTable_GetEditorName) == 0x000008, "Wrong alignment on EntityLootTable_GetEditorName");
static_assert(sizeof(EntityLootTable_GetEditorName) == 0x000010, "Wrong size on EntityLootTable_GetEditorName");
static_assert(offsetof(EntityLootTable_GetEditorName, ReturnValue) == 0x000000, "Member 'EntityLootTable_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.ManOutlineVFXSubsystem.Get
// 0x0010 (0x0010 - 0x0000)
struct ManOutlineVFXSubsystem_Get final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManOutlineVFXSubsystem*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManOutlineVFXSubsystem_Get) == 0x000008, "Wrong alignment on ManOutlineVFXSubsystem_Get");
static_assert(sizeof(ManOutlineVFXSubsystem_Get) == 0x000010, "Wrong size on ManOutlineVFXSubsystem_Get");
static_assert(offsetof(ManOutlineVFXSubsystem_Get, WorldContextObject) == 0x000000, "Member 'ManOutlineVFXSubsystem_Get::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ManOutlineVFXSubsystem_Get, ReturnValue) == 0x000008, "Member 'ManOutlineVFXSubsystem_Get::ReturnValue' has a wrong offset!");

// Function man.TutorialPromptUserWidget.BPShow
// 0x0008 (0x0008 - 0x0000)
struct TutorialPromptUserWidget_BPShow final
{
public:
	class ATutorialPromptActor*                   InTutorialPromptActor;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptUserWidget_BPShow) == 0x000008, "Wrong alignment on TutorialPromptUserWidget_BPShow");
static_assert(sizeof(TutorialPromptUserWidget_BPShow) == 0x000008, "Wrong size on TutorialPromptUserWidget_BPShow");
static_assert(offsetof(TutorialPromptUserWidget_BPShow, InTutorialPromptActor) == 0x000000, "Member 'TutorialPromptUserWidget_BPShow::InTutorialPromptActor' has a wrong offset!");

// Function man.TutorialPromptUserWidget.OnAbilityChanged
// 0x0004 (0x0004 - 0x0000)
struct TutorialPromptUserWidget_OnAbilityChanged final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptUserWidget_OnAbilityChanged) == 0x000004, "Wrong alignment on TutorialPromptUserWidget_OnAbilityChanged");
static_assert(sizeof(TutorialPromptUserWidget_OnAbilityChanged) == 0x000004, "Wrong size on TutorialPromptUserWidget_OnAbilityChanged");
static_assert(offsetof(TutorialPromptUserWidget_OnAbilityChanged, SlotIndex) == 0x000000, "Member 'TutorialPromptUserWidget_OnAbilityChanged::SlotIndex' has a wrong offset!");

// Function man.ManPlayerController.OnApplicationActivationStateChanged
// 0x0001 (0x0001 - 0x0000)
struct ManPlayerController_OnApplicationActivationStateChanged final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManPlayerController_OnApplicationActivationStateChanged) == 0x000001, "Wrong alignment on ManPlayerController_OnApplicationActivationStateChanged");
static_assert(sizeof(ManPlayerController_OnApplicationActivationStateChanged) == 0x000001, "Wrong size on ManPlayerController_OnApplicationActivationStateChanged");
static_assert(offsetof(ManPlayerController_OnApplicationActivationStateChanged, bIsFocused) == 0x000000, "Member 'ManPlayerController_OnApplicationActivationStateChanged::bIsFocused' has a wrong offset!");

// Function man.ManPlayerController.GetManLocalPlayer
// 0x0008 (0x0008 - 0x0000)
struct ManPlayerController_GetManLocalPlayer final
{
public:
	class UManLocalPlayer*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManPlayerController_GetManLocalPlayer) == 0x000008, "Wrong alignment on ManPlayerController_GetManLocalPlayer");
static_assert(sizeof(ManPlayerController_GetManLocalPlayer) == 0x000008, "Wrong size on ManPlayerController_GetManLocalPlayer");
static_assert(offsetof(ManPlayerController_GetManLocalPlayer, ReturnValue) == 0x000000, "Member 'ManPlayerController_GetManLocalPlayer::ReturnValue' has a wrong offset!");

// Function man.VendorDiagram.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct VendorDiagram_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorDiagram_GetEditorName) == 0x000008, "Wrong alignment on VendorDiagram_GetEditorName");
static_assert(sizeof(VendorDiagram_GetEditorName) == 0x000010, "Wrong size on VendorDiagram_GetEditorName");
static_assert(offsetof(VendorDiagram_GetEditorName, ReturnValue) == 0x000000, "Member 'VendorDiagram_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddAreaReachedObjective
// 0x00A0 (0x00A0 - 0x0000)
struct ManQuest_AddAreaReachedObjective final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Story;                                             // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FTextAndStoryParams                    TextAndStoryParams;                                // 0x0038(0x0038)(Parm, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0070(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMapSegmentVolumeID*                    SegmentUniqueID;                                   // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     RequiredObjective;                                 // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalObjective;                                // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestFinisher;                                    // 0x0095(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreObjectiveCompletedEvent;                       // 0x0096(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97[0x1];                                       // 0x0097(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UManQuestObjectiveReachArea*            ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddAreaReachedObjective) == 0x000008, "Wrong alignment on ManQuest_AddAreaReachedObjective");
static_assert(sizeof(ManQuest_AddAreaReachedObjective) == 0x0000A0, "Wrong size on ManQuest_AddAreaReachedObjective");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, Name_0) == 0x000000, "Member 'ManQuest_AddAreaReachedObjective::Name_0' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, Text) == 0x000008, "Member 'ManQuest_AddAreaReachedObjective::Text' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, Story) == 0x000020, "Member 'ManQuest_AddAreaReachedObjective::Story' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, TextAndStoryParams) == 0x000038, "Member 'ManQuest_AddAreaReachedObjective::TextAndStoryParams' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, QuestMarker) == 0x000070, "Member 'ManQuest_AddAreaReachedObjective::QuestMarker' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, SegmentUniqueID) == 0x000080, "Member 'ManQuest_AddAreaReachedObjective::SegmentUniqueID' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, RequiredObjective) == 0x000088, "Member 'ManQuest_AddAreaReachedObjective::RequiredObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, RequiredProgress) == 0x000090, "Member 'ManQuest_AddAreaReachedObjective::RequiredProgress' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, bCriticalObjective) == 0x000094, "Member 'ManQuest_AddAreaReachedObjective::bCriticalObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, bQuestFinisher) == 0x000095, "Member 'ManQuest_AddAreaReachedObjective::bQuestFinisher' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, bPreObjectiveCompletedEvent) == 0x000096, "Member 'ManQuest_AddAreaReachedObjective::bPreObjectiveCompletedEvent' has a wrong offset!");
static_assert(offsetof(ManQuest_AddAreaReachedObjective, ReturnValue) == 0x000098, "Member 'ManQuest_AddAreaReachedObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddItemAquiredObjective
// 0x0080 (0x0080 - 0x0000)
struct ManQuest_AddItemAquiredObjective final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	bool                                          bHideCounter;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Story;                                             // 0x0028(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0040(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               ItemAbility;                                       // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQuantisedItemAbility>          RequiredItems;                                     // 0x0058(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     RequiredObjective;                                 // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalObjective;                                // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestFinisher;                                    // 0x0075(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreObjectiveCompletedEvent;                       // 0x0076(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77[0x1];                                       // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UManQuestObjectiveAcquireItems*         ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddItemAquiredObjective) == 0x000008, "Wrong alignment on ManQuest_AddItemAquiredObjective");
static_assert(sizeof(ManQuest_AddItemAquiredObjective) == 0x000080, "Wrong size on ManQuest_AddItemAquiredObjective");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, Name_0) == 0x000000, "Member 'ManQuest_AddItemAquiredObjective::Name_0' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, Text) == 0x000008, "Member 'ManQuest_AddItemAquiredObjective::Text' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, bHideCounter) == 0x000020, "Member 'ManQuest_AddItemAquiredObjective::bHideCounter' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, Story) == 0x000028, "Member 'ManQuest_AddItemAquiredObjective::Story' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, QuestMarker) == 0x000040, "Member 'ManQuest_AddItemAquiredObjective::QuestMarker' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, ItemAbility) == 0x000050, "Member 'ManQuest_AddItemAquiredObjective::ItemAbility' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, RequiredItems) == 0x000058, "Member 'ManQuest_AddItemAquiredObjective::RequiredItems' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, RequiredObjective) == 0x000068, "Member 'ManQuest_AddItemAquiredObjective::RequiredObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, RequiredProgress) == 0x000070, "Member 'ManQuest_AddItemAquiredObjective::RequiredProgress' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, bCriticalObjective) == 0x000074, "Member 'ManQuest_AddItemAquiredObjective::bCriticalObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, bQuestFinisher) == 0x000075, "Member 'ManQuest_AddItemAquiredObjective::bQuestFinisher' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, bPreObjectiveCompletedEvent) == 0x000076, "Member 'ManQuest_AddItemAquiredObjective::bPreObjectiveCompletedEvent' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemAquiredObjective, ReturnValue) == 0x000078, "Member 'ManQuest_AddItemAquiredObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddItemEquippedObjective
// 0x00A0 (0x00A0 - 0x0000)
struct ManQuest_AddItemEquippedObjective final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Story;                                             // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FTextAndStoryParams                    TextAndStoryParams;                                // 0x0038(0x0038)(Parm, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0070(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               ItemAbility;                                       // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     RequiredObjective;                                 // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalObjective;                                // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestFinisher;                                    // 0x0095(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreObjectiveCompletedEvent;                       // 0x0096(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97[0x1];                                       // 0x0097(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UManQuestObjectiveEquipItem*            ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddItemEquippedObjective) == 0x000008, "Wrong alignment on ManQuest_AddItemEquippedObjective");
static_assert(sizeof(ManQuest_AddItemEquippedObjective) == 0x0000A0, "Wrong size on ManQuest_AddItemEquippedObjective");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, Name_0) == 0x000000, "Member 'ManQuest_AddItemEquippedObjective::Name_0' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, Text) == 0x000008, "Member 'ManQuest_AddItemEquippedObjective::Text' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, Story) == 0x000020, "Member 'ManQuest_AddItemEquippedObjective::Story' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, TextAndStoryParams) == 0x000038, "Member 'ManQuest_AddItemEquippedObjective::TextAndStoryParams' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, QuestMarker) == 0x000070, "Member 'ManQuest_AddItemEquippedObjective::QuestMarker' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, ItemAbility) == 0x000080, "Member 'ManQuest_AddItemEquippedObjective::ItemAbility' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, RequiredObjective) == 0x000088, "Member 'ManQuest_AddItemEquippedObjective::RequiredObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, RequiredProgress) == 0x000090, "Member 'ManQuest_AddItemEquippedObjective::RequiredProgress' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, bCriticalObjective) == 0x000094, "Member 'ManQuest_AddItemEquippedObjective::bCriticalObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, bQuestFinisher) == 0x000095, "Member 'ManQuest_AddItemEquippedObjective::bQuestFinisher' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, bPreObjectiveCompletedEvent) == 0x000096, "Member 'ManQuest_AddItemEquippedObjective::bPreObjectiveCompletedEvent' has a wrong offset!");
static_assert(offsetof(ManQuest_AddItemEquippedObjective, ReturnValue) == 0x000098, "Member 'ManQuest_AddItemEquippedObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddKillObjective
// 0x00C0 (0x00C0 - 0x0000)
struct ManQuest_AddKillObjective final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Story;                                             // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FTextAndStoryParams                    TextAndStoryParams;                                // 0x0038(0x0038)(Parm, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0070(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ActorTypes;                                        // 0x0080(0x0010)(Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActorSoulNames;                                    // 0x0090(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     RequiredObjective;                                 // 0x00A0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x00A8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalObjective;                                // 0x00AC(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestFinisher;                                    // 0x00AD(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreObjectiveCompletedEvent;                       // 0x00AE(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseActorSouls;                                    // 0x00AF(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCounter;                                      // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UManQuestObjectiveKillEnemies*          ReturnValue;                                       // 0x00B8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddKillObjective) == 0x000008, "Wrong alignment on ManQuest_AddKillObjective");
static_assert(sizeof(ManQuest_AddKillObjective) == 0x0000C0, "Wrong size on ManQuest_AddKillObjective");
static_assert(offsetof(ManQuest_AddKillObjective, Name_0) == 0x000000, "Member 'ManQuest_AddKillObjective::Name_0' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, Text) == 0x000008, "Member 'ManQuest_AddKillObjective::Text' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, Story) == 0x000020, "Member 'ManQuest_AddKillObjective::Story' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, TextAndStoryParams) == 0x000038, "Member 'ManQuest_AddKillObjective::TextAndStoryParams' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, QuestMarker) == 0x000070, "Member 'ManQuest_AddKillObjective::QuestMarker' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, ActorTypes) == 0x000080, "Member 'ManQuest_AddKillObjective::ActorTypes' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, ActorSoulNames) == 0x000090, "Member 'ManQuest_AddKillObjective::ActorSoulNames' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, RequiredObjective) == 0x0000A0, "Member 'ManQuest_AddKillObjective::RequiredObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, RequiredProgress) == 0x0000A8, "Member 'ManQuest_AddKillObjective::RequiredProgress' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, bCriticalObjective) == 0x0000AC, "Member 'ManQuest_AddKillObjective::bCriticalObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, bQuestFinisher) == 0x0000AD, "Member 'ManQuest_AddKillObjective::bQuestFinisher' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, bPreObjectiveCompletedEvent) == 0x0000AE, "Member 'ManQuest_AddKillObjective::bPreObjectiveCompletedEvent' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, bUseActorSouls) == 0x0000AF, "Member 'ManQuest_AddKillObjective::bUseActorSouls' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, bShowCounter) == 0x0000B0, "Member 'ManQuest_AddKillObjective::bShowCounter' has a wrong offset!");
static_assert(offsetof(ManQuest_AddKillObjective, ReturnValue) == 0x0000B8, "Member 'ManQuest_AddKillObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddObjective
// 0x00A8 (0x00A8 - 0x0000)
struct ManQuest_AddObjective final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Story;                                             // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FTextAndStoryParams                    TextAndStoryParams;                                // 0x0038(0x0038)(Parm, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0070(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     RequiredObjective;                                 // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProgress;                                  // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalObjective;                                // 0x008C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuestFinisher;                                    // 0x008D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreObjectiveCompletedEvent;                       // 0x008E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentVariableName;                               // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxVariableName;                                   // 0x0098(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ReturnValue;                                       // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddObjective) == 0x000008, "Wrong alignment on ManQuest_AddObjective");
static_assert(sizeof(ManQuest_AddObjective) == 0x0000A8, "Wrong size on ManQuest_AddObjective");
static_assert(offsetof(ManQuest_AddObjective, Name_0) == 0x000000, "Member 'ManQuest_AddObjective::Name_0' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, Text) == 0x000008, "Member 'ManQuest_AddObjective::Text' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, Story) == 0x000020, "Member 'ManQuest_AddObjective::Story' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, TextAndStoryParams) == 0x000038, "Member 'ManQuest_AddObjective::TextAndStoryParams' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, QuestMarker) == 0x000070, "Member 'ManQuest_AddObjective::QuestMarker' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, RequiredObjective) == 0x000080, "Member 'ManQuest_AddObjective::RequiredObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, RequiredProgress) == 0x000088, "Member 'ManQuest_AddObjective::RequiredProgress' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, bCriticalObjective) == 0x00008C, "Member 'ManQuest_AddObjective::bCriticalObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, bQuestFinisher) == 0x00008D, "Member 'ManQuest_AddObjective::bQuestFinisher' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, bPreObjectiveCompletedEvent) == 0x00008E, "Member 'ManQuest_AddObjective::bPreObjectiveCompletedEvent' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, CurrentVariableName) == 0x000090, "Member 'ManQuest_AddObjective::CurrentVariableName' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, MaxVariableName) == 0x000098, "Member 'ManQuest_AddObjective::MaxVariableName' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjective, ReturnValue) == 0x0000A0, "Member 'ManQuest_AddObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddObjectiveReward
// 0x0038 (0x0038 - 0x0000)
struct ManQuest_AddObjectiveReward final
{
public:
	struct FQuestReward                           RewardToAdd;                                       // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     Objective;                                         // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_AddObjectiveReward) == 0x000008, "Wrong alignment on ManQuest_AddObjectiveReward");
static_assert(sizeof(ManQuest_AddObjectiveReward) == 0x000038, "Wrong size on ManQuest_AddObjectiveReward");
static_assert(offsetof(ManQuest_AddObjectiveReward, RewardToAdd) == 0x000000, "Member 'ManQuest_AddObjectiveReward::RewardToAdd' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjectiveReward, Objective) == 0x000028, "Member 'ManQuest_AddObjectiveReward::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddObjectiveReward, ReturnValue) == 0x000030, "Member 'ManQuest_AddObjectiveReward::ReturnValue' has a wrong offset!");

// Function man.ManQuest.AddQuestProgress
// 0x0028 (0x0028 - 0x0000)
struct ManQuest_AddQuestProgress final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComplete;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CallSource;                                        // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_AddQuestProgress) == 0x000008, "Wrong alignment on ManQuest_AddQuestProgress");
static_assert(sizeof(ManQuest_AddQuestProgress) == 0x000028, "Wrong size on ManQuest_AddQuestProgress");
static_assert(offsetof(ManQuest_AddQuestProgress, Objective) == 0x000000, "Member 'ManQuest_AddQuestProgress::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_AddQuestProgress, ObjectiveName) == 0x000008, "Member 'ManQuest_AddQuestProgress::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuest_AddQuestProgress, bComplete) == 0x000010, "Member 'ManQuest_AddQuestProgress::bComplete' has a wrong offset!");
static_assert(offsetof(ManQuest_AddQuestProgress, CallSource) == 0x000018, "Member 'ManQuest_AddQuestProgress::CallSource' has a wrong offset!");

// Function man.ManQuest.CheckQuestEventData
// 0x0068 (0x0068 - 0x0000)
struct ManQuest_CheckQuestEventData final
{
public:
	struct FQuestEventData                        IncomingData;                                      // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FObjectiveCompletionData               CompletionData;                                    // 0x0028(0x0038)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_CheckQuestEventData) == 0x000008, "Wrong alignment on ManQuest_CheckQuestEventData");
static_assert(sizeof(ManQuest_CheckQuestEventData) == 0x000068, "Wrong size on ManQuest_CheckQuestEventData");
static_assert(offsetof(ManQuest_CheckQuestEventData, IncomingData) == 0x000000, "Member 'ManQuest_CheckQuestEventData::IncomingData' has a wrong offset!");
static_assert(offsetof(ManQuest_CheckQuestEventData, CompletionData) == 0x000028, "Member 'ManQuest_CheckQuestEventData::CompletionData' has a wrong offset!");
static_assert(offsetof(ManQuest_CheckQuestEventData, ReturnValue) == 0x000060, "Member 'ManQuest_CheckQuestEventData::ReturnValue' has a wrong offset!");

// Function man.ManQuest.GetManGameMode
// 0x0008 (0x0008 - 0x0000)
struct ManQuest_GetManGameMode final
{
public:
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_GetManGameMode) == 0x000008, "Wrong alignment on ManQuest_GetManGameMode");
static_assert(sizeof(ManQuest_GetManGameMode) == 0x000008, "Wrong size on ManQuest_GetManGameMode");
static_assert(offsetof(ManQuest_GetManGameMode, ReturnValue) == 0x000000, "Member 'ManQuest_GetManGameMode::ReturnValue' has a wrong offset!");

// Function man.ManQuest.GetObjectiveRewardIcons
// 0x0018 (0x0018 - 0x0000)
struct ManQuest_GetObjectiveRewardIcons final
{
public:
	bool                                          bIncludeQuestReward;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_GetObjectiveRewardIcons) == 0x000008, "Wrong alignment on ManQuest_GetObjectiveRewardIcons");
static_assert(sizeof(ManQuest_GetObjectiveRewardIcons) == 0x000018, "Wrong size on ManQuest_GetObjectiveRewardIcons");
static_assert(offsetof(ManQuest_GetObjectiveRewardIcons, bIncludeQuestReward) == 0x000000, "Member 'ManQuest_GetObjectiveRewardIcons::bIncludeQuestReward' has a wrong offset!");
static_assert(offsetof(ManQuest_GetObjectiveRewardIcons, ReturnValue) == 0x000008, "Member 'ManQuest_GetObjectiveRewardIcons::ReturnValue' has a wrong offset!");

// Function man.ManQuest.GetQuestConclusion
// 0x0018 (0x0018 - 0x0000)
struct ManQuest_GetQuestConclusion final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_GetQuestConclusion) == 0x000008, "Wrong alignment on ManQuest_GetQuestConclusion");
static_assert(sizeof(ManQuest_GetQuestConclusion) == 0x000018, "Wrong size on ManQuest_GetQuestConclusion");
static_assert(offsetof(ManQuest_GetQuestConclusion, ReturnValue) == 0x000000, "Member 'ManQuest_GetQuestConclusion::ReturnValue' has a wrong offset!");

// Function man.ManQuest.GetQuestDisplayName
// 0x0018 (0x0018 - 0x0000)
struct ManQuest_GetQuestDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_GetQuestDisplayName) == 0x000008, "Wrong alignment on ManQuest_GetQuestDisplayName");
static_assert(sizeof(ManQuest_GetQuestDisplayName) == 0x000018, "Wrong size on ManQuest_GetQuestDisplayName");
static_assert(offsetof(ManQuest_GetQuestDisplayName, ReturnValue) == 0x000000, "Member 'ManQuest_GetQuestDisplayName::ReturnValue' has a wrong offset!");

// Function man.ManQuest.GetRequiredItemsText
// 0x0028 (0x0028 - 0x0000)
struct ManQuest_GetRequiredItemsText final
{
public:
	TArray<struct FQuantisedItemAbility>          RequiredItems;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_GetRequiredItemsText) == 0x000008, "Wrong alignment on ManQuest_GetRequiredItemsText");
static_assert(sizeof(ManQuest_GetRequiredItemsText) == 0x000028, "Wrong size on ManQuest_GetRequiredItemsText");
static_assert(offsetof(ManQuest_GetRequiredItemsText, RequiredItems) == 0x000000, "Member 'ManQuest_GetRequiredItemsText::RequiredItems' has a wrong offset!");
static_assert(offsetof(ManQuest_GetRequiredItemsText, ReturnValue) == 0x000010, "Member 'ManQuest_GetRequiredItemsText::ReturnValue' has a wrong offset!");

// Function man.ManQuest.HasFailedObjective
// 0x0001 (0x0001 - 0x0000)
struct ManQuest_HasFailedObjective final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_HasFailedObjective) == 0x000001, "Wrong alignment on ManQuest_HasFailedObjective");
static_assert(sizeof(ManQuest_HasFailedObjective) == 0x000001, "Wrong size on ManQuest_HasFailedObjective");
static_assert(offsetof(ManQuest_HasFailedObjective, ReturnValue) == 0x000000, "Member 'ManQuest_HasFailedObjective::ReturnValue' has a wrong offset!");

// Function man.ManQuest.IsObjectiveCompleted
// 0x0018 (0x0018 - 0x0000)
struct ManQuest_IsObjectiveCompleted final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_IsObjectiveCompleted) == 0x000008, "Wrong alignment on ManQuest_IsObjectiveCompleted");
static_assert(sizeof(ManQuest_IsObjectiveCompleted) == 0x000018, "Wrong size on ManQuest_IsObjectiveCompleted");
static_assert(offsetof(ManQuest_IsObjectiveCompleted, Objective) == 0x000000, "Member 'ManQuest_IsObjectiveCompleted::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_IsObjectiveCompleted, ObjectiveName) == 0x000008, "Member 'ManQuest_IsObjectiveCompleted::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuest_IsObjectiveCompleted, ReturnValue) == 0x000010, "Member 'ManQuest_IsObjectiveCompleted::ReturnValue' has a wrong offset!");

// Function man.ManQuest.IsObjectiveFailed
// 0x0018 (0x0018 - 0x0000)
struct ManQuest_IsObjectiveFailed final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_IsObjectiveFailed) == 0x000008, "Wrong alignment on ManQuest_IsObjectiveFailed");
static_assert(sizeof(ManQuest_IsObjectiveFailed) == 0x000018, "Wrong size on ManQuest_IsObjectiveFailed");
static_assert(offsetof(ManQuest_IsObjectiveFailed, Objective) == 0x000000, "Member 'ManQuest_IsObjectiveFailed::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_IsObjectiveFailed, ObjectiveName) == 0x000008, "Member 'ManQuest_IsObjectiveFailed::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuest_IsObjectiveFailed, ReturnValue) == 0x000010, "Member 'ManQuest_IsObjectiveFailed::ReturnValue' has a wrong offset!");

// Function man.ManQuest.IsQuestActive
// 0x0001 (0x0001 - 0x0000)
struct ManQuest_IsQuestActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_IsQuestActive) == 0x000001, "Wrong alignment on ManQuest_IsQuestActive");
static_assert(sizeof(ManQuest_IsQuestActive) == 0x000001, "Wrong size on ManQuest_IsQuestActive");
static_assert(offsetof(ManQuest_IsQuestActive, ReturnValue) == 0x000000, "Member 'ManQuest_IsQuestActive::ReturnValue' has a wrong offset!");

// Function man.ManQuest.IsQuestCompleted
// 0x0001 (0x0001 - 0x0000)
struct ManQuest_IsQuestCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_IsQuestCompleted) == 0x000001, "Wrong alignment on ManQuest_IsQuestCompleted");
static_assert(sizeof(ManQuest_IsQuestCompleted) == 0x000001, "Wrong size on ManQuest_IsQuestCompleted");
static_assert(offsetof(ManQuest_IsQuestCompleted, ReturnValue) == 0x000000, "Member 'ManQuest_IsQuestCompleted::ReturnValue' has a wrong offset!");

// Function man.ManQuest.IsQuestObjectiveCompleted
// 0x0010 (0x0010 - 0x0000)
struct ManQuest_IsQuestObjectiveCompleted final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_IsQuestObjectiveCompleted) == 0x000008, "Wrong alignment on ManQuest_IsQuestObjectiveCompleted");
static_assert(sizeof(ManQuest_IsQuestObjectiveCompleted) == 0x000010, "Wrong size on ManQuest_IsQuestObjectiveCompleted");
static_assert(offsetof(ManQuest_IsQuestObjectiveCompleted, Objective) == 0x000000, "Member 'ManQuest_IsQuestObjectiveCompleted::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_IsQuestObjectiveCompleted, ReturnValue) == 0x000008, "Member 'ManQuest_IsQuestObjectiveCompleted::ReturnValue' has a wrong offset!");

// Function man.ManQuest.OnGameplayQuestEvent
// 0x0028 (0x0028 - 0x0000)
struct ManQuest_OnGameplayQuestEvent final
{
public:
	struct FQuestEventData                        Data;                                              // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_OnGameplayQuestEvent) == 0x000008, "Wrong alignment on ManQuest_OnGameplayQuestEvent");
static_assert(sizeof(ManQuest_OnGameplayQuestEvent) == 0x000028, "Wrong size on ManQuest_OnGameplayQuestEvent");
static_assert(offsetof(ManQuest_OnGameplayQuestEvent, Data) == 0x000000, "Member 'ManQuest_OnGameplayQuestEvent::Data' has a wrong offset!");

// Function man.ManQuest.OnPreQuestObjectiveCompleted
// 0x0010 (0x0010 - 0x0000)
struct ManQuest_OnPreQuestObjectiveCompleted final
{
public:
	class UManQuestObjective*                     CompletedObjective;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowCompletion;                                   // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManQuest_OnPreQuestObjectiveCompleted) == 0x000008, "Wrong alignment on ManQuest_OnPreQuestObjectiveCompleted");
static_assert(sizeof(ManQuest_OnPreQuestObjectiveCompleted) == 0x000010, "Wrong size on ManQuest_OnPreQuestObjectiveCompleted");
static_assert(offsetof(ManQuest_OnPreQuestObjectiveCompleted, CompletedObjective) == 0x000000, "Member 'ManQuest_OnPreQuestObjectiveCompleted::CompletedObjective' has a wrong offset!");
static_assert(offsetof(ManQuest_OnPreQuestObjectiveCompleted, AllowCompletion) == 0x000008, "Member 'ManQuest_OnPreQuestObjectiveCompleted::AllowCompletion' has a wrong offset!");

// Function man.ManQuest.OnQuestObjectiveCompleted
// 0x0008 (0x0008 - 0x0000)
struct ManQuest_OnQuestObjectiveCompleted final
{
public:
	class UManQuestObjective*                     CompletedObjective;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_OnQuestObjectiveCompleted) == 0x000008, "Wrong alignment on ManQuest_OnQuestObjectiveCompleted");
static_assert(sizeof(ManQuest_OnQuestObjectiveCompleted) == 0x000008, "Wrong size on ManQuest_OnQuestObjectiveCompleted");
static_assert(offsetof(ManQuest_OnQuestObjectiveCompleted, CompletedObjective) == 0x000000, "Member 'ManQuest_OnQuestObjectiveCompleted::CompletedObjective' has a wrong offset!");

// Function man.ManQuest.OnQuestObjectiveFailed
// 0x0008 (0x0008 - 0x0000)
struct ManQuest_OnQuestObjectiveFailed final
{
public:
	class UManQuestObjective*                     FailedObjective;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_OnQuestObjectiveFailed) == 0x000008, "Wrong alignment on ManQuest_OnQuestObjectiveFailed");
static_assert(sizeof(ManQuest_OnQuestObjectiveFailed) == 0x000008, "Wrong size on ManQuest_OnQuestObjectiveFailed");
static_assert(offsetof(ManQuest_OnQuestObjectiveFailed, FailedObjective) == 0x000000, "Member 'ManQuest_OnQuestObjectiveFailed::FailedObjective' has a wrong offset!");

// Function man.ManQuest.SetObjectiveFailed
// 0x0010 (0x0010 - 0x0000)
struct ManQuest_SetObjectiveFailed final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_SetObjectiveFailed) == 0x000008, "Wrong alignment on ManQuest_SetObjectiveFailed");
static_assert(sizeof(ManQuest_SetObjectiveFailed) == 0x000010, "Wrong size on ManQuest_SetObjectiveFailed");
static_assert(offsetof(ManQuest_SetObjectiveFailed, Objective) == 0x000000, "Member 'ManQuest_SetObjectiveFailed::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_SetObjectiveFailed, ObjectiveName) == 0x000008, "Member 'ManQuest_SetObjectiveFailed::ObjectiveName' has a wrong offset!");

// Function man.ManQuest.SetObjectiveQuestMarker
// 0x0020 (0x0020 - 0x0000)
struct ManQuest_SetObjectiveQuestMarker final
{
public:
	class UManQuestObjective*                     Objective;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuestMarker                           QuestMarker;                                       // 0x0010(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManQuest_SetObjectiveQuestMarker) == 0x000008, "Wrong alignment on ManQuest_SetObjectiveQuestMarker");
static_assert(sizeof(ManQuest_SetObjectiveQuestMarker) == 0x000020, "Wrong size on ManQuest_SetObjectiveQuestMarker");
static_assert(offsetof(ManQuest_SetObjectiveQuestMarker, Objective) == 0x000000, "Member 'ManQuest_SetObjectiveQuestMarker::Objective' has a wrong offset!");
static_assert(offsetof(ManQuest_SetObjectiveQuestMarker, ObjectiveName) == 0x000008, "Member 'ManQuest_SetObjectiveQuestMarker::ObjectiveName' has a wrong offset!");
static_assert(offsetof(ManQuest_SetObjectiveQuestMarker, QuestMarker) == 0x000010, "Member 'ManQuest_SetObjectiveQuestMarker::QuestMarker' has a wrong offset!");

// Function man.ManSaveGameSettings.Save
// 0x0010 (0x0010 - 0x0000)
struct ManSaveGameSettings_Save final
{
public:
	class UManGameUserSettings*                   Settings;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ManSaveGameSettings_Save) == 0x000008, "Wrong alignment on ManSaveGameSettings_Save");
static_assert(sizeof(ManSaveGameSettings_Save) == 0x000010, "Wrong size on ManSaveGameSettings_Save");
static_assert(offsetof(ManSaveGameSettings_Save, Settings) == 0x000000, "Member 'ManSaveGameSettings_Save::Settings' has a wrong offset!");
static_assert(offsetof(ManSaveGameSettings_Save, ReturnValue) == 0x000008, "Member 'ManSaveGameSettings_Save::ReturnValue' has a wrong offset!");

// Function man.ManSaveManager.OnSaveAchToSlotFinish
// 0x0068 (0x0068 - 0x0000)
struct ManSaveManager_OnSaveAchToSlotFinish final
{
public:
	class FString                                 SaveName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManAchBundle                          pAchBundle;                                        // 0x0018(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSaveManager_OnSaveAchToSlotFinish) == 0x000008, "Wrong alignment on ManSaveManager_OnSaveAchToSlotFinish");
static_assert(sizeof(ManSaveManager_OnSaveAchToSlotFinish) == 0x000068, "Wrong size on ManSaveManager_OnSaveAchToSlotFinish");
static_assert(offsetof(ManSaveManager_OnSaveAchToSlotFinish, SaveName) == 0x000000, "Member 'ManSaveManager_OnSaveAchToSlotFinish::SaveName' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveAchToSlotFinish, PlayerIndex) == 0x000010, "Member 'ManSaveManager_OnSaveAchToSlotFinish::PlayerIndex' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveAchToSlotFinish, bResult) == 0x000014, "Member 'ManSaveManager_OnSaveAchToSlotFinish::bResult' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveAchToSlotFinish, pAchBundle) == 0x000018, "Member 'ManSaveManager_OnSaveAchToSlotFinish::pAchBundle' has a wrong offset!");

// Function man.ManSaveManager.OnSaveGamePreviewToSlotFinish
// 0x0030 (0x0030 - 0x0000)
struct ManSaveManager_OnSaveGamePreviewToSlotFinish final
{
public:
	class FString                                 SaveName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManSaveBundle                         SaveBundle;                                        // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSaveManager_OnSaveGamePreviewToSlotFinish) == 0x000008, "Wrong alignment on ManSaveManager_OnSaveGamePreviewToSlotFinish");
static_assert(sizeof(ManSaveManager_OnSaveGamePreviewToSlotFinish) == 0x000030, "Wrong size on ManSaveManager_OnSaveGamePreviewToSlotFinish");
static_assert(offsetof(ManSaveManager_OnSaveGamePreviewToSlotFinish, SaveName) == 0x000000, "Member 'ManSaveManager_OnSaveGamePreviewToSlotFinish::SaveName' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGamePreviewToSlotFinish, PlayerIndex) == 0x000010, "Member 'ManSaveManager_OnSaveGamePreviewToSlotFinish::PlayerIndex' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGamePreviewToSlotFinish, bResult) == 0x000014, "Member 'ManSaveManager_OnSaveGamePreviewToSlotFinish::bResult' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGamePreviewToSlotFinish, SaveBundle) == 0x000018, "Member 'ManSaveManager_OnSaveGamePreviewToSlotFinish::SaveBundle' has a wrong offset!");

// Function man.ManSaveManager.OnSaveGameToSlotFinish
// 0x0030 (0x0030 - 0x0000)
struct ManSaveManager_OnSaveGameToSlotFinish final
{
public:
	class FString                                 SaveName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManSaveBundle                         SaveBundle;                                        // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManSaveManager_OnSaveGameToSlotFinish) == 0x000008, "Wrong alignment on ManSaveManager_OnSaveGameToSlotFinish");
static_assert(sizeof(ManSaveManager_OnSaveGameToSlotFinish) == 0x000030, "Wrong size on ManSaveManager_OnSaveGameToSlotFinish");
static_assert(offsetof(ManSaveManager_OnSaveGameToSlotFinish, SaveName) == 0x000000, "Member 'ManSaveManager_OnSaveGameToSlotFinish::SaveName' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGameToSlotFinish, PlayerIndex) == 0x000010, "Member 'ManSaveManager_OnSaveGameToSlotFinish::PlayerIndex' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGameToSlotFinish, bResult) == 0x000014, "Member 'ManSaveManager_OnSaveGameToSlotFinish::bResult' has a wrong offset!");
static_assert(offsetof(ManSaveManager_OnSaveGameToSlotFinish, SaveBundle) == 0x000018, "Member 'ManSaveManager_OnSaveGameToSlotFinish::SaveBundle' has a wrong offset!");

// Function man.VoidBossAttackInhale.BPGetOuterCircleRadius
// 0x0004 (0x0004 - 0x0000)
struct VoidBossAttackInhale_BPGetOuterCircleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidBossAttackInhale_BPGetOuterCircleRadius) == 0x000004, "Wrong alignment on VoidBossAttackInhale_BPGetOuterCircleRadius");
static_assert(sizeof(VoidBossAttackInhale_BPGetOuterCircleRadius) == 0x000004, "Wrong size on VoidBossAttackInhale_BPGetOuterCircleRadius");
static_assert(offsetof(VoidBossAttackInhale_BPGetOuterCircleRadius, ReturnValue) == 0x000000, "Member 'VoidBossAttackInhale_BPGetOuterCircleRadius::ReturnValue' has a wrong offset!");

// Function man.VoidBossAttackInhale.IsCollideSignatureEx_Pre
// 0x0030 (0x0030 - 0x0000)
struct VoidBossAttackInhale_IsCollideSignatureEx_Pre final
{
public:
	struct FGroundMovecollideIsCollideSignatureParam Param;                                             // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidBossAttackInhale_IsCollideSignatureEx_Pre) == 0x000008, "Wrong alignment on VoidBossAttackInhale_IsCollideSignatureEx_Pre");
static_assert(sizeof(VoidBossAttackInhale_IsCollideSignatureEx_Pre) == 0x000030, "Wrong size on VoidBossAttackInhale_IsCollideSignatureEx_Pre");
static_assert(offsetof(VoidBossAttackInhale_IsCollideSignatureEx_Pre, Param) == 0x000000, "Member 'VoidBossAttackInhale_IsCollideSignatureEx_Pre::Param' has a wrong offset!");

// Function man.ManTriggerVolume.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManTriggerVolume_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManTriggerVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on ManTriggerVolume_OnBeginOverlap");
static_assert(sizeof(ManTriggerVolume_OnBeginOverlap) == 0x000010, "Wrong size on ManTriggerVolume_OnBeginOverlap");
static_assert(offsetof(ManTriggerVolume_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'ManTriggerVolume_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManTriggerVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'ManTriggerVolume_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.ManTriggerVolume.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct ManTriggerVolume_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ManTriggerVolume_OnEndOverlap) == 0x000008, "Wrong alignment on ManTriggerVolume_OnEndOverlap");
static_assert(sizeof(ManTriggerVolume_OnEndOverlap) == 0x000010, "Wrong size on ManTriggerVolume_OnEndOverlap");
static_assert(offsetof(ManTriggerVolume_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'ManTriggerVolume_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(ManTriggerVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'ManTriggerVolume_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.VoidRatSummonAbilitiy.GetResurrectTarget
// 0x0008 (0x0008 - 0x0000)
struct VoidRatSummonAbilitiy_GetResurrectTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidRatSummonAbilitiy_GetResurrectTarget) == 0x000008, "Wrong alignment on VoidRatSummonAbilitiy_GetResurrectTarget");
static_assert(sizeof(VoidRatSummonAbilitiy_GetResurrectTarget) == 0x000008, "Wrong size on VoidRatSummonAbilitiy_GetResurrectTarget");
static_assert(offsetof(VoidRatSummonAbilitiy_GetResurrectTarget, ReturnValue) == 0x000000, "Member 'VoidRatSummonAbilitiy_GetResurrectTarget::ReturnValue' has a wrong offset!");

// Function man.MovementSpeedModifierVolume.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct MovementSpeedModifierVolume_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementSpeedModifierVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on MovementSpeedModifierVolume_OnBeginOverlap");
static_assert(sizeof(MovementSpeedModifierVolume_OnBeginOverlap) == 0x000010, "Wrong size on MovementSpeedModifierVolume_OnBeginOverlap");
static_assert(offsetof(MovementSpeedModifierVolume_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'MovementSpeedModifierVolume_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(MovementSpeedModifierVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'MovementSpeedModifierVolume_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.MovementSpeedModifierVolume.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct MovementSpeedModifierVolume_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementSpeedModifierVolume_OnEndOverlap) == 0x000008, "Wrong alignment on MovementSpeedModifierVolume_OnEndOverlap");
static_assert(sizeof(MovementSpeedModifierVolume_OnEndOverlap) == 0x000010, "Wrong size on MovementSpeedModifierVolume_OnEndOverlap");
static_assert(offsetof(MovementSpeedModifierVolume_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'MovementSpeedModifierVolume_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(MovementSpeedModifierVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'MovementSpeedModifierVolume_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.VoidBossEntropyRainAbility.OnProjectileDestroyed
// 0x0008 (0x0008 - 0x0000)
struct VoidBossEntropyRainAbility_OnProjectileDestroyed final
{
public:
	class AActor*                                 ProjectileActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidBossEntropyRainAbility_OnProjectileDestroyed) == 0x000008, "Wrong alignment on VoidBossEntropyRainAbility_OnProjectileDestroyed");
static_assert(sizeof(VoidBossEntropyRainAbility_OnProjectileDestroyed) == 0x000008, "Wrong size on VoidBossEntropyRainAbility_OnProjectileDestroyed");
static_assert(offsetof(VoidBossEntropyRainAbility_OnProjectileDestroyed, ProjectileActor) == 0x000000, "Member 'VoidBossEntropyRainAbility_OnProjectileDestroyed::ProjectileActor' has a wrong offset!");

// Function man.VoidBossEntropyRainAbility.OnProjectileShot
// 0x0008 (0x0008 - 0x0000)
struct VoidBossEntropyRainAbility_OnProjectileShot final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidBossEntropyRainAbility_OnProjectileShot) == 0x000008, "Wrong alignment on VoidBossEntropyRainAbility_OnProjectileShot");
static_assert(sizeof(VoidBossEntropyRainAbility_OnProjectileShot) == 0x000008, "Wrong size on VoidBossEntropyRainAbility_OnProjectileShot");
static_assert(offsetof(VoidBossEntropyRainAbility_OnProjectileShot, Projectile) == 0x000000, "Member 'VoidBossEntropyRainAbility_OnProjectileShot::Projectile' has a wrong offset!");

// Function man.MapManager.BPOverrideGlobalTileEdges
// 0x0010 (0x0010 - 0x0000)
struct MapManager_BPOverrideGlobalTileEdges final
{
public:
	struct FIntPoint                              GlobalTilePos;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               TopEdge;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               RightEdge;                                         // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               BottomEdge;                                        // 0x000E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               LeftEdge;                                          // 0x000F(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapManager_BPOverrideGlobalTileEdges) == 0x000004, "Wrong alignment on MapManager_BPOverrideGlobalTileEdges");
static_assert(sizeof(MapManager_BPOverrideGlobalTileEdges) == 0x000010, "Wrong size on MapManager_BPOverrideGlobalTileEdges");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, GlobalTilePos) == 0x000000, "Member 'MapManager_BPOverrideGlobalTileEdges::GlobalTilePos' has a wrong offset!");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, LayerIndex) == 0x000008, "Member 'MapManager_BPOverrideGlobalTileEdges::LayerIndex' has a wrong offset!");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, TopEdge) == 0x00000C, "Member 'MapManager_BPOverrideGlobalTileEdges::TopEdge' has a wrong offset!");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, RightEdge) == 0x00000D, "Member 'MapManager_BPOverrideGlobalTileEdges::RightEdge' has a wrong offset!");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, BottomEdge) == 0x00000E, "Member 'MapManager_BPOverrideGlobalTileEdges::BottomEdge' has a wrong offset!");
static_assert(offsetof(MapManager_BPOverrideGlobalTileEdges, LeftEdge) == 0x00000F, "Member 'MapManager_BPOverrideGlobalTileEdges::LeftEdge' has a wrong offset!");

// Function man.MapManager.BPSetCheckPointUnlocked
// 0x0010 (0x0010 - 0x0000)
struct MapManager_BPSetCheckPointUnlocked final
{
public:
	class UCheckpointData*                        Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapManager_BPSetCheckPointUnlocked) == 0x000008, "Wrong alignment on MapManager_BPSetCheckPointUnlocked");
static_assert(sizeof(MapManager_BPSetCheckPointUnlocked) == 0x000010, "Wrong size on MapManager_BPSetCheckPointUnlocked");
static_assert(offsetof(MapManager_BPSetCheckPointUnlocked, Data) == 0x000000, "Member 'MapManager_BPSetCheckPointUnlocked::Data' has a wrong offset!");
static_assert(offsetof(MapManager_BPSetCheckPointUnlocked, ObjName) == 0x000008, "Member 'MapManager_BPSetCheckPointUnlocked::ObjName' has a wrong offset!");

// Function man.MapManager.GetCurrentLevelName
// 0x0008 (0x0008 - 0x0000)
struct MapManager_GetCurrentLevelName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapManager_GetCurrentLevelName) == 0x000004, "Wrong alignment on MapManager_GetCurrentLevelName");
static_assert(sizeof(MapManager_GetCurrentLevelName) == 0x000008, "Wrong size on MapManager_GetCurrentLevelName");
static_assert(offsetof(MapManager_GetCurrentLevelName, ReturnValue) == 0x000000, "Member 'MapManager_GetCurrentLevelName::ReturnValue' has a wrong offset!");

// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot0Icon
// 0x0010 (0x0010 - 0x0000)
struct VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon final
{
public:
	EDialogueType                                 DialogueType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon) == 0x000008, "Wrong alignment on VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon");
static_assert(sizeof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon) == 0x000010, "Wrong size on VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon, DialogueType) == 0x000000, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon::DialogueType' has a wrong offset!");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon, ReturnValue) == 0x000008, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot0Icon::ReturnValue' has a wrong offset!");

// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot0Name
// 0x0020 (0x0020 - 0x0000)
struct VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name final
{
public:
	EDialogueType                                 DialogueType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name) == 0x000008, "Wrong alignment on VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name");
static_assert(sizeof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name) == 0x000020, "Wrong size on VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name, DialogueType) == 0x000000, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name::DialogueType' has a wrong offset!");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name, ReturnValue) == 0x000008, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot0Name::ReturnValue' has a wrong offset!");

// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot1Icon
// 0x0010 (0x0010 - 0x0000)
struct VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon final
{
public:
	EDialogueType                                 DialogueType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon) == 0x000008, "Wrong alignment on VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon");
static_assert(sizeof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon) == 0x000010, "Wrong size on VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon, DialogueType) == 0x000000, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon::DialogueType' has a wrong offset!");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon, ReturnValue) == 0x000008, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot1Icon::ReturnValue' has a wrong offset!");

// Function man.VendorAlchemistUserWidget.GetConfirmationWindowSlot1Name
// 0x0020 (0x0020 - 0x0000)
struct VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name final
{
public:
	EDialogueType                                 DialogueType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name) == 0x000008, "Wrong alignment on VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name");
static_assert(sizeof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name) == 0x000020, "Wrong size on VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name, DialogueType) == 0x000000, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name::DialogueType' has a wrong offset!");
static_assert(offsetof(VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name, ReturnValue) == 0x000008, "Member 'VendorAlchemistUserWidget_GetConfirmationWindowSlot1Name::ReturnValue' has a wrong offset!");

// Function man.VendorAlchemistUserWidget.GetItemAbility
// 0x0010 (0x0010 - 0x0000)
struct VendorAlchemistUserWidget_GetItemAbility final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorAlchemistUserWidget_GetItemAbility) == 0x000008, "Wrong alignment on VendorAlchemistUserWidget_GetItemAbility");
static_assert(sizeof(VendorAlchemistUserWidget_GetItemAbility) == 0x000010, "Wrong size on VendorAlchemistUserWidget_GetItemAbility");
static_assert(offsetof(VendorAlchemistUserWidget_GetItemAbility, ManItemSlotBase) == 0x000000, "Member 'VendorAlchemistUserWidget_GetItemAbility::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(VendorAlchemistUserWidget_GetItemAbility, ReturnValue) == 0x000008, "Member 'VendorAlchemistUserWidget_GetItemAbility::ReturnValue' has a wrong offset!");

// Function man.MapWindowMarkerUserWidget.OnSetBtnVisiblity
// 0x0001 (0x0001 - 0x0000)
struct MapWindowMarkerUserWidget_OnSetBtnVisiblity final
{
public:
	ESlateVisibility                              SlateVisibility;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowMarkerUserWidget_OnSetBtnVisiblity) == 0x000001, "Wrong alignment on MapWindowMarkerUserWidget_OnSetBtnVisiblity");
static_assert(sizeof(MapWindowMarkerUserWidget_OnSetBtnVisiblity) == 0x000001, "Wrong size on MapWindowMarkerUserWidget_OnSetBtnVisiblity");
static_assert(offsetof(MapWindowMarkerUserWidget_OnSetBtnVisiblity, SlateVisibility) == 0x000000, "Member 'MapWindowMarkerUserWidget_OnSetBtnVisiblity::SlateVisibility' has a wrong offset!");

// Function man.MapWindowMarkerUserWidget.OnSetSelected
// 0x0001 (0x0001 - 0x0000)
struct MapWindowMarkerUserWidget_OnSetSelected final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowMarkerUserWidget_OnSetSelected) == 0x000001, "Wrong alignment on MapWindowMarkerUserWidget_OnSetSelected");
static_assert(sizeof(MapWindowMarkerUserWidget_OnSetSelected) == 0x000001, "Wrong size on MapWindowMarkerUserWidget_OnSetSelected");
static_assert(offsetof(MapWindowMarkerUserWidget_OnSetSelected, bInSelected) == 0x000000, "Member 'MapWindowMarkerUserWidget_OnSetSelected::bInSelected' has a wrong offset!");

// Function man.MapWindowUserWidget.GetMapObjectUserWidgets
// 0x0010 (0x0010 - 0x0000)
struct MapWindowUserWidget_GetMapObjectUserWidgets final
{
public:
	TArray<class UMapObjectUserWidget*>           ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_GetMapObjectUserWidgets) == 0x000008, "Wrong alignment on MapWindowUserWidget_GetMapObjectUserWidgets");
static_assert(sizeof(MapWindowUserWidget_GetMapObjectUserWidgets) == 0x000010, "Wrong size on MapWindowUserWidget_GetMapObjectUserWidgets");
static_assert(offsetof(MapWindowUserWidget_GetMapObjectUserWidgets, ReturnValue) == 0x000000, "Member 'MapWindowUserWidget_GetMapObjectUserWidgets::ReturnValue' has a wrong offset!");

// Function man.MapWindowUserWidget.OnChangeMapSegmentsScale
// 0x0004 (0x0004 - 0x0000)
struct MapWindowUserWidget_OnChangeMapSegmentsScale final
{
public:
	float                                         InCurrentZoomValue;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnChangeMapSegmentsScale) == 0x000004, "Wrong alignment on MapWindowUserWidget_OnChangeMapSegmentsScale");
static_assert(sizeof(MapWindowUserWidget_OnChangeMapSegmentsScale) == 0x000004, "Wrong size on MapWindowUserWidget_OnChangeMapSegmentsScale");
static_assert(offsetof(MapWindowUserWidget_OnChangeMapSegmentsScale, InCurrentZoomValue) == 0x000000, "Member 'MapWindowUserWidget_OnChangeMapSegmentsScale::InCurrentZoomValue' has a wrong offset!");

// Function man.MapWindowUserWidget.OnMiniMapElementChange
// 0x0008 (0x0008 - 0x0000)
struct MapWindowUserWidget_OnMiniMapElementChange final
{
public:
	class UMiniMapActorComponent*                 MiniMapActorComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnMiniMapElementChange) == 0x000008, "Wrong alignment on MapWindowUserWidget_OnMiniMapElementChange");
static_assert(sizeof(MapWindowUserWidget_OnMiniMapElementChange) == 0x000008, "Wrong size on MapWindowUserWidget_OnMiniMapElementChange");
static_assert(offsetof(MapWindowUserWidget_OnMiniMapElementChange, MiniMapActorComponent) == 0x000000, "Member 'MapWindowUserWidget_OnMiniMapElementChange::MiniMapActorComponent' has a wrong offset!");

// Function man.MapWindowUserWidget.OnPanEnabled
// 0x0001 (0x0001 - 0x0000)
struct MapWindowUserWidget_OnPanEnabled final
{
public:
	bool                                          bPanEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnPanEnabled) == 0x000001, "Wrong alignment on MapWindowUserWidget_OnPanEnabled");
static_assert(sizeof(MapWindowUserWidget_OnPanEnabled) == 0x000001, "Wrong size on MapWindowUserWidget_OnPanEnabled");
static_assert(offsetof(MapWindowUserWidget_OnPanEnabled, bPanEnabled) == 0x000000, "Member 'MapWindowUserWidget_OnPanEnabled::bPanEnabled' has a wrong offset!");

// Function man.MapWindowUserWidget.OnSetMapName
// 0x0018 (0x0018 - 0x0000)
struct MapWindowUserWidget_OnSetMapName final
{
public:
	class FText                                   InMapName;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnSetMapName) == 0x000008, "Wrong alignment on MapWindowUserWidget_OnSetMapName");
static_assert(sizeof(MapWindowUserWidget_OnSetMapName) == 0x000018, "Wrong size on MapWindowUserWidget_OnSetMapName");
static_assert(offsetof(MapWindowUserWidget_OnSetMapName, InMapName) == 0x000000, "Member 'MapWindowUserWidget_OnSetMapName::InMapName' has a wrong offset!");

// Function man.MapWindowUserWidget.OnSetMarkerNumText
// 0x0020 (0x0020 - 0x0000)
struct MapWindowUserWidget_OnSetMarkerNumText final
{
public:
	class FText                                   InMarkerNumText;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InCurrentMarkerNum;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxMarkerNum;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnSetMarkerNumText) == 0x000008, "Wrong alignment on MapWindowUserWidget_OnSetMarkerNumText");
static_assert(sizeof(MapWindowUserWidget_OnSetMarkerNumText) == 0x000020, "Wrong size on MapWindowUserWidget_OnSetMarkerNumText");
static_assert(offsetof(MapWindowUserWidget_OnSetMarkerNumText, InMarkerNumText) == 0x000000, "Member 'MapWindowUserWidget_OnSetMarkerNumText::InMarkerNumText' has a wrong offset!");
static_assert(offsetof(MapWindowUserWidget_OnSetMarkerNumText, InCurrentMarkerNum) == 0x000018, "Member 'MapWindowUserWidget_OnSetMarkerNumText::InCurrentMarkerNum' has a wrong offset!");
static_assert(offsetof(MapWindowUserWidget_OnSetMarkerNumText, InMaxMarkerNum) == 0x00001C, "Member 'MapWindowUserWidget_OnSetMarkerNumText::InMaxMarkerNum' has a wrong offset!");

// Function man.MapWindowUserWidget.OnSetOffscreenQuestIndicator
// 0x0008 (0x0008 - 0x0000)
struct MapWindowUserWidget_OnSetOffscreenQuestIndicator final
{
public:
	float                                         InrAngle;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRenderOpacity;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnSetOffscreenQuestIndicator) == 0x000004, "Wrong alignment on MapWindowUserWidget_OnSetOffscreenQuestIndicator");
static_assert(sizeof(MapWindowUserWidget_OnSetOffscreenQuestIndicator) == 0x000008, "Wrong size on MapWindowUserWidget_OnSetOffscreenQuestIndicator");
static_assert(offsetof(MapWindowUserWidget_OnSetOffscreenQuestIndicator, InrAngle) == 0x000000, "Member 'MapWindowUserWidget_OnSetOffscreenQuestIndicator::InrAngle' has a wrong offset!");
static_assert(offsetof(MapWindowUserWidget_OnSetOffscreenQuestIndicator, InRenderOpacity) == 0x000004, "Member 'MapWindowUserWidget_OnSetOffscreenQuestIndicator::InRenderOpacity' has a wrong offset!");

// Function man.MapWindowUserWidget.OnSetQuestText
// 0x0018 (0x0018 - 0x0000)
struct MapWindowUserWidget_OnSetQuestText final
{
public:
	class FText                                   InQuestText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnSetQuestText) == 0x000008, "Wrong alignment on MapWindowUserWidget_OnSetQuestText");
static_assert(sizeof(MapWindowUserWidget_OnSetQuestText) == 0x000018, "Wrong size on MapWindowUserWidget_OnSetQuestText");
static_assert(offsetof(MapWindowUserWidget_OnSetQuestText, InQuestText) == 0x000000, "Member 'MapWindowUserWidget_OnSetQuestText::InQuestText' has a wrong offset!");

// Function man.MapWindowUserWidget.OnShowLegend
// 0x0001 (0x0001 - 0x0000)
struct MapWindowUserWidget_OnShowLegend final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnShowLegend) == 0x000001, "Wrong alignment on MapWindowUserWidget_OnShowLegend");
static_assert(sizeof(MapWindowUserWidget_OnShowLegend) == 0x000001, "Wrong size on MapWindowUserWidget_OnShowLegend");
static_assert(offsetof(MapWindowUserWidget_OnShowLegend, bShow) == 0x000000, "Member 'MapWindowUserWidget_OnShowLegend::bShow' has a wrong offset!");

// Function man.MapWindowUserWidget.OnToggleMapLayer
// 0x0004 (0x0004 - 0x0000)
struct MapWindowUserWidget_OnToggleMapLayer final
{
public:
	int32                                         MapLayerIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_OnToggleMapLayer) == 0x000004, "Wrong alignment on MapWindowUserWidget_OnToggleMapLayer");
static_assert(sizeof(MapWindowUserWidget_OnToggleMapLayer) == 0x000004, "Wrong size on MapWindowUserWidget_OnToggleMapLayer");
static_assert(offsetof(MapWindowUserWidget_OnToggleMapLayer, MapLayerIndex) == 0x000000, "Member 'MapWindowUserWidget_OnToggleMapLayer::MapLayerIndex' has a wrong offset!");

// Function man.MapWindowUserWidget.GetCurrentMapLayerIndex
// 0x0004 (0x0004 - 0x0000)
struct MapWindowUserWidget_GetCurrentMapLayerIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapWindowUserWidget_GetCurrentMapLayerIndex) == 0x000004, "Wrong alignment on MapWindowUserWidget_GetCurrentMapLayerIndex");
static_assert(sizeof(MapWindowUserWidget_GetCurrentMapLayerIndex) == 0x000004, "Wrong size on MapWindowUserWidget_GetCurrentMapLayerIndex");
static_assert(offsetof(MapWindowUserWidget_GetCurrentMapLayerIndex, ReturnValue) == 0x000000, "Member 'MapWindowUserWidget_GetCurrentMapLayerIndex::ReturnValue' has a wrong offset!");

// Function man.VeteranPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct VeteranPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VeteranPassive_DamageDealt) == 0x000008, "Wrong alignment on VeteranPassive_DamageDealt");
static_assert(sizeof(VeteranPassive_DamageDealt) == 0x0002D8, "Wrong size on VeteranPassive_DamageDealt");
static_assert(offsetof(VeteranPassive_DamageDealt, Param) == 0x000000, "Member 'VeteranPassive_DamageDealt::Param' has a wrong offset!");

// Function man.MeltdownPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct MeltdownPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeltdownPassive_DamageDealt) == 0x000008, "Wrong alignment on MeltdownPassive_DamageDealt");
static_assert(sizeof(MeltdownPassive_DamageDealt) == 0x0002D8, "Wrong size on MeltdownPassive_DamageDealt");
static_assert(offsetof(MeltdownPassive_DamageDealt, Param) == 0x000000, "Member 'MeltdownPassive_DamageDealt::Param' has a wrong offset!");

// Function man.MeshSamplingVisualEntity.BPGetNiagaraAsset
// 0x0008 (0x0008 - 0x0000)
struct MeshSamplingVisualEntity_BPGetNiagaraAsset final
{
public:
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshSamplingVisualEntity_BPGetNiagaraAsset) == 0x000008, "Wrong alignment on MeshSamplingVisualEntity_BPGetNiagaraAsset");
static_assert(sizeof(MeshSamplingVisualEntity_BPGetNiagaraAsset) == 0x000008, "Wrong size on MeshSamplingVisualEntity_BPGetNiagaraAsset");
static_assert(offsetof(MeshSamplingVisualEntity_BPGetNiagaraAsset, ReturnValue) == 0x000000, "Member 'MeshSamplingVisualEntity_BPGetNiagaraAsset::ReturnValue' has a wrong offset!");

// Function man.MeshSamplingVisualEntity.IsOnHero
// 0x0001 (0x0001 - 0x0000)
struct MeshSamplingVisualEntity_IsOnHero final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshSamplingVisualEntity_IsOnHero) == 0x000001, "Wrong alignment on MeshSamplingVisualEntity_IsOnHero");
static_assert(sizeof(MeshSamplingVisualEntity_IsOnHero) == 0x000001, "Wrong size on MeshSamplingVisualEntity_IsOnHero");
static_assert(offsetof(MeshSamplingVisualEntity_IsOnHero, ReturnValue) == 0x000000, "Member 'MeshSamplingVisualEntity_IsOnHero::ReturnValue' has a wrong offset!");

// Function man.MeshSamplingVisualEntity.ToggleVFXOnMeshes
// 0x0002 (0x0002 - 0x0000)
struct MeshSamplingVisualEntity_ToggleVFXOnMeshes final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshSamplingVisualEntity_ToggleVFXOnMeshes) == 0x000001, "Wrong alignment on MeshSamplingVisualEntity_ToggleVFXOnMeshes");
static_assert(sizeof(MeshSamplingVisualEntity_ToggleVFXOnMeshes) == 0x000002, "Wrong size on MeshSamplingVisualEntity_ToggleVFXOnMeshes");
static_assert(offsetof(MeshSamplingVisualEntity_ToggleVFXOnMeshes, bActivate) == 0x000000, "Member 'MeshSamplingVisualEntity_ToggleVFXOnMeshes::bActivate' has a wrong offset!");
static_assert(offsetof(MeshSamplingVisualEntity_ToggleVFXOnMeshes, bReset) == 0x000001, "Member 'MeshSamplingVisualEntity_ToggleVFXOnMeshes::bReset' has a wrong offset!");

// Function man.MomentumFamiliarAbility.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct MomentumFamiliarAbility_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MomentumFamiliarAbility_PostDamageDealt) == 0x000008, "Wrong alignment on MomentumFamiliarAbility_PostDamageDealt");
static_assert(sizeof(MomentumFamiliarAbility_PostDamageDealt) == 0x0002D8, "Wrong size on MomentumFamiliarAbility_PostDamageDealt");
static_assert(offsetof(MomentumFamiliarAbility_PostDamageDealt, Param) == 0x000000, "Member 'MomentumFamiliarAbility_PostDamageDealt::Param' has a wrong offset!");

// Function man.MoveToTargetPointAbility.SetTargetPoint
// 0x000C (0x000C - 0x0000)
struct MoveToTargetPointAbility_SetTargetPoint final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoveToTargetPointAbility_SetTargetPoint) == 0x000004, "Wrong alignment on MoveToTargetPointAbility_SetTargetPoint");
static_assert(sizeof(MoveToTargetPointAbility_SetTargetPoint) == 0x00000C, "Wrong size on MoveToTargetPointAbility_SetTargetPoint");
static_assert(offsetof(MoveToTargetPointAbility_SetTargetPoint, Point) == 0x000000, "Member 'MoveToTargetPointAbility_SetTargetPoint::Point' has a wrong offset!");

// Function man.MusicManager.PostEventCallback
// 0x0010 (0x0010 - 0x0000)
struct MusicManager_PostEventCallback final
{
public:
	EAkCallbackType                               in_eType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkCallbackInfo*                        in_pCallbackInfo;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicManager_PostEventCallback) == 0x000008, "Wrong alignment on MusicManager_PostEventCallback");
static_assert(sizeof(MusicManager_PostEventCallback) == 0x000010, "Wrong size on MusicManager_PostEventCallback");
static_assert(offsetof(MusicManager_PostEventCallback, in_eType) == 0x000000, "Member 'MusicManager_PostEventCallback::in_eType' has a wrong offset!");
static_assert(offsetof(MusicManager_PostEventCallback, in_pCallbackInfo) == 0x000008, "Member 'MusicManager_PostEventCallback::in_pCallbackInfo' has a wrong offset!");

// Function man.NecroTormentedSoulProjectivePassive.OnProjectileApex
// 0x0004 (0x0004 - 0x0000)
struct NecroTormentedSoulProjectivePassive_OnProjectileApex final
{
public:
	float                                         RemainingTime;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NecroTormentedSoulProjectivePassive_OnProjectileApex) == 0x000004, "Wrong alignment on NecroTormentedSoulProjectivePassive_OnProjectileApex");
static_assert(sizeof(NecroTormentedSoulProjectivePassive_OnProjectileApex) == 0x000004, "Wrong size on NecroTormentedSoulProjectivePassive_OnProjectileApex");
static_assert(offsetof(NecroTormentedSoulProjectivePassive_OnProjectileApex, RemainingTime) == 0x000000, "Member 'NecroTormentedSoulProjectivePassive_OnProjectileApex::RemainingTime' has a wrong offset!");

// Function man.NecroTormentedSoul.BPPrecursorToggled
// 0x0014 (0x0014 - 0x0000)
struct NecroTormentedSoul_BPPrecursorToggled final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStarted;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrecursorLocation;                                 // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NecroTormentedSoul_BPPrecursorToggled) == 0x000004, "Wrong alignment on NecroTormentedSoul_BPPrecursorToggled");
static_assert(sizeof(NecroTormentedSoul_BPPrecursorToggled) == 0x000014, "Wrong size on NecroTormentedSoul_BPPrecursorToggled");
static_assert(offsetof(NecroTormentedSoul_BPPrecursorToggled, Index_0) == 0x000000, "Member 'NecroTormentedSoul_BPPrecursorToggled::Index_0' has a wrong offset!");
static_assert(offsetof(NecroTormentedSoul_BPPrecursorToggled, bStarted) == 0x000004, "Member 'NecroTormentedSoul_BPPrecursorToggled::bStarted' has a wrong offset!");
static_assert(offsetof(NecroTormentedSoul_BPPrecursorToggled, PrecursorLocation) == 0x000008, "Member 'NecroTormentedSoul_BPPrecursorToggled::PrecursorLocation' has a wrong offset!");

// Function man.NetherBlades.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct NetherBlades_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetherBlades_DamageDealt) == 0x000008, "Wrong alignment on NetherBlades_DamageDealt");
static_assert(sizeof(NetherBlades_DamageDealt) == 0x0002D8, "Wrong size on NetherBlades_DamageDealt");
static_assert(offsetof(NetherBlades_DamageDealt, Param) == 0x000000, "Member 'NetherBlades_DamageDealt::Param' has a wrong offset!");

// Function man.NetherBlades.GetTargetRotation
// 0x000C (0x000C - 0x0000)
struct NetherBlades_GetTargetRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetherBlades_GetTargetRotation) == 0x000004, "Wrong alignment on NetherBlades_GetTargetRotation");
static_assert(sizeof(NetherBlades_GetTargetRotation) == 0x00000C, "Wrong size on NetherBlades_GetTargetRotation");
static_assert(offsetof(NetherBlades_GetTargetRotation, ReturnValue) == 0x000000, "Member 'NetherBlades_GetTargetRotation::ReturnValue' has a wrong offset!");

// Function man.NetherwalkPassive.DamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct NetherwalkPassive_DamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NetherwalkPassive_DamageReceived) == 0x000008, "Wrong alignment on NetherwalkPassive_DamageReceived");
static_assert(sizeof(NetherwalkPassive_DamageReceived) == 0x0002D8, "Wrong size on NetherwalkPassive_DamageReceived");
static_assert(offsetof(NetherwalkPassive_DamageReceived, Param) == 0x000000, "Member 'NetherwalkPassive_DamageReceived::Param' has a wrong offset!");

// Function man.NewGameUserWidget.OnDeleteSaveGame
// 0x0008 (0x0008 - 0x0000)
struct NewGameUserWidget_OnDeleteSaveGame final
{
public:
	bool                                          bSucceeded;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotID;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NewGameUserWidget_OnDeleteSaveGame) == 0x000004, "Wrong alignment on NewGameUserWidget_OnDeleteSaveGame");
static_assert(sizeof(NewGameUserWidget_OnDeleteSaveGame) == 0x000008, "Wrong size on NewGameUserWidget_OnDeleteSaveGame");
static_assert(offsetof(NewGameUserWidget_OnDeleteSaveGame, bSucceeded) == 0x000000, "Member 'NewGameUserWidget_OnDeleteSaveGame::bSucceeded' has a wrong offset!");
static_assert(offsetof(NewGameUserWidget_OnDeleteSaveGame, SlotID) == 0x000004, "Member 'NewGameUserWidget_OnDeleteSaveGame::SlotID' has a wrong offset!");

// Function man.NewGameUserWidget.OnDialogueOverwriteSavedGameResult
// 0x0001 (0x0001 - 0x0000)
struct NewGameUserWidget_OnDialogueOverwriteSavedGameResult final
{
public:
	EDialogueButtonType                           ButtonType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NewGameUserWidget_OnDialogueOverwriteSavedGameResult) == 0x000001, "Wrong alignment on NewGameUserWidget_OnDialogueOverwriteSavedGameResult");
static_assert(sizeof(NewGameUserWidget_OnDialogueOverwriteSavedGameResult) == 0x000001, "Wrong size on NewGameUserWidget_OnDialogueOverwriteSavedGameResult");
static_assert(offsetof(NewGameUserWidget_OnDialogueOverwriteSavedGameResult, ButtonType) == 0x000000, "Member 'NewGameUserWidget_OnDialogueOverwriteSavedGameResult::ButtonType' has a wrong offset!");

// Function man.SunderAbility.AddIgnoredActor
// 0x0008 (0x0008 - 0x0000)
struct SunderAbility_AddIgnoredActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SunderAbility_AddIgnoredActor) == 0x000008, "Wrong alignment on SunderAbility_AddIgnoredActor");
static_assert(sizeof(SunderAbility_AddIgnoredActor) == 0x000008, "Wrong size on SunderAbility_AddIgnoredActor");
static_assert(offsetof(SunderAbility_AddIgnoredActor, Actor) == 0x000000, "Member 'SunderAbility_AddIgnoredActor::Actor' has a wrong offset!");

// Function man.SunderAbility.PostDamageCasued
// 0x02D8 (0x02D8 - 0x0000)
struct SunderAbility_PostDamageCasued final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SunderAbility_PostDamageCasued) == 0x000008, "Wrong alignment on SunderAbility_PostDamageCasued");
static_assert(sizeof(SunderAbility_PostDamageCasued) == 0x0002D8, "Wrong size on SunderAbility_PostDamageCasued");
static_assert(offsetof(SunderAbility_PostDamageCasued, Param) == 0x000000, "Member 'SunderAbility_PostDamageCasued::Param' has a wrong offset!");

// Function man.SunderAbility.PreDamageCasued
// 0x02D8 (0x02D8 - 0x0000)
struct SunderAbility_PreDamageCasued final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SunderAbility_PreDamageCasued) == 0x000008, "Wrong alignment on SunderAbility_PreDamageCasued");
static_assert(sizeof(SunderAbility_PreDamageCasued) == 0x0002D8, "Wrong size on SunderAbility_PreDamageCasued");
static_assert(offsetof(SunderAbility_PreDamageCasued, Param) == 0x000000, "Member 'SunderAbility_PreDamageCasued::Param' has a wrong offset!");

// Function man.NpcAnimInstance.SetLookRange
// 0x0030 (0x0030 - 0x0000)
struct NpcAnimInstance_SetLookRange final
{
public:
	struct FVector                                LookRangeMin;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookRangeMax;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookRangeHoldMin;                                  // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookRangeHoldMax;                                  // 0x0024(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NpcAnimInstance_SetLookRange) == 0x000004, "Wrong alignment on NpcAnimInstance_SetLookRange");
static_assert(sizeof(NpcAnimInstance_SetLookRange) == 0x000030, "Wrong size on NpcAnimInstance_SetLookRange");
static_assert(offsetof(NpcAnimInstance_SetLookRange, LookRangeMin) == 0x000000, "Member 'NpcAnimInstance_SetLookRange::LookRangeMin' has a wrong offset!");
static_assert(offsetof(NpcAnimInstance_SetLookRange, LookRangeMax) == 0x00000C, "Member 'NpcAnimInstance_SetLookRange::LookRangeMax' has a wrong offset!");
static_assert(offsetof(NpcAnimInstance_SetLookRange, LookRangeHoldMin) == 0x000018, "Member 'NpcAnimInstance_SetLookRange::LookRangeHoldMin' has a wrong offset!");
static_assert(offsetof(NpcAnimInstance_SetLookRange, LookRangeHoldMax) == 0x000024, "Member 'NpcAnimInstance_SetLookRange::LookRangeHoldMax' has a wrong offset!");

// Function man.NPCBestiaryBtnUserWidget.OnSetSlot
// 0x0020 (0x0020 - 0x0000)
struct NPCBestiaryBtnUserWidget_OnSetSlot final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInNewRegistry;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBestiaryBtnUserWidget_OnSetSlot) == 0x000008, "Wrong alignment on NPCBestiaryBtnUserWidget_OnSetSlot");
static_assert(sizeof(NPCBestiaryBtnUserWidget_OnSetSlot) == 0x000020, "Wrong size on NPCBestiaryBtnUserWidget_OnSetSlot");
static_assert(offsetof(NPCBestiaryBtnUserWidget_OnSetSlot, InName) == 0x000000, "Member 'NPCBestiaryBtnUserWidget_OnSetSlot::InName' has a wrong offset!");
static_assert(offsetof(NPCBestiaryBtnUserWidget_OnSetSlot, bInNewRegistry) == 0x000018, "Member 'NPCBestiaryBtnUserWidget_OnSetSlot::bInNewRegistry' has a wrong offset!");

// Function man.NPCBestiarySectionUserWidget.OnSetSlot
// 0x0008 (0x0008 - 0x0000)
struct NPCBestiarySectionUserWidget_OnSetSlot final
{
public:
	int32                                         InKillRequirement;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSectionHidden;                                  // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NPCBestiarySectionUserWidget_OnSetSlot) == 0x000004, "Wrong alignment on NPCBestiarySectionUserWidget_OnSetSlot");
static_assert(sizeof(NPCBestiarySectionUserWidget_OnSetSlot) == 0x000008, "Wrong size on NPCBestiarySectionUserWidget_OnSetSlot");
static_assert(offsetof(NPCBestiarySectionUserWidget_OnSetSlot, InKillRequirement) == 0x000000, "Member 'NPCBestiarySectionUserWidget_OnSetSlot::InKillRequirement' has a wrong offset!");
static_assert(offsetof(NPCBestiarySectionUserWidget_OnSetSlot, bInSectionHidden) == 0x000004, "Member 'NPCBestiarySectionUserWidget_OnSetSlot::bInSectionHidden' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.BPSetFilter
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryUserWidget_BPSetFilter final
{
public:
	EBestiaryCategory                             InBestiaryCategoryFilter;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_BPSetFilter) == 0x000001, "Wrong alignment on NPCBestiaryUserWidget_BPSetFilter");
static_assert(sizeof(NPCBestiaryUserWidget_BPSetFilter) == 0x000001, "Wrong size on NPCBestiaryUserWidget_BPSetFilter");
static_assert(offsetof(NPCBestiaryUserWidget_BPSetFilter, InBestiaryCategoryFilter) == 0x000000, "Member 'NPCBestiaryUserWidget_BPSetFilter::InBestiaryCategoryFilter' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.GetEntropyTexture
// 0x0008 (0x0008 - 0x0000)
struct NPCBestiaryUserWidget_GetEntropyTexture final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_GetEntropyTexture) == 0x000008, "Wrong alignment on NPCBestiaryUserWidget_GetEntropyTexture");
static_assert(sizeof(NPCBestiaryUserWidget_GetEntropyTexture) == 0x000008, "Wrong size on NPCBestiaryUserWidget_GetEntropyTexture");
static_assert(offsetof(NPCBestiaryUserWidget_GetEntropyTexture, ReturnValue) == 0x000000, "Member 'NPCBestiaryUserWidget_GetEntropyTexture::ReturnValue' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.JumpToPrevFilter
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryUserWidget_JumpToPrevFilter final
{
public:
	bool                                          bSelectLastPage;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_JumpToPrevFilter) == 0x000001, "Wrong alignment on NPCBestiaryUserWidget_JumpToPrevFilter");
static_assert(sizeof(NPCBestiaryUserWidget_JumpToPrevFilter) == 0x000001, "Wrong size on NPCBestiaryUserWidget_JumpToPrevFilter");
static_assert(offsetof(NPCBestiaryUserWidget_JumpToPrevFilter, bSelectLastPage) == 0x000000, "Member 'NPCBestiaryUserWidget_JumpToPrevFilter::bSelectLastPage' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.OnSetFilter
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryUserWidget_OnSetFilter final
{
public:
	EBestiaryCategory                             InBestiaryCategoryFilter;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_OnSetFilter) == 0x000001, "Wrong alignment on NPCBestiaryUserWidget_OnSetFilter");
static_assert(sizeof(NPCBestiaryUserWidget_OnSetFilter) == 0x000001, "Wrong size on NPCBestiaryUserWidget_OnSetFilter");
static_assert(offsetof(NPCBestiaryUserWidget_OnSetFilter, InBestiaryCategoryFilter) == 0x000000, "Member 'NPCBestiaryUserWidget_OnSetFilter::InBestiaryCategoryFilter' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.OnSetNextBtnState
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryUserWidget_OnSetNextBtnState final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_OnSetNextBtnState) == 0x000001, "Wrong alignment on NPCBestiaryUserWidget_OnSetNextBtnState");
static_assert(sizeof(NPCBestiaryUserWidget_OnSetNextBtnState) == 0x000001, "Wrong size on NPCBestiaryUserWidget_OnSetNextBtnState");
static_assert(offsetof(NPCBestiaryUserWidget_OnSetNextBtnState, bInEnabled) == 0x000000, "Member 'NPCBestiaryUserWidget_OnSetNextBtnState::bInEnabled' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.OnSetPrevBtnState
// 0x0001 (0x0001 - 0x0000)
struct NPCBestiaryUserWidget_OnSetPrevBtnState final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_OnSetPrevBtnState) == 0x000001, "Wrong alignment on NPCBestiaryUserWidget_OnSetPrevBtnState");
static_assert(sizeof(NPCBestiaryUserWidget_OnSetPrevBtnState) == 0x000001, "Wrong size on NPCBestiaryUserWidget_OnSetPrevBtnState");
static_assert(offsetof(NPCBestiaryUserWidget_OnSetPrevBtnState, bInEnabled) == 0x000000, "Member 'NPCBestiaryUserWidget_OnSetPrevBtnState::bInEnabled' has a wrong offset!");

// Function man.NPCBestiaryUserWidget.OnUpdateBestiaryPanels
// 0x0070 (0x0070 - 0x0000)
struct NPCBestiaryUserWidget_OnUpdateBestiaryPanels final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDescription;                                     // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UTexture2D*                       InPicture;                                         // 0x0030(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InKillNum;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InKillNumRequestForNextSection;                    // 0x0040(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InPageNumber;                                      // 0x0058(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels) == 0x000008, "Wrong alignment on NPCBestiaryUserWidget_OnUpdateBestiaryPanels");
static_assert(sizeof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels) == 0x000070, "Wrong size on NPCBestiaryUserWidget_OnUpdateBestiaryPanels");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InName) == 0x000000, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InName' has a wrong offset!");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InDescription) == 0x000018, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InDescription' has a wrong offset!");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InPicture) == 0x000030, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InPicture' has a wrong offset!");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InKillNum) == 0x000038, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InKillNum' has a wrong offset!");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InKillNumRequestForNextSection) == 0x000040, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InKillNumRequestForNextSection' has a wrong offset!");
static_assert(offsetof(NPCBestiaryUserWidget_OnUpdateBestiaryPanels, InPageNumber) == 0x000058, "Member 'NPCBestiaryUserWidget_OnUpdateBestiaryPanels::InPageNumber' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnApplyEnchant
// 0x0010 (0x0010 - 0x0000)
struct VendorEnchantUserWidget_OnApplyEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnApplyEnchant) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnApplyEnchant");
static_assert(sizeof(VendorEnchantUserWidget_OnApplyEnchant) == 0x000010, "Wrong size on VendorEnchantUserWidget_OnApplyEnchant");
static_assert(offsetof(VendorEnchantUserWidget_OnApplyEnchant, TargetItem) == 0x000000, "Member 'VendorEnchantUserWidget_OnApplyEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnApplyEnchant, Enchant) == 0x000008, "Member 'VendorEnchantUserWidget_OnApplyEnchant::Enchant' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnDestroyRune
// 0x0008 (0x0008 - 0x0000)
struct VendorEnchantUserWidget_OnDestroyRune final
{
public:
	const class UTexture2D*                       DestroyRuneIcon;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnDestroyRune) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnDestroyRune");
static_assert(sizeof(VendorEnchantUserWidget_OnDestroyRune) == 0x000008, "Wrong size on VendorEnchantUserWidget_OnDestroyRune");
static_assert(offsetof(VendorEnchantUserWidget_OnDestroyRune, DestroyRuneIcon) == 0x000000, "Member 'VendorEnchantUserWidget_OnDestroyRune::DestroyRuneIcon' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnRemoveEnchant
// 0x0010 (0x0010 - 0x0000)
struct VendorEnchantUserWidget_OnRemoveEnchant final
{
public:
	class UItemAbility*                           TargetItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemEnchantItemAbility>    Enchant;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnRemoveEnchant) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnRemoveEnchant");
static_assert(sizeof(VendorEnchantUserWidget_OnRemoveEnchant) == 0x000010, "Wrong size on VendorEnchantUserWidget_OnRemoveEnchant");
static_assert(offsetof(VendorEnchantUserWidget_OnRemoveEnchant, TargetItem) == 0x000000, "Member 'VendorEnchantUserWidget_OnRemoveEnchant::TargetItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnRemoveEnchant, Enchant) == 0x000008, "Member 'VendorEnchantUserWidget_OnRemoveEnchant::Enchant' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnSetEnchantText
// 0x0030 (0x0030 - 0x0000)
struct VendorEnchantUserWidget_OnSetEnchantText final
{
public:
	class FText                                   EnchantName;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   EnchantDescription;                                // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnSetEnchantText) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnSetEnchantText");
static_assert(sizeof(VendorEnchantUserWidget_OnSetEnchantText) == 0x000030, "Wrong size on VendorEnchantUserWidget_OnSetEnchantText");
static_assert(offsetof(VendorEnchantUserWidget_OnSetEnchantText, EnchantName) == 0x000000, "Member 'VendorEnchantUserWidget_OnSetEnchantText::EnchantName' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnSetEnchantText, EnchantDescription) == 0x000018, "Member 'VendorEnchantUserWidget_OnSetEnchantText::EnchantDescription' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnSetItem
// 0x0008 (0x0008 - 0x0000)
struct VendorEnchantUserWidget_OnSetItem final
{
public:
	class UItemAbility*                           Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnSetItem) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnSetItem");
static_assert(sizeof(VendorEnchantUserWidget_OnSetItem) == 0x000008, "Wrong size on VendorEnchantUserWidget_OnSetItem");
static_assert(offsetof(VendorEnchantUserWidget_OnSetItem, Item) == 0x000000, "Member 'VendorEnchantUserWidget_OnSetItem::Item' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnSetRightPanelSlots
// 0x0010 (0x0010 - 0x0000)
struct VendorEnchantUserWidget_OnSetRightPanelSlots final
{
public:
	class UItemAbility*                           UpgradeItem;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RuneStoneItem;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnSetRightPanelSlots) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnSetRightPanelSlots");
static_assert(sizeof(VendorEnchantUserWidget_OnSetRightPanelSlots) == 0x000010, "Wrong size on VendorEnchantUserWidget_OnSetRightPanelSlots");
static_assert(offsetof(VendorEnchantUserWidget_OnSetRightPanelSlots, UpgradeItem) == 0x000000, "Member 'VendorEnchantUserWidget_OnSetRightPanelSlots::UpgradeItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnSetRightPanelSlots, RuneStoneItem) == 0x000008, "Member 'VendorEnchantUserWidget_OnSetRightPanelSlots::RuneStoneItem' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnSetRuneStone
// 0x0008 (0x0008 - 0x0000)
struct VendorEnchantUserWidget_OnSetRuneStone final
{
public:
	class UItemAbility*                           RuneStoneItem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnSetRuneStone) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnSetRuneStone");
static_assert(sizeof(VendorEnchantUserWidget_OnSetRuneStone) == 0x000008, "Wrong size on VendorEnchantUserWidget_OnSetRuneStone");
static_assert(offsetof(VendorEnchantUserWidget_OnSetRuneStone, RuneStoneItem) == 0x000000, "Member 'VendorEnchantUserWidget_OnSetRuneStone::RuneStoneItem' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnUpdateUpgradeItemDetailsPanel
// 0x0038 (0x0038 - 0x0000)
struct VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel final
{
public:
	class FText                                   ItemRequirementText;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UItemAbility*                           InItem;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InComparedItem;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InEnchantItem;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel");
static_assert(sizeof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel) == 0x000038, "Wrong size on VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, ItemRequirementText) == 0x000000, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::ItemRequirementText' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, InItem) == 0x000018, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::InItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, InComparedItem) == 0x000020, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::InComparedItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, InEnchantItem) == 0x000028, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::InEnchantItem' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, bEquipped) == 0x000030, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::bEquipped' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel, bAnimate) == 0x000031, "Member 'VendorEnchantUserWidget_OnUpdateUpgradeItemDetailsPanel::bAnimate' has a wrong offset!");

// Function man.VendorEnchantUserWidget.OnUpgradeItem
// 0x0010 (0x0010 - 0x0000)
struct VendorEnchantUserWidget_OnUpgradeItem final
{
public:
	const class UTexture2D*                       UpgradeItemIcon;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UTexture2D*                       UpgradeRuneStoneIcon;                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_OnUpgradeItem) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_OnUpgradeItem");
static_assert(sizeof(VendorEnchantUserWidget_OnUpgradeItem) == 0x000010, "Wrong size on VendorEnchantUserWidget_OnUpgradeItem");
static_assert(offsetof(VendorEnchantUserWidget_OnUpgradeItem, UpgradeItemIcon) == 0x000000, "Member 'VendorEnchantUserWidget_OnUpgradeItem::UpgradeItemIcon' has a wrong offset!");
static_assert(offsetof(VendorEnchantUserWidget_OnUpgradeItem, UpgradeRuneStoneIcon) == 0x000008, "Member 'VendorEnchantUserWidget_OnUpgradeItem::UpgradeRuneStoneIcon' has a wrong offset!");

// Function man.VendorEnchantUserWidget.GetEnchantItemCalculatedXPText
// 0x0018 (0x0018 - 0x0000)
struct VendorEnchantUserWidget_GetEnchantItemCalculatedXPText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPText) == 0x000008, "Wrong alignment on VendorEnchantUserWidget_GetEnchantItemCalculatedXPText");
static_assert(sizeof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPText) == 0x000018, "Wrong size on VendorEnchantUserWidget_GetEnchantItemCalculatedXPText");
static_assert(offsetof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPText, ReturnValue) == 0x000000, "Member 'VendorEnchantUserWidget_GetEnchantItemCalculatedXPText::ReturnValue' has a wrong offset!");

// Function man.VendorEnchantUserWidget.GetEnchantItemCalculatedXPValue
// 0x0004 (0x0004 - 0x0000)
struct VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue) == 0x000004, "Wrong alignment on VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue");
static_assert(sizeof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue) == 0x000004, "Wrong size on VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue");
static_assert(offsetof(VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue, ReturnValue) == 0x000000, "Member 'VendorEnchantUserWidget_GetEnchantItemCalculatedXPValue::ReturnValue' has a wrong offset!");

// Function man.OpportunistWeakPointPassive.DamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct OpportunistWeakPointPassive_DamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OpportunistWeakPointPassive_DamageReceived) == 0x000008, "Wrong alignment on OpportunistWeakPointPassive_DamageReceived");
static_assert(sizeof(OpportunistWeakPointPassive_DamageReceived) == 0x0002D8, "Wrong size on OpportunistWeakPointPassive_DamageReceived");
static_assert(offsetof(OpportunistWeakPointPassive_DamageReceived, Param) == 0x000000, "Member 'OpportunistWeakPointPassive_DamageReceived::Param' has a wrong offset!");

// Function man.OptionsButtonUserWidget.GetIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsButtonUserWidget_GetIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsButtonUserWidget_GetIndex) == 0x000004, "Wrong alignment on OptionsButtonUserWidget_GetIndex");
static_assert(sizeof(OptionsButtonUserWidget_GetIndex) == 0x000004, "Wrong size on OptionsButtonUserWidget_GetIndex");
static_assert(offsetof(OptionsButtonUserWidget_GetIndex, ReturnValue) == 0x000000, "Member 'OptionsButtonUserWidget_GetIndex::ReturnValue' has a wrong offset!");

// Function man.OptionsButtonUserWidget.OnSetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OptionsButtonUserWidget_OnSetDisplayName final
{
public:
	class FText                                   InDisplayName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsButtonUserWidget_OnSetDisplayName) == 0x000008, "Wrong alignment on OptionsButtonUserWidget_OnSetDisplayName");
static_assert(sizeof(OptionsButtonUserWidget_OnSetDisplayName) == 0x000018, "Wrong size on OptionsButtonUserWidget_OnSetDisplayName");
static_assert(offsetof(OptionsButtonUserWidget_OnSetDisplayName, InDisplayName) == 0x000000, "Member 'OptionsButtonUserWidget_OnSetDisplayName::InDisplayName' has a wrong offset!");

// Function man.OptionsGeneralUserWidget.SetTextLanguageIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsGeneralUserWidget_SetTextLanguageIndex final
{
public:
	int32                                         TextLanguageIndex;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsGeneralUserWidget_SetTextLanguageIndex) == 0x000004, "Wrong alignment on OptionsGeneralUserWidget_SetTextLanguageIndex");
static_assert(sizeof(OptionsGeneralUserWidget_SetTextLanguageIndex) == 0x000004, "Wrong size on OptionsGeneralUserWidget_SetTextLanguageIndex");
static_assert(offsetof(OptionsGeneralUserWidget_SetTextLanguageIndex, TextLanguageIndex) == 0x000000, "Member 'OptionsGeneralUserWidget_SetTextLanguageIndex::TextLanguageIndex' has a wrong offset!");

// Function man.OptionsKeyBindingsUserWidget.OnSetUnboundText
// 0x0018 (0x0018 - 0x0000)
struct OptionsKeyBindingsUserWidget_OnSetUnboundText final
{
public:
	class FText                                   InUnboundText;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsKeyBindingsUserWidget_OnSetUnboundText) == 0x000008, "Wrong alignment on OptionsKeyBindingsUserWidget_OnSetUnboundText");
static_assert(sizeof(OptionsKeyBindingsUserWidget_OnSetUnboundText) == 0x000018, "Wrong size on OptionsKeyBindingsUserWidget_OnSetUnboundText");
static_assert(offsetof(OptionsKeyBindingsUserWidget_OnSetUnboundText, InUnboundText) == 0x000000, "Member 'OptionsKeyBindingsUserWidget_OnSetUnboundText::InUnboundText' has a wrong offset!");

// Function man.OptionsKeyBindingsUserWidget.SetMainWindowWidgetsZorder
// 0x0001 (0x0001 - 0x0000)
struct OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder final
{
public:
	EWidgetsZorder                                InMainWindowWidgetsZorder;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder) == 0x000001, "Wrong alignment on OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder");
static_assert(sizeof(OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder) == 0x000001, "Wrong size on OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder");
static_assert(offsetof(OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder, InMainWindowWidgetsZorder) == 0x000000, "Member 'OptionsKeyBindingsUserWidget_SetMainWindowWidgetsZorder::InMainWindowWidgetsZorder' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.OnSetActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSelectorUserWidget_OnSetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_OnSetActive) == 0x000001, "Wrong alignment on OptionsSelectorUserWidget_OnSetActive");
static_assert(sizeof(OptionsSelectorUserWidget_OnSetActive) == 0x000001, "Wrong size on OptionsSelectorUserWidget_OnSetActive");
static_assert(offsetof(OptionsSelectorUserWidget_OnSetActive, bInIsActive) == 0x000000, "Member 'OptionsSelectorUserWidget_OnSetActive::bInIsActive' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.OnSetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OptionsSelectorUserWidget_OnSetDisplayName final
{
public:
	class FText                                   InDisplayName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_OnSetDisplayName) == 0x000008, "Wrong alignment on OptionsSelectorUserWidget_OnSetDisplayName");
static_assert(sizeof(OptionsSelectorUserWidget_OnSetDisplayName) == 0x000018, "Wrong size on OptionsSelectorUserWidget_OnSetDisplayName");
static_assert(offsetof(OptionsSelectorUserWidget_OnSetDisplayName, InDisplayName) == 0x000000, "Member 'OptionsSelectorUserWidget_OnSetDisplayName::InDisplayName' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.OnSetHasChanged
// 0x0001 (0x0001 - 0x0000)
struct OptionsSelectorUserWidget_OnSetHasChanged final
{
public:
	bool                                          bInHasChanged;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_OnSetHasChanged) == 0x000001, "Wrong alignment on OptionsSelectorUserWidget_OnSetHasChanged");
static_assert(sizeof(OptionsSelectorUserWidget_OnSetHasChanged) == 0x000001, "Wrong size on OptionsSelectorUserWidget_OnSetHasChanged");
static_assert(offsetof(OptionsSelectorUserWidget_OnSetHasChanged, bInHasChanged) == 0x000000, "Member 'OptionsSelectorUserWidget_OnSetHasChanged::bInHasChanged' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.OnSetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsSelectorUserWidget_OnSetSelectedIndex final
{
public:
	int32                                         InSelectedIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_OnSetSelectedIndex) == 0x000004, "Wrong alignment on OptionsSelectorUserWidget_OnSetSelectedIndex");
static_assert(sizeof(OptionsSelectorUserWidget_OnSetSelectedIndex) == 0x000004, "Wrong size on OptionsSelectorUserWidget_OnSetSelectedIndex");
static_assert(offsetof(OptionsSelectorUserWidget_OnSetSelectedIndex, InSelectedIndex) == 0x000000, "Member 'OptionsSelectorUserWidget_OnSetSelectedIndex::InSelectedIndex' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.SetActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSelectorUserWidget_SetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_SetActive) == 0x000001, "Wrong alignment on OptionsSelectorUserWidget_SetActive");
static_assert(sizeof(OptionsSelectorUserWidget_SetActive) == 0x000001, "Wrong size on OptionsSelectorUserWidget_SetActive");
static_assert(offsetof(OptionsSelectorUserWidget_SetActive, bInIsActive) == 0x000000, "Member 'OptionsSelectorUserWidget_SetActive::bInIsActive' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.SetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct OptionsSelectorUserWidget_SetSelectedIndex final
{
public:
	int32                                         InSelectedIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_SetSelectedIndex) == 0x000004, "Wrong alignment on OptionsSelectorUserWidget_SetSelectedIndex");
static_assert(sizeof(OptionsSelectorUserWidget_SetSelectedIndex) == 0x000004, "Wrong size on OptionsSelectorUserWidget_SetSelectedIndex");
static_assert(offsetof(OptionsSelectorUserWidget_SetSelectedIndex, InSelectedIndex) == 0x000000, "Member 'OptionsSelectorUserWidget_SetSelectedIndex::InSelectedIndex' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.ValueChanged
// 0x0004 (0x0004 - 0x0000)
struct OptionsSelectorUserWidget_ValueChanged final
{
public:
	int32                                         NewIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_ValueChanged) == 0x000004, "Wrong alignment on OptionsSelectorUserWidget_ValueChanged");
static_assert(sizeof(OptionsSelectorUserWidget_ValueChanged) == 0x000004, "Wrong size on OptionsSelectorUserWidget_ValueChanged");
static_assert(offsetof(OptionsSelectorUserWidget_ValueChanged, NewIndex) == 0x000000, "Member 'OptionsSelectorUserWidget_ValueChanged::NewIndex' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.GetOptions
// 0x0010 (0x0010 - 0x0000)
struct OptionsSelectorUserWidget_GetOptions final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_GetOptions) == 0x000008, "Wrong alignment on OptionsSelectorUserWidget_GetOptions");
static_assert(sizeof(OptionsSelectorUserWidget_GetOptions) == 0x000010, "Wrong size on OptionsSelectorUserWidget_GetOptions");
static_assert(offsetof(OptionsSelectorUserWidget_GetOptions, ReturnValue) == 0x000000, "Member 'OptionsSelectorUserWidget_GetOptions::ReturnValue' has a wrong offset!");

// Function man.OptionsSelectorUserWidget.IsActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSelectorUserWidget_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSelectorUserWidget_IsActive) == 0x000001, "Wrong alignment on OptionsSelectorUserWidget_IsActive");
static_assert(sizeof(OptionsSelectorUserWidget_IsActive) == 0x000001, "Wrong size on OptionsSelectorUserWidget_IsActive");
static_assert(offsetof(OptionsSelectorUserWidget_IsActive, ReturnValue) == 0x000000, "Member 'OptionsSelectorUserWidget_IsActive::ReturnValue' has a wrong offset!");

// Function man.RatingObject_Glicko.SetRating
// 0x0004 (0x0004 - 0x0000)
struct RatingObject_Glicko_SetRating final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_SetRating) == 0x000004, "Wrong alignment on RatingObject_Glicko_SetRating");
static_assert(sizeof(RatingObject_Glicko_SetRating) == 0x000004, "Wrong size on RatingObject_Glicko_SetRating");
static_assert(offsetof(RatingObject_Glicko_SetRating, Value) == 0x000000, "Member 'RatingObject_Glicko_SetRating::Value' has a wrong offset!");

// Function man.RatingObject_Glicko.SetRatingsDeviation
// 0x0004 (0x0004 - 0x0000)
struct RatingObject_Glicko_SetRatingsDeviation final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_SetRatingsDeviation) == 0x000004, "Wrong alignment on RatingObject_Glicko_SetRatingsDeviation");
static_assert(sizeof(RatingObject_Glicko_SetRatingsDeviation) == 0x000004, "Wrong size on RatingObject_Glicko_SetRatingsDeviation");
static_assert(offsetof(RatingObject_Glicko_SetRatingsDeviation, Value) == 0x000000, "Member 'RatingObject_Glicko_SetRatingsDeviation::Value' has a wrong offset!");

// Function man.RatingObject_Glicko.UpdateToTime
// 0x000C (0x000C - 0x0000)
struct RatingObject_Glicko_UpdateToTime final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRatingsDeviation;                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationChange;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_UpdateToTime) == 0x000004, "Wrong alignment on RatingObject_Glicko_UpdateToTime");
static_assert(sizeof(RatingObject_Glicko_UpdateToTime) == 0x00000C, "Wrong size on RatingObject_Glicko_UpdateToTime");
static_assert(offsetof(RatingObject_Glicko_UpdateToTime, Timestamp) == 0x000000, "Member 'RatingObject_Glicko_UpdateToTime::Timestamp' has a wrong offset!");
static_assert(offsetof(RatingObject_Glicko_UpdateToTime, InitialRatingsDeviation) == 0x000004, "Member 'RatingObject_Glicko_UpdateToTime::InitialRatingsDeviation' has a wrong offset!");
static_assert(offsetof(RatingObject_Glicko_UpdateToTime, DeviationChange) == 0x000008, "Member 'RatingObject_Glicko_UpdateToTime::DeviationChange' has a wrong offset!");

// Function man.RatingObject_Glicko.GetRating
// 0x0004 (0x0004 - 0x0000)
struct RatingObject_Glicko_GetRating final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_GetRating) == 0x000004, "Wrong alignment on RatingObject_Glicko_GetRating");
static_assert(sizeof(RatingObject_Glicko_GetRating) == 0x000004, "Wrong size on RatingObject_Glicko_GetRating");
static_assert(offsetof(RatingObject_Glicko_GetRating, ReturnValue) == 0x000000, "Member 'RatingObject_Glicko_GetRating::ReturnValue' has a wrong offset!");

// Function man.RatingObject_Glicko.GetRatingsDeviation
// 0x0004 (0x0004 - 0x0000)
struct RatingObject_Glicko_GetRatingsDeviation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_GetRatingsDeviation) == 0x000004, "Wrong alignment on RatingObject_Glicko_GetRatingsDeviation");
static_assert(sizeof(RatingObject_Glicko_GetRatingsDeviation) == 0x000004, "Wrong size on RatingObject_Glicko_GetRatingsDeviation");
static_assert(offsetof(RatingObject_Glicko_GetRatingsDeviation, ReturnValue) == 0x000000, "Member 'RatingObject_Glicko_GetRatingsDeviation::ReturnValue' has a wrong offset!");

// Function man.RatingObject_Glicko.GetRatingValue
// 0x0004 (0x0004 - 0x0000)
struct RatingObject_Glicko_GetRatingValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObject_Glicko_GetRatingValue) == 0x000004, "Wrong alignment on RatingObject_Glicko_GetRatingValue");
static_assert(sizeof(RatingObject_Glicko_GetRatingValue) == 0x000004, "Wrong size on RatingObject_Glicko_GetRatingValue");
static_assert(offsetof(RatingObject_Glicko_GetRatingValue, ReturnValue) == 0x000000, "Member 'RatingObject_Glicko_GetRatingValue::ReturnValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.GetOptionsType
// 0x0001 (0x0001 - 0x0000)
struct OptionsSliderUserWidget_GetOptionsType final
{
public:
	EOptionsType                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_GetOptionsType) == 0x000001, "Wrong alignment on OptionsSliderUserWidget_GetOptionsType");
static_assert(sizeof(OptionsSliderUserWidget_GetOptionsType) == 0x000001, "Wrong size on OptionsSliderUserWidget_GetOptionsType");
static_assert(offsetof(OptionsSliderUserWidget_GetOptionsType, ReturnValue) == 0x000000, "Member 'OptionsSliderUserWidget_GetOptionsType::ReturnValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.OnSetActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSliderUserWidget_OnSetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_OnSetActive) == 0x000001, "Wrong alignment on OptionsSliderUserWidget_OnSetActive");
static_assert(sizeof(OptionsSliderUserWidget_OnSetActive) == 0x000001, "Wrong size on OptionsSliderUserWidget_OnSetActive");
static_assert(offsetof(OptionsSliderUserWidget_OnSetActive, bInIsActive) == 0x000000, "Member 'OptionsSliderUserWidget_OnSetActive::bInIsActive' has a wrong offset!");

// Function man.OptionsSliderUserWidget.OnSetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OptionsSliderUserWidget_OnSetDisplayName final
{
public:
	class FText                                   InDisplayName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_OnSetDisplayName) == 0x000008, "Wrong alignment on OptionsSliderUserWidget_OnSetDisplayName");
static_assert(sizeof(OptionsSliderUserWidget_OnSetDisplayName) == 0x000018, "Wrong size on OptionsSliderUserWidget_OnSetDisplayName");
static_assert(offsetof(OptionsSliderUserWidget_OnSetDisplayName, InDisplayName) == 0x000000, "Member 'OptionsSliderUserWidget_OnSetDisplayName::InDisplayName' has a wrong offset!");

// Function man.OptionsSliderUserWidget.OnSetValue
// 0x0004 (0x0004 - 0x0000)
struct OptionsSliderUserWidget_OnSetValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_OnSetValue) == 0x000004, "Wrong alignment on OptionsSliderUserWidget_OnSetValue");
static_assert(sizeof(OptionsSliderUserWidget_OnSetValue) == 0x000004, "Wrong size on OptionsSliderUserWidget_OnSetValue");
static_assert(offsetof(OptionsSliderUserWidget_OnSetValue, InValue) == 0x000000, "Member 'OptionsSliderUserWidget_OnSetValue::InValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.SetActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSliderUserWidget_SetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_SetActive) == 0x000001, "Wrong alignment on OptionsSliderUserWidget_SetActive");
static_assert(sizeof(OptionsSliderUserWidget_SetActive) == 0x000001, "Wrong size on OptionsSliderUserWidget_SetActive");
static_assert(offsetof(OptionsSliderUserWidget_SetActive, bInIsActive) == 0x000000, "Member 'OptionsSliderUserWidget_SetActive::bInIsActive' has a wrong offset!");

// Function man.OptionsSliderUserWidget.SetValue
// 0x0008 (0x0008 - 0x0000)
struct OptionsSliderUserWidget_SetValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAkEvent;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OptionsSliderUserWidget_SetValue) == 0x000004, "Wrong alignment on OptionsSliderUserWidget_SetValue");
static_assert(sizeof(OptionsSliderUserWidget_SetValue) == 0x000008, "Wrong size on OptionsSliderUserWidget_SetValue");
static_assert(offsetof(OptionsSliderUserWidget_SetValue, InValue) == 0x000000, "Member 'OptionsSliderUserWidget_SetValue::InValue' has a wrong offset!");
static_assert(offsetof(OptionsSliderUserWidget_SetValue, bPlayAkEvent) == 0x000004, "Member 'OptionsSliderUserWidget_SetValue::bPlayAkEvent' has a wrong offset!");

// Function man.OptionsSliderUserWidget.ValueChanged
// 0x0004 (0x0004 - 0x0000)
struct OptionsSliderUserWidget_ValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_ValueChanged) == 0x000004, "Wrong alignment on OptionsSliderUserWidget_ValueChanged");
static_assert(sizeof(OptionsSliderUserWidget_ValueChanged) == 0x000004, "Wrong size on OptionsSliderUserWidget_ValueChanged");
static_assert(offsetof(OptionsSliderUserWidget_ValueChanged, NewValue) == 0x000000, "Member 'OptionsSliderUserWidget_ValueChanged::NewValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.GetDisplayValue
// 0x0020 (0x0020 - 0x0000)
struct OptionsSliderUserWidget_GetDisplayValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_GetDisplayValue) == 0x000008, "Wrong alignment on OptionsSliderUserWidget_GetDisplayValue");
static_assert(sizeof(OptionsSliderUserWidget_GetDisplayValue) == 0x000020, "Wrong size on OptionsSliderUserWidget_GetDisplayValue");
static_assert(offsetof(OptionsSliderUserWidget_GetDisplayValue, InValue) == 0x000000, "Member 'OptionsSliderUserWidget_GetDisplayValue::InValue' has a wrong offset!");
static_assert(offsetof(OptionsSliderUserWidget_GetDisplayValue, ReturnValue) == 0x000008, "Member 'OptionsSliderUserWidget_GetDisplayValue::ReturnValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.GetPercentValue
// 0x0008 (0x0008 - 0x0000)
struct OptionsSliderUserWidget_GetPercentValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_GetPercentValue) == 0x000004, "Wrong alignment on OptionsSliderUserWidget_GetPercentValue");
static_assert(sizeof(OptionsSliderUserWidget_GetPercentValue) == 0x000008, "Wrong size on OptionsSliderUserWidget_GetPercentValue");
static_assert(offsetof(OptionsSliderUserWidget_GetPercentValue, InValue) == 0x000000, "Member 'OptionsSliderUserWidget_GetPercentValue::InValue' has a wrong offset!");
static_assert(offsetof(OptionsSliderUserWidget_GetPercentValue, ReturnValue) == 0x000004, "Member 'OptionsSliderUserWidget_GetPercentValue::ReturnValue' has a wrong offset!");

// Function man.OptionsSliderUserWidget.IsActive
// 0x0001 (0x0001 - 0x0000)
struct OptionsSliderUserWidget_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsSliderUserWidget_IsActive) == 0x000001, "Wrong alignment on OptionsSliderUserWidget_IsActive");
static_assert(sizeof(OptionsSliderUserWidget_IsActive) == 0x000001, "Wrong size on OptionsSliderUserWidget_IsActive");
static_assert(offsetof(OptionsSliderUserWidget_IsActive, ReturnValue) == 0x000000, "Member 'OptionsSliderUserWidget_IsActive::ReturnValue' has a wrong offset!");

// Function man.OptionsVideoAdvancedUserWidget.OnSetVramText
// 0x0018 (0x0018 - 0x0000)
struct OptionsVideoAdvancedUserWidget_OnSetVramText final
{
public:
	class FText                                   VRamText;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OptionsVideoAdvancedUserWidget_OnSetVramText) == 0x000008, "Wrong alignment on OptionsVideoAdvancedUserWidget_OnSetVramText");
static_assert(sizeof(OptionsVideoAdvancedUserWidget_OnSetVramText) == 0x000018, "Wrong size on OptionsVideoAdvancedUserWidget_OnSetVramText");
static_assert(offsetof(OptionsVideoAdvancedUserWidget_OnSetVramText, VRamText) == 0x000000, "Member 'OptionsVideoAdvancedUserWidget_OnSetVramText::VRamText' has a wrong offset!");

// Function man.OrbOfDoomAbility.OnProjectileEvent
// 0x0008 (0x0008 - 0x0000)
struct OrbOfDoomAbility_OnProjectileEvent final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrbOfDoomAbility_OnProjectileEvent) == 0x000008, "Wrong alignment on OrbOfDoomAbility_OnProjectileEvent");
static_assert(sizeof(OrbOfDoomAbility_OnProjectileEvent) == 0x000008, "Wrong size on OrbOfDoomAbility_OnProjectileEvent");
static_assert(offsetof(OrbOfDoomAbility_OnProjectileEvent, DestroyedActor) == 0x000000, "Member 'OrbOfDoomAbility_OnProjectileEvent::DestroyedActor' has a wrong offset!");

// Function man.OrbOfDoomAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct OrbOfDoomAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrbOfDoomAbility_PreDamageDealt) == 0x000008, "Wrong alignment on OrbOfDoomAbility_PreDamageDealt");
static_assert(sizeof(OrbOfDoomAbility_PreDamageDealt) == 0x0002D8, "Wrong size on OrbOfDoomAbility_PreDamageDealt");
static_assert(offsetof(OrbOfDoomAbility_PreDamageDealt, Param) == 0x000000, "Member 'OrbOfDoomAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.ParryAbility.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct ParryAbility_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParryAbility_OnPreDamagedPriority) == 0x000008, "Wrong alignment on ParryAbility_OnPreDamagedPriority");
static_assert(sizeof(ParryAbility_OnPreDamagedPriority) == 0x0002D8, "Wrong size on ParryAbility_OnPreDamagedPriority");
static_assert(offsetof(ParryAbility_OnPreDamagedPriority, Param) == 0x000000, "Member 'ParryAbility_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.PauseMenuUserWidget.IsControllerSchemeVisible
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_IsControllerSchemeVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_IsControllerSchemeVisible) == 0x000001, "Wrong alignment on PauseMenuUserWidget_IsControllerSchemeVisible");
static_assert(sizeof(PauseMenuUserWidget_IsControllerSchemeVisible) == 0x000001, "Wrong size on PauseMenuUserWidget_IsControllerSchemeVisible");
static_assert(offsetof(PauseMenuUserWidget_IsControllerSchemeVisible, ReturnValue) == 0x000000, "Member 'PauseMenuUserWidget_IsControllerSchemeVisible::ReturnValue' has a wrong offset!");

// Function man.PauseMenuUserWidget.OnDoubleJumpUnlock
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_OnDoubleJumpUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_OnDoubleJumpUnlock) == 0x000001, "Wrong alignment on PauseMenuUserWidget_OnDoubleJumpUnlock");
static_assert(sizeof(PauseMenuUserWidget_OnDoubleJumpUnlock) == 0x000001, "Wrong size on PauseMenuUserWidget_OnDoubleJumpUnlock");
static_assert(offsetof(PauseMenuUserWidget_OnDoubleJumpUnlock, bAnimate) == 0x000000, "Member 'PauseMenuUserWidget_OnDoubleJumpUnlock::bAnimate' has a wrong offset!");

// Function man.PauseMenuUserWidget.OnGlideUnlock
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_OnGlideUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_OnGlideUnlock) == 0x000001, "Wrong alignment on PauseMenuUserWidget_OnGlideUnlock");
static_assert(sizeof(PauseMenuUserWidget_OnGlideUnlock) == 0x000001, "Wrong size on PauseMenuUserWidget_OnGlideUnlock");
static_assert(offsetof(PauseMenuUserWidget_OnGlideUnlock, bAnimate) == 0x000000, "Member 'PauseMenuUserWidget_OnGlideUnlock::bAnimate' has a wrong offset!");

// Function man.PauseMenuUserWidget.OnGrapplingHookUnlock
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_OnGrapplingHookUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_OnGrapplingHookUnlock) == 0x000001, "Wrong alignment on PauseMenuUserWidget_OnGrapplingHookUnlock");
static_assert(sizeof(PauseMenuUserWidget_OnGrapplingHookUnlock) == 0x000001, "Wrong size on PauseMenuUserWidget_OnGrapplingHookUnlock");
static_assert(offsetof(PauseMenuUserWidget_OnGrapplingHookUnlock, bAnimate) == 0x000000, "Member 'PauseMenuUserWidget_OnGrapplingHookUnlock::bAnimate' has a wrong offset!");

// Function man.PauseMenuUserWidget.OnGroundSlamUnlock
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_OnGroundSlamUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_OnGroundSlamUnlock) == 0x000001, "Wrong alignment on PauseMenuUserWidget_OnGroundSlamUnlock");
static_assert(sizeof(PauseMenuUserWidget_OnGroundSlamUnlock) == 0x000001, "Wrong size on PauseMenuUserWidget_OnGroundSlamUnlock");
static_assert(offsetof(PauseMenuUserWidget_OnGroundSlamUnlock, bAnimate) == 0x000000, "Member 'PauseMenuUserWidget_OnGroundSlamUnlock::bAnimate' has a wrong offset!");

// Function man.PauseMenuUserWidget.OnSetQuickUseDefault
// 0x0001 (0x0001 - 0x0000)
struct PauseMenuUserWidget_OnSetQuickUseDefault final
{
public:
	bool                                          bQuickUseDefault;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PauseMenuUserWidget_OnSetQuickUseDefault) == 0x000001, "Wrong alignment on PauseMenuUserWidget_OnSetQuickUseDefault");
static_assert(sizeof(PauseMenuUserWidget_OnSetQuickUseDefault) == 0x000001, "Wrong size on PauseMenuUserWidget_OnSetQuickUseDefault");
static_assert(offsetof(PauseMenuUserWidget_OnSetQuickUseDefault, bQuickUseDefault) == 0x000000, "Member 'PauseMenuUserWidget_OnSetQuickUseDefault::bQuickUseDefault' has a wrong offset!");

// Function man.MoveAblePlatformActor.OnBeginOverlapInterior
// 0x00A8 (0x00A8 - 0x0000)
struct MoveAblePlatformActor_OnBeginOverlapInterior final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(MoveAblePlatformActor_OnBeginOverlapInterior) == 0x000008, "Wrong alignment on MoveAblePlatformActor_OnBeginOverlapInterior");
static_assert(sizeof(MoveAblePlatformActor_OnBeginOverlapInterior) == 0x0000A8, "Wrong size on MoveAblePlatformActor_OnBeginOverlapInterior");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, OverlappedComponent) == 0x000000, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, OtherActor) == 0x000008, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::OtherActor' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, OtherComp) == 0x000010, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::OtherComp' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, OtherBodyIndex) == 0x000018, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, bFromSweep) == 0x00001C, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::bFromSweep' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnBeginOverlapInterior, SweepResult) == 0x000020, "Member 'MoveAblePlatformActor_OnBeginOverlapInterior::SweepResult' has a wrong offset!");

// Function man.MoveAblePlatformActor.OnEndOverlapInterior
// 0x0020 (0x0020 - 0x0000)
struct MoveAblePlatformActor_OnEndOverlapInterior final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MoveAblePlatformActor_OnEndOverlapInterior) == 0x000008, "Wrong alignment on MoveAblePlatformActor_OnEndOverlapInterior");
static_assert(sizeof(MoveAblePlatformActor_OnEndOverlapInterior) == 0x000020, "Wrong size on MoveAblePlatformActor_OnEndOverlapInterior");
static_assert(offsetof(MoveAblePlatformActor_OnEndOverlapInterior, OverlappedComponent) == 0x000000, "Member 'MoveAblePlatformActor_OnEndOverlapInterior::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnEndOverlapInterior, OtherActor) == 0x000008, "Member 'MoveAblePlatformActor_OnEndOverlapInterior::OtherActor' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnEndOverlapInterior, OtherComp) == 0x000010, "Member 'MoveAblePlatformActor_OnEndOverlapInterior::OtherComp' has a wrong offset!");
static_assert(offsetof(MoveAblePlatformActor_OnEndOverlapInterior, OtherBodyIndex) == 0x000018, "Member 'MoveAblePlatformActor_OnEndOverlapInterior::OtherBodyIndex' has a wrong offset!");

// Function man.PlatfromMoverComponent.TriggerBoxActivated
// 0x0020 (0x0020 - 0x0000)
struct PlatfromMoverComponent_TriggerBoxActivated final
{
public:
	class UAbilityController*                     InAbilityController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEventID*                       _GameplayEventID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             paramActorSoul;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatfromMoverComponent_TriggerBoxActivated) == 0x000008, "Wrong alignment on PlatfromMoverComponent_TriggerBoxActivated");
static_assert(sizeof(PlatfromMoverComponent_TriggerBoxActivated) == 0x000020, "Wrong size on PlatfromMoverComponent_TriggerBoxActivated");
static_assert(offsetof(PlatfromMoverComponent_TriggerBoxActivated, InAbilityController) == 0x000000, "Member 'PlatfromMoverComponent_TriggerBoxActivated::InAbilityController' has a wrong offset!");
static_assert(offsetof(PlatfromMoverComponent_TriggerBoxActivated, _GameplayEventID) == 0x000008, "Member 'PlatfromMoverComponent_TriggerBoxActivated::_GameplayEventID' has a wrong offset!");
static_assert(offsetof(PlatfromMoverComponent_TriggerBoxActivated, CustomName) == 0x000010, "Member 'PlatfromMoverComponent_TriggerBoxActivated::CustomName' has a wrong offset!");
static_assert(offsetof(PlatfromMoverComponent_TriggerBoxActivated, paramActorSoul) == 0x000018, "Member 'PlatfromMoverComponent_TriggerBoxActivated::paramActorSoul' has a wrong offset!");

// Function man.PlatformMoverVolume.OnBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct PlatformMoverVolume_OnBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformMoverVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on PlatformMoverVolume_OnBeginOverlap");
static_assert(sizeof(PlatformMoverVolume_OnBeginOverlap) == 0x000010, "Wrong size on PlatformMoverVolume_OnBeginOverlap");
static_assert(offsetof(PlatformMoverVolume_OnBeginOverlap, OverlappedActor) == 0x000000, "Member 'PlatformMoverVolume_OnBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(PlatformMoverVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'PlatformMoverVolume_OnBeginOverlap::OtherActor' has a wrong offset!");

// Function man.PlatformMoverVolume.OnEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct PlatformMoverVolume_OnEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformMoverVolume_OnEndOverlap) == 0x000008, "Wrong alignment on PlatformMoverVolume_OnEndOverlap");
static_assert(sizeof(PlatformMoverVolume_OnEndOverlap) == 0x000010, "Wrong size on PlatformMoverVolume_OnEndOverlap");
static_assert(offsetof(PlatformMoverVolume_OnEndOverlap, OverlappedActor) == 0x000000, "Member 'PlatformMoverVolume_OnEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(PlatformMoverVolume_OnEndOverlap, OtherActor) == 0x000008, "Member 'PlatformMoverVolume_OnEndOverlap::OtherActor' has a wrong offset!");

// Function man.PlayerMonologueUserWidget.OnPlayVideo
// 0x0010 (0x0010 - 0x0000)
struct PlayerMonologueUserWidget_OnPlayVideo final
{
public:
	class FString                                 VideoUrl;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMonologueUserWidget_OnPlayVideo) == 0x000008, "Wrong alignment on PlayerMonologueUserWidget_OnPlayVideo");
static_assert(sizeof(PlayerMonologueUserWidget_OnPlayVideo) == 0x000010, "Wrong size on PlayerMonologueUserWidget_OnPlayVideo");
static_assert(offsetof(PlayerMonologueUserWidget_OnPlayVideo, VideoUrl) == 0x000000, "Member 'PlayerMonologueUserWidget_OnPlayVideo::VideoUrl' has a wrong offset!");

// Function man.PlayerMonologueUserWidget.OnSetPicture
// 0x0008 (0x0008 - 0x0000)
struct PlayerMonologueUserWidget_OnSetPicture final
{
public:
	class UTexture2D*                             Picture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMonologueUserWidget_OnSetPicture) == 0x000008, "Wrong alignment on PlayerMonologueUserWidget_OnSetPicture");
static_assert(sizeof(PlayerMonologueUserWidget_OnSetPicture) == 0x000008, "Wrong size on PlayerMonologueUserWidget_OnSetPicture");
static_assert(offsetof(PlayerMonologueUserWidget_OnSetPicture, Picture) == 0x000000, "Member 'PlayerMonologueUserWidget_OnSetPicture::Picture' has a wrong offset!");

// Function man.PlayerMonologueUserWidget.OnShowText
// 0x0038 (0x0038 - 0x0000)
struct PlayerMonologueUserWidget_OnShowText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InLineIDText;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bSubtitleEnable;                                   // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerMonologueUserWidget_OnShowText) == 0x000008, "Wrong alignment on PlayerMonologueUserWidget_OnShowText");
static_assert(sizeof(PlayerMonologueUserWidget_OnShowText) == 0x000038, "Wrong size on PlayerMonologueUserWidget_OnShowText");
static_assert(offsetof(PlayerMonologueUserWidget_OnShowText, InText) == 0x000000, "Member 'PlayerMonologueUserWidget_OnShowText::InText' has a wrong offset!");
static_assert(offsetof(PlayerMonologueUserWidget_OnShowText, InLineIDText) == 0x000018, "Member 'PlayerMonologueUserWidget_OnShowText::InLineIDText' has a wrong offset!");
static_assert(offsetof(PlayerMonologueUserWidget_OnShowText, bSubtitleEnable) == 0x000030, "Member 'PlayerMonologueUserWidget_OnShowText::bSubtitleEnable' has a wrong offset!");

// Function man.PlayerStatsStatUserWidget.OnSetCaption
// 0x0018 (0x0018 - 0x0000)
struct PlayerStatsStatUserWidget_OnSetCaption final
{
public:
	class FText                                   InCaption;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerStatsStatUserWidget_OnSetCaption) == 0x000008, "Wrong alignment on PlayerStatsStatUserWidget_OnSetCaption");
static_assert(sizeof(PlayerStatsStatUserWidget_OnSetCaption) == 0x000018, "Wrong size on PlayerStatsStatUserWidget_OnSetCaption");
static_assert(offsetof(PlayerStatsStatUserWidget_OnSetCaption, InCaption) == 0x000000, "Member 'PlayerStatsStatUserWidget_OnSetCaption::InCaption' has a wrong offset!");

// Function man.PlayerStatsStatUserWidget.OnSetHidden
// 0x0001 (0x0001 - 0x0000)
struct PlayerStatsStatUserWidget_OnSetHidden final
{
public:
	bool                                          bInHidden;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerStatsStatUserWidget_OnSetHidden) == 0x000001, "Wrong alignment on PlayerStatsStatUserWidget_OnSetHidden");
static_assert(sizeof(PlayerStatsStatUserWidget_OnSetHidden) == 0x000001, "Wrong size on PlayerStatsStatUserWidget_OnSetHidden");
static_assert(offsetof(PlayerStatsStatUserWidget_OnSetHidden, bInHidden) == 0x000000, "Member 'PlayerStatsStatUserWidget_OnSetHidden::bInHidden' has a wrong offset!");

// Function man.PlayerStatsStatUserWidget.OnSetValue
// 0x0018 (0x0018 - 0x0000)
struct PlayerStatsStatUserWidget_OnSetValue final
{
public:
	class FText                                   InValue;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerStatsStatUserWidget_OnSetValue) == 0x000008, "Wrong alignment on PlayerStatsStatUserWidget_OnSetValue");
static_assert(sizeof(PlayerStatsStatUserWidget_OnSetValue) == 0x000018, "Wrong size on PlayerStatsStatUserWidget_OnSetValue");
static_assert(offsetof(PlayerStatsStatUserWidget_OnSetValue, InValue) == 0x000000, "Member 'PlayerStatsStatUserWidget_OnSetValue::InValue' has a wrong offset!");

// Function man.LevelToModifierElement.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct LevelToModifierElement_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelToModifierElement_GetEditorName) == 0x000008, "Wrong alignment on LevelToModifierElement_GetEditorName");
static_assert(sizeof(LevelToModifierElement_GetEditorName) == 0x000010, "Wrong size on LevelToModifierElement_GetEditorName");
static_assert(offsetof(LevelToModifierElement_GetEditorName, ReturnValue) == 0x000000, "Member 'LevelToModifierElement_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.PoseableMeshActor.BPOnTeleportedBack
// 0x0008 (0x0008 - 0x0000)
struct PoseableMeshActor_BPOnTeleportedBack final
{
public:
	class AActor*                                 TeleporterActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshActor_BPOnTeleportedBack) == 0x000008, "Wrong alignment on PoseableMeshActor_BPOnTeleportedBack");
static_assert(sizeof(PoseableMeshActor_BPOnTeleportedBack) == 0x000008, "Wrong size on PoseableMeshActor_BPOnTeleportedBack");
static_assert(offsetof(PoseableMeshActor_BPOnTeleportedBack, TeleporterActor) == 0x000000, "Member 'PoseableMeshActor_BPOnTeleportedBack::TeleporterActor' has a wrong offset!");

// Function man.PoseableMeshActor.BPTakeFormOf
// 0x0008 (0x0008 - 0x0000)
struct PoseableMeshActor_BPTakeFormOf final
{
public:
	class AActor*                                 ActorToShapeInto;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshActor_BPTakeFormOf) == 0x000008, "Wrong alignment on PoseableMeshActor_BPTakeFormOf");
static_assert(sizeof(PoseableMeshActor_BPTakeFormOf) == 0x000008, "Wrong size on PoseableMeshActor_BPTakeFormOf");
static_assert(offsetof(PoseableMeshActor_BPTakeFormOf, ActorToShapeInto) == 0x000000, "Member 'PoseableMeshActor_BPTakeFormOf::ActorToShapeInto' has a wrong offset!");

// Function man.PowerVacuumPassive.EnergyUsed
// 0x0010 (0x0010 - 0x0000)
struct PowerVacuumPassive_EnergyUsed final
{
public:
	EEntityProperty                               resource;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerVacuumPassive_EnergyUsed) == 0x000008, "Wrong alignment on PowerVacuumPassive_EnergyUsed");
static_assert(sizeof(PowerVacuumPassive_EnergyUsed) == 0x000010, "Wrong size on PowerVacuumPassive_EnergyUsed");
static_assert(offsetof(PowerVacuumPassive_EnergyUsed, resource) == 0x000000, "Member 'PowerVacuumPassive_EnergyUsed::resource' has a wrong offset!");
static_assert(offsetof(PowerVacuumPassive_EnergyUsed, amount) == 0x000004, "Member 'PowerVacuumPassive_EnergyUsed::amount' has a wrong offset!");
static_assert(offsetof(PowerVacuumPassive_EnergyUsed, Ability) == 0x000008, "Member 'PowerVacuumPassive_EnergyUsed::Ability' has a wrong offset!");

// Function man.ConcentrationPassive.OnPostDamaged_Concentration
// 0x02D8 (0x02D8 - 0x0000)
struct ConcentrationPassive_OnPostDamaged_Concentration final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ConcentrationPassive_OnPostDamaged_Concentration) == 0x000008, "Wrong alignment on ConcentrationPassive_OnPostDamaged_Concentration");
static_assert(sizeof(ConcentrationPassive_OnPostDamaged_Concentration) == 0x0002D8, "Wrong size on ConcentrationPassive_OnPostDamaged_Concentration");
static_assert(offsetof(ConcentrationPassive_OnPostDamaged_Concentration, Param) == 0x000000, "Member 'ConcentrationPassive_OnPostDamaged_Concentration::Param' has a wrong offset!");

// Function man.QuickChargePassive.PropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct QuickChargePassive_PropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(QuickChargePassive_PropertyChanged) == 0x000004, "Wrong alignment on QuickChargePassive_PropertyChanged");
static_assert(sizeof(QuickChargePassive_PropertyChanged) == 0x000014, "Wrong size on QuickChargePassive_PropertyChanged");
static_assert(offsetof(QuickChargePassive_PropertyChanged, PropertyType) == 0x000000, "Member 'QuickChargePassive_PropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(QuickChargePassive_PropertyChanged, Value) == 0x000004, "Member 'QuickChargePassive_PropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(QuickChargePassive_PropertyChanged, RoundedFloatValue) == 0x000008, "Member 'QuickChargePassive_PropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(QuickChargePassive_PropertyChanged, RoundedIntValue) == 0x00000C, "Member 'QuickChargePassive_PropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(QuickChargePassive_PropertyChanged, bAnimate) == 0x000010, "Member 'QuickChargePassive_PropertyChanged::bAnimate' has a wrong offset!");

// Function man.PrimalMath.Compare_CaseNotEqualUClass
// 0x0018 (0x0018 - 0x0000)
struct PrimalMath_Compare_CaseNotEqualUClass final
{
public:
	class UClass*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimalMath_Compare_CaseNotEqualUClass) == 0x000008, "Wrong alignment on PrimalMath_Compare_CaseNotEqualUClass");
static_assert(sizeof(PrimalMath_Compare_CaseNotEqualUClass) == 0x000018, "Wrong size on PrimalMath_Compare_CaseNotEqualUClass");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUClass, A) == 0x000000, "Member 'PrimalMath_Compare_CaseNotEqualUClass::A' has a wrong offset!");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUClass, B) == 0x000008, "Member 'PrimalMath_Compare_CaseNotEqualUClass::B' has a wrong offset!");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUClass, ReturnValue) == 0x000010, "Member 'PrimalMath_Compare_CaseNotEqualUClass::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.Compare_CaseNotEqualUObject
// 0x0018 (0x0018 - 0x0000)
struct PrimalMath_Compare_CaseNotEqualUObject final
{
public:
	class UObject*                                A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimalMath_Compare_CaseNotEqualUObject) == 0x000008, "Wrong alignment on PrimalMath_Compare_CaseNotEqualUObject");
static_assert(sizeof(PrimalMath_Compare_CaseNotEqualUObject) == 0x000018, "Wrong size on PrimalMath_Compare_CaseNotEqualUObject");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUObject, A) == 0x000000, "Member 'PrimalMath_Compare_CaseNotEqualUObject::A' has a wrong offset!");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUObject, B) == 0x000008, "Member 'PrimalMath_Compare_CaseNotEqualUObject::B' has a wrong offset!");
static_assert(offsetof(PrimalMath_Compare_CaseNotEqualUObject, ReturnValue) == 0x000010, "Member 'PrimalMath_Compare_CaseNotEqualUObject::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.GetRatio
// 0x0010 (0x0010 - 0x0000)
struct PrimalMath_GetRatio final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_GetRatio) == 0x000004, "Wrong alignment on PrimalMath_GetRatio");
static_assert(sizeof(PrimalMath_GetRatio) == 0x000010, "Wrong size on PrimalMath_GetRatio");
static_assert(offsetof(PrimalMath_GetRatio, X) == 0x000000, "Member 'PrimalMath_GetRatio::X' has a wrong offset!");
static_assert(offsetof(PrimalMath_GetRatio, Min) == 0x000004, "Member 'PrimalMath_GetRatio::Min' has a wrong offset!");
static_assert(offsetof(PrimalMath_GetRatio, Max) == 0x000008, "Member 'PrimalMath_GetRatio::Max' has a wrong offset!");
static_assert(offsetof(PrimalMath_GetRatio, ReturnValue) == 0x00000C, "Member 'PrimalMath_GetRatio::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.Interpolate
// 0x0014 (0x0014 - 0x0000)
struct PrimalMath_Interpolate final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_Interpolate) == 0x000004, "Wrong alignment on PrimalMath_Interpolate");
static_assert(sizeof(PrimalMath_Interpolate) == 0x000014, "Wrong size on PrimalMath_Interpolate");
static_assert(offsetof(PrimalMath_Interpolate, Current) == 0x000000, "Member 'PrimalMath_Interpolate::Current' has a wrong offset!");
static_assert(offsetof(PrimalMath_Interpolate, Target) == 0x000004, "Member 'PrimalMath_Interpolate::Target' has a wrong offset!");
static_assert(offsetof(PrimalMath_Interpolate, DeltaTime) == 0x000008, "Member 'PrimalMath_Interpolate::DeltaTime' has a wrong offset!");
static_assert(offsetof(PrimalMath_Interpolate, Duration) == 0x00000C, "Member 'PrimalMath_Interpolate::Duration' has a wrong offset!");
static_assert(offsetof(PrimalMath_Interpolate, ReturnValue) == 0x000010, "Member 'PrimalMath_Interpolate::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.InterpolateBySpeed
// 0x0014 (0x0014 - 0x0000)
struct PrimalMath_InterpolateBySpeed final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_InterpolateBySpeed) == 0x000004, "Wrong alignment on PrimalMath_InterpolateBySpeed");
static_assert(sizeof(PrimalMath_InterpolateBySpeed) == 0x000014, "Wrong size on PrimalMath_InterpolateBySpeed");
static_assert(offsetof(PrimalMath_InterpolateBySpeed, Current) == 0x000000, "Member 'PrimalMath_InterpolateBySpeed::Current' has a wrong offset!");
static_assert(offsetof(PrimalMath_InterpolateBySpeed, Target) == 0x000004, "Member 'PrimalMath_InterpolateBySpeed::Target' has a wrong offset!");
static_assert(offsetof(PrimalMath_InterpolateBySpeed, DeltaTime) == 0x000008, "Member 'PrimalMath_InterpolateBySpeed::DeltaTime' has a wrong offset!");
static_assert(offsetof(PrimalMath_InterpolateBySpeed, Speed) == 0x00000C, "Member 'PrimalMath_InterpolateBySpeed::Speed' has a wrong offset!");
static_assert(offsetof(PrimalMath_InterpolateBySpeed, ReturnValue) == 0x000010, "Member 'PrimalMath_InterpolateBySpeed::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.SmootherStep
// 0x0008 (0x0008 - 0x0000)
struct PrimalMath_SmootherStep final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_SmootherStep) == 0x000004, "Wrong alignment on PrimalMath_SmootherStep");
static_assert(sizeof(PrimalMath_SmootherStep) == 0x000008, "Wrong size on PrimalMath_SmootherStep");
static_assert(offsetof(PrimalMath_SmootherStep, X) == 0x000000, "Member 'PrimalMath_SmootherStep::X' has a wrong offset!");
static_assert(offsetof(PrimalMath_SmootherStep, ReturnValue) == 0x000004, "Member 'PrimalMath_SmootherStep::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.SmoothSinStep
// 0x0008 (0x0008 - 0x0000)
struct PrimalMath_SmoothSinStep final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_SmoothSinStep) == 0x000004, "Wrong alignment on PrimalMath_SmoothSinStep");
static_assert(sizeof(PrimalMath_SmoothSinStep) == 0x000008, "Wrong size on PrimalMath_SmoothSinStep");
static_assert(offsetof(PrimalMath_SmoothSinStep, X) == 0x000000, "Member 'PrimalMath_SmoothSinStep::X' has a wrong offset!");
static_assert(offsetof(PrimalMath_SmoothSinStep, ReturnValue) == 0x000004, "Member 'PrimalMath_SmoothSinStep::ReturnValue' has a wrong offset!");

// Function man.PrimalMath.SmoothStep
// 0x0008 (0x0008 - 0x0000)
struct PrimalMath_SmoothStep final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalMath_SmoothStep) == 0x000004, "Wrong alignment on PrimalMath_SmoothStep");
static_assert(sizeof(PrimalMath_SmoothStep) == 0x000008, "Wrong size on PrimalMath_SmoothStep");
static_assert(offsetof(PrimalMath_SmoothStep, X) == 0x000000, "Member 'PrimalMath_SmoothStep::X' has a wrong offset!");
static_assert(offsetof(PrimalMath_SmoothStep, ReturnValue) == 0x000004, "Member 'PrimalMath_SmoothStep::ReturnValue' has a wrong offset!");

// Function man.PrimalSlotHandler.ActivateSlotItem
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_ActivateSlotItem final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialName;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_ActivateSlotItem) == 0x000004, "Wrong alignment on PrimalSlotHandler_ActivateSlotItem");
static_assert(sizeof(PrimalSlotHandler_ActivateSlotItem) == 0x000010, "Wrong size on PrimalSlotHandler_ActivateSlotItem");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItem, SlotName) == 0x000000, "Member 'PrimalSlotHandler_ActivateSlotItem::SlotName' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItem, MaterialName) == 0x000008, "Member 'PrimalSlotHandler_ActivateSlotItem::MaterialName' has a wrong offset!");

// Function man.PrimalSlotHandler.ActivateSlotItemByMaterial
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_ActivateSlotItemByMaterial final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UMaterialInstance*                MaterialInstance;                                  // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_ActivateSlotItemByMaterial) == 0x000008, "Wrong alignment on PrimalSlotHandler_ActivateSlotItemByMaterial");
static_assert(sizeof(PrimalSlotHandler_ActivateSlotItemByMaterial) == 0x000010, "Wrong size on PrimalSlotHandler_ActivateSlotItemByMaterial");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItemByMaterial, SlotName) == 0x000000, "Member 'PrimalSlotHandler_ActivateSlotItemByMaterial::SlotName' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItemByMaterial, MaterialInstance) == 0x000008, "Member 'PrimalSlotHandler_ActivateSlotItemByMaterial::MaterialInstance' has a wrong offset!");

// Function man.PrimalSlotHandler.ActivateSlotItemByMaterialOnly
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_ActivateSlotItemByMaterialOnly final
{
public:
	const class UMaterialInstance*                MaterialInstance;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivate;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimalSlotHandler_ActivateSlotItemByMaterialOnly) == 0x000008, "Wrong alignment on PrimalSlotHandler_ActivateSlotItemByMaterialOnly");
static_assert(sizeof(PrimalSlotHandler_ActivateSlotItemByMaterialOnly) == 0x000010, "Wrong size on PrimalSlotHandler_ActivateSlotItemByMaterialOnly");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItemByMaterialOnly, MaterialInstance) == 0x000000, "Member 'PrimalSlotHandler_ActivateSlotItemByMaterialOnly::MaterialInstance' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_ActivateSlotItemByMaterialOnly, bActivate) == 0x000008, "Member 'PrimalSlotHandler_ActivateSlotItemByMaterialOnly::bActivate' has a wrong offset!");

// Function man.PrimalSlotHandler.GetSlotIndexByMaterialOnly
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_GetSlotIndexByMaterialOnly final
{
public:
	const class UMaterialInstance*                MaterialInstance;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimalSlotHandler_GetSlotIndexByMaterialOnly) == 0x000008, "Wrong alignment on PrimalSlotHandler_GetSlotIndexByMaterialOnly");
static_assert(sizeof(PrimalSlotHandler_GetSlotIndexByMaterialOnly) == 0x000010, "Wrong size on PrimalSlotHandler_GetSlotIndexByMaterialOnly");
static_assert(offsetof(PrimalSlotHandler_GetSlotIndexByMaterialOnly, MaterialInstance) == 0x000000, "Member 'PrimalSlotHandler_GetSlotIndexByMaterialOnly::MaterialInstance' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_GetSlotIndexByMaterialOnly, ReturnValue) == 0x000008, "Member 'PrimalSlotHandler_GetSlotIndexByMaterialOnly::ReturnValue' has a wrong offset!");

// Function man.PrimalSlotHandler.GetSlotIndexByName
// 0x000C (0x000C - 0x0000)
struct PrimalSlotHandler_GetSlotIndexByName final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_GetSlotIndexByName) == 0x000004, "Wrong alignment on PrimalSlotHandler_GetSlotIndexByName");
static_assert(sizeof(PrimalSlotHandler_GetSlotIndexByName) == 0x00000C, "Wrong size on PrimalSlotHandler_GetSlotIndexByName");
static_assert(offsetof(PrimalSlotHandler_GetSlotIndexByName, SlotName) == 0x000000, "Member 'PrimalSlotHandler_GetSlotIndexByName::SlotName' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_GetSlotIndexByName, ReturnValue) == 0x000008, "Member 'PrimalSlotHandler_GetSlotIndexByName::ReturnValue' has a wrong offset!");

// Function man.PrimalSlotHandler.GetActiveSlotItemsMaterialName
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_GetActiveSlotItemsMaterialName final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_GetActiveSlotItemsMaterialName) == 0x000004, "Wrong alignment on PrimalSlotHandler_GetActiveSlotItemsMaterialName");
static_assert(sizeof(PrimalSlotHandler_GetActiveSlotItemsMaterialName) == 0x000010, "Wrong size on PrimalSlotHandler_GetActiveSlotItemsMaterialName");
static_assert(offsetof(PrimalSlotHandler_GetActiveSlotItemsMaterialName, SlotName) == 0x000000, "Member 'PrimalSlotHandler_GetActiveSlotItemsMaterialName::SlotName' has a wrong offset!");
static_assert(offsetof(PrimalSlotHandler_GetActiveSlotItemsMaterialName, ReturnValue) == 0x000008, "Member 'PrimalSlotHandler_GetActiveSlotItemsMaterialName::ReturnValue' has a wrong offset!");

// Function man.PrimalSlotHandler.GetSlotRules
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_GetSlotRules final
{
public:
	TArray<struct FPrimalSlotRule>                ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_GetSlotRules) == 0x000008, "Wrong alignment on PrimalSlotHandler_GetSlotRules");
static_assert(sizeof(PrimalSlotHandler_GetSlotRules) == 0x000010, "Wrong size on PrimalSlotHandler_GetSlotRules");
static_assert(offsetof(PrimalSlotHandler_GetSlotRules, ReturnValue) == 0x000000, "Member 'PrimalSlotHandler_GetSlotRules::ReturnValue' has a wrong offset!");

// Function man.PrimalSlotHandler.GetSlots
// 0x0010 (0x0010 - 0x0000)
struct PrimalSlotHandler_GetSlots final
{
public:
	TArray<struct FPrimalSlot>                    ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalSlotHandler_GetSlots) == 0x000008, "Wrong alignment on PrimalSlotHandler_GetSlots");
static_assert(sizeof(PrimalSlotHandler_GetSlots) == 0x000010, "Wrong size on PrimalSlotHandler_GetSlots");
static_assert(offsetof(PrimalSlotHandler_GetSlots, ReturnValue) == 0x000000, "Member 'PrimalSlotHandler_GetSlots::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetChangeListVersion
// 0x0004 (0x0004 - 0x0000)
struct PrimalVersion_GetChangeListVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetChangeListVersion) == 0x000004, "Wrong alignment on PrimalVersion_GetChangeListVersion");
static_assert(sizeof(PrimalVersion_GetChangeListVersion) == 0x000004, "Wrong size on PrimalVersion_GetChangeListVersion");
static_assert(offsetof(PrimalVersion_GetChangeListVersion, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetChangeListVersion::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetHotfixVersion
// 0x0004 (0x0004 - 0x0000)
struct PrimalVersion_GetHotfixVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetHotfixVersion) == 0x000004, "Wrong alignment on PrimalVersion_GetHotfixVersion");
static_assert(sizeof(PrimalVersion_GetHotfixVersion) == 0x000004, "Wrong size on PrimalVersion_GetHotfixVersion");
static_assert(offsetof(PrimalVersion_GetHotfixVersion, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetHotfixVersion::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetMajorVersion
// 0x0004 (0x0004 - 0x0000)
struct PrimalVersion_GetMajorVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetMajorVersion) == 0x000004, "Wrong alignment on PrimalVersion_GetMajorVersion");
static_assert(sizeof(PrimalVersion_GetMajorVersion) == 0x000004, "Wrong size on PrimalVersion_GetMajorVersion");
static_assert(offsetof(PrimalVersion_GetMajorVersion, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetMajorVersion::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetMinorVersion
// 0x0004 (0x0004 - 0x0000)
struct PrimalVersion_GetMinorVersion final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetMinorVersion) == 0x000004, "Wrong alignment on PrimalVersion_GetMinorVersion");
static_assert(sizeof(PrimalVersion_GetMinorVersion) == 0x000004, "Wrong size on PrimalVersion_GetMinorVersion");
static_assert(offsetof(PrimalVersion_GetMinorVersion, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetMinorVersion::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetTag
// 0x0010 (0x0010 - 0x0000)
struct PrimalVersion_GetTag final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetTag) == 0x000008, "Wrong alignment on PrimalVersion_GetTag");
static_assert(sizeof(PrimalVersion_GetTag) == 0x000010, "Wrong size on PrimalVersion_GetTag");
static_assert(offsetof(PrimalVersion_GetTag, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetTag::ReturnValue' has a wrong offset!");

// Function man.PrimalVersion.GetVersion
// 0x0010 (0x0010 - 0x0000)
struct PrimalVersion_GetVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimalVersion_GetVersion) == 0x000008, "Wrong alignment on PrimalVersion_GetVersion");
static_assert(sizeof(PrimalVersion_GetVersion) == 0x000010, "Wrong size on PrimalVersion_GetVersion");
static_assert(offsetof(PrimalVersion_GetVersion, ReturnValue) == 0x000000, "Member 'PrimalVersion_GetVersion::ReturnValue' has a wrong offset!");

// Function man.PrismAbility.DamageCaused
// 0x0028 (0x0028 - 0x0000)
struct PrismAbility_DamageCaused final
{
public:
	int32                                         DamageGroupID;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageValue>                   DamageValues;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_DamageCaused) == 0x000008, "Wrong alignment on PrismAbility_DamageCaused");
static_assert(sizeof(PrismAbility_DamageCaused) == 0x000028, "Wrong size on PrismAbility_DamageCaused");
static_assert(offsetof(PrismAbility_DamageCaused, DamageGroupID) == 0x000000, "Member 'PrismAbility_DamageCaused::DamageGroupID' has a wrong offset!");
static_assert(offsetof(PrismAbility_DamageCaused, Source) == 0x000008, "Member 'PrismAbility_DamageCaused::Source' has a wrong offset!");
static_assert(offsetof(PrismAbility_DamageCaused, DamageTarget) == 0x000010, "Member 'PrismAbility_DamageCaused::DamageTarget' has a wrong offset!");
static_assert(offsetof(PrismAbility_DamageCaused, DamageValues) == 0x000018, "Member 'PrismAbility_DamageCaused::DamageValues' has a wrong offset!");

// Function man.PrismAbility.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct PrismAbility_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_DamageDealt) == 0x000008, "Wrong alignment on PrismAbility_DamageDealt");
static_assert(sizeof(PrismAbility_DamageDealt) == 0x0002D8, "Wrong size on PrismAbility_DamageDealt");
static_assert(offsetof(PrismAbility_DamageDealt, Param) == 0x000000, "Member 'PrismAbility_DamageDealt::Param' has a wrong offset!");

// Function man.PrismAbility.GetCurrentDamageCharge
// 0x0004 (0x0004 - 0x0000)
struct PrismAbility_GetCurrentDamageCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_GetCurrentDamageCharge) == 0x000004, "Wrong alignment on PrismAbility_GetCurrentDamageCharge");
static_assert(sizeof(PrismAbility_GetCurrentDamageCharge) == 0x000004, "Wrong size on PrismAbility_GetCurrentDamageCharge");
static_assert(offsetof(PrismAbility_GetCurrentDamageCharge, ReturnValue) == 0x000000, "Member 'PrismAbility_GetCurrentDamageCharge::ReturnValue' has a wrong offset!");

// Function man.PrismAbility.GetCurrentPulseCount
// 0x0004 (0x0004 - 0x0000)
struct PrismAbility_GetCurrentPulseCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_GetCurrentPulseCount) == 0x000004, "Wrong alignment on PrismAbility_GetCurrentPulseCount");
static_assert(sizeof(PrismAbility_GetCurrentPulseCount) == 0x000004, "Wrong size on PrismAbility_GetCurrentPulseCount");
static_assert(offsetof(PrismAbility_GetCurrentPulseCount, ReturnValue) == 0x000000, "Member 'PrismAbility_GetCurrentPulseCount::ReturnValue' has a wrong offset!");

// Function man.PrismAbility.GetLastDamagedActor
// 0x0008 (0x0008 - 0x0000)
struct PrismAbility_GetLastDamagedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_GetLastDamagedActor) == 0x000008, "Wrong alignment on PrismAbility_GetLastDamagedActor");
static_assert(sizeof(PrismAbility_GetLastDamagedActor) == 0x000008, "Wrong size on PrismAbility_GetLastDamagedActor");
static_assert(offsetof(PrismAbility_GetLastDamagedActor, ReturnValue) == 0x000000, "Member 'PrismAbility_GetLastDamagedActor::ReturnValue' has a wrong offset!");

// Function man.PrismAbility.GetMaxDamageCharge
// 0x0004 (0x0004 - 0x0000)
struct PrismAbility_GetMaxDamageCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_GetMaxDamageCharge) == 0x000004, "Wrong alignment on PrismAbility_GetMaxDamageCharge");
static_assert(sizeof(PrismAbility_GetMaxDamageCharge) == 0x000004, "Wrong size on PrismAbility_GetMaxDamageCharge");
static_assert(offsetof(PrismAbility_GetMaxDamageCharge, ReturnValue) == 0x000000, "Member 'PrismAbility_GetMaxDamageCharge::ReturnValue' has a wrong offset!");

// Function man.PrismAbility.IsPrimed
// 0x0001 (0x0001 - 0x0000)
struct PrismAbility_IsPrimed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrismAbility_IsPrimed) == 0x000001, "Wrong alignment on PrismAbility_IsPrimed");
static_assert(sizeof(PrismAbility_IsPrimed) == 0x000001, "Wrong size on PrismAbility_IsPrimed");
static_assert(offsetof(PrismAbility_IsPrimed, ReturnValue) == 0x000000, "Member 'PrismAbility_IsPrimed::ReturnValue' has a wrong offset!");

// Function man.PushAbility.BPGetCurrentPushObject
// 0x0008 (0x0008 - 0x0000)
struct PushAbility_BPGetCurrentPushObject final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PushAbility_BPGetCurrentPushObject) == 0x000008, "Wrong alignment on PushAbility_BPGetCurrentPushObject");
static_assert(sizeof(PushAbility_BPGetCurrentPushObject) == 0x000008, "Wrong size on PushAbility_BPGetCurrentPushObject");
static_assert(offsetof(PushAbility_BPGetCurrentPushObject, ReturnValue) == 0x000000, "Member 'PushAbility_BPGetCurrentPushObject::ReturnValue' has a wrong offset!");

// Function man.PutridGhoulAI.GetStaminaDrainSourceVFX
// 0x0008 (0x0008 - 0x0000)
struct PutridGhoulAI_GetStaminaDrainSourceVFX final
{
public:
	class UParticleSystemComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PutridGhoulAI_GetStaminaDrainSourceVFX) == 0x000008, "Wrong alignment on PutridGhoulAI_GetStaminaDrainSourceVFX");
static_assert(sizeof(PutridGhoulAI_GetStaminaDrainSourceVFX) == 0x000008, "Wrong size on PutridGhoulAI_GetStaminaDrainSourceVFX");
static_assert(offsetof(PutridGhoulAI_GetStaminaDrainSourceVFX, ReturnValue) == 0x000000, "Member 'PutridGhoulAI_GetStaminaDrainSourceVFX::ReturnValue' has a wrong offset!");

// Function man.PutridGhoulAI.OnGhoulDamageTaken
// 0x0160 (0x0160 - 0x0000)
struct PutridGhoulAI_OnGhoulDamageTaken final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     TargetArg;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PutridGhoulAI_OnGhoulDamageTaken) == 0x000008, "Wrong alignment on PutridGhoulAI_OnGhoulDamageTaken");
static_assert(sizeof(PutridGhoulAI_OnGhoulDamageTaken) == 0x000160, "Wrong size on PutridGhoulAI_OnGhoulDamageTaken");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, Source) == 0x000000, "Member 'PutridGhoulAI_OnGhoulDamageTaken::Source' has a wrong offset!");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, Bullet) == 0x000008, "Member 'PutridGhoulAI_OnGhoulDamageTaken::Bullet' has a wrong offset!");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, TargetArg) == 0x000010, "Member 'PutridGhoulAI_OnGhoulDamageTaken::TargetArg' has a wrong offset!");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, Ability) == 0x000018, "Member 'PutridGhoulAI_OnGhoulDamageTaken::Ability' has a wrong offset!");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, effectiveDamage) == 0x000020, "Member 'PutridGhoulAI_OnGhoulDamageTaken::effectiveDamage' has a wrong offset!");
static_assert(offsetof(PutridGhoulAI_OnGhoulDamageTaken, DamageValue) == 0x000028, "Member 'PutridGhoulAI_OnGhoulDamageTaken::DamageValue' has a wrong offset!");

// Function man.QuestItemUserWidget.OnSetAmount
// 0x0004 (0x0004 - 0x0000)
struct QuestItemUserWidget_OnSetAmount final
{
public:
	int32                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestItemUserWidget_OnSetAmount) == 0x000004, "Wrong alignment on QuestItemUserWidget_OnSetAmount");
static_assert(sizeof(QuestItemUserWidget_OnSetAmount) == 0x000004, "Wrong size on QuestItemUserWidget_OnSetAmount");
static_assert(offsetof(QuestItemUserWidget_OnSetAmount, InAmount) == 0x000000, "Member 'QuestItemUserWidget_OnSetAmount::InAmount' has a wrong offset!");

// Function man.QuestItemUserWidget.OnSetEssence
// 0x0018 (0x0018 - 0x0000)
struct QuestItemUserWidget_OnSetEssence final
{
public:
	class FText                                   EssenceText;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestItemUserWidget_OnSetEssence) == 0x000008, "Wrong alignment on QuestItemUserWidget_OnSetEssence");
static_assert(sizeof(QuestItemUserWidget_OnSetEssence) == 0x000018, "Wrong size on QuestItemUserWidget_OnSetEssence");
static_assert(offsetof(QuestItemUserWidget_OnSetEssence, EssenceText) == 0x000000, "Member 'QuestItemUserWidget_OnSetEssence::EssenceText' has a wrong offset!");

// Function man.QuestItemUserWidget.OnSetGold
// 0x0018 (0x0018 - 0x0000)
struct QuestItemUserWidget_OnSetGold final
{
public:
	class FText                                   GoldText;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestItemUserWidget_OnSetGold) == 0x000008, "Wrong alignment on QuestItemUserWidget_OnSetGold");
static_assert(sizeof(QuestItemUserWidget_OnSetGold) == 0x000018, "Wrong size on QuestItemUserWidget_OnSetGold");
static_assert(offsetof(QuestItemUserWidget_OnSetGold, GoldText) == 0x000000, "Member 'QuestItemUserWidget_OnSetGold::GoldText' has a wrong offset!");

// Function man.QuestItemUserWidget.OnSetItem
// 0x0008 (0x0008 - 0x0000)
struct QuestItemUserWidget_OnSetItem final
{
public:
	class UItemAbility*                           InItemAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestItemUserWidget_OnSetItem) == 0x000008, "Wrong alignment on QuestItemUserWidget_OnSetItem");
static_assert(sizeof(QuestItemUserWidget_OnSetItem) == 0x000008, "Wrong size on QuestItemUserWidget_OnSetItem");
static_assert(offsetof(QuestItemUserWidget_OnSetItem, InItemAbility) == 0x000000, "Member 'QuestItemUserWidget_OnSetItem::InItemAbility' has a wrong offset!");

// Function man.QuestListCategoryUserWidget.OnSetState
// 0x0001 (0x0001 - 0x0000)
struct QuestListCategoryUserWidget_OnSetState final
{
public:
	bool                                          InIsCollapsed;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestListCategoryUserWidget_OnSetState) == 0x000001, "Wrong alignment on QuestListCategoryUserWidget_OnSetState");
static_assert(sizeof(QuestListCategoryUserWidget_OnSetState) == 0x000001, "Wrong size on QuestListCategoryUserWidget_OnSetState");
static_assert(offsetof(QuestListCategoryUserWidget_OnSetState, InIsCollapsed) == 0x000000, "Member 'QuestListCategoryUserWidget_OnSetState::InIsCollapsed' has a wrong offset!");

// Function man.SmartTextTemplateBase.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct SmartTextTemplateBase_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartTextTemplateBase_GetEditorName) == 0x000008, "Wrong alignment on SmartTextTemplateBase_GetEditorName");
static_assert(sizeof(SmartTextTemplateBase_GetEditorName) == 0x000010, "Wrong size on SmartTextTemplateBase_GetEditorName");
static_assert(offsetof(SmartTextTemplateBase_GetEditorName, ReturnValue) == 0x000000, "Member 'SmartTextTemplateBase_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.QuestListItemUserWidget.OnSetName
// 0x0018 (0x0018 - 0x0000)
struct QuestListItemUserWidget_OnSetName final
{
public:
	class FText                                   InQuestName;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestListItemUserWidget_OnSetName) == 0x000008, "Wrong alignment on QuestListItemUserWidget_OnSetName");
static_assert(sizeof(QuestListItemUserWidget_OnSetName) == 0x000018, "Wrong size on QuestListItemUserWidget_OnSetName");
static_assert(offsetof(QuestListItemUserWidget_OnSetName, InQuestName) == 0x000000, "Member 'QuestListItemUserWidget_OnSetName::InQuestName' has a wrong offset!");

// Function man.QuestListItemUserWidget.OnSetState
// 0x0001 (0x0001 - 0x0000)
struct QuestListItemUserWidget_OnSetState final
{
public:
	EQuestState                                   InQuestState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestListItemUserWidget_OnSetState) == 0x000001, "Wrong alignment on QuestListItemUserWidget_OnSetState");
static_assert(sizeof(QuestListItemUserWidget_OnSetState) == 0x000001, "Wrong size on QuestListItemUserWidget_OnSetState");
static_assert(offsetof(QuestListItemUserWidget_OnSetState, InQuestState) == 0x000000, "Member 'QuestListItemUserWidget_OnSetState::InQuestState' has a wrong offset!");

// Function man.QuestListItemUserWidget.OnSetType
// 0x0001 (0x0001 - 0x0000)
struct QuestListItemUserWidget_OnSetType final
{
public:
	bool                                          bInMainQuest;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestListItemUserWidget_OnSetType) == 0x000001, "Wrong alignment on QuestListItemUserWidget_OnSetType");
static_assert(sizeof(QuestListItemUserWidget_OnSetType) == 0x000001, "Wrong size on QuestListItemUserWidget_OnSetType");
static_assert(offsetof(QuestListItemUserWidget_OnSetType, bInMainQuest) == 0x000000, "Member 'QuestListItemUserWidget_OnSetType::bInMainQuest' has a wrong offset!");

// Function man.QuestObjectiveUserWidget.OnSetCounterText
// 0x0018 (0x0018 - 0x0000)
struct QuestObjectiveUserWidget_OnSetCounterText final
{
public:
	class FText                                   InCounterText;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestObjectiveUserWidget_OnSetCounterText) == 0x000008, "Wrong alignment on QuestObjectiveUserWidget_OnSetCounterText");
static_assert(sizeof(QuestObjectiveUserWidget_OnSetCounterText) == 0x000018, "Wrong size on QuestObjectiveUserWidget_OnSetCounterText");
static_assert(offsetof(QuestObjectiveUserWidget_OnSetCounterText, InCounterText) == 0x000000, "Member 'QuestObjectiveUserWidget_OnSetCounterText::InCounterText' has a wrong offset!");

// Function man.QuestObjectiveUserWidget.OnSetObjectiveState
// 0x0001 (0x0001 - 0x0000)
struct QuestObjectiveUserWidget_OnSetObjectiveState final
{
public:
	EQuestState                                   InObjectiveState;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestObjectiveUserWidget_OnSetObjectiveState) == 0x000001, "Wrong alignment on QuestObjectiveUserWidget_OnSetObjectiveState");
static_assert(sizeof(QuestObjectiveUserWidget_OnSetObjectiveState) == 0x000001, "Wrong size on QuestObjectiveUserWidget_OnSetObjectiveState");
static_assert(offsetof(QuestObjectiveUserWidget_OnSetObjectiveState, InObjectiveState) == 0x000000, "Member 'QuestObjectiveUserWidget_OnSetObjectiveState::InObjectiveState' has a wrong offset!");

// Function man.QuestObjectiveUserWidget.OnSetObjectiveText
// 0x0018 (0x0018 - 0x0000)
struct QuestObjectiveUserWidget_OnSetObjectiveText final
{
public:
	class FText                                   InObjectiveText;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuestObjectiveUserWidget_OnSetObjectiveText) == 0x000008, "Wrong alignment on QuestObjectiveUserWidget_OnSetObjectiveText");
static_assert(sizeof(QuestObjectiveUserWidget_OnSetObjectiveText) == 0x000018, "Wrong size on QuestObjectiveUserWidget_OnSetObjectiveText");
static_assert(offsetof(QuestObjectiveUserWidget_OnSetObjectiveText, InObjectiveText) == 0x000000, "Member 'QuestObjectiveUserWidget_OnSetObjectiveText::InObjectiveText' has a wrong offset!");

// Function man.RatingObjectInterface.GetRatingValue
// 0x0004 (0x0004 - 0x0000)
struct RatingObjectInterface_GetRatingValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingObjectInterface_GetRatingValue) == 0x000004, "Wrong alignment on RatingObjectInterface_GetRatingValue");
static_assert(sizeof(RatingObjectInterface_GetRatingValue) == 0x000004, "Wrong size on RatingObjectInterface_GetRatingValue");
static_assert(offsetof(RatingObjectInterface_GetRatingValue, ReturnValue) == 0x000000, "Member 'RatingObjectInterface_GetRatingValue::ReturnValue' has a wrong offset!");

// Function man.RatingSystemInterface.AddMatch
// 0x0028 (0x0028 - 0x0000)
struct RatingSystemInterface_AddMatch final
{
public:
	TScriptInterface<class IRatingObjectInterface> Rating1;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IRatingObjectInterface> Rating2;                                           // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RatingSystemInterface_AddMatch) == 0x000008, "Wrong alignment on RatingSystemInterface_AddMatch");
static_assert(sizeof(RatingSystemInterface_AddMatch) == 0x000028, "Wrong size on RatingSystemInterface_AddMatch");
static_assert(offsetof(RatingSystemInterface_AddMatch, Rating1) == 0x000000, "Member 'RatingSystemInterface_AddMatch::Rating1' has a wrong offset!");
static_assert(offsetof(RatingSystemInterface_AddMatch, Rating2) == 0x000010, "Member 'RatingSystemInterface_AddMatch::Rating2' has a wrong offset!");
static_assert(offsetof(RatingSystemInterface_AddMatch, Result) == 0x000020, "Member 'RatingSystemInterface_AddMatch::Result' has a wrong offset!");

// Function man.RatingSystemInterface.CreateRatingObject
// 0x0010 (0x0010 - 0x0000)
struct RatingSystemInterface_CreateRatingObject final
{
public:
	TScriptInterface<class IRatingObjectInterface> ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystemInterface_CreateRatingObject) == 0x000008, "Wrong alignment on RatingSystemInterface_CreateRatingObject");
static_assert(sizeof(RatingSystemInterface_CreateRatingObject) == 0x000010, "Wrong size on RatingSystemInterface_CreateRatingObject");
static_assert(offsetof(RatingSystemInterface_CreateRatingObject, ReturnValue) == 0x000000, "Member 'RatingSystemInterface_CreateRatingObject::ReturnValue' has a wrong offset!");

// Function man.RatingSystemLibrary.AddRace
// 0x0020 (0x0020 - 0x0000)
struct RatingSystemLibrary_AddRace final
{
public:
	TScriptInterface<class IRatingSystemInterface> RatingSystem;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FRatingResultCategory>          Results;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RatingSystemLibrary_AddRace) == 0x000008, "Wrong alignment on RatingSystemLibrary_AddRace");
static_assert(sizeof(RatingSystemLibrary_AddRace) == 0x000020, "Wrong size on RatingSystemLibrary_AddRace");
static_assert(offsetof(RatingSystemLibrary_AddRace, RatingSystem) == 0x000000, "Member 'RatingSystemLibrary_AddRace::RatingSystem' has a wrong offset!");
static_assert(offsetof(RatingSystemLibrary_AddRace, Results) == 0x000010, "Member 'RatingSystemLibrary_AddRace::Results' has a wrong offset!");

// Function man.ReactiveBlastAbility.ApplyEffectToTarget
// 0x0008 (0x0008 - 0x0000)
struct ReactiveBlastAbility_ApplyEffectToTarget final
{
public:
	class AEnemyCharacter*                        Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReactiveBlastAbility_ApplyEffectToTarget) == 0x000008, "Wrong alignment on ReactiveBlastAbility_ApplyEffectToTarget");
static_assert(sizeof(ReactiveBlastAbility_ApplyEffectToTarget) == 0x000008, "Wrong size on ReactiveBlastAbility_ApplyEffectToTarget");
static_assert(offsetof(ReactiveBlastAbility_ApplyEffectToTarget, Enemy) == 0x000000, "Member 'ReactiveBlastAbility_ApplyEffectToTarget::Enemy' has a wrong offset!");

// Function man.ReactiveBlastAbility.DoExplosionOn
// 0x0008 (0x0008 - 0x0000)
struct ReactiveBlastAbility_DoExplosionOn final
{
public:
	class AEnemyCharacter*                        Enemy;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReactiveBlastAbility_DoExplosionOn) == 0x000008, "Wrong alignment on ReactiveBlastAbility_DoExplosionOn");
static_assert(sizeof(ReactiveBlastAbility_DoExplosionOn) == 0x000008, "Wrong size on ReactiveBlastAbility_DoExplosionOn");
static_assert(offsetof(ReactiveBlastAbility_DoExplosionOn, Enemy) == 0x000000, "Member 'ReactiveBlastAbility_DoExplosionOn::Enemy' has a wrong offset!");

// Function man.ReactiveBlastAbility.GetVESourceLocation
// 0x000C (0x000C - 0x0000)
struct ReactiveBlastAbility_GetVESourceLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReactiveBlastAbility_GetVESourceLocation) == 0x000004, "Wrong alignment on ReactiveBlastAbility_GetVESourceLocation");
static_assert(sizeof(ReactiveBlastAbility_GetVESourceLocation) == 0x00000C, "Wrong size on ReactiveBlastAbility_GetVESourceLocation");
static_assert(offsetof(ReactiveBlastAbility_GetVESourceLocation, ReturnValue) == 0x000000, "Member 'ReactiveBlastAbility_GetVESourceLocation::ReturnValue' has a wrong offset!");

// Function man.ReactiveBlastAbility.GetVETarget
// 0x0008 (0x0008 - 0x0000)
struct ReactiveBlastAbility_GetVETarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReactiveBlastAbility_GetVETarget) == 0x000008, "Wrong alignment on ReactiveBlastAbility_GetVETarget");
static_assert(sizeof(ReactiveBlastAbility_GetVETarget) == 0x000008, "Wrong size on ReactiveBlastAbility_GetVETarget");
static_assert(offsetof(ReactiveBlastAbility_GetVETarget, ReturnValue) == 0x000000, "Member 'ReactiveBlastAbility_GetVETarget::ReturnValue' has a wrong offset!");

// Function man.ReactiveBlastAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ReactiveBlastAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReactiveBlastAbility_PreDamageDealt) == 0x000008, "Wrong alignment on ReactiveBlastAbility_PreDamageDealt");
static_assert(sizeof(ReactiveBlastAbility_PreDamageDealt) == 0x0002D8, "Wrong size on ReactiveBlastAbility_PreDamageDealt");
static_assert(offsetof(ReactiveBlastAbility_PreDamageDealt, Param) == 0x000000, "Member 'ReactiveBlastAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.RelicDischargeAbility.GetCurrentRelicCharge
// 0x0004 (0x0004 - 0x0000)
struct RelicDischargeAbility_GetCurrentRelicCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RelicDischargeAbility_GetCurrentRelicCharge) == 0x000004, "Wrong alignment on RelicDischargeAbility_GetCurrentRelicCharge");
static_assert(sizeof(RelicDischargeAbility_GetCurrentRelicCharge) == 0x000004, "Wrong size on RelicDischargeAbility_GetCurrentRelicCharge");
static_assert(offsetof(RelicDischargeAbility_GetCurrentRelicCharge, ReturnValue) == 0x000000, "Member 'RelicDischargeAbility_GetCurrentRelicCharge::ReturnValue' has a wrong offset!");

// Function man.RelicDischargeAbility.GetMaxRelicCharge
// 0x0004 (0x0004 - 0x0000)
struct RelicDischargeAbility_GetMaxRelicCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RelicDischargeAbility_GetMaxRelicCharge) == 0x000004, "Wrong alignment on RelicDischargeAbility_GetMaxRelicCharge");
static_assert(sizeof(RelicDischargeAbility_GetMaxRelicCharge) == 0x000004, "Wrong size on RelicDischargeAbility_GetMaxRelicCharge");
static_assert(offsetof(RelicDischargeAbility_GetMaxRelicCharge, ReturnValue) == 0x000000, "Member 'RelicDischargeAbility_GetMaxRelicCharge::ReturnValue' has a wrong offset!");

// Function man.RelicDischargePrepare.OnAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct RelicDischargePrepare_OnAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RelicDischargePrepare_OnAbilityStarted) == 0x000008, "Wrong alignment on RelicDischargePrepare_OnAbilityStarted");
static_assert(sizeof(RelicDischargePrepare_OnAbilityStarted) == 0x000010, "Wrong size on RelicDischargePrepare_OnAbilityStarted");
static_assert(offsetof(RelicDischargePrepare_OnAbilityStarted, StartedAbility) == 0x000000, "Member 'RelicDischargePrepare_OnAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(RelicDischargePrepare_OnAbilityStarted, bDesired) == 0x000008, "Member 'RelicDischargePrepare_OnAbilityStarted::bDesired' has a wrong offset!");

// Function man.RetalentUserWidget.GetEssenceRequired
// 0x0004 (0x0004 - 0x0000)
struct RetalentUserWidget_GetEssenceRequired final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RetalentUserWidget_GetEssenceRequired) == 0x000004, "Wrong alignment on RetalentUserWidget_GetEssenceRequired");
static_assert(sizeof(RetalentUserWidget_GetEssenceRequired) == 0x000004, "Wrong size on RetalentUserWidget_GetEssenceRequired");
static_assert(offsetof(RetalentUserWidget_GetEssenceRequired, ReturnValue) == 0x000000, "Member 'RetalentUserWidget_GetEssenceRequired::ReturnValue' has a wrong offset!");

// Function man.RetalentUserWidget.OnSetRetalentText
// 0x0020 (0x0020 - 0x0000)
struct RetalentUserWidget_OnSetRetalentText final
{
public:
	class FText                                   RetalentText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bDefaultTree;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RetalentUserWidget_OnSetRetalentText) == 0x000008, "Wrong alignment on RetalentUserWidget_OnSetRetalentText");
static_assert(sizeof(RetalentUserWidget_OnSetRetalentText) == 0x000020, "Wrong size on RetalentUserWidget_OnSetRetalentText");
static_assert(offsetof(RetalentUserWidget_OnSetRetalentText, RetalentText) == 0x000000, "Member 'RetalentUserWidget_OnSetRetalentText::RetalentText' has a wrong offset!");
static_assert(offsetof(RetalentUserWidget_OnSetRetalentText, bDefaultTree) == 0x000018, "Member 'RetalentUserWidget_OnSetRetalentText::bDefaultTree' has a wrong offset!");

// Function man.RetreatAttackAbility.IsWarningActive
// 0x0001 (0x0001 - 0x0000)
struct RetreatAttackAbility_IsWarningActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RetreatAttackAbility_IsWarningActive) == 0x000001, "Wrong alignment on RetreatAttackAbility_IsWarningActive");
static_assert(sizeof(RetreatAttackAbility_IsWarningActive) == 0x000001, "Wrong size on RetreatAttackAbility_IsWarningActive");
static_assert(offsetof(RetreatAttackAbility_IsWarningActive, ReturnValue) == 0x000000, "Member 'RetreatAttackAbility_IsWarningActive::ReturnValue' has a wrong offset!");

// Function man.RetreatAttackAbility.OnTravel
// 0x0020 (0x0020 - 0x0000)
struct RetreatAttackAbility_OnTravel final
{
public:
	class ALevelVisualVolume*                     SourceLevelVisualVolume;                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelVisualVolume*                     TargetLevelVisualVolume;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewPos;                                            // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RetreatAttackAbility_OnTravel) == 0x000008, "Wrong alignment on RetreatAttackAbility_OnTravel");
static_assert(sizeof(RetreatAttackAbility_OnTravel) == 0x000020, "Wrong size on RetreatAttackAbility_OnTravel");
static_assert(offsetof(RetreatAttackAbility_OnTravel, SourceLevelVisualVolume) == 0x000000, "Member 'RetreatAttackAbility_OnTravel::SourceLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(RetreatAttackAbility_OnTravel, TargetLevelVisualVolume) == 0x000008, "Member 'RetreatAttackAbility_OnTravel::TargetLevelVisualVolume' has a wrong offset!");
static_assert(offsetof(RetreatAttackAbility_OnTravel, NewPos) == 0x000010, "Member 'RetreatAttackAbility_OnTravel::NewPos' has a wrong offset!");

// Function man.RevengePassive.DamageReceived
// 0x02D8 (0x02D8 - 0x0000)
struct RevengePassive_DamageReceived final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevengePassive_DamageReceived) == 0x000008, "Wrong alignment on RevengePassive_DamageReceived");
static_assert(sizeof(RevengePassive_DamageReceived) == 0x0002D8, "Wrong size on RevengePassive_DamageReceived");
static_assert(offsetof(RevengePassive_DamageReceived, Param) == 0x000000, "Member 'RevengePassive_DamageReceived::Param' has a wrong offset!");

// Function man.RevengePassive.OnDefend
// 0x0160 (0x0160 - 0x0000)
struct RevengePassive_OnDefend final
{
public:
	class UAbilityController*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     Bullet;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     TargetControler;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           Ability;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         effectiveDamage;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageValue                           DamageValue;                                       // 0x0028(0x0138)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevengePassive_OnDefend) == 0x000008, "Wrong alignment on RevengePassive_OnDefend");
static_assert(sizeof(RevengePassive_OnDefend) == 0x000160, "Wrong size on RevengePassive_OnDefend");
static_assert(offsetof(RevengePassive_OnDefend, Source) == 0x000000, "Member 'RevengePassive_OnDefend::Source' has a wrong offset!");
static_assert(offsetof(RevengePassive_OnDefend, Bullet) == 0x000008, "Member 'RevengePassive_OnDefend::Bullet' has a wrong offset!");
static_assert(offsetof(RevengePassive_OnDefend, TargetControler) == 0x000010, "Member 'RevengePassive_OnDefend::TargetControler' has a wrong offset!");
static_assert(offsetof(RevengePassive_OnDefend, Ability) == 0x000018, "Member 'RevengePassive_OnDefend::Ability' has a wrong offset!");
static_assert(offsetof(RevengePassive_OnDefend, effectiveDamage) == 0x000020, "Member 'RevengePassive_OnDefend::effectiveDamage' has a wrong offset!");
static_assert(offsetof(RevengePassive_OnDefend, DamageValue) == 0x000028, "Member 'RevengePassive_OnDefend::DamageValue' has a wrong offset!");

// Function man.RevengePassive.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct RevengePassive_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(RevengePassive_PreDamageDealt) == 0x000008, "Wrong alignment on RevengePassive_PreDamageDealt");
static_assert(sizeof(RevengePassive_PreDamageDealt) == 0x0002D8, "Wrong size on RevengePassive_PreDamageDealt");
static_assert(offsetof(RevengePassive_PreDamageDealt, Param) == 0x000000, "Member 'RevengePassive_PreDamageDealt::Param' has a wrong offset!");

// Function man.ReverberatingStrikesPassive.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ReverberatingStrikesPassive_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReverberatingStrikesPassive_PostDamageDealt) == 0x000008, "Wrong alignment on ReverberatingStrikesPassive_PostDamageDealt");
static_assert(sizeof(ReverberatingStrikesPassive_PostDamageDealt) == 0x0002D8, "Wrong size on ReverberatingStrikesPassive_PostDamageDealt");
static_assert(offsetof(ReverberatingStrikesPassive_PostDamageDealt, Param) == 0x000000, "Member 'ReverberatingStrikesPassive_PostDamageDealt::Param' has a wrong offset!");

// Function man.RogueMageAttackZap.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct RogueMageAttackZap_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RogueMageAttackZap_BPGetTargetLocation) == 0x000004, "Wrong alignment on RogueMageAttackZap_BPGetTargetLocation");
static_assert(sizeof(RogueMageAttackZap_BPGetTargetLocation) == 0x00000C, "Wrong size on RogueMageAttackZap_BPGetTargetLocation");
static_assert(offsetof(RogueMageAttackZap_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'RogueMageAttackZap_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.SkillTreeClassUserWidget.GetCharacterClass
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeClassUserWidget_GetCharacterClass final
{
public:
	ECharacterClass                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeClassUserWidget_GetCharacterClass) == 0x000001, "Wrong alignment on SkillTreeClassUserWidget_GetCharacterClass");
static_assert(sizeof(SkillTreeClassUserWidget_GetCharacterClass) == 0x000001, "Wrong size on SkillTreeClassUserWidget_GetCharacterClass");
static_assert(offsetof(SkillTreeClassUserWidget_GetCharacterClass, ReturnValue) == 0x000000, "Member 'SkillTreeClassUserWidget_GetCharacterClass::ReturnValue' has a wrong offset!");

// Function man.SkillTreeSelectorNodeUserWidget.OnPlayUnlockVFX
// 0x0001 (0x0001 - 0x0000)
struct SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX) == 0x000001, "Wrong alignment on SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX");
static_assert(sizeof(SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX) == 0x000001, "Wrong size on SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX");
static_assert(offsetof(SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX, bAnimate) == 0x000000, "Member 'SkillTreeSelectorNodeUserWidget_OnPlayUnlockVFX::bAnimate' has a wrong offset!");

// Function man.SkillTreeSelectorNodeUserWidget.OnSetSelectorNode
// 0x0010 (0x0010 - 0x0000)
struct SkillTreeSelectorNodeUserWidget_OnSetSelectorNode final
{
public:
	ESkillTreeNodeState                           InSkillTreeNodeState;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterClass                               InCharacterClass;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             InNodeIcon;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillTreeSelectorNodeUserWidget_OnSetSelectorNode) == 0x000008, "Wrong alignment on SkillTreeSelectorNodeUserWidget_OnSetSelectorNode");
static_assert(sizeof(SkillTreeSelectorNodeUserWidget_OnSetSelectorNode) == 0x000010, "Wrong size on SkillTreeSelectorNodeUserWidget_OnSetSelectorNode");
static_assert(offsetof(SkillTreeSelectorNodeUserWidget_OnSetSelectorNode, InSkillTreeNodeState) == 0x000000, "Member 'SkillTreeSelectorNodeUserWidget_OnSetSelectorNode::InSkillTreeNodeState' has a wrong offset!");
static_assert(offsetof(SkillTreeSelectorNodeUserWidget_OnSetSelectorNode, InCharacterClass) == 0x000001, "Member 'SkillTreeSelectorNodeUserWidget_OnSetSelectorNode::InCharacterClass' has a wrong offset!");
static_assert(offsetof(SkillTreeSelectorNodeUserWidget_OnSetSelectorNode, InNodeIcon) == 0x000008, "Member 'SkillTreeSelectorNodeUserWidget_OnSetSelectorNode::InNodeIcon' has a wrong offset!");

// Function man.SkillTreeTooltipUserWidget.OnSetup
// 0x0070 (0x0070 - 0x0000)
struct SkillTreeTooltipUserWidget_OnSetup final
{
public:
	ESkillTreeNodeState                           SkillTreeNodeState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_0;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   CostText;                                          // 0x0038(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   WarningText;                                       // 0x0050(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ECharacterClass                               NodeRegion;                                        // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkillTreeTooltipUserWidget_OnSetup) == 0x000008, "Wrong alignment on SkillTreeTooltipUserWidget_OnSetup");
static_assert(sizeof(SkillTreeTooltipUserWidget_OnSetup) == 0x000070, "Wrong size on SkillTreeTooltipUserWidget_OnSetup");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, SkillTreeNodeState) == 0x000000, "Member 'SkillTreeTooltipUserWidget_OnSetup::SkillTreeNodeState' has a wrong offset!");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, Name_0) == 0x000008, "Member 'SkillTreeTooltipUserWidget_OnSetup::Name_0' has a wrong offset!");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, Description) == 0x000020, "Member 'SkillTreeTooltipUserWidget_OnSetup::Description' has a wrong offset!");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, CostText) == 0x000038, "Member 'SkillTreeTooltipUserWidget_OnSetup::CostText' has a wrong offset!");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, WarningText) == 0x000050, "Member 'SkillTreeTooltipUserWidget_OnSetup::WarningText' has a wrong offset!");
static_assert(offsetof(SkillTreeTooltipUserWidget_OnSetup, NodeRegion) == 0x000068, "Member 'SkillTreeTooltipUserWidget_OnSetup::NodeRegion' has a wrong offset!");

// Function man.SkipCutsceneUserWidget.OnConversationModeToggle
// 0x0018 (0x0018 - 0x0000)
struct SkipCutsceneUserWidget_OnConversationModeToggle final
{
public:
	class AHeroBase*                              Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkipCutsceneUserWidget_OnConversationModeToggle) == 0x000008, "Wrong alignment on SkipCutsceneUserWidget_OnConversationModeToggle");
static_assert(sizeof(SkipCutsceneUserWidget_OnConversationModeToggle) == 0x000018, "Wrong size on SkipCutsceneUserWidget_OnConversationModeToggle");
static_assert(offsetof(SkipCutsceneUserWidget_OnConversationModeToggle, Hero) == 0x000000, "Member 'SkipCutsceneUserWidget_OnConversationModeToggle::Hero' has a wrong offset!");
static_assert(offsetof(SkipCutsceneUserWidget_OnConversationModeToggle, TargetActor) == 0x000008, "Member 'SkipCutsceneUserWidget_OnConversationModeToggle::TargetActor' has a wrong offset!");
static_assert(offsetof(SkipCutsceneUserWidget_OnConversationModeToggle, bStart) == 0x000010, "Member 'SkipCutsceneUserWidget_OnConversationModeToggle::bStart' has a wrong offset!");

// Function man.SkipCutsceneUserWidget.OnCutsceneModeToggle
// 0x0001 (0x0001 - 0x0000)
struct SkipCutsceneUserWidget_OnCutsceneModeToggle final
{
public:
	bool                                          bStart;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkipCutsceneUserWidget_OnCutsceneModeToggle) == 0x000001, "Wrong alignment on SkipCutsceneUserWidget_OnCutsceneModeToggle");
static_assert(sizeof(SkipCutsceneUserWidget_OnCutsceneModeToggle) == 0x000001, "Wrong size on SkipCutsceneUserWidget_OnCutsceneModeToggle");
static_assert(offsetof(SkipCutsceneUserWidget_OnCutsceneModeToggle, bStart) == 0x000000, "Member 'SkipCutsceneUserWidget_OnCutsceneModeToggle::bStart' has a wrong offset!");

// Function man.SmashPassive.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct SmashPassive_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmashPassive_OnPostDamaged) == 0x000008, "Wrong alignment on SmashPassive_OnPostDamaged");
static_assert(sizeof(SmashPassive_OnPostDamaged) == 0x0002D8, "Wrong size on SmashPassive_OnPostDamaged");
static_assert(offsetof(SmashPassive_OnPostDamaged, Param) == 0x000000, "Member 'SmashPassive_OnPostDamaged::Param' has a wrong offset!");

// Function man.SmashPassive.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct SmashPassive_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmashPassive_OnPreDamagedPriority) == 0x000008, "Wrong alignment on SmashPassive_OnPreDamagedPriority");
static_assert(sizeof(SmashPassive_OnPreDamagedPriority) == 0x0002D8, "Wrong size on SmashPassive_OnPreDamagedPriority");
static_assert(offsetof(SmashPassive_OnPreDamagedPriority, Param) == 0x000000, "Member 'SmashPassive_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.SmiteAbility.DoesExecute
// 0x0001 (0x0001 - 0x0000)
struct SmiteAbility_DoesExecute final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmiteAbility_DoesExecute) == 0x000001, "Wrong alignment on SmiteAbility_DoesExecute");
static_assert(sizeof(SmiteAbility_DoesExecute) == 0x000001, "Wrong size on SmiteAbility_DoesExecute");
static_assert(offsetof(SmiteAbility_DoesExecute, ReturnValue) == 0x000000, "Member 'SmiteAbility_DoesExecute::ReturnValue' has a wrong offset!");

// Function man.SmiteAbility.HasMaxCharge
// 0x0001 (0x0001 - 0x0000)
struct SmiteAbility_HasMaxCharge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmiteAbility_HasMaxCharge) == 0x000001, "Wrong alignment on SmiteAbility_HasMaxCharge");
static_assert(sizeof(SmiteAbility_HasMaxCharge) == 0x000001, "Wrong size on SmiteAbility_HasMaxCharge");
static_assert(offsetof(SmiteAbility_HasMaxCharge, ReturnValue) == 0x000000, "Member 'SmiteAbility_HasMaxCharge::ReturnValue' has a wrong offset!");

// Function man.SoulTear.AbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct SoulTear_AbilityEnd final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoulTear_AbilityEnd) == 0x000008, "Wrong alignment on SoulTear_AbilityEnd");
static_assert(sizeof(SoulTear_AbilityEnd) == 0x000008, "Wrong size on SoulTear_AbilityEnd");
static_assert(offsetof(SoulTear_AbilityEnd, Ability) == 0x000000, "Member 'SoulTear_AbilityEnd::Ability' has a wrong offset!");

// Function man.SoulTear.ChaosRolled
// 0x0008 (0x0008 - 0x0000)
struct SoulTear_ChaosRolled final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoulTear_ChaosRolled) == 0x000008, "Wrong alignment on SoulTear_ChaosRolled");
static_assert(sizeof(SoulTear_ChaosRolled) == 0x000008, "Wrong size on SoulTear_ChaosRolled");
static_assert(offsetof(SoulTear_ChaosRolled, Ability) == 0x000000, "Member 'SoulTear_ChaosRolled::Ability' has a wrong offset!");

// Function man.SoulTear.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct SoulTear_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoulTear_DamageDealt) == 0x000008, "Wrong alignment on SoulTear_DamageDealt");
static_assert(sizeof(SoulTear_DamageDealt) == 0x0002D8, "Wrong size on SoulTear_DamageDealt");
static_assert(offsetof(SoulTear_DamageDealt, Param) == 0x000000, "Member 'SoulTear_DamageDealt::Param' has a wrong offset!");

// Function man.SoundTrackUserWidget.OnSetTrack
// 0x0020 (0x0020 - 0x0000)
struct SoundTrackUserWidget_OnSetTrack final
{
public:
	class FText                                   TrackName;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InCurrentTrack;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxTrack;                                        // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundTrackUserWidget_OnSetTrack) == 0x000008, "Wrong alignment on SoundTrackUserWidget_OnSetTrack");
static_assert(sizeof(SoundTrackUserWidget_OnSetTrack) == 0x000020, "Wrong size on SoundTrackUserWidget_OnSetTrack");
static_assert(offsetof(SoundTrackUserWidget_OnSetTrack, TrackName) == 0x000000, "Member 'SoundTrackUserWidget_OnSetTrack::TrackName' has a wrong offset!");
static_assert(offsetof(SoundTrackUserWidget_OnSetTrack, InCurrentTrack) == 0x000018, "Member 'SoundTrackUserWidget_OnSetTrack::InCurrentTrack' has a wrong offset!");
static_assert(offsetof(SoundTrackUserWidget_OnSetTrack, InMaxTrack) == 0x00001C, "Member 'SoundTrackUserWidget_OnSetTrack::InMaxTrack' has a wrong offset!");

// Function man.SoundTrackUserWidget.SetTrack
// 0x0004 (0x0004 - 0x0000)
struct SoundTrackUserWidget_SetTrack final
{
public:
	int32                                         InTrackIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundTrackUserWidget_SetTrack) == 0x000004, "Wrong alignment on SoundTrackUserWidget_SetTrack");
static_assert(sizeof(SoundTrackUserWidget_SetTrack) == 0x000004, "Wrong size on SoundTrackUserWidget_SetTrack");
static_assert(offsetof(SoundTrackUserWidget_SetTrack, InTrackIndex) == 0x000000, "Member 'SoundTrackUserWidget_SetTrack::InTrackIndex' has a wrong offset!");

// Function man.SpeechBubbleUserWidget.OnShowText
// 0x0001 (0x0001 - 0x0000)
struct SpeechBubbleUserWidget_OnShowText final
{
public:
	bool                                          bInShow;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpeechBubbleUserWidget_OnShowText) == 0x000001, "Wrong alignment on SpeechBubbleUserWidget_OnShowText");
static_assert(sizeof(SpeechBubbleUserWidget_OnShowText) == 0x000001, "Wrong size on SpeechBubbleUserWidget_OnShowText");
static_assert(offsetof(SpeechBubbleUserWidget_OnShowText, bInShow) == 0x000000, "Member 'SpeechBubbleUserWidget_OnShowText::bInShow' has a wrong offset!");

// Function man.SpeechBubbleUserWidget.OnSubtitleEnable
// 0x0001 (0x0001 - 0x0000)
struct SpeechBubbleUserWidget_OnSubtitleEnable final
{
public:
	bool                                          bSubtitleEnable;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpeechBubbleUserWidget_OnSubtitleEnable) == 0x000001, "Wrong alignment on SpeechBubbleUserWidget_OnSubtitleEnable");
static_assert(sizeof(SpeechBubbleUserWidget_OnSubtitleEnable) == 0x000001, "Wrong size on SpeechBubbleUserWidget_OnSubtitleEnable");
static_assert(offsetof(SpeechBubbleUserWidget_OnSubtitleEnable, bSubtitleEnable) == 0x000000, "Member 'SpeechBubbleUserWidget_OnSubtitleEnable::bSubtitleEnable' has a wrong offset!");

// Function man.SpikedWallAbility.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpikedWallAbility_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpikedWallAbility_OnPreDamageCaused) == 0x000008, "Wrong alignment on SpikedWallAbility_OnPreDamageCaused");
static_assert(sizeof(SpikedWallAbility_OnPreDamageCaused) == 0x0002D8, "Wrong size on SpikedWallAbility_OnPreDamageCaused");
static_assert(offsetof(SpikedWallAbility_OnPreDamageCaused, Param) == 0x000000, "Member 'SpikedWallAbility_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.SpiritCompanionAbility.OnActorKilled
// 0x0008 (0x0008 - 0x0000)
struct SpiritCompanionAbility_OnActorKilled final
{
public:
	class AActor*                                 InKilledActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAbility_OnActorKilled) == 0x000008, "Wrong alignment on SpiritCompanionAbility_OnActorKilled");
static_assert(sizeof(SpiritCompanionAbility_OnActorKilled) == 0x000008, "Wrong size on SpiritCompanionAbility_OnActorKilled");
static_assert(offsetof(SpiritCompanionAbility_OnActorKilled, InKilledActor) == 0x000000, "Member 'SpiritCompanionAbility_OnActorKilled::InKilledActor' has a wrong offset!");

// Function man.SpiritCompanionAI.OnHeroPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpiritCompanionAI_OnHeroPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnHeroPostDamageCaused) == 0x000008, "Wrong alignment on SpiritCompanionAI_OnHeroPostDamageCaused");
static_assert(sizeof(SpiritCompanionAI_OnHeroPostDamageCaused) == 0x0002D8, "Wrong size on SpiritCompanionAI_OnHeroPostDamageCaused");
static_assert(offsetof(SpiritCompanionAI_OnHeroPostDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'SpiritCompanionAI_OnHeroPostDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.SpiritCompanionAI.OnHeroPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpiritCompanionAI_OnHeroPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnHeroPreDamageCaused) == 0x000008, "Wrong alignment on SpiritCompanionAI_OnHeroPreDamageCaused");
static_assert(sizeof(SpiritCompanionAI_OnHeroPreDamageCaused) == 0x0002D8, "Wrong size on SpiritCompanionAI_OnHeroPreDamageCaused");
static_assert(offsetof(SpiritCompanionAI_OnHeroPreDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'SpiritCompanionAI_OnHeroPreDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.SpiritCompanionAI.OnOwnerTeleported
// 0x000C (0x000C - 0x0000)
struct SpiritCompanionAI_OnOwnerTeleported final
{
public:
	struct FVector                                TeleportPos;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnOwnerTeleported) == 0x000004, "Wrong alignment on SpiritCompanionAI_OnOwnerTeleported");
static_assert(sizeof(SpiritCompanionAI_OnOwnerTeleported) == 0x00000C, "Wrong size on SpiritCompanionAI_OnOwnerTeleported");
static_assert(offsetof(SpiritCompanionAI_OnOwnerTeleported, TeleportPos) == 0x000000, "Member 'SpiritCompanionAI_OnOwnerTeleported::TeleportPos' has a wrong offset!");

// Function man.SpiritCompanionAI.OnSpiritCompanionKilled
// 0x0010 (0x0010 - 0x0000)
struct SpiritCompanionAI_OnSpiritCompanionKilled final
{
public:
	class UObject*                                Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     KillerAbilityController;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnSpiritCompanionKilled) == 0x000008, "Wrong alignment on SpiritCompanionAI_OnSpiritCompanionKilled");
static_assert(sizeof(SpiritCompanionAI_OnSpiritCompanionKilled) == 0x000010, "Wrong size on SpiritCompanionAI_OnSpiritCompanionKilled");
static_assert(offsetof(SpiritCompanionAI_OnSpiritCompanionKilled, Killer) == 0x000000, "Member 'SpiritCompanionAI_OnSpiritCompanionKilled::Killer' has a wrong offset!");
static_assert(offsetof(SpiritCompanionAI_OnSpiritCompanionKilled, KillerAbilityController) == 0x000008, "Member 'SpiritCompanionAI_OnSpiritCompanionKilled::KillerAbilityController' has a wrong offset!");

// Function man.SpiritCompanionAI.OnSpiritPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpiritCompanionAI_OnSpiritPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnSpiritPostDamageCaused) == 0x000008, "Wrong alignment on SpiritCompanionAI_OnSpiritPostDamageCaused");
static_assert(sizeof(SpiritCompanionAI_OnSpiritPostDamageCaused) == 0x0002D8, "Wrong size on SpiritCompanionAI_OnSpiritPostDamageCaused");
static_assert(offsetof(SpiritCompanionAI_OnSpiritPostDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'SpiritCompanionAI_OnSpiritPostDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.SpiritCompanionAI.OnSpiritPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SpiritCompanionAI_OnSpiritPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  PreDamagedEventParam;                              // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritCompanionAI_OnSpiritPreDamageCaused) == 0x000008, "Wrong alignment on SpiritCompanionAI_OnSpiritPreDamageCaused");
static_assert(sizeof(SpiritCompanionAI_OnSpiritPreDamageCaused) == 0x0002D8, "Wrong size on SpiritCompanionAI_OnSpiritPreDamageCaused");
static_assert(offsetof(SpiritCompanionAI_OnSpiritPreDamageCaused, PreDamagedEventParam) == 0x000000, "Member 'SpiritCompanionAI_OnSpiritPreDamageCaused::PreDamagedEventParam' has a wrong offset!");

// Function man.StatusTypeController.BPGetStatusEffectStackNum
// 0x0004 (0x0004 - 0x0000)
struct StatusTypeController_BPGetStatusEffectStackNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusTypeController_BPGetStatusEffectStackNum) == 0x000004, "Wrong alignment on StatusTypeController_BPGetStatusEffectStackNum");
static_assert(sizeof(StatusTypeController_BPGetStatusEffectStackNum) == 0x000004, "Wrong size on StatusTypeController_BPGetStatusEffectStackNum");
static_assert(offsetof(StatusTypeController_BPGetStatusEffectStackNum, ReturnValue) == 0x000000, "Member 'StatusTypeController_BPGetStatusEffectStackNum::ReturnValue' has a wrong offset!");

// Function man.StatusTypeController.GetLastSECauserDamageData
// 0x000C (0x000C - 0x0000)
struct StatusTypeController_GetLastSECauserDamageData final
{
public:
	struct FStatusEffectCauserDamage              ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusTypeController_GetLastSECauserDamageData) == 0x000004, "Wrong alignment on StatusTypeController_GetLastSECauserDamageData");
static_assert(sizeof(StatusTypeController_GetLastSECauserDamageData) == 0x00000C, "Wrong size on StatusTypeController_GetLastSECauserDamageData");
static_assert(offsetof(StatusTypeController_GetLastSECauserDamageData, ReturnValue) == 0x000000, "Member 'StatusTypeController_GetLastSECauserDamageData::ReturnValue' has a wrong offset!");

// Function man.StatusEffectPassive.BPGetSourceActor
// 0x0008 (0x0008 - 0x0000)
struct StatusEffectPassive_BPGetSourceActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectPassive_BPGetSourceActor) == 0x000008, "Wrong alignment on StatusEffectPassive_BPGetSourceActor");
static_assert(sizeof(StatusEffectPassive_BPGetSourceActor) == 0x000008, "Wrong size on StatusEffectPassive_BPGetSourceActor");
static_assert(offsetof(StatusEffectPassive_BPGetSourceActor, ReturnValue) == 0x000000, "Member 'StatusEffectPassive_BPGetSourceActor::ReturnValue' has a wrong offset!");

// Function man.StatusEffectPassive.BPGetSourceSourceAbility
// 0x0008 (0x0008 - 0x0000)
struct StatusEffectPassive_BPGetSourceSourceAbility final
{
public:
	class UAbilityBase*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectPassive_BPGetSourceSourceAbility) == 0x000008, "Wrong alignment on StatusEffectPassive_BPGetSourceSourceAbility");
static_assert(sizeof(StatusEffectPassive_BPGetSourceSourceAbility) == 0x000008, "Wrong size on StatusEffectPassive_BPGetSourceSourceAbility");
static_assert(offsetof(StatusEffectPassive_BPGetSourceSourceAbility, ReturnValue) == 0x000000, "Member 'StatusEffectPassive_BPGetSourceSourceAbility::ReturnValue' has a wrong offset!");

// Function man.EnemyModifiersNode.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct EnemyModifiersNode_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnemyModifiersNode_GetEditorName) == 0x000008, "Wrong alignment on EnemyModifiersNode_GetEditorName");
static_assert(sizeof(EnemyModifiersNode_GetEditorName) == 0x000010, "Wrong size on EnemyModifiersNode_GetEditorName");
static_assert(offsetof(EnemyModifiersNode_GetEditorName, ReturnValue) == 0x000000, "Member 'EnemyModifiersNode_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.SummonImpAbility.AbilityModifierChanged
// 0x000C (0x000C - 0x0000)
struct SummonImpAbility_AbilityModifierChanged final
{
public:
	bool                                          bAddedModifier;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGeneralAbilityModifier                       GeneralID;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomID;                                          // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonImpAbility_AbilityModifierChanged) == 0x000004, "Wrong alignment on SummonImpAbility_AbilityModifierChanged");
static_assert(sizeof(SummonImpAbility_AbilityModifierChanged) == 0x00000C, "Wrong size on SummonImpAbility_AbilityModifierChanged");
static_assert(offsetof(SummonImpAbility_AbilityModifierChanged, bAddedModifier) == 0x000000, "Member 'SummonImpAbility_AbilityModifierChanged::bAddedModifier' has a wrong offset!");
static_assert(offsetof(SummonImpAbility_AbilityModifierChanged, GeneralID) == 0x000001, "Member 'SummonImpAbility_AbilityModifierChanged::GeneralID' has a wrong offset!");
static_assert(offsetof(SummonImpAbility_AbilityModifierChanged, CustomID) == 0x000004, "Member 'SummonImpAbility_AbilityModifierChanged::CustomID' has a wrong offset!");

// Function man.SummonImpAbility.FamiliarAnimEvent
// 0x0030 (0x0030 - 0x0000)
struct SummonImpAbility_FamiliarAnimEvent final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonImpAbility_FamiliarAnimEvent) == 0x000008, "Wrong alignment on SummonImpAbility_FamiliarAnimEvent");
static_assert(sizeof(SummonImpAbility_FamiliarAnimEvent) == 0x000030, "Wrong size on SummonImpAbility_FamiliarAnimEvent");
static_assert(offsetof(SummonImpAbility_FamiliarAnimEvent, AnimEventParam) == 0x000000, "Member 'SummonImpAbility_FamiliarAnimEvent::AnimEventParam' has a wrong offset!");

// Function man.SummonImpAbility.PreDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct SummonImpAbility_PreDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SummonImpAbility_PreDamageDealt) == 0x000008, "Wrong alignment on SummonImpAbility_PreDamageDealt");
static_assert(sizeof(SummonImpAbility_PreDamageDealt) == 0x0002D8, "Wrong size on SummonImpAbility_PreDamageDealt");
static_assert(offsetof(SummonImpAbility_PreDamageDealt, Param) == 0x000000, "Member 'SummonImpAbility_PreDamageDealt::Param' has a wrong offset!");

// Function man.SurfaceTypeVolume.ChangeDataAsset
// 0x0008 (0x0008 - 0x0000)
struct SurfaceTypeVolume_ChangeDataAsset final
{
public:
	class USurfaceEffectTypeDataAsset*            InDataAsset;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SurfaceTypeVolume_ChangeDataAsset) == 0x000008, "Wrong alignment on SurfaceTypeVolume_ChangeDataAsset");
static_assert(sizeof(SurfaceTypeVolume_ChangeDataAsset) == 0x000008, "Wrong size on SurfaceTypeVolume_ChangeDataAsset");
static_assert(offsetof(SurfaceTypeVolume_ChangeDataAsset, InDataAsset) == 0x000000, "Member 'SurfaceTypeVolume_ChangeDataAsset::InDataAsset' has a wrong offset!");

// Function man.SurfaceEffectComponent.OnSurfaceVolBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct SurfaceEffectComponent_OnSurfaceVolBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap) == 0x000008, "Wrong alignment on SurfaceEffectComponent_OnSurfaceVolBeginOverlap");
static_assert(sizeof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap) == 0x0000A8, "Wrong size on SurfaceEffectComponent_OnSurfaceVolBeginOverlap");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, OtherActor) == 0x000008, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, OtherComp) == 0x000010, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, bFromSweep) == 0x00001C, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolBeginOverlap, SweepResult) == 0x000020, "Member 'SurfaceEffectComponent_OnSurfaceVolBeginOverlap::SweepResult' has a wrong offset!");

// Function man.SurfaceEffectComponent.OnSurfaceVolEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct SurfaceEffectComponent_OnSurfaceVolEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SurfaceEffectComponent_OnSurfaceVolEndOverlap) == 0x000008, "Wrong alignment on SurfaceEffectComponent_OnSurfaceVolEndOverlap");
static_assert(sizeof(SurfaceEffectComponent_OnSurfaceVolEndOverlap) == 0x000020, "Wrong size on SurfaceEffectComponent_OnSurfaceVolEndOverlap");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolEndOverlap, OverlappedComponent) == 0x000000, "Member 'SurfaceEffectComponent_OnSurfaceVolEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolEndOverlap, OtherActor) == 0x000008, "Member 'SurfaceEffectComponent_OnSurfaceVolEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolEndOverlap, OtherComp) == 0x000010, "Member 'SurfaceEffectComponent_OnSurfaceVolEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SurfaceEffectComponent_OnSurfaceVolEndOverlap, OtherBodyIndex) == 0x000018, "Member 'SurfaceEffectComponent_OnSurfaceVolEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.TabButtonUserWidget.OnSetActive
// 0x0001 (0x0001 - 0x0000)
struct TabButtonUserWidget_OnSetActive final
{
public:
	bool                                          bInIsActive;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TabButtonUserWidget_OnSetActive) == 0x000001, "Wrong alignment on TabButtonUserWidget_OnSetActive");
static_assert(sizeof(TabButtonUserWidget_OnSetActive) == 0x000001, "Wrong size on TabButtonUserWidget_OnSetActive");
static_assert(offsetof(TabButtonUserWidget_OnSetActive, bInIsActive) == 0x000000, "Member 'TabButtonUserWidget_OnSetActive::bInIsActive' has a wrong offset!");

// Function man.TabButtonUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct TabButtonUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TabButtonUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on TabButtonUserWidget_OnSetEnabled");
static_assert(sizeof(TabButtonUserWidget_OnSetEnabled) == 0x000001, "Wrong size on TabButtonUserWidget_OnSetEnabled");
static_assert(offsetof(TabButtonUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'TabButtonUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.TabButtonUserWidget.OnSetText
// 0x0018 (0x0018 - 0x0000)
struct TabButtonUserWidget_OnSetText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TabButtonUserWidget_OnSetText) == 0x000008, "Wrong alignment on TabButtonUserWidget_OnSetText");
static_assert(sizeof(TabButtonUserWidget_OnSetText) == 0x000018, "Wrong size on TabButtonUserWidget_OnSetText");
static_assert(offsetof(TabButtonUserWidget_OnSetText, Text) == 0x000000, "Member 'TabButtonUserWidget_OnSetText::Text' has a wrong offset!");

// Function man.TabButtonUserWidget.OnToggleNewItemWarning
// 0x0001 (0x0001 - 0x0000)
struct TabButtonUserWidget_OnToggleNewItemWarning final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TabButtonUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong alignment on TabButtonUserWidget_OnToggleNewItemWarning");
static_assert(sizeof(TabButtonUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong size on TabButtonUserWidget_OnToggleNewItemWarning");
static_assert(offsetof(TabButtonUserWidget_OnToggleNewItemWarning, bInVisible) == 0x000000, "Member 'TabButtonUserWidget_OnToggleNewItemWarning::bInVisible' has a wrong offset!");

// Function man.TeleportHelperAbility.OnUserInput
// 0x0004 (0x0004 - 0x0000)
struct TeleportHelperAbility_OnUserInput final
{
public:
	int32                                         InputCommandNum;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportHelperAbility_OnUserInput) == 0x000004, "Wrong alignment on TeleportHelperAbility_OnUserInput");
static_assert(sizeof(TeleportHelperAbility_OnUserInput) == 0x000004, "Wrong size on TeleportHelperAbility_OnUserInput");
static_assert(offsetof(TeleportHelperAbility_OnUserInput, InputCommandNum) == 0x000000, "Member 'TeleportHelperAbility_OnUserInput::InputCommandNum' has a wrong offset!");

// Function man.TeleportTriggerVolume.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct TeleportTriggerVolume_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportTriggerVolume_IsEnabled) == 0x000001, "Wrong alignment on TeleportTriggerVolume_IsEnabled");
static_assert(sizeof(TeleportTriggerVolume_IsEnabled) == 0x000001, "Wrong size on TeleportTriggerVolume_IsEnabled");
static_assert(offsetof(TeleportTriggerVolume_IsEnabled, ReturnValue) == 0x000000, "Member 'TeleportTriggerVolume_IsEnabled::ReturnValue' has a wrong offset!");

// Function man.TeleportTriggerVolume.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct TeleportTriggerVolume_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportTriggerVolume_OnBeginOverlap) == 0x000008, "Wrong alignment on TeleportTriggerVolume_OnBeginOverlap");
static_assert(sizeof(TeleportTriggerVolume_OnBeginOverlap) == 0x0000A8, "Wrong size on TeleportTriggerVolume_OnBeginOverlap");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'TeleportTriggerVolume_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, OtherActor) == 0x000008, "Member 'TeleportTriggerVolume_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, OtherComp) == 0x000010, "Member 'TeleportTriggerVolume_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'TeleportTriggerVolume_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'TeleportTriggerVolume_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(TeleportTriggerVolume_OnBeginOverlap, SweepResult) == 0x000020, "Member 'TeleportTriggerVolume_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function man.TeleportTriggerVolume.OnCinematicFinished
// 0x0008 (0x0008 - 0x0000)
struct TeleportTriggerVolume_OnCinematicFinished final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportTriggerVolume_OnCinematicFinished) == 0x000008, "Wrong alignment on TeleportTriggerVolume_OnCinematicFinished");
static_assert(sizeof(TeleportTriggerVolume_OnCinematicFinished) == 0x000008, "Wrong size on TeleportTriggerVolume_OnCinematicFinished");
static_assert(offsetof(TeleportTriggerVolume_OnCinematicFinished, ManUserWidgetBase) == 0x000000, "Member 'TeleportTriggerVolume_OnCinematicFinished::ManUserWidgetBase' has a wrong offset!");

// Function man.TeleportTriggerVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct TeleportTriggerVolume_SetEnabled final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeleportTriggerVolume_SetEnabled) == 0x000001, "Wrong alignment on TeleportTriggerVolume_SetEnabled");
static_assert(sizeof(TeleportTriggerVolume_SetEnabled) == 0x000001, "Wrong size on TeleportTriggerVolume_SetEnabled");
static_assert(offsetof(TeleportTriggerVolume_SetEnabled, bValue) == 0x000000, "Member 'TeleportTriggerVolume_SetEnabled::bValue' has a wrong offset!");

// Function man.TextBubbleWidgetComponent.BPAddDialogue
// 0x0018 (0x0018 - 0x0000)
struct TextBubbleWidgetComponent_BPAddDialogue final
{
public:
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                addOnce;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitforOtherVO;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TextBubbleWidgetComponent_BPAddDialogue) == 0x000008, "Wrong alignment on TextBubbleWidgetComponent_BPAddDialogue");
static_assert(sizeof(TextBubbleWidgetComponent_BPAddDialogue) == 0x000018, "Wrong size on TextBubbleWidgetComponent_BPAddDialogue");
static_assert(offsetof(TextBubbleWidgetComponent_BPAddDialogue, DialogueDataAsset) == 0x000000, "Member 'TextBubbleWidgetComponent_BPAddDialogue::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(TextBubbleWidgetComponent_BPAddDialogue, addOnce) == 0x000008, "Member 'TextBubbleWidgetComponent_BPAddDialogue::addOnce' has a wrong offset!");
static_assert(offsetof(TextBubbleWidgetComponent_BPAddDialogue, bWaitforOtherVO) == 0x000010, "Member 'TextBubbleWidgetComponent_BPAddDialogue::bWaitforOtherVO' has a wrong offset!");

// Function man.TextBubbleWidgetComponent.BPAddDialogueInstant
// 0x0010 (0x0010 - 0x0000)
struct TextBubbleWidgetComponent_BPAddDialogueInstant final
{
public:
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                addOnce;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextBubbleWidgetComponent_BPAddDialogueInstant) == 0x000008, "Wrong alignment on TextBubbleWidgetComponent_BPAddDialogueInstant");
static_assert(sizeof(TextBubbleWidgetComponent_BPAddDialogueInstant) == 0x000010, "Wrong size on TextBubbleWidgetComponent_BPAddDialogueInstant");
static_assert(offsetof(TextBubbleWidgetComponent_BPAddDialogueInstant, DialogueDataAsset) == 0x000000, "Member 'TextBubbleWidgetComponent_BPAddDialogueInstant::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(TextBubbleWidgetComponent_BPAddDialogueInstant, addOnce) == 0x000008, "Member 'TextBubbleWidgetComponent_BPAddDialogueInstant::addOnce' has a wrong offset!");

// Function man.TextBubbleWidgetComponent.BPInit
// 0x0038 (0x0038 - 0x0000)
struct TextBubbleWidgetComponent_BPInit final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   LineIDText;                                        // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EDialogueBubbleType                           DialogueBubbleType;                                // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TextBubbleWidgetComponent_BPInit) == 0x000008, "Wrong alignment on TextBubbleWidgetComponent_BPInit");
static_assert(sizeof(TextBubbleWidgetComponent_BPInit) == 0x000038, "Wrong size on TextBubbleWidgetComponent_BPInit");
static_assert(offsetof(TextBubbleWidgetComponent_BPInit, Text) == 0x000000, "Member 'TextBubbleWidgetComponent_BPInit::Text' has a wrong offset!");
static_assert(offsetof(TextBubbleWidgetComponent_BPInit, LineIDText) == 0x000018, "Member 'TextBubbleWidgetComponent_BPInit::LineIDText' has a wrong offset!");
static_assert(offsetof(TextBubbleWidgetComponent_BPInit, DialogueBubbleType) == 0x000030, "Member 'TextBubbleWidgetComponent_BPInit::DialogueBubbleType' has a wrong offset!");

// Function man.ToxicCutsPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ToxicCutsPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToxicCutsPassive_DamageDealt) == 0x000008, "Wrong alignment on ToxicCutsPassive_DamageDealt");
static_assert(sizeof(ToxicCutsPassive_DamageDealt) == 0x0002D8, "Wrong size on ToxicCutsPassive_DamageDealt");
static_assert(offsetof(ToxicCutsPassive_DamageDealt, Param) == 0x000000, "Member 'ToxicCutsPassive_DamageDealt::Param' has a wrong offset!");

// Function man.ToxicPool.PostDamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct ToxicPool_PostDamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ToxicPool_PostDamageDealt) == 0x000008, "Wrong alignment on ToxicPool_PostDamageDealt");
static_assert(sizeof(ToxicPool_PostDamageDealt) == 0x0002D8, "Wrong size on ToxicPool_PostDamageDealt");
static_assert(offsetof(ToxicPool_PostDamageDealt, Param) == 0x000000, "Member 'ToxicPool_PostDamageDealt::Param' has a wrong offset!");

// Function man.TrapActorBase.IsOperational
// 0x0001 (0x0001 - 0x0000)
struct TrapActorBase_IsOperational final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrapActorBase_IsOperational) == 0x000001, "Wrong alignment on TrapActorBase_IsOperational");
static_assert(sizeof(TrapActorBase_IsOperational) == 0x000001, "Wrong size on TrapActorBase_IsOperational");
static_assert(offsetof(TrapActorBase_IsOperational, ReturnValue) == 0x000000, "Member 'TrapActorBase_IsOperational::ReturnValue' has a wrong offset!");

// Function man.TrapActorBase.ToggleTrap
// 0x0001 (0x0001 - 0x0000)
struct TrapActorBase_ToggleTrap final
{
public:
	bool                                          bBringOnline;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrapActorBase_ToggleTrap) == 0x000001, "Wrong alignment on TrapActorBase_ToggleTrap");
static_assert(sizeof(TrapActorBase_ToggleTrap) == 0x000001, "Wrong size on TrapActorBase_ToggleTrap");
static_assert(offsetof(TrapActorBase_ToggleTrap, bBringOnline) == 0x000000, "Member 'TrapActorBase_ToggleTrap::bBringOnline' has a wrong offset!");

// Function man.ProjectileTrap.ProjectileShot
// 0x0008 (0x0008 - 0x0000)
struct ProjectileTrap_ProjectileShot final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileTrap_ProjectileShot) == 0x000008, "Wrong alignment on ProjectileTrap_ProjectileShot");
static_assert(sizeof(ProjectileTrap_ProjectileShot) == 0x000008, "Wrong size on ProjectileTrap_ProjectileShot");
static_assert(offsetof(ProjectileTrap_ProjectileShot, Projectile) == 0x000000, "Member 'ProjectileTrap_ProjectileShot::Projectile' has a wrong offset!");

// Function man.TreasureGoblinAI.Damaged
// 0x02D8 (0x02D8 - 0x0000)
struct TreasureGoblinAI_Damaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TreasureGoblinAI_Damaged) == 0x000008, "Wrong alignment on TreasureGoblinAI_Damaged");
static_assert(sizeof(TreasureGoblinAI_Damaged) == 0x0002D8, "Wrong size on TreasureGoblinAI_Damaged");
static_assert(offsetof(TreasureGoblinAI_Damaged, Param) == 0x000000, "Member 'TreasureGoblinAI_Damaged::Param' has a wrong offset!");

// Function man.TriggerBoxComponent.OnBeginOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct TriggerBoxComponent_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TriggerBoxComponent_OnBeginOverlap) == 0x000008, "Wrong alignment on TriggerBoxComponent_OnBeginOverlap");
static_assert(sizeof(TriggerBoxComponent_OnBeginOverlap) == 0x0000A8, "Wrong size on TriggerBoxComponent_OnBeginOverlap");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'TriggerBoxComponent_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, OtherActor) == 0x000008, "Member 'TriggerBoxComponent_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, OtherComp) == 0x000010, "Member 'TriggerBoxComponent_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'TriggerBoxComponent_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'TriggerBoxComponent_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnBeginOverlap, SweepResult) == 0x000020, "Member 'TriggerBoxComponent_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function man.TriggerBoxComponent.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct TriggerBoxComponent_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TriggerBoxComponent_OnEndOverlap) == 0x000008, "Wrong alignment on TriggerBoxComponent_OnEndOverlap");
static_assert(sizeof(TriggerBoxComponent_OnEndOverlap) == 0x000020, "Wrong size on TriggerBoxComponent_OnEndOverlap");
static_assert(offsetof(TriggerBoxComponent_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'TriggerBoxComponent_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnEndOverlap, OtherActor) == 0x000008, "Member 'TriggerBoxComponent_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnEndOverlap, OtherComp) == 0x000010, "Member 'TriggerBoxComponent_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(TriggerBoxComponent_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'TriggerBoxComponent_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function man.OnGPEventToggleAbility_Trigger.OnSpawned
// 0x0018 (0x0018 - 0x0000)
struct OnGPEventToggleAbility_Trigger_OnSpawned final
{
public:
	class AActorSoul*                             ActorSoul;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 BondActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityController*                     AbilityController;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnGPEventToggleAbility_Trigger_OnSpawned) == 0x000008, "Wrong alignment on OnGPEventToggleAbility_Trigger_OnSpawned");
static_assert(sizeof(OnGPEventToggleAbility_Trigger_OnSpawned) == 0x000018, "Wrong size on OnGPEventToggleAbility_Trigger_OnSpawned");
static_assert(offsetof(OnGPEventToggleAbility_Trigger_OnSpawned, ActorSoul) == 0x000000, "Member 'OnGPEventToggleAbility_Trigger_OnSpawned::ActorSoul' has a wrong offset!");
static_assert(offsetof(OnGPEventToggleAbility_Trigger_OnSpawned, BondActor) == 0x000008, "Member 'OnGPEventToggleAbility_Trigger_OnSpawned::BondActor' has a wrong offset!");
static_assert(offsetof(OnGPEventToggleAbility_Trigger_OnSpawned, AbilityController) == 0x000010, "Member 'OnGPEventToggleAbility_Trigger_OnSpawned::AbilityController' has a wrong offset!");

// Function man.TrinityAbility.GetVASphereSize
// 0x0004 (0x0004 - 0x0000)
struct TrinityAbility_GetVASphereSize final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrinityAbility_GetVASphereSize) == 0x000004, "Wrong alignment on TrinityAbility_GetVASphereSize");
static_assert(sizeof(TrinityAbility_GetVASphereSize) == 0x000004, "Wrong size on TrinityAbility_GetVASphereSize");
static_assert(offsetof(TrinityAbility_GetVASphereSize, ReturnValue) == 0x000000, "Member 'TrinityAbility_GetVASphereSize::ReturnValue' has a wrong offset!");

// Function man.TutorialPromptVolume_DestroyCeramic.DamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct TutorialPromptVolume_DestroyCeramic_DamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_DestroyCeramic_DamageCaused) == 0x000008, "Wrong alignment on TutorialPromptVolume_DestroyCeramic_DamageCaused");
static_assert(sizeof(TutorialPromptVolume_DestroyCeramic_DamageCaused) == 0x0002D8, "Wrong size on TutorialPromptVolume_DestroyCeramic_DamageCaused");
static_assert(offsetof(TutorialPromptVolume_DestroyCeramic_DamageCaused, Param) == 0x000000, "Member 'TutorialPromptVolume_DestroyCeramic_DamageCaused::Param' has a wrong offset!");

// Function man.TutorialPromptVolume_AbilityTrigger.AbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct TutorialPromptVolume_AbilityTrigger_AbilityStarted final
{
public:
	class UAbilityBase*                           pAbility;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TutorialPromptVolume_AbilityTrigger_AbilityStarted) == 0x000008, "Wrong alignment on TutorialPromptVolume_AbilityTrigger_AbilityStarted");
static_assert(sizeof(TutorialPromptVolume_AbilityTrigger_AbilityStarted) == 0x000010, "Wrong size on TutorialPromptVolume_AbilityTrigger_AbilityStarted");
static_assert(offsetof(TutorialPromptVolume_AbilityTrigger_AbilityStarted, pAbility) == 0x000000, "Member 'TutorialPromptVolume_AbilityTrigger_AbilityStarted::pAbility' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_AbilityTrigger_AbilityStarted, bDesired) == 0x000008, "Member 'TutorialPromptVolume_AbilityTrigger_AbilityStarted::bDesired' has a wrong offset!");

// Function man.TutorialPromptVolume_UseQuickItem.AbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct TutorialPromptVolume_UseQuickItem_AbilityStarted final
{
public:
	class UAbilityBase*                           pAbility;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TutorialPromptVolume_UseQuickItem_AbilityStarted) == 0x000008, "Wrong alignment on TutorialPromptVolume_UseQuickItem_AbilityStarted");
static_assert(sizeof(TutorialPromptVolume_UseQuickItem_AbilityStarted) == 0x000010, "Wrong size on TutorialPromptVolume_UseQuickItem_AbilityStarted");
static_assert(offsetof(TutorialPromptVolume_UseQuickItem_AbilityStarted, pAbility) == 0x000000, "Member 'TutorialPromptVolume_UseQuickItem_AbilityStarted::pAbility' has a wrong offset!");
static_assert(offsetof(TutorialPromptVolume_UseQuickItem_AbilityStarted, bDesired) == 0x000008, "Member 'TutorialPromptVolume_UseQuickItem_AbilityStarted::bDesired' has a wrong offset!");

// Function man.TutorialPromptVolume_LookUpDown.OnLookVAxisInput
// 0x0004 (0x0004 - 0x0000)
struct TutorialPromptVolume_LookUpDown_OnLookVAxisInput final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_LookUpDown_OnLookVAxisInput) == 0x000004, "Wrong alignment on TutorialPromptVolume_LookUpDown_OnLookVAxisInput");
static_assert(sizeof(TutorialPromptVolume_LookUpDown_OnLookVAxisInput) == 0x000004, "Wrong size on TutorialPromptVolume_LookUpDown_OnLookVAxisInput");
static_assert(offsetof(TutorialPromptVolume_LookUpDown_OnLookVAxisInput, Value) == 0x000000, "Member 'TutorialPromptVolume_LookUpDown_OnLookVAxisInput::Value' has a wrong offset!");

// Function man.TutorialPromptVolume_OpenStartMenu.OnStartMenuHide
// 0x0008 (0x0008 - 0x0000)
struct TutorialPromptVolume_OpenStartMenu_OnStartMenuHide final
{
public:
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialPromptVolume_OpenStartMenu_OnStartMenuHide) == 0x000008, "Wrong alignment on TutorialPromptVolume_OpenStartMenu_OnStartMenuHide");
static_assert(sizeof(TutorialPromptVolume_OpenStartMenu_OnStartMenuHide) == 0x000008, "Wrong size on TutorialPromptVolume_OpenStartMenu_OnStartMenuHide");
static_assert(offsetof(TutorialPromptVolume_OpenStartMenu_OnStartMenuHide, ManUserWidgetBase) == 0x000000, "Member 'TutorialPromptVolume_OpenStartMenu_OnStartMenuHide::ManUserWidgetBase' has a wrong offset!");

// Function man.TutorialScreenUserWidget.OnSetDescription
// 0x0018 (0x0018 - 0x0000)
struct TutorialScreenUserWidget_OnSetDescription final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialScreenUserWidget_OnSetDescription) == 0x000008, "Wrong alignment on TutorialScreenUserWidget_OnSetDescription");
static_assert(sizeof(TutorialScreenUserWidget_OnSetDescription) == 0x000018, "Wrong size on TutorialScreenUserWidget_OnSetDescription");
static_assert(offsetof(TutorialScreenUserWidget_OnSetDescription, Description) == 0x000000, "Member 'TutorialScreenUserWidget_OnSetDescription::Description' has a wrong offset!");

// Function man.TutorialScreenUserWidget.OnSetPage
// 0x0040 (0x0040 - 0x0000)
struct TutorialScreenUserWidget_OnSetPage final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InPageNumber;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         CurrentPage;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPage;                                           // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFade;                                             // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TutorialScreenUserWidget_OnSetPage) == 0x000008, "Wrong alignment on TutorialScreenUserWidget_OnSetPage");
static_assert(sizeof(TutorialScreenUserWidget_OnSetPage) == 0x000040, "Wrong size on TutorialScreenUserWidget_OnSetPage");
static_assert(offsetof(TutorialScreenUserWidget_OnSetPage, Title) == 0x000000, "Member 'TutorialScreenUserWidget_OnSetPage::Title' has a wrong offset!");
static_assert(offsetof(TutorialScreenUserWidget_OnSetPage, InPageNumber) == 0x000018, "Member 'TutorialScreenUserWidget_OnSetPage::InPageNumber' has a wrong offset!");
static_assert(offsetof(TutorialScreenUserWidget_OnSetPage, CurrentPage) == 0x000030, "Member 'TutorialScreenUserWidget_OnSetPage::CurrentPage' has a wrong offset!");
static_assert(offsetof(TutorialScreenUserWidget_OnSetPage, MaxPage) == 0x000034, "Member 'TutorialScreenUserWidget_OnSetPage::MaxPage' has a wrong offset!");
static_assert(offsetof(TutorialScreenUserWidget_OnSetPage, bFade) == 0x000038, "Member 'TutorialScreenUserWidget_OnSetPage::bFade' has a wrong offset!");

// Function man.TutorialScreenUserWidget.OnSetReplayBtnsState
// 0x0002 (0x0002 - 0x0000)
struct TutorialScreenUserWidget_OnSetReplayBtnsState final
{
public:
	bool                                          bUpEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDownEnabled;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TutorialScreenUserWidget_OnSetReplayBtnsState) == 0x000001, "Wrong alignment on TutorialScreenUserWidget_OnSetReplayBtnsState");
static_assert(sizeof(TutorialScreenUserWidget_OnSetReplayBtnsState) == 0x000002, "Wrong size on TutorialScreenUserWidget_OnSetReplayBtnsState");
static_assert(offsetof(TutorialScreenUserWidget_OnSetReplayBtnsState, bUpEnabled) == 0x000000, "Member 'TutorialScreenUserWidget_OnSetReplayBtnsState::bUpEnabled' has a wrong offset!");
static_assert(offsetof(TutorialScreenUserWidget_OnSetReplayBtnsState, bDownEnabled) == 0x000001, "Member 'TutorialScreenUserWidget_OnSetReplayBtnsState::bDownEnabled' has a wrong offset!");

// Function man.TypeWriterTextUserWidget.SetText
// 0x0018 (0x0018 - 0x0000)
struct TypeWriterTextUserWidget_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TypeWriterTextUserWidget_SetText) == 0x000008, "Wrong alignment on TypeWriterTextUserWidget_SetText");
static_assert(sizeof(TypeWriterTextUserWidget_SetText) == 0x000018, "Wrong size on TypeWriterTextUserWidget_SetText");
static_assert(offsetof(TypeWriterTextUserWidget_SetText, InText) == 0x000000, "Member 'TypeWriterTextUserWidget_SetText::InText' has a wrong offset!");

// Function man.UIFunctionLibrary.BPAddDialogueBrawler
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_BPAddDialogueBrawler final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                addOnce;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitforOtherVO;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_BPAddDialogueBrawler) == 0x000008, "Wrong alignment on UIFunctionLibrary_BPAddDialogueBrawler");
static_assert(sizeof(UIFunctionLibrary_BPAddDialogueBrawler) == 0x000020, "Wrong size on UIFunctionLibrary_BPAddDialogueBrawler");
static_assert(offsetof(UIFunctionLibrary_BPAddDialogueBrawler, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_BPAddDialogueBrawler::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddDialogueBrawler, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_BPAddDialogueBrawler::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddDialogueBrawler, addOnce) == 0x000010, "Member 'UIFunctionLibrary_BPAddDialogueBrawler::addOnce' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddDialogueBrawler, bWaitforOtherVO) == 0x000018, "Member 'UIFunctionLibrary_BPAddDialogueBrawler::bWaitforOtherVO' has a wrong offset!");

// Function man.UIFunctionLibrary.BPAddGlobalOneTimeDialogueBrawler
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitforOtherVO;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler) == 0x000008, "Wrong alignment on UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler");
static_assert(sizeof(UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler) == 0x000018, "Wrong size on UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler");
static_assert(offsetof(UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler, bWaitforOtherVO) == 0x000010, "Member 'UIFunctionLibrary_BPAddGlobalOneTimeDialogueBrawler::bWaitforOtherVO' has a wrong offset!");

// Function man.UIFunctionLibrary.BPAddRandomDialogueBrawler
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_BPAddRandomDialogueBrawler final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                addOnce;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitforOtherVO;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_BPAddRandomDialogueBrawler) == 0x000008, "Wrong alignment on UIFunctionLibrary_BPAddRandomDialogueBrawler");
static_assert(sizeof(UIFunctionLibrary_BPAddRandomDialogueBrawler) == 0x000020, "Wrong size on UIFunctionLibrary_BPAddRandomDialogueBrawler");
static_assert(offsetof(UIFunctionLibrary_BPAddRandomDialogueBrawler, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_BPAddRandomDialogueBrawler::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRandomDialogueBrawler, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_BPAddRandomDialogueBrawler::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRandomDialogueBrawler, addOnce) == 0x000010, "Member 'UIFunctionLibrary_BPAddRandomDialogueBrawler::addOnce' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRandomDialogueBrawler, bWaitforOtherVO) == 0x000018, "Member 'UIFunctionLibrary_BPAddRandomDialogueBrawler::bWaitforOtherVO' has a wrong offset!");

// Function man.UIFunctionLibrary.BPAddRepeatableDialogueLineBrawler
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                addOnce;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitforOtherVO;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler) == 0x000008, "Wrong alignment on UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler");
static_assert(sizeof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler) == 0x000020, "Wrong size on UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler");
static_assert(offsetof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler, addOnce) == 0x000010, "Member 'UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler::addOnce' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler, bWaitforOtherVO) == 0x000018, "Member 'UIFunctionLibrary_BPAddRepeatableDialogueLineBrawler::bWaitforOtherVO' has a wrong offset!");

// Function man.UIFunctionLibrary.BPSetFade
// 0x0040 (0x0040 - 0x0000)
struct UIFunctionLibrary_BPSetFade final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFadeOutFinished;                                 // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFadeInFinished;                                  // 0x0024(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPlayerInvulnerableDuringFade;                     // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerMoveInputDuringFadeOut;                      // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLockAtFadeOutFinished;                      // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_BPSetFade) == 0x000008, "Wrong alignment on UIFunctionLibrary_BPSetFade");
static_assert(sizeof(UIFunctionLibrary_BPSetFade) == 0x000040, "Wrong size on UIFunctionLibrary_BPSetFade");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_BPSetFade::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, FadeOutTime) == 0x000008, "Member 'UIFunctionLibrary_BPSetFade::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, FadeDuration) == 0x00000C, "Member 'UIFunctionLibrary_BPSetFade::FadeDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, FadeInTime) == 0x000010, "Member 'UIFunctionLibrary_BPSetFade::FadeInTime' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, OnFadeOutFinished) == 0x000014, "Member 'UIFunctionLibrary_BPSetFade::OnFadeOutFinished' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, OnFadeInFinished) == 0x000024, "Member 'UIFunctionLibrary_BPSetFade::OnFadeInFinished' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, bPlayerInvulnerableDuringFade) == 0x000034, "Member 'UIFunctionLibrary_BPSetFade::bPlayerInvulnerableDuringFade' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, PlayerMoveInputDuringFadeOut) == 0x000038, "Member 'UIFunctionLibrary_BPSetFade::PlayerMoveInputDuringFadeOut' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_BPSetFade, bPlayerLockAtFadeOutFinished) == 0x00003C, "Member 'UIFunctionLibrary_BPSetFade::bPlayerLockAtFadeOutFinished' has a wrong offset!");

// Function man.UIFunctionLibrary.ChangeHotkey
// 0x0058 (0x0058 - 0x0000)
struct UIFunctionLibrary_ChangeHotkey final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AxisName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   OldKey;                                            // 0x0020(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   NewKey;                                            // 0x0038(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimary;                                          // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ChangeHotkey) == 0x000008, "Wrong alignment on UIFunctionLibrary_ChangeHotkey");
static_assert(sizeof(UIFunctionLibrary_ChangeHotkey) == 0x000058, "Wrong size on UIFunctionLibrary_ChangeHotkey");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ChangeHotkey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, ActionName) == 0x000008, "Member 'UIFunctionLibrary_ChangeHotkey::ActionName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, AxisName) == 0x000010, "Member 'UIFunctionLibrary_ChangeHotkey::AxisName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, AxisScale) == 0x000018, "Member 'UIFunctionLibrary_ChangeHotkey::AxisScale' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, OldKey) == 0x000020, "Member 'UIFunctionLibrary_ChangeHotkey::OldKey' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, NewKey) == 0x000038, "Member 'UIFunctionLibrary_ChangeHotkey::NewKey' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ChangeHotkey, bPrimary) == 0x000050, "Member 'UIFunctionLibrary_ChangeHotkey::bPrimary' has a wrong offset!");

// Function man.UIFunctionLibrary.ClearTutorialSign
// 0x0008 (0x0008 - 0x0000)
struct UIFunctionLibrary_ClearTutorialSign final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ClearTutorialSign) == 0x000008, "Wrong alignment on UIFunctionLibrary_ClearTutorialSign");
static_assert(sizeof(UIFunctionLibrary_ClearTutorialSign) == 0x000008, "Wrong size on UIFunctionLibrary_ClearTutorialSign");
static_assert(offsetof(UIFunctionLibrary_ClearTutorialSign, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ClearTutorialSign::WorldContextObject' has a wrong offset!");

// Function man.UIFunctionLibrary.FloatToText
// 0x0038 (0x0038 - 0x0000)
struct UIFunctionLibrary_FloatToText final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumFractionalDigits;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysSign;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsPercent;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_FloatToText) == 0x000008, "Wrong alignment on UIFunctionLibrary_FloatToText");
static_assert(sizeof(UIFunctionLibrary_FloatToText) == 0x000038, "Wrong size on UIFunctionLibrary_FloatToText");
static_assert(offsetof(UIFunctionLibrary_FloatToText, Value) == 0x000000, "Member 'UIFunctionLibrary_FloatToText::Value' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, RoundingMode) == 0x000004, "Member 'UIFunctionLibrary_FloatToText::RoundingMode' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, MinimumFractionalDigits) == 0x000008, "Member 'UIFunctionLibrary_FloatToText::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, MaximumFractionalDigits) == 0x00000C, "Member 'UIFunctionLibrary_FloatToText::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, bAlwaysSign) == 0x000010, "Member 'UIFunctionLibrary_FloatToText::bAlwaysSign' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, bUseGrouping) == 0x000011, "Member 'UIFunctionLibrary_FloatToText::bUseGrouping' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, MinimumIntegralDigits) == 0x000014, "Member 'UIFunctionLibrary_FloatToText::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, MaximumIntegralDigits) == 0x000018, "Member 'UIFunctionLibrary_FloatToText::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, bAsPercent) == 0x00001C, "Member 'UIFunctionLibrary_FloatToText::bAsPercent' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_FloatToText, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_FloatToText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetActiveAbilitiesWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActiveAbilitiesWindowUserWidget*       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetActiveAbilitiesWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetAttributeIcon
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetAttributeIcon final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetAttributeIcon) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetAttributeIcon");
static_assert(sizeof(UIFunctionLibrary_GetAttributeIcon) == 0x000018, "Wrong size on UIFunctionLibrary_GetAttributeIcon");
static_assert(offsetof(UIFunctionLibrary_GetAttributeIcon, attribute) == 0x000000, "Member 'UIFunctionLibrary_GetAttributeIcon::attribute' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetAttributeIcon, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetAttributeIcon::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetBountyBoardItems
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetBountyBoardItems final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBountyBoardItem>               ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetBountyBoardItems) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetBountyBoardItems");
static_assert(sizeof(UIFunctionLibrary_GetBountyBoardItems) == 0x000018, "Wrong size on UIFunctionLibrary_GetBountyBoardItems");
static_assert(offsetof(UIFunctionLibrary_GetBountyBoardItems, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetBountyBoardItems::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetBountyBoardItems, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetBountyBoardItems::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetCharacterNameUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetCharacterNameUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterNameUserWidget*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetCharacterNameUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetCharacterNameUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetCharacterNameUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetCharacterNameUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetCharacterNameUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetCharacterNameUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetCharacterNameUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetCharacterNameUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetCharacterWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetCharacterWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterWindowUserWidget*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetCharacterWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetCharacterWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetCharacterWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetCharacterWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetCharacterWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetCharacterWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetCharacterWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetCharacterWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetControlDisplay
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetControlDisplay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetControlDisplay) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetControlDisplay");
static_assert(sizeof(UIFunctionLibrary_GetControlDisplay) == 0x000010, "Wrong size on UIFunctionLibrary_GetControlDisplay");
static_assert(offsetof(UIFunctionLibrary_GetControlDisplay, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetControlDisplay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetControlDisplay, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetControlDisplay::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetConversationManager
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetConversationManager final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManConversationManager*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetConversationManager) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetConversationManager");
static_assert(sizeof(UIFunctionLibrary_GetConversationManager) == 0x000010, "Wrong size on UIFunctionLibrary_GetConversationManager");
static_assert(offsetof(UIFunctionLibrary_GetConversationManager, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetConversationManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetConversationManager, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetConversationManager::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetConversationUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetConversationUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConversationUserWidget*                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetConversationUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetConversationUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetConversationUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetConversationUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetConversationUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetConversationUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetConversationUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetConversationUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetCreateCharacterUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetCreateCharacterUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreateCharacterUserWidget*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetCreateCharacterUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetCreateCharacterUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetCreateCharacterUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetCreateCharacterUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetCreateCharacterUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetCreateCharacterUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetCreateCharacterUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetCreateCharacterUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetCreditsUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetCreditsUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreditsUserWidget*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetCreditsUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetCreditsUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetCreditsUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetCreditsUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetCreditsUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetCreditsUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetCreditsUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetCreditsUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetDialogueNodeVisibleTime
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetDialogueNodeVisibleTime final
{
public:
	const class UDialogueDataAsset*               DialogueDataAsset;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DialogueIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetDialogueNodeVisibleTime) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetDialogueNodeVisibleTime");
static_assert(sizeof(UIFunctionLibrary_GetDialogueNodeVisibleTime) == 0x000010, "Wrong size on UIFunctionLibrary_GetDialogueNodeVisibleTime");
static_assert(offsetof(UIFunctionLibrary_GetDialogueNodeVisibleTime, DialogueDataAsset) == 0x000000, "Member 'UIFunctionLibrary_GetDialogueNodeVisibleTime::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetDialogueNodeVisibleTime, DialogueIndex) == 0x000008, "Member 'UIFunctionLibrary_GetDialogueNodeVisibleTime::DialogueIndex' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetDialogueNodeVisibleTime, ReturnValue) == 0x00000C, "Member 'UIFunctionLibrary_GetDialogueNodeVisibleTime::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetEmptyLoreText
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetEmptyLoreText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetEmptyLoreText) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetEmptyLoreText");
static_assert(sizeof(UIFunctionLibrary_GetEmptyLoreText) == 0x000018, "Wrong size on UIFunctionLibrary_GetEmptyLoreText");
static_assert(offsetof(UIFunctionLibrary_GetEmptyLoreText, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_GetEmptyLoreText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetEquipLoadIndicatorColor
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetEquipLoadIndicatorColor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipLoadIndicator                           ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetEquipLoadIndicatorColor) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetEquipLoadIndicatorColor");
static_assert(sizeof(UIFunctionLibrary_GetEquipLoadIndicatorColor) == 0x000010, "Wrong size on UIFunctionLibrary_GetEquipLoadIndicatorColor");
static_assert(offsetof(UIFunctionLibrary_GetEquipLoadIndicatorColor, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetEquipLoadIndicatorColor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetEquipLoadIndicatorColor, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetEquipLoadIndicatorColor::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetFormattedSubtitleText
// 0x0050 (0x0050 - 0x0000)
struct UIFunctionLibrary_GetFormattedSubtitleText final
{
public:
	class FText                                   InSpeakerName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InText;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseDefault;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetFormattedSubtitleText) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetFormattedSubtitleText");
static_assert(sizeof(UIFunctionLibrary_GetFormattedSubtitleText) == 0x000050, "Wrong size on UIFunctionLibrary_GetFormattedSubtitleText");
static_assert(offsetof(UIFunctionLibrary_GetFormattedSubtitleText, InSpeakerName) == 0x000000, "Member 'UIFunctionLibrary_GetFormattedSubtitleText::InSpeakerName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetFormattedSubtitleText, InText) == 0x000018, "Member 'UIFunctionLibrary_GetFormattedSubtitleText::InText' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetFormattedSubtitleText, bUseDefault) == 0x000030, "Member 'UIFunctionLibrary_GetFormattedSubtitleText::bUseDefault' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetFormattedSubtitleText, ReturnValue) == 0x000038, "Member 'UIFunctionLibrary_GetFormattedSubtitleText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetGameInstance
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetGameInstance final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManGameInstance*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetGameInstance) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetGameInstance");
static_assert(sizeof(UIFunctionLibrary_GetGameInstance) == 0x000010, "Wrong size on UIFunctionLibrary_GetGameInstance");
static_assert(offsetof(UIFunctionLibrary_GetGameInstance, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetGameInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetGameInstance, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetGameInstance::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetGameMode
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetGameMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMandragoraGameMode*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetGameMode) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetGameMode");
static_assert(sizeof(UIFunctionLibrary_GetGameMode) == 0x000010, "Wrong size on UIFunctionLibrary_GetGameMode");
static_assert(offsetof(UIFunctionLibrary_GetGameMode, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetGameMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetGameMode, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetGameMode::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroAbilitiesData
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroAbilitiesData final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeroAbilitiesData*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHeroAbilitiesData) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroAbilitiesData");
static_assert(sizeof(UIFunctionLibrary_GetHeroAbilitiesData) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroAbilitiesData");
static_assert(offsetof(UIFunctionLibrary_GetHeroAbilitiesData, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroAbilitiesData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroAbilitiesData, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroAbilitiesData::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroComboPoint
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroComboPoint final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroComboPoint) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroComboPoint");
static_assert(sizeof(UIFunctionLibrary_GetHeroComboPoint) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroComboPoint");
static_assert(offsetof(UIFunctionLibrary_GetHeroComboPoint, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroComboPoint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroComboPoint, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroComboPoint::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroComboPointFraction
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroComboPointFraction final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroComboPointFraction) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroComboPointFraction");
static_assert(sizeof(UIFunctionLibrary_GetHeroComboPointFraction) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroComboPointFraction");
static_assert(offsetof(UIFunctionLibrary_GetHeroComboPointFraction, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroComboPointFraction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroComboPointFraction, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroComboPointFraction::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroCurrentItemSetIndex
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroCurrentItemSetIndex final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroCurrentItemSetIndex) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroCurrentItemSetIndex");
static_assert(sizeof(UIFunctionLibrary_GetHeroCurrentItemSetIndex) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroCurrentItemSetIndex");
static_assert(offsetof(UIFunctionLibrary_GetHeroCurrentItemSetIndex, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroCurrentItemSetIndex::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroCurrentItemSetIndex, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroCurrentItemSetIndex::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroDefaultCharacterClass
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroDefaultCharacterClass final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterClass                               ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroDefaultCharacterClass) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroDefaultCharacterClass");
static_assert(sizeof(UIFunctionLibrary_GetHeroDefaultCharacterClass) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroDefaultCharacterClass");
static_assert(offsetof(UIFunctionLibrary_GetHeroDefaultCharacterClass, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroDefaultCharacterClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroDefaultCharacterClass, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroDefaultCharacterClass::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroDescription
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_GetHeroDescription final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHeroDescription) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroDescription");
static_assert(sizeof(UIFunctionLibrary_GetHeroDescription) == 0x000020, "Wrong size on UIFunctionLibrary_GetHeroDescription");
static_assert(offsetof(UIFunctionLibrary_GetHeroDescription, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroDescription::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroDescription, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroDescription::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroEntropicEssence
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroEntropicEssence final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroEntropicEssence) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroEntropicEssence");
static_assert(sizeof(UIFunctionLibrary_GetHeroEntropicEssence) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroEntropicEssence");
static_assert(offsetof(UIFunctionLibrary_GetHeroEntropicEssence, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroEntropicEssence::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroEntropicEssence, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroEntropicEssence::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroEssence
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroEssence final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroEssence) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroEssence");
static_assert(sizeof(UIFunctionLibrary_GetHeroEssence) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroEssence");
static_assert(offsetof(UIFunctionLibrary_GetHeroEssence, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroEssence::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroEssence, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroEssence::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroGold
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroGold final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroGold) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroGold");
static_assert(sizeof(UIFunctionLibrary_GetHeroGold) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroGold");
static_assert(offsetof(UIFunctionLibrary_GetHeroGold, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroGold::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroGold, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroGold::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroIsInCombat
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroIsInCombat final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroIsInCombat) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroIsInCombat");
static_assert(sizeof(UIFunctionLibrary_GetHeroIsInCombat) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroIsInCombat");
static_assert(offsetof(UIFunctionLibrary_GetHeroIsInCombat, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroIsInCombat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroIsInCombat, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroIsInCombat::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroMaxComboPoint
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroMaxComboPoint final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroMaxComboPoint) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroMaxComboPoint");
static_assert(sizeof(UIFunctionLibrary_GetHeroMaxComboPoint) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroMaxComboPoint");
static_assert(offsetof(UIFunctionLibrary_GetHeroMaxComboPoint, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroMaxComboPoint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroMaxComboPoint, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroMaxComboPoint::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroName
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetHeroName final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHeroName) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroName");
static_assert(sizeof(UIFunctionLibrary_GetHeroName) == 0x000018, "Wrong size on UIFunctionLibrary_GetHeroName");
static_assert(offsetof(UIFunctionLibrary_GetHeroName, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroName, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroName::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHeroSkillPoint
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHeroSkillPoint final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetHeroSkillPoint) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHeroSkillPoint");
static_assert(sizeof(UIFunctionLibrary_GetHeroSkillPoint) == 0x000010, "Wrong size on UIFunctionLibrary_GetHeroSkillPoint");
static_assert(offsetof(UIFunctionLibrary_GetHeroSkillPoint, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHeroSkillPoint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHeroSkillPoint, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHeroSkillPoint::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHotkeyDataAsset
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHotkeyDataAsset final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHotkeyDataAsset*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHotkeyDataAsset) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHotkeyDataAsset");
static_assert(sizeof(UIFunctionLibrary_GetHotkeyDataAsset) == 0x000010, "Wrong size on UIFunctionLibrary_GetHotkeyDataAsset");
static_assert(offsetof(UIFunctionLibrary_GetHotkeyDataAsset, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHotkeyDataAsset::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHotkeyDataAsset, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHotkeyDataAsset::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHotkeyKeys
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetHotkeyKeys final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHotkeyKeys) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHotkeyKeys");
static_assert(sizeof(UIFunctionLibrary_GetHotkeyKeys) == 0x000018, "Wrong size on UIFunctionLibrary_GetHotkeyKeys");
static_assert(offsetof(UIFunctionLibrary_GetHotkeyKeys, ActionName) == 0x000000, "Member 'UIFunctionLibrary_GetHotkeyKeys::ActionName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHotkeyKeys, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHotkeyKeys::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetHUDWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetHUDWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHUDUserWidget*                         ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetHUDWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetHUDWidget");
static_assert(sizeof(UIFunctionLibrary_GetHUDWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetHUDWidget");
static_assert(offsetof(UIFunctionLibrary_GetHUDWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetHUDWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetHUDWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetHUDWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetInputDisplay
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetInputDisplay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDisplay                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetInputDisplay) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetInputDisplay");
static_assert(sizeof(UIFunctionLibrary_GetInputDisplay) == 0x000010, "Wrong size on UIFunctionLibrary_GetInputDisplay");
static_assert(offsetof(UIFunctionLibrary_GetInputDisplay, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetInputDisplay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetInputDisplay, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetInputDisplay::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetInventory
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetInventory final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetInventory) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetInventory");
static_assert(sizeof(UIFunctionLibrary_GetInventory) == 0x000010, "Wrong size on UIFunctionLibrary_GetInventory");
static_assert(offsetof(UIFunctionLibrary_GetInventory, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetInventory::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetInventory, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetInventory::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetInventoryWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetInventoryWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryWindowUserWidget*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetInventoryWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetInventoryWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetInventoryWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetInventoryWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetInventoryWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetInventoryWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetInventoryWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetInventoryWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetItemsTooltipDataAsset
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetItemsTooltipDataAsset final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemsTooltipDataAsset*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetItemsTooltipDataAsset) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetItemsTooltipDataAsset");
static_assert(sizeof(UIFunctionLibrary_GetItemsTooltipDataAsset) == 0x000010, "Wrong size on UIFunctionLibrary_GetItemsTooltipDataAsset");
static_assert(offsetof(UIFunctionLibrary_GetItemsTooltipDataAsset, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetItemsTooltipDataAsset::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetItemsTooltipDataAsset, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetItemsTooltipDataAsset::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetLevelText
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_GetLevelText final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetLevelText) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetLevelText");
static_assert(sizeof(UIFunctionLibrary_GetLevelText) == 0x000020, "Wrong size on UIFunctionLibrary_GetLevelText");
static_assert(offsetof(UIFunctionLibrary_GetLevelText, Level) == 0x000000, "Member 'UIFunctionLibrary_GetLevelText::Level' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetLevelText, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetLevelText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetLevelUpWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetLevelUpWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelUpWindowUserWidget*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetLevelUpWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetLevelUpWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetLevelUpWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetLevelUpWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetLevelUpWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetLevelUpWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetLevelUpWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetLevelUpWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetLoadGameUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetLoadGameUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadGameUserWidget*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetLoadGameUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetLoadGameUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetLoadGameUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetLoadGameUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetLoadGameUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetLoadGameUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetLoadGameUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetLoadGameUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetMainParent
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetMainParent final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ChildWidget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetMainParent) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetMainParent");
static_assert(sizeof(UIFunctionLibrary_GetMainParent) == 0x000018, "Wrong size on UIFunctionLibrary_GetMainParent");
static_assert(offsetof(UIFunctionLibrary_GetMainParent, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetMainParent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetMainParent, ChildWidget) == 0x000008, "Member 'UIFunctionLibrary_GetMainParent::ChildWidget' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetMainParent, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_GetMainParent::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetManLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetManLocalPlayer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManLocalPlayer*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetManLocalPlayer) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetManLocalPlayer");
static_assert(sizeof(UIFunctionLibrary_GetManLocalPlayer) == 0x000010, "Wrong size on UIFunctionLibrary_GetManLocalPlayer");
static_assert(offsetof(UIFunctionLibrary_GetManLocalPlayer, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetManLocalPlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetManLocalPlayer, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetManLocalPlayer::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetManPlayerInput
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetManPlayerInput final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManPlayerInput*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetManPlayerInput) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetManPlayerInput");
static_assert(sizeof(UIFunctionLibrary_GetManPlayerInput) == 0x000010, "Wrong size on UIFunctionLibrary_GetManPlayerInput");
static_assert(offsetof(UIFunctionLibrary_GetManPlayerInput, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetManPlayerInput::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetManPlayerInput, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetManPlayerInput::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetManUserWidgetBase
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_GetManUserWidgetBase final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetsZorder                                WidgetsZorder;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetManUserWidgetBase) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetManUserWidgetBase");
static_assert(sizeof(UIFunctionLibrary_GetManUserWidgetBase) == 0x000018, "Wrong size on UIFunctionLibrary_GetManUserWidgetBase");
static_assert(offsetof(UIFunctionLibrary_GetManUserWidgetBase, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetManUserWidgetBase::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetManUserWidgetBase, WidgetsZorder) == 0x000008, "Member 'UIFunctionLibrary_GetManUserWidgetBase::WidgetsZorder' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetManUserWidgetBase, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_GetManUserWidgetBase::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetMapManager
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetMapManager final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapManager*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetMapManager) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetMapManager");
static_assert(sizeof(UIFunctionLibrary_GetMapManager) == 0x000010, "Wrong size on UIFunctionLibrary_GetMapManager");
static_assert(offsetof(UIFunctionLibrary_GetMapManager, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetMapManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetMapManager, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetMapManager::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetMapWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetMapWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapWindowUserWidget*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetMapWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetMapWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetMapWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetMapWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetMapWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetMapWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetMapWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetMapWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetMaxSaveGameSlotNum
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetMaxSaveGameSlotNum final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetMaxSaveGameSlotNum) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetMaxSaveGameSlotNum");
static_assert(sizeof(UIFunctionLibrary_GetMaxSaveGameSlotNum) == 0x000010, "Wrong size on UIFunctionLibrary_GetMaxSaveGameSlotNum");
static_assert(offsetof(UIFunctionLibrary_GetMaxSaveGameSlotNum, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetMaxSaveGameSlotNum::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetMaxSaveGameSlotNum, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetMaxSaveGameSlotNum::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetNewGameUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetNewGameUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNewGameUserWidget*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetNewGameUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetNewGameUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetNewGameUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetNewGameUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetNewGameUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetNewGameUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetNewGameUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetNewGameUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetNPCBestiaryUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetNPCBestiaryUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNPCBestiaryUserWidget*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetNPCBestiaryUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetNPCBestiaryUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetNPCBestiaryUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetNPCBestiaryUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetNPCBestiaryUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetNPCBestiaryUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetNPCBestiaryUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetNPCBestiaryUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetPauseMenuUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetPauseMenuUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPauseMenuUserWidget*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetPauseMenuUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetPauseMenuUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetPauseMenuUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetPauseMenuUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetPauseMenuUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetPauseMenuUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetPauseMenuUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetPauseMenuUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetQuestManager
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetQuestManager final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestManager*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetQuestManager) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetQuestManager");
static_assert(sizeof(UIFunctionLibrary_GetQuestManager) == 0x000010, "Wrong size on UIFunctionLibrary_GetQuestManager");
static_assert(offsetof(UIFunctionLibrary_GetQuestManager, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetQuestManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetQuestManager, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetQuestManager::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetQuestWindowUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetQuestWindowUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQuestWindowUserWidget*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetQuestWindowUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetQuestWindowUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetQuestWindowUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetQuestWindowUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetQuestWindowUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetQuestWindowUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetQuestWindowUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetQuestWindowUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetShortLevelText
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_GetShortLevelText final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetShortLevelText) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetShortLevelText");
static_assert(sizeof(UIFunctionLibrary_GetShortLevelText) == 0x000020, "Wrong size on UIFunctionLibrary_GetShortLevelText");
static_assert(offsetof(UIFunctionLibrary_GetShortLevelText, Level) == 0x000000, "Member 'UIFunctionLibrary_GetShortLevelText::Level' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetShortLevelText, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetShortLevelText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetSkillTreeManager
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetSkillTreeManager final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkillTreeManager*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetSkillTreeManager) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetSkillTreeManager");
static_assert(sizeof(UIFunctionLibrary_GetSkillTreeManager) == 0x000010, "Wrong size on UIFunctionLibrary_GetSkillTreeManager");
static_assert(offsetof(UIFunctionLibrary_GetSkillTreeManager, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetSkillTreeManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSkillTreeManager, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetSkillTreeManager::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetSkillTreeUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetSkillTreeUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkillTreeUserWidget*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetSkillTreeUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetSkillTreeUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetSkillTreeUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetSkillTreeUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetSkillTreeUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetSkillTreeUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSkillTreeUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetSkillTreeUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetSmallScreenMode
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetSmallScreenMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmallScreenMode                              ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetSmallScreenMode) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetSmallScreenMode");
static_assert(sizeof(UIFunctionLibrary_GetSmallScreenMode) == 0x000010, "Wrong size on UIFunctionLibrary_GetSmallScreenMode");
static_assert(offsetof(UIFunctionLibrary_GetSmallScreenMode, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetSmallScreenMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSmallScreenMode, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetSmallScreenMode::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetSubLevelActors
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_GetSubLevelActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubLevelName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetSubLevelActors) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetSubLevelActors");
static_assert(sizeof(UIFunctionLibrary_GetSubLevelActors) == 0x000028, "Wrong size on UIFunctionLibrary_GetSubLevelActors");
static_assert(offsetof(UIFunctionLibrary_GetSubLevelActors, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetSubLevelActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSubLevelActors, SubLevelName) == 0x000008, "Member 'UIFunctionLibrary_GetSubLevelActors::SubLevelName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSubLevelActors, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_GetSubLevelActors::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetSwappedKey
// 0x0030 (0x0030 - 0x0000)
struct UIFunctionLibrary_GetSwappedKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetSwappedKey) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetSwappedKey");
static_assert(sizeof(UIFunctionLibrary_GetSwappedKey) == 0x000030, "Wrong size on UIFunctionLibrary_GetSwappedKey");
static_assert(offsetof(UIFunctionLibrary_GetSwappedKey, Key) == 0x000000, "Member 'UIFunctionLibrary_GetSwappedKey::Key' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetSwappedKey, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_GetSwappedKey::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetTopMostManUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetTopMostManUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetTopMostManUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetTopMostManUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetTopMostManUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetTopMostManUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetTopMostManUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetTopMostManUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetTopMostManUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetTopMostManUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetUIScale
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetUIScale final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetUIScale) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetUIScale");
static_assert(sizeof(UIFunctionLibrary_GetUIScale) == 0x000010, "Wrong size on UIFunctionLibrary_GetUIScale");
static_assert(offsetof(UIFunctionLibrary_GetUIScale, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetUIScale::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetUIScale, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetUIScale::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorAlchemistUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorAlchemistUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorAlchemistUserWidget*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorAlchemistUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorAlchemistUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorAlchemistUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorAlchemistUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorAlchemistUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorAlchemistUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorAlchemistUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorAlchemistUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorBuyUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorBuyUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorBuyUserWidget*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorBuyUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorBuyUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorBuyUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorBuyUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorBuyUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorBuyUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorBuyUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorBuyUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorCraftUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorCraftUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorCraftUserWidget*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorCraftUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorCraftUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorCraftUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorCraftUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorCraftUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorCraftUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorCraftUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorCraftUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorCurrentExperience
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorCurrentExperience final
{
public:
	class AActorBase*                             InteractedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetVendorCurrentExperience) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorCurrentExperience");
static_assert(sizeof(UIFunctionLibrary_GetVendorCurrentExperience) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorCurrentExperience");
static_assert(offsetof(UIFunctionLibrary_GetVendorCurrentExperience, InteractedActor) == 0x000000, "Member 'UIFunctionLibrary_GetVendorCurrentExperience::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorCurrentExperience, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorCurrentExperience::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorCurrentLevel
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorCurrentLevel final
{
public:
	class AActorBase*                             InteractedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetVendorCurrentLevel) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorCurrentLevel");
static_assert(sizeof(UIFunctionLibrary_GetVendorCurrentLevel) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorCurrentLevel");
static_assert(offsetof(UIFunctionLibrary_GetVendorCurrentLevel, InteractedActor) == 0x000000, "Member 'UIFunctionLibrary_GetVendorCurrentLevel::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorCurrentLevel, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorCurrentLevel::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorEnchantUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorEnchantUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorEnchantUserWidget*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorEnchantUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorEnchantUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorEnchantUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorEnchantUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorEnchantUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorEnchantUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorEnchantUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorEnchantUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorExperienceForCurrentLevel
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorExperienceForCurrentLevel final
{
public:
	class AActorBase*                             InteractedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetVendorExperienceForCurrentLevel) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorExperienceForCurrentLevel");
static_assert(sizeof(UIFunctionLibrary_GetVendorExperienceForCurrentLevel) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorExperienceForCurrentLevel");
static_assert(offsetof(UIFunctionLibrary_GetVendorExperienceForCurrentLevel, InteractedActor) == 0x000000, "Member 'UIFunctionLibrary_GetVendorExperienceForCurrentLevel::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorExperienceForCurrentLevel, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorExperienceForCurrentLevel::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorExperienceForNextLevel
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorExperienceForNextLevel final
{
public:
	class AActorBase*                             InteractedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetVendorExperienceForNextLevel) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorExperienceForNextLevel");
static_assert(sizeof(UIFunctionLibrary_GetVendorExperienceForNextLevel) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorExperienceForNextLevel");
static_assert(offsetof(UIFunctionLibrary_GetVendorExperienceForNextLevel, InteractedActor) == 0x000000, "Member 'UIFunctionLibrary_GetVendorExperienceForNextLevel::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorExperienceForNextLevel, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorExperienceForNextLevel::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorMapFragmentUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorMapFragmentUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorMapFragmentUserWidget*           ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorMapFragmentUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorMapFragmentUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorMapFragmentUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorMapFragmentUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorMapFragmentUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorMapFragmentUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorMapFragmentUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorMapFragmentUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorNextLevel
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorNextLevel final
{
public:
	class AActorBase*                             InteractedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_GetVendorNextLevel) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorNextLevel");
static_assert(sizeof(UIFunctionLibrary_GetVendorNextLevel) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorNextLevel");
static_assert(offsetof(UIFunctionLibrary_GetVendorNextLevel, InteractedActor) == 0x000000, "Member 'UIFunctionLibrary_GetVendorNextLevel::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorNextLevel, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorNextLevel::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorPortraitsUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorPortraitsUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorPortraitsUserWidget*             ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorPortraitsUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorPortraitsUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorPortraitsUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorPortraitsUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorPortraitsUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorPortraitsUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorPortraitsUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorPortraitsUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorSellUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorSellUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorSellUserWidget*                  ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorSellUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorSellUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorSellUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorSellUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorSellUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorSellUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorSellUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorSellUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorTransmogUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorTransmogUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorTransmogUserWidget*              ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorTransmogUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorTransmogUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorTransmogUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorTransmogUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorTransmogUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorTransmogUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorTransmogUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorTransmogUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.GetVendorUpgradeUserWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_GetVendorUpgradeUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorUpgradeUserWidget*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_GetVendorUpgradeUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_GetVendorUpgradeUserWidget");
static_assert(sizeof(UIFunctionLibrary_GetVendorUpgradeUserWidget) == 0x000010, "Wrong size on UIFunctionLibrary_GetVendorUpgradeUserWidget");
static_assert(offsetof(UIFunctionLibrary_GetVendorUpgradeUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_GetVendorUpgradeUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_GetVendorUpgradeUserWidget, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_GetVendorUpgradeUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.HideAllWindows
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_HideAllWindows final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInputModeGameOnly;                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_HideAllWindows) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideAllWindows");
static_assert(sizeof(UIFunctionLibrary_HideAllWindows) == 0x000010, "Wrong size on UIFunctionLibrary_HideAllWindows");
static_assert(offsetof(UIFunctionLibrary_HideAllWindows, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_HideAllWindows::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideAllWindows, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_HideAllWindows::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideAllWindows, bSetInputModeGameOnly) == 0x00000C, "Member 'UIFunctionLibrary_HideAllWindows::bSetInputModeGameOnly' has a wrong offset!");

// Function man.UIFunctionLibrary.HideAllWindowsWithKeepArray
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_HideAllWindowsWithKeepArray final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EWidgetsZorder>                        KeepWindowsArray;                                  // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInputModeGameOnly;                             // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_HideAllWindowsWithKeepArray) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideAllWindowsWithKeepArray");
static_assert(sizeof(UIFunctionLibrary_HideAllWindowsWithKeepArray) == 0x000020, "Wrong size on UIFunctionLibrary_HideAllWindowsWithKeepArray");
static_assert(offsetof(UIFunctionLibrary_HideAllWindowsWithKeepArray, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_HideAllWindowsWithKeepArray::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideAllWindowsWithKeepArray, KeepWindowsArray) == 0x000008, "Member 'UIFunctionLibrary_HideAllWindowsWithKeepArray::KeepWindowsArray' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideAllWindowsWithKeepArray, AnimDuration) == 0x000018, "Member 'UIFunctionLibrary_HideAllWindowsWithKeepArray::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideAllWindowsWithKeepArray, bSetInputModeGameOnly) == 0x00001C, "Member 'UIFunctionLibrary_HideAllWindowsWithKeepArray::bSetInputModeGameOnly' has a wrong offset!");

// Function man.UIFunctionLibrary.HideHUD
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_HideHUD final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_HideHUD) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideHUD");
static_assert(sizeof(UIFunctionLibrary_HideHUD) == 0x000010, "Wrong size on UIFunctionLibrary_HideHUD");
static_assert(offsetof(UIFunctionLibrary_HideHUD, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_HideHUD::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideHUD, bAnimate) == 0x000008, "Member 'UIFunctionLibrary_HideHUD::bAnimate' has a wrong offset!");

// Function man.UIFunctionLibrary.HideSubtitle
// 0x0008 (0x0008 - 0x0000)
struct UIFunctionLibrary_HideSubtitle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_HideSubtitle) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideSubtitle");
static_assert(sizeof(UIFunctionLibrary_HideSubtitle) == 0x000008, "Wrong size on UIFunctionLibrary_HideSubtitle");
static_assert(offsetof(UIFunctionLibrary_HideSubtitle, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_HideSubtitle::WorldContextObject' has a wrong offset!");

// Function man.UIFunctionLibrary.HideWindow
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_HideWindow final
{
public:
	class UManUserWidgetBase*                     InManUserWidgetBase;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInputModeGameOnly;                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_HideWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideWindow");
static_assert(sizeof(UIFunctionLibrary_HideWindow) == 0x000010, "Wrong size on UIFunctionLibrary_HideWindow");
static_assert(offsetof(UIFunctionLibrary_HideWindow, InManUserWidgetBase) == 0x000000, "Member 'UIFunctionLibrary_HideWindow::InManUserWidgetBase' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_HideWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideWindow, bSetInputModeGameOnly) == 0x00000C, "Member 'UIFunctionLibrary_HideWindow::bSetInputModeGameOnly' has a wrong offset!");

// Function man.UIFunctionLibrary.HideWindowByZorder
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_HideWindowByZorder final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetsZorder                                WidgetsZorder;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetInputModeGameOnly;                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_HideWindowByZorder) == 0x000008, "Wrong alignment on UIFunctionLibrary_HideWindowByZorder");
static_assert(sizeof(UIFunctionLibrary_HideWindowByZorder) == 0x000018, "Wrong size on UIFunctionLibrary_HideWindowByZorder");
static_assert(offsetof(UIFunctionLibrary_HideWindowByZorder, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_HideWindowByZorder::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideWindowByZorder, WidgetsZorder) == 0x000008, "Member 'UIFunctionLibrary_HideWindowByZorder::WidgetsZorder' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideWindowByZorder, AnimDuration) == 0x00000C, "Member 'UIFunctionLibrary_HideWindowByZorder::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_HideWindowByZorder, bSetInputModeGameOnly) == 0x000010, "Member 'UIFunctionLibrary_HideWindowByZorder::bSetInputModeGameOnly' has a wrong offset!");

// Function man.UIFunctionLibrary.IntToText
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_IntToText final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysSign;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IntToText) == 0x000008, "Wrong alignment on UIFunctionLibrary_IntToText");
static_assert(sizeof(UIFunctionLibrary_IntToText) == 0x000028, "Wrong size on UIFunctionLibrary_IntToText");
static_assert(offsetof(UIFunctionLibrary_IntToText, Value) == 0x000000, "Member 'UIFunctionLibrary_IntToText::Value' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IntToText, bAlwaysSign) == 0x000004, "Member 'UIFunctionLibrary_IntToText::bAlwaysSign' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IntToText, bUseGrouping) == 0x000005, "Member 'UIFunctionLibrary_IntToText::bUseGrouping' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IntToText, MinimumIntegralDigits) == 0x000008, "Member 'UIFunctionLibrary_IntToText::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IntToText, MaximumIntegralDigits) == 0x00000C, "Member 'UIFunctionLibrary_IntToText::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IntToText, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_IntToText::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsAltarActive
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsAltarActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsAltarActive) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsAltarActive");
static_assert(sizeof(UIFunctionLibrary_IsAltarActive) == 0x000010, "Wrong size on UIFunctionLibrary_IsAltarActive");
static_assert(offsetof(UIFunctionLibrary_IsAltarActive, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsAltarActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsAltarActive, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsAltarActive::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsCheckPointActive
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsCheckPointActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsCheckPointActive) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsCheckPointActive");
static_assert(sizeof(UIFunctionLibrary_IsCheckPointActive) == 0x000010, "Wrong size on UIFunctionLibrary_IsCheckPointActive");
static_assert(offsetof(UIFunctionLibrary_IsCheckPointActive, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsCheckPointActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsCheckPointActive, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsCheckPointActive::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsConversationActive
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsConversationActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsConversationActive) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsConversationActive");
static_assert(sizeof(UIFunctionLibrary_IsConversationActive) == 0x000010, "Wrong size on UIFunctionLibrary_IsConversationActive");
static_assert(offsetof(UIFunctionLibrary_IsConversationActive, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsConversationActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsConversationActive, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsConversationActive::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsCutsceneCinematicRuning
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsCutsceneCinematicRuning final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsCutsceneCinematicRuning) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsCutsceneCinematicRuning");
static_assert(sizeof(UIFunctionLibrary_IsCutsceneCinematicRuning) == 0x000010, "Wrong size on UIFunctionLibrary_IsCutsceneCinematicRuning");
static_assert(offsetof(UIFunctionLibrary_IsCutsceneCinematicRuning, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsCutsceneCinematicRuning::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsCutsceneCinematicRuning, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsCutsceneCinematicRuning::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsCutsceneRuning
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsCutsceneRuning final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsCutsceneRuning) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsCutsceneRuning");
static_assert(sizeof(UIFunctionLibrary_IsCutsceneRuning) == 0x000010, "Wrong size on UIFunctionLibrary_IsCutsceneRuning");
static_assert(offsetof(UIFunctionLibrary_IsCutsceneRuning, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsCutsceneRuning::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsCutsceneRuning, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsCutsceneRuning::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsDefaultGamepadHotkey
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_IsDefaultGamepadHotkey final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsDefaultGamepadHotkey) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsDefaultGamepadHotkey");
static_assert(sizeof(UIFunctionLibrary_IsDefaultGamepadHotkey) == 0x000018, "Wrong size on UIFunctionLibrary_IsDefaultGamepadHotkey");
static_assert(offsetof(UIFunctionLibrary_IsDefaultGamepadHotkey, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsDefaultGamepadHotkey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsDefaultGamepadHotkey, ActionName) == 0x000008, "Member 'UIFunctionLibrary_IsDefaultGamepadHotkey::ActionName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsDefaultGamepadHotkey, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_IsDefaultGamepadHotkey::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsGeneratingShader
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsGeneratingShader final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsGeneratingShader) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsGeneratingShader");
static_assert(sizeof(UIFunctionLibrary_IsGeneratingShader) == 0x000010, "Wrong size on UIFunctionLibrary_IsGeneratingShader");
static_assert(offsetof(UIFunctionLibrary_IsGeneratingShader, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsGeneratingShader::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsGeneratingShader, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsGeneratingShader::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsGodModeActive
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsGodModeActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsGodModeActive) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsGodModeActive");
static_assert(sizeof(UIFunctionLibrary_IsGodModeActive) == 0x000010, "Wrong size on UIFunctionLibrary_IsGodModeActive");
static_assert(offsetof(UIFunctionLibrary_IsGodModeActive, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsGodModeActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsGodModeActive, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsGodModeActive::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsHotkeyKey
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_IsHotkeyKey final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsHotkeyKey) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsHotkeyKey");
static_assert(sizeof(UIFunctionLibrary_IsHotkeyKey) == 0x000028, "Wrong size on UIFunctionLibrary_IsHotkeyKey");
static_assert(offsetof(UIFunctionLibrary_IsHotkeyKey, ActionName) == 0x000000, "Member 'UIFunctionLibrary_IsHotkeyKey::ActionName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsHotkeyKey, Key) == 0x000008, "Member 'UIFunctionLibrary_IsHotkeyKey::Key' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsHotkeyKey, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_IsHotkeyKey::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsInputModeUIOnly
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsInputModeUIOnly final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsInputModeUIOnly) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsInputModeUIOnly");
static_assert(sizeof(UIFunctionLibrary_IsInputModeUIOnly) == 0x000010, "Wrong size on UIFunctionLibrary_IsInputModeUIOnly");
static_assert(offsetof(UIFunctionLibrary_IsInputModeUIOnly, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsInputModeUIOnly::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsInputModeUIOnly, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsInputModeUIOnly::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsKeyboardEnabled
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsKeyboardEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsKeyboardEnabled) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsKeyboardEnabled");
static_assert(sizeof(UIFunctionLibrary_IsKeyboardEnabled) == 0x000001, "Wrong size on UIFunctionLibrary_IsKeyboardEnabled");
static_assert(offsetof(UIFunctionLibrary_IsKeyboardEnabled, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsKeyboardEnabled::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsKeyboardInputDisplay
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsKeyboardInputDisplay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsKeyboardInputDisplay) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsKeyboardInputDisplay");
static_assert(sizeof(UIFunctionLibrary_IsKeyboardInputDisplay) == 0x000010, "Wrong size on UIFunctionLibrary_IsKeyboardInputDisplay");
static_assert(offsetof(UIFunctionLibrary_IsKeyboardInputDisplay, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsKeyboardInputDisplay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsKeyboardInputDisplay, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsKeyboardInputDisplay::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsKeyPressed
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_IsKeyPressed final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsKeyPressed) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsKeyPressed");
static_assert(sizeof(UIFunctionLibrary_IsKeyPressed) == 0x000018, "Wrong size on UIFunctionLibrary_IsKeyPressed");
static_assert(offsetof(UIFunctionLibrary_IsKeyPressed, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsKeyPressed::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsKeyPressed, ActionName) == 0x000008, "Member 'UIFunctionLibrary_IsKeyPressed::ActionName' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsKeyPressed, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_IsKeyPressed::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsLeftAndRightSticksSwapped
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsLeftAndRightSticksSwapped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsLeftAndRightSticksSwapped) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsLeftAndRightSticksSwapped");
static_assert(sizeof(UIFunctionLibrary_IsLeftAndRightSticksSwapped) == 0x000001, "Wrong size on UIFunctionLibrary_IsLeftAndRightSticksSwapped");
static_assert(offsetof(UIFunctionLibrary_IsLeftAndRightSticksSwapped, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsLeftAndRightSticksSwapped::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsLeftClickToBuySellSelectedItem
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsLeftClickToBuySellSelectedItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsLeftClickToBuySellSelectedItem) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsLeftClickToBuySellSelectedItem");
static_assert(sizeof(UIFunctionLibrary_IsLeftClickToBuySellSelectedItem) == 0x000001, "Wrong size on UIFunctionLibrary_IsLeftClickToBuySellSelectedItem");
static_assert(offsetof(UIFunctionLibrary_IsLeftClickToBuySellSelectedItem, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsLeftClickToBuySellSelectedItem::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsMouseInputDisplay
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsMouseInputDisplay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsMouseInputDisplay) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsMouseInputDisplay");
static_assert(sizeof(UIFunctionLibrary_IsMouseInputDisplay) == 0x000010, "Wrong size on UIFunctionLibrary_IsMouseInputDisplay");
static_assert(offsetof(UIFunctionLibrary_IsMouseInputDisplay, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsMouseInputDisplay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsMouseInputDisplay, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsMouseInputDisplay::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsPauseMenuAllowed
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsPauseMenuAllowed final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsPauseMenuAllowed) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsPauseMenuAllowed");
static_assert(sizeof(UIFunctionLibrary_IsPauseMenuAllowed) == 0x000010, "Wrong size on UIFunctionLibrary_IsPauseMenuAllowed");
static_assert(offsetof(UIFunctionLibrary_IsPauseMenuAllowed, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsPauseMenuAllowed::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsPauseMenuAllowed, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsPauseMenuAllowed::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsReachedTheCaravan
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsReachedTheCaravan final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsReachedTheCaravan) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsReachedTheCaravan");
static_assert(sizeof(UIFunctionLibrary_IsReachedTheCaravan) == 0x000010, "Wrong size on UIFunctionLibrary_IsReachedTheCaravan");
static_assert(offsetof(UIFunctionLibrary_IsReachedTheCaravan, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsReachedTheCaravan::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsReachedTheCaravan, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsReachedTheCaravan::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsSmallScreenMode
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsSmallScreenMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsSmallScreenMode) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsSmallScreenMode");
static_assert(sizeof(UIFunctionLibrary_IsSmallScreenMode) == 0x000010, "Wrong size on UIFunctionLibrary_IsSmallScreenMode");
static_assert(offsetof(UIFunctionLibrary_IsSmallScreenMode, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsSmallScreenMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsSmallScreenMode, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsSmallScreenMode::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsSprintToggleMode
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsSprintToggleMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsSprintToggleMode) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsSprintToggleMode");
static_assert(sizeof(UIFunctionLibrary_IsSprintToggleMode) == 0x000001, "Wrong size on UIFunctionLibrary_IsSprintToggleMode");
static_assert(offsetof(UIFunctionLibrary_IsSprintToggleMode, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsSprintToggleMode::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsSubtitleVisible
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_IsSubtitleVisible final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsSubtitleVisible) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsSubtitleVisible");
static_assert(sizeof(UIFunctionLibrary_IsSubtitleVisible) == 0x000010, "Wrong size on UIFunctionLibrary_IsSubtitleVisible");
static_assert(offsetof(UIFunctionLibrary_IsSubtitleVisible, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsSubtitleVisible::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsSubtitleVisible, ReturnValue) == 0x000008, "Member 'UIFunctionLibrary_IsSubtitleVisible::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsTopMostWidget
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_IsTopMostWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     InManUserWidgetBase;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_IsTopMostWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_IsTopMostWidget");
static_assert(sizeof(UIFunctionLibrary_IsTopMostWidget) == 0x000018, "Wrong size on UIFunctionLibrary_IsTopMostWidget");
static_assert(offsetof(UIFunctionLibrary_IsTopMostWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_IsTopMostWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsTopMostWidget, InManUserWidgetBase) == 0x000008, "Member 'UIFunctionLibrary_IsTopMostWidget::InManUserWidgetBase' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_IsTopMostWidget, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_IsTopMostWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsXAxisInverted
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsXAxisInverted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsXAxisInverted) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsXAxisInverted");
static_assert(sizeof(UIFunctionLibrary_IsXAxisInverted) == 0x000001, "Wrong size on UIFunctionLibrary_IsXAxisInverted");
static_assert(offsetof(UIFunctionLibrary_IsXAxisInverted, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsXAxisInverted::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.IsYAxisInverted
// 0x0001 (0x0001 - 0x0000)
struct UIFunctionLibrary_IsYAxisInverted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_IsYAxisInverted) == 0x000001, "Wrong alignment on UIFunctionLibrary_IsYAxisInverted");
static_assert(sizeof(UIFunctionLibrary_IsYAxisInverted) == 0x000001, "Wrong size on UIFunctionLibrary_IsYAxisInverted");
static_assert(offsetof(UIFunctionLibrary_IsYAxisInverted, ReturnValue) == 0x000000, "Member 'UIFunctionLibrary_IsYAxisInverted::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.OpenSteamPage
// 0x0008 (0x0008 - 0x0000)
struct UIFunctionLibrary_OpenSteamPage final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_OpenSteamPage) == 0x000008, "Wrong alignment on UIFunctionLibrary_OpenSteamPage");
static_assert(sizeof(UIFunctionLibrary_OpenSteamPage) == 0x000008, "Wrong size on UIFunctionLibrary_OpenSteamPage");
static_assert(offsetof(UIFunctionLibrary_OpenSteamPage, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_OpenSteamPage::WorldContextObject' has a wrong offset!");

// Function man.UIFunctionLibrary.OpenStore
// 0x0008 (0x0008 - 0x0000)
struct UIFunctionLibrary_OpenStore final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_OpenStore) == 0x000008, "Wrong alignment on UIFunctionLibrary_OpenStore");
static_assert(sizeof(UIFunctionLibrary_OpenStore) == 0x000008, "Wrong size on UIFunctionLibrary_OpenStore");
static_assert(offsetof(UIFunctionLibrary_OpenStore, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_OpenStore::WorldContextObject' has a wrong offset!");

// Function man.UIFunctionLibrary.OverrideNavigationRule
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_OverrideNavigationRule final
{
public:
	class UManUserWidgetBase*                     MainWidget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Widget;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUINavigation                                 Direction;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUINavigationRule                             Rule;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidgetToFocus;                                     // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_OverrideNavigationRule) == 0x000008, "Wrong alignment on UIFunctionLibrary_OverrideNavigationRule");
static_assert(sizeof(UIFunctionLibrary_OverrideNavigationRule) == 0x000020, "Wrong size on UIFunctionLibrary_OverrideNavigationRule");
static_assert(offsetof(UIFunctionLibrary_OverrideNavigationRule, MainWidget) == 0x000000, "Member 'UIFunctionLibrary_OverrideNavigationRule::MainWidget' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_OverrideNavigationRule, Widget) == 0x000008, "Member 'UIFunctionLibrary_OverrideNavigationRule::Widget' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_OverrideNavigationRule, Direction) == 0x000010, "Member 'UIFunctionLibrary_OverrideNavigationRule::Direction' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_OverrideNavigationRule, Rule) == 0x000011, "Member 'UIFunctionLibrary_OverrideNavigationRule::Rule' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_OverrideNavigationRule, WidgetToFocus) == 0x000014, "Member 'UIFunctionLibrary_OverrideNavigationRule::WidgetToFocus' has a wrong offset!");

// Function man.UIFunctionLibrary.PlayAkAudioEvent
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_PlayAkAudioEvent final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AkEventActor;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_PlayAkAudioEvent) == 0x000008, "Wrong alignment on UIFunctionLibrary_PlayAkAudioEvent");
static_assert(sizeof(UIFunctionLibrary_PlayAkAudioEvent) == 0x000018, "Wrong size on UIFunctionLibrary_PlayAkAudioEvent");
static_assert(offsetof(UIFunctionLibrary_PlayAkAudioEvent, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_PlayAkAudioEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_PlayAkAudioEvent, AkEvent) == 0x000008, "Member 'UIFunctionLibrary_PlayAkAudioEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_PlayAkAudioEvent, AkEventActor) == 0x000010, "Member 'UIFunctionLibrary_PlayAkAudioEvent::AkEventActor' has a wrong offset!");

// Function man.UIFunctionLibrary.SetConversationOpacity
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_SetConversationOpacity final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_SetConversationOpacity) == 0x000008, "Wrong alignment on UIFunctionLibrary_SetConversationOpacity");
static_assert(sizeof(UIFunctionLibrary_SetConversationOpacity) == 0x000010, "Wrong size on UIFunctionLibrary_SetConversationOpacity");
static_assert(offsetof(UIFunctionLibrary_SetConversationOpacity, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_SetConversationOpacity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetConversationOpacity, Opacity) == 0x000008, "Member 'UIFunctionLibrary_SetConversationOpacity::Opacity' has a wrong offset!");

// Function man.UIFunctionLibrary.SetLungeActionName
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_SetLungeActionName final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractButtonUserWidget*              InteractButtonUserWidget;                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_SetLungeActionName) == 0x000008, "Wrong alignment on UIFunctionLibrary_SetLungeActionName");
static_assert(sizeof(UIFunctionLibrary_SetLungeActionName) == 0x000018, "Wrong size on UIFunctionLibrary_SetLungeActionName");
static_assert(offsetof(UIFunctionLibrary_SetLungeActionName, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_SetLungeActionName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetLungeActionName, InteractButtonUserWidget) == 0x000008, "Member 'UIFunctionLibrary_SetLungeActionName::InteractButtonUserWidget' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetLungeActionName, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_SetLungeActionName::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.SetTabButtonNewItemWarningInAllWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETabButtonType                                TabButtonType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewItemWarning;                                   // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget");
static_assert(sizeof(UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget) == 0x000010, "Wrong size on UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget");
static_assert(offsetof(UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget, TabButtonType) == 0x000008, "Member 'UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget::TabButtonType' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget, bNewItemWarning) == 0x000009, "Member 'UIFunctionLibrary_SetTabButtonNewItemWarningInAllWidget::bNewItemWarning' has a wrong offset!");

// Function man.UIFunctionLibrary.SetTabButtonsStateInAllWidget
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_SetTabButtonsStateInAllWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETabButtonType                                TabButtonType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_SetTabButtonsStateInAllWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_SetTabButtonsStateInAllWidget");
static_assert(sizeof(UIFunctionLibrary_SetTabButtonsStateInAllWidget) == 0x000010, "Wrong size on UIFunctionLibrary_SetTabButtonsStateInAllWidget");
static_assert(offsetof(UIFunctionLibrary_SetTabButtonsStateInAllWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_SetTabButtonsStateInAllWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetTabButtonsStateInAllWidget, TabButtonType) == 0x000008, "Member 'UIFunctionLibrary_SetTabButtonsStateInAllWidget::TabButtonType' has a wrong offset!");

// Function man.UIFunctionLibrary.SetTextFormatByHeroGender
// 0x0038 (0x0038 - 0x0000)
struct UIFunctionLibrary_SetTextFormatByHeroGender final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InText;                                            // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_SetTextFormatByHeroGender) == 0x000008, "Wrong alignment on UIFunctionLibrary_SetTextFormatByHeroGender");
static_assert(sizeof(UIFunctionLibrary_SetTextFormatByHeroGender) == 0x000038, "Wrong size on UIFunctionLibrary_SetTextFormatByHeroGender");
static_assert(offsetof(UIFunctionLibrary_SetTextFormatByHeroGender, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_SetTextFormatByHeroGender::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetTextFormatByHeroGender, InText) == 0x000008, "Member 'UIFunctionLibrary_SetTextFormatByHeroGender::InText' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_SetTextFormatByHeroGender, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_SetTextFormatByHeroGender::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowBossScreenWindow
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_ShowBossScreenWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttributeContainer*                    BossAttributeContainer;                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowBossScreenWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowBossScreenWindow");
static_assert(sizeof(UIFunctionLibrary_ShowBossScreenWindow) == 0x000018, "Wrong size on UIFunctionLibrary_ShowBossScreenWindow");
static_assert(offsetof(UIFunctionLibrary_ShowBossScreenWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowBossScreenWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowBossScreenWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowBossScreenWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowBossScreenWindow, BossAttributeContainer) == 0x000010, "Member 'UIFunctionLibrary_ShowBossScreenWindow::BossAttributeContainer' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowBountyBoardWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowBountyBoardWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowBountyBoardWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowBountyBoardWindow");
static_assert(sizeof(UIFunctionLibrary_ShowBountyBoardWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowBountyBoardWindow");
static_assert(offsetof(UIFunctionLibrary_ShowBountyBoardWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowBountyBoardWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowBountyBoardWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowBountyBoardWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowBountyBoardWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowBountyBoardWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowBountyBoardWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowBountyBoardWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowCharacterWindow
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowCharacterWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowCharacterWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowCharacterWindow");
static_assert(sizeof(UIFunctionLibrary_ShowCharacterWindow) == 0x000010, "Wrong size on UIFunctionLibrary_ShowCharacterWindow");
static_assert(offsetof(UIFunctionLibrary_ShowCharacterWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowCharacterWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCharacterWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowCharacterWindow::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowConversationWindow
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_ShowConversationWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowConversationWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowConversationWindow");
static_assert(sizeof(UIFunctionLibrary_ShowConversationWindow) == 0x000018, "Wrong size on UIFunctionLibrary_ShowConversationWindow");
static_assert(offsetof(UIFunctionLibrary_ShowConversationWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowConversationWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowConversationWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowConversationWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowConversationWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowConversationWindow::InteractedActor' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowCreateCharacter
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowCreateCharacter final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowCreateCharacter) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowCreateCharacter");
static_assert(sizeof(UIFunctionLibrary_ShowCreateCharacter) == 0x000010, "Wrong size on UIFunctionLibrary_ShowCreateCharacter");
static_assert(offsetof(UIFunctionLibrary_ShowCreateCharacter, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowCreateCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCreateCharacter, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowCreateCharacter::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowCredits
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowCredits final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)> OnCompleted;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UCreditsUserWidget*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowCredits) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowCredits");
static_assert(sizeof(UIFunctionLibrary_ShowCredits) == 0x000020, "Wrong size on UIFunctionLibrary_ShowCredits");
static_assert(offsetof(UIFunctionLibrary_ShowCredits, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowCredits::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCredits, OnCompleted) == 0x000008, "Member 'UIFunctionLibrary_ShowCredits::OnCompleted' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCredits, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowCredits::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowCutsceneCinematic
// 0x0030 (0x0030 - 0x0000)
struct UIFunctionLibrary_ShowCutsceneCinematic final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCutsceneCinematicDataAsset*            CutsceneCinematicDataAsset;                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)> OnCompleted;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAlwaysResumeToGame;                               // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCutsceneCinematicUserWidget*           ReturnValue;                                       // 0x0028(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowCutsceneCinematic) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowCutsceneCinematic");
static_assert(sizeof(UIFunctionLibrary_ShowCutsceneCinematic) == 0x000030, "Wrong size on UIFunctionLibrary_ShowCutsceneCinematic");
static_assert(offsetof(UIFunctionLibrary_ShowCutsceneCinematic, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowCutsceneCinematic::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCutsceneCinematic, CutsceneCinematicDataAsset) == 0x000008, "Member 'UIFunctionLibrary_ShowCutsceneCinematic::CutsceneCinematicDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCutsceneCinematic, OnCompleted) == 0x000010, "Member 'UIFunctionLibrary_ShowCutsceneCinematic::OnCompleted' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCutsceneCinematic, bAlwaysResumeToGame) == 0x000020, "Member 'UIFunctionLibrary_ShowCutsceneCinematic::bAlwaysResumeToGame' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowCutsceneCinematic, ReturnValue) == 0x000028, "Member 'UIFunctionLibrary_ShowCutsceneCinematic::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowDeathScreen
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowDeathScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowDeathScreen) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowDeathScreen");
static_assert(sizeof(UIFunctionLibrary_ShowDeathScreen) == 0x000010, "Wrong size on UIFunctionLibrary_ShowDeathScreen");
static_assert(offsetof(UIFunctionLibrary_ShowDeathScreen, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowDeathScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowDeathScreen, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowDeathScreen::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowHUD
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowHUD final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowHUD) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowHUD");
static_assert(sizeof(UIFunctionLibrary_ShowHUD) == 0x000010, "Wrong size on UIFunctionLibrary_ShowHUD");
static_assert(offsetof(UIFunctionLibrary_ShowHUD, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowHUD::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowHUD, bAnimate) == 0x000008, "Member 'UIFunctionLibrary_ShowHUD::bAnimate' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowInfoScreenWindow
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowInfoScreenWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInfoScreentDataAsset*                  InfoScreenData;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowInfoScreenWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowInfoScreenWindow");
static_assert(sizeof(UIFunctionLibrary_ShowInfoScreenWindow) == 0x000010, "Wrong size on UIFunctionLibrary_ShowInfoScreenWindow");
static_assert(offsetof(UIFunctionLibrary_ShowInfoScreenWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowInfoScreenWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowInfoScreenWindow, InfoScreenData) == 0x000008, "Member 'UIFunctionLibrary_ShowInfoScreenWindow::InfoScreenData' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowLevelUpWindow
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowLevelUpWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowLevelUpWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowLevelUpWindow");
static_assert(sizeof(UIFunctionLibrary_ShowLevelUpWindow) == 0x000010, "Wrong size on UIFunctionLibrary_ShowLevelUpWindow");
static_assert(offsetof(UIFunctionLibrary_ShowLevelUpWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowLevelUpWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowLevelUpWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowLevelUpWindow::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowLoadGame
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowLoadGame final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowLoadGame) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowLoadGame");
static_assert(sizeof(UIFunctionLibrary_ShowLoadGame) == 0x000010, "Wrong size on UIFunctionLibrary_ShowLoadGame");
static_assert(offsetof(UIFunctionLibrary_ShowLoadGame, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowLoadGame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowLoadGame, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowLoadGame::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowMainMenu
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowMainMenu final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowMainMenu) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowMainMenu");
static_assert(sizeof(UIFunctionLibrary_ShowMainMenu) == 0x000010, "Wrong size on UIFunctionLibrary_ShowMainMenu");
static_assert(offsetof(UIFunctionLibrary_ShowMainMenu, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowMainMenu::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowMainMenu, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowMainMenu::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowManUserWidget
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_ShowManUserWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ManUserWidgetBase;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideHUD;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowManUserWidget) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowManUserWidget");
static_assert(sizeof(UIFunctionLibrary_ShowManUserWidget) == 0x000028, "Wrong size on UIFunctionLibrary_ShowManUserWidget");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidget, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowManUserWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidget, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowManUserWidget::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidget, ManUserWidgetBase) == 0x000010, "Member 'UIFunctionLibrary_ShowManUserWidget::ManUserWidgetBase' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidget, HideHUD) == 0x000018, "Member 'UIFunctionLibrary_ShowManUserWidget::HideHUD' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidget, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_ShowManUserWidget::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowManUserWidgetByZorder
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_ShowManUserWidgetByZorder final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetsZorder                                WidgetsZorder;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideHUD;                                           // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowManUserWidgetByZorder) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowManUserWidgetByZorder");
static_assert(sizeof(UIFunctionLibrary_ShowManUserWidgetByZorder) == 0x000018, "Wrong size on UIFunctionLibrary_ShowManUserWidgetByZorder");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidgetByZorder, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowManUserWidgetByZorder::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidgetByZorder, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowManUserWidgetByZorder::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidgetByZorder, WidgetsZorder) == 0x00000C, "Member 'UIFunctionLibrary_ShowManUserWidgetByZorder::WidgetsZorder' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidgetByZorder, HideHUD) == 0x00000D, "Member 'UIFunctionLibrary_ShowManUserWidgetByZorder::HideHUD' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowManUserWidgetByZorder, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_ShowManUserWidgetByZorder::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowMapWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowMapWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapWindowUserWidget*                   ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowMapWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowMapWindow");
static_assert(sizeof(UIFunctionLibrary_ShowMapWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowMapWindow");
static_assert(offsetof(UIFunctionLibrary_ShowMapWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowMapWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowMapWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowMapWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowMapWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowMapWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowMapWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowMapWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowMouseCursor
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowMouseCursor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowMouseCursor) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowMouseCursor");
static_assert(sizeof(UIFunctionLibrary_ShowMouseCursor) == 0x000010, "Wrong size on UIFunctionLibrary_ShowMouseCursor");
static_assert(offsetof(UIFunctionLibrary_ShowMouseCursor, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowMouseCursor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowMouseCursor, bShow) == 0x000008, "Member 'UIFunctionLibrary_ShowMouseCursor::bShow' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowNPCBestiaryWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowNPCBestiaryWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowNPCBestiaryWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowNPCBestiaryWindow");
static_assert(sizeof(UIFunctionLibrary_ShowNPCBestiaryWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowNPCBestiaryWindow");
static_assert(offsetof(UIFunctionLibrary_ShowNPCBestiaryWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowNPCBestiaryWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowNPCBestiaryWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowNPCBestiaryWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowNPCBestiaryWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowNPCBestiaryWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowNPCBestiaryWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowNPCBestiaryWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowOptions
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowOptions final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowOptions) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowOptions");
static_assert(sizeof(UIFunctionLibrary_ShowOptions) == 0x000010, "Wrong size on UIFunctionLibrary_ShowOptions");
static_assert(offsetof(UIFunctionLibrary_ShowOptions, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowOptions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowOptions, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowOptions::AnimDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowOptionsSubtitle
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowOptionsSubtitle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowOptionsSubtitle) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowOptionsSubtitle");
static_assert(sizeof(UIFunctionLibrary_ShowOptionsSubtitle) == 0x000010, "Wrong size on UIFunctionLibrary_ShowOptionsSubtitle");
static_assert(offsetof(UIFunctionLibrary_ShowOptionsSubtitle, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowOptionsSubtitle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowOptionsSubtitle, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_ShowOptionsSubtitle::DialogueDataAsset' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowPauseMenu
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_ShowPauseMenu final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenAkEvent;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowPauseMenu) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowPauseMenu");
static_assert(sizeof(UIFunctionLibrary_ShowPauseMenu) == 0x000018, "Wrong size on UIFunctionLibrary_ShowPauseMenu");
static_assert(offsetof(UIFunctionLibrary_ShowPauseMenu, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowPauseMenu::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPauseMenu, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowPauseMenu::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPauseMenu, bOpenAkEvent) == 0x00000C, "Member 'UIFunctionLibrary_ShowPauseMenu::bOpenAkEvent' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPauseMenu, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_ShowPauseMenu::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowPlayerMonologue
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_ShowPlayerMonologue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)> OnCompleted;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UPlayerMonologueUserWidget*             ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowPlayerMonologue) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowPlayerMonologue");
static_assert(sizeof(UIFunctionLibrary_ShowPlayerMonologue) == 0x000028, "Wrong size on UIFunctionLibrary_ShowPlayerMonologue");
static_assert(offsetof(UIFunctionLibrary_ShowPlayerMonologue, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowPlayerMonologue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPlayerMonologue, DialogueDataAsset) == 0x000008, "Member 'UIFunctionLibrary_ShowPlayerMonologue::DialogueDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPlayerMonologue, OnCompleted) == 0x000010, "Member 'UIFunctionLibrary_ShowPlayerMonologue::OnCompleted' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowPlayerMonologue, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_ShowPlayerMonologue::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowSubtitle
// 0x0078 (0x0078 - 0x0000)
struct UIFunctionLibrary_ShowSubtitle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueNode                          DialogueNode;                                      // 0x0008(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         SubtitleDuration;                                  // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowSubtitle) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowSubtitle");
static_assert(sizeof(UIFunctionLibrary_ShowSubtitle) == 0x000078, "Wrong size on UIFunctionLibrary_ShowSubtitle");
static_assert(offsetof(UIFunctionLibrary_ShowSubtitle, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowSubtitle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowSubtitle, DialogueNode) == 0x000008, "Member 'UIFunctionLibrary_ShowSubtitle::DialogueNode' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowSubtitle, SubtitleDuration) == 0x000070, "Member 'UIFunctionLibrary_ShowSubtitle::SubtitleDuration' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowTutorialReplayScreen
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_ShowTutorialReplayScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTutorialScreenDataAsset*               TutorialScreenDataAsset;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTutorialScreenUserWidget*              ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowTutorialReplayScreen) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowTutorialReplayScreen");
static_assert(sizeof(UIFunctionLibrary_ShowTutorialReplayScreen) == 0x000018, "Wrong size on UIFunctionLibrary_ShowTutorialReplayScreen");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialReplayScreen, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowTutorialReplayScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialReplayScreen, TutorialScreenDataAsset) == 0x000008, "Member 'UIFunctionLibrary_ShowTutorialReplayScreen::TutorialScreenDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialReplayScreen, ReturnValue) == 0x000010, "Member 'UIFunctionLibrary_ShowTutorialReplayScreen::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowTutorialScreen
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_ShowTutorialScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTutorialScreenDataAsset*               TutorialScreenDataAsset;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UManUserWidgetBase* ManUserWidgetBase)> OnCompleted;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UTutorialScreenUserWidget*              ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowTutorialScreen) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowTutorialScreen");
static_assert(sizeof(UIFunctionLibrary_ShowTutorialScreen) == 0x000028, "Wrong size on UIFunctionLibrary_ShowTutorialScreen");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialScreen, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowTutorialScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialScreen, TutorialScreenDataAsset) == 0x000008, "Member 'UIFunctionLibrary_ShowTutorialScreen::TutorialScreenDataAsset' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialScreen, OnCompleted) == 0x000010, "Member 'UIFunctionLibrary_ShowTutorialScreen::OnCompleted' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialScreen, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_ShowTutorialScreen::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowTutorialSign
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_ShowTutorialSign final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptStruct;                                      // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowTutorialSign) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowTutorialSign");
static_assert(sizeof(UIFunctionLibrary_ShowTutorialSign) == 0x000028, "Wrong size on UIFunctionLibrary_ShowTutorialSign");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialSign, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowTutorialSign::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowTutorialSign, PromptStruct) == 0x000008, "Member 'UIFunctionLibrary_ShowTutorialSign::PromptStruct' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorAlchemistWindow
// 0x0028 (0x0028 - 0x0000)
struct UIFunctionLibrary_ShowVendorAlchemistWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExclusiveGardenMode;                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorAlchemistWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorAlchemistWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorAlchemistWindow) == 0x000028, "Wrong size on UIFunctionLibrary_ShowVendorAlchemistWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorAlchemistWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorAlchemistWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorAlchemistWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorAlchemistWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorAlchemistWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorAlchemistWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorAlchemistWindow, bExclusiveGardenMode) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorAlchemistWindow::bExclusiveGardenMode' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorAlchemistWindow, ReturnValue) == 0x000020, "Member 'UIFunctionLibrary_ShowVendorAlchemistWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorBuyWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorBuyWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorBuyWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorBuyWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorBuyWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorBuyWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorBuyWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorBuyWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorBuyWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorBuyWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorBuyWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorBuyWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorBuyWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorBuyWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorCraftWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorCraftWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorCraftWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorCraftWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorCraftWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorCraftWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorCraftWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorCraftWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorCraftWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorCraftWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorCraftWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorCraftWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorCraftWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorCraftWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorEnchantWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorEnchantWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorEnchantWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorEnchantWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorEnchantWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorEnchantWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorEnchantWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorEnchantWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorEnchantWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorEnchantWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorEnchantWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorEnchantWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorEnchantWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorEnchantWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorMapFragmentWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorMapFragmentWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorMapFragmentWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorMapFragmentWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorMapFragmentWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorMapFragmentWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorMapFragmentWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorMapFragmentWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorMapFragmentWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorMapFragmentWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorMapFragmentWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorMapFragmentWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorMapFragmentWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorMapFragmentWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorSellWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorSellWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorSellWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorSellWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorSellWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorSellWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorSellWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorSellWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorSellWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorSellWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorSellWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorSellWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorSellWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorSellWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorTransmogWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorTransmogWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorTransmogWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorTransmogWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorTransmogWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorTransmogWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorTransmogWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorTransmogWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorTransmogWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorTransmogWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorTransmogWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorTransmogWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorTransmogWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorTransmogWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowVendorUpgradeWindow
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_ShowVendorUpgradeWindow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDuration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManUserWidgetBase*                     ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_ShowVendorUpgradeWindow) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowVendorUpgradeWindow");
static_assert(sizeof(UIFunctionLibrary_ShowVendorUpgradeWindow) == 0x000020, "Wrong size on UIFunctionLibrary_ShowVendorUpgradeWindow");
static_assert(offsetof(UIFunctionLibrary_ShowVendorUpgradeWindow, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowVendorUpgradeWindow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorUpgradeWindow, AnimDuration) == 0x000008, "Member 'UIFunctionLibrary_ShowVendorUpgradeWindow::AnimDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorUpgradeWindow, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_ShowVendorUpgradeWindow::InteractedActor' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowVendorUpgradeWindow, ReturnValue) == 0x000018, "Member 'UIFunctionLibrary_ShowVendorUpgradeWindow::ReturnValue' has a wrong offset!");

// Function man.UIFunctionLibrary.ShowWindowByTabButtonType
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_ShowWindowByTabButtonType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETabButtonType                                TabButtonType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_ShowWindowByTabButtonType) == 0x000008, "Wrong alignment on UIFunctionLibrary_ShowWindowByTabButtonType");
static_assert(sizeof(UIFunctionLibrary_ShowWindowByTabButtonType) == 0x000010, "Wrong size on UIFunctionLibrary_ShowWindowByTabButtonType");
static_assert(offsetof(UIFunctionLibrary_ShowWindowByTabButtonType, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_ShowWindowByTabButtonType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_ShowWindowByTabButtonType, TabButtonType) == 0x000008, "Member 'UIFunctionLibrary_ShowWindowByTabButtonType::TabButtonType' has a wrong offset!");

// Function man.UIFunctionLibrary.SimulateInputKey
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_SimulateInputKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_SimulateInputKey) == 0x000008, "Wrong alignment on UIFunctionLibrary_SimulateInputKey");
static_assert(sizeof(UIFunctionLibrary_SimulateInputKey) == 0x000018, "Wrong size on UIFunctionLibrary_SimulateInputKey");
static_assert(offsetof(UIFunctionLibrary_SimulateInputKey, Key) == 0x000000, "Member 'UIFunctionLibrary_SimulateInputKey::Key' has a wrong offset!");

// Function man.UIFunctionLibrary.StopAkAudioEvent
// 0x0020 (0x0020 - 0x0000)
struct UIFunctionLibrary_StopAkAudioEvent final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionDuration;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AkEventActor;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_StopAkAudioEvent) == 0x000008, "Wrong alignment on UIFunctionLibrary_StopAkAudioEvent");
static_assert(sizeof(UIFunctionLibrary_StopAkAudioEvent) == 0x000020, "Wrong size on UIFunctionLibrary_StopAkAudioEvent");
static_assert(offsetof(UIFunctionLibrary_StopAkAudioEvent, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_StopAkAudioEvent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_StopAkAudioEvent, AkEvent) == 0x000008, "Member 'UIFunctionLibrary_StopAkAudioEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_StopAkAudioEvent, TransitionDuration) == 0x000010, "Member 'UIFunctionLibrary_StopAkAudioEvent::TransitionDuration' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_StopAkAudioEvent, AkEventActor) == 0x000018, "Member 'UIFunctionLibrary_StopAkAudioEvent::AkEventActor' has a wrong offset!");

// Function man.UIFunctionLibrary.TriggerHudCommand
// 0x0018 (0x0018 - 0x0000)
struct UIFunctionLibrary_TriggerHudCommand final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudCommand                                   HUDCommand;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActorBase*                             InteractedActor;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIFunctionLibrary_TriggerHudCommand) == 0x000008, "Wrong alignment on UIFunctionLibrary_TriggerHudCommand");
static_assert(sizeof(UIFunctionLibrary_TriggerHudCommand) == 0x000018, "Wrong size on UIFunctionLibrary_TriggerHudCommand");
static_assert(offsetof(UIFunctionLibrary_TriggerHudCommand, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_TriggerHudCommand::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_TriggerHudCommand, HUDCommand) == 0x000008, "Member 'UIFunctionLibrary_TriggerHudCommand::HUDCommand' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_TriggerHudCommand, InteractedActor) == 0x000010, "Member 'UIFunctionLibrary_TriggerHudCommand::InteractedActor' has a wrong offset!");

// Function man.UIFunctionLibrary.TriggerHudMessage
// 0x0010 (0x0010 - 0x0000)
struct UIFunctionLibrary_TriggerHudMessage final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudMessage                                   Msg;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIFunctionLibrary_TriggerHudMessage) == 0x000008, "Wrong alignment on UIFunctionLibrary_TriggerHudMessage");
static_assert(sizeof(UIFunctionLibrary_TriggerHudMessage) == 0x000010, "Wrong size on UIFunctionLibrary_TriggerHudMessage");
static_assert(offsetof(UIFunctionLibrary_TriggerHudMessage, WorldContextObject) == 0x000000, "Member 'UIFunctionLibrary_TriggerHudMessage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UIFunctionLibrary_TriggerHudMessage, Msg) == 0x000008, "Member 'UIFunctionLibrary_TriggerHudMessage::Msg' has a wrong offset!");

// Function man.UnstableBurst.StatusEffectApplied
// 0x0018 (0x0018 - 0x0000)
struct UnstableBurst_StatusEffectApplied final
{
public:
	class AActor*                                 effecttarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnstableBurst_StatusEffectApplied) == 0x000008, "Wrong alignment on UnstableBurst_StatusEffectApplied");
static_assert(sizeof(UnstableBurst_StatusEffectApplied) == 0x000018, "Wrong size on UnstableBurst_StatusEffectApplied");
static_assert(offsetof(UnstableBurst_StatusEffectApplied, effecttarget) == 0x000000, "Member 'UnstableBurst_StatusEffectApplied::effecttarget' has a wrong offset!");
static_assert(offsetof(UnstableBurst_StatusEffectApplied, Type) == 0x000008, "Member 'UnstableBurst_StatusEffectApplied::Type' has a wrong offset!");
static_assert(offsetof(UnstableBurst_StatusEffectApplied, IsNewEffect) == 0x000009, "Member 'UnstableBurst_StatusEffectApplied::IsNewEffect' has a wrong offset!");
static_assert(offsetof(UnstableBurst_StatusEffectApplied, Instance) == 0x000010, "Member 'UnstableBurst_StatusEffectApplied::Instance' has a wrong offset!");

// Function man.UnstableTrailActor.IsValidDetonator
// 0x0010 (0x0010 - 0x0000)
struct UnstableTrailActor_IsValidDetonator final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UnstableTrailActor_IsValidDetonator) == 0x000008, "Wrong alignment on UnstableTrailActor_IsValidDetonator");
static_assert(sizeof(UnstableTrailActor_IsValidDetonator) == 0x000010, "Wrong size on UnstableTrailActor_IsValidDetonator");
static_assert(offsetof(UnstableTrailActor_IsValidDetonator, Actor) == 0x000000, "Member 'UnstableTrailActor_IsValidDetonator::Actor' has a wrong offset!");
static_assert(offsetof(UnstableTrailActor_IsValidDetonator, ReturnValue) == 0x000008, "Member 'UnstableTrailActor_IsValidDetonator::ReturnValue' has a wrong offset!");

// Function man.UseInventoryAbility.OnRecoveryEnded
// 0x0008 (0x0008 - 0x0000)
struct UseInventoryAbility_OnRecoveryEnded final
{
public:
	class UAbilityBase*                           RecoveryAbility;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseInventoryAbility_OnRecoveryEnded) == 0x000008, "Wrong alignment on UseInventoryAbility_OnRecoveryEnded");
static_assert(sizeof(UseInventoryAbility_OnRecoveryEnded) == 0x000008, "Wrong size on UseInventoryAbility_OnRecoveryEnded");
static_assert(offsetof(UseInventoryAbility_OnRecoveryEnded, RecoveryAbility) == 0x000000, "Member 'UseInventoryAbility_OnRecoveryEnded::RecoveryAbility' has a wrong offset!");

// Function man.VampireBeastAI.EventOnAbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct VampireBeastAI_EventOnAbilityEnd final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireBeastAI_EventOnAbilityEnd) == 0x000008, "Wrong alignment on VampireBeastAI_EventOnAbilityEnd");
static_assert(sizeof(VampireBeastAI_EventOnAbilityEnd) == 0x000008, "Wrong size on VampireBeastAI_EventOnAbilityEnd");
static_assert(offsetof(VampireBeastAI_EventOnAbilityEnd, InAbility) == 0x000000, "Member 'VampireBeastAI_EventOnAbilityEnd::InAbility' has a wrong offset!");

// Function man.VampireBeastAI.EventOnAbilityStarting
// 0x0008 (0x0008 - 0x0000)
struct VampireBeastAI_EventOnAbilityStarting final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireBeastAI_EventOnAbilityStarting) == 0x000008, "Wrong alignment on VampireBeastAI_EventOnAbilityStarting");
static_assert(sizeof(VampireBeastAI_EventOnAbilityStarting) == 0x000008, "Wrong size on VampireBeastAI_EventOnAbilityStarting");
static_assert(offsetof(VampireBeastAI_EventOnAbilityStarting, InAbility) == 0x000000, "Member 'VampireBeastAI_EventOnAbilityStarting::InAbility' has a wrong offset!");

// Function man.VampireLordAI.BPStartAggro
// 0x0002 (0x0002 - 0x0000)
struct VampireLordAI_BPStartAggro final
{
public:
	bool                                          bInSkipRoomEnter;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSerialize;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireLordAI_BPStartAggro) == 0x000001, "Wrong alignment on VampireLordAI_BPStartAggro");
static_assert(sizeof(VampireLordAI_BPStartAggro) == 0x000002, "Wrong size on VampireLordAI_BPStartAggro");
static_assert(offsetof(VampireLordAI_BPStartAggro, bInSkipRoomEnter) == 0x000000, "Member 'VampireLordAI_BPStartAggro::bInSkipRoomEnter' has a wrong offset!");
static_assert(offsetof(VampireLordAI_BPStartAggro, bSerialize) == 0x000001, "Member 'VampireLordAI_BPStartAggro::bSerialize' has a wrong offset!");

// Function man.VampireLordAI.EventOnAbilityEnd
// 0x0008 (0x0008 - 0x0000)
struct VampireLordAI_EventOnAbilityEnd final
{
public:
	class UAbilityBase*                           InAbility;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VampireLordAI_EventOnAbilityEnd) == 0x000008, "Wrong alignment on VampireLordAI_EventOnAbilityEnd");
static_assert(sizeof(VampireLordAI_EventOnAbilityEnd) == 0x000008, "Wrong size on VampireLordAI_EventOnAbilityEnd");
static_assert(offsetof(VampireLordAI_EventOnAbilityEnd, InAbility) == 0x000000, "Member 'VampireLordAI_EventOnAbilityEnd::InAbility' has a wrong offset!");

// Function man.Varlist.BPFindVariable
// 0x000C (0x000C - 0x0000)
struct Varlist_BPFindVariable final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Varlist_BPFindVariable) == 0x000004, "Wrong alignment on Varlist_BPFindVariable");
static_assert(sizeof(Varlist_BPFindVariable) == 0x00000C, "Wrong size on Varlist_BPFindVariable");
static_assert(offsetof(Varlist_BPFindVariable, Name_0) == 0x000000, "Member 'Varlist_BPFindVariable::Name_0' has a wrong offset!");
static_assert(offsetof(Varlist_BPFindVariable, ReturnValue) == 0x000008, "Member 'Varlist_BPFindVariable::ReturnValue' has a wrong offset!");

// Function man.Varlist.BPGetValue_Text
// 0x0020 (0x0020 - 0x0000)
struct Varlist_BPGetValue_Text final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Varlist_BPGetValue_Text) == 0x000008, "Wrong alignment on Varlist_BPGetValue_Text");
static_assert(sizeof(Varlist_BPGetValue_Text) == 0x000020, "Wrong size on Varlist_BPGetValue_Text");
static_assert(offsetof(Varlist_BPGetValue_Text, Name_0) == 0x000000, "Member 'Varlist_BPGetValue_Text::Name_0' has a wrong offset!");
static_assert(offsetof(Varlist_BPGetValue_Text, ReturnValue) == 0x000008, "Member 'Varlist_BPGetValue_Text::ReturnValue' has a wrong offset!");

// Function man.Varlist.BPGetVariable
// 0x0010 (0x0010 - 0x0000)
struct Varlist_BPGetVariable final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVarlistValue*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Varlist_BPGetVariable) == 0x000008, "Wrong alignment on Varlist_BPGetVariable");
static_assert(sizeof(Varlist_BPGetVariable) == 0x000010, "Wrong size on Varlist_BPGetVariable");
static_assert(offsetof(Varlist_BPGetVariable, Name_0) == 0x000000, "Member 'Varlist_BPGetVariable::Name_0' has a wrong offset!");
static_assert(offsetof(Varlist_BPGetVariable, ReturnValue) == 0x000008, "Member 'Varlist_BPGetVariable::ReturnValue' has a wrong offset!");

// Function man.VarlistValueFloat.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct VarlistValueFloat_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VarlistValueFloat_GetEditorName) == 0x000008, "Wrong alignment on VarlistValueFloat_GetEditorName");
static_assert(sizeof(VarlistValueFloat_GetEditorName) == 0x000010, "Wrong size on VarlistValueFloat_GetEditorName");
static_assert(offsetof(VarlistValueFloat_GetEditorName, ReturnValue) == 0x000000, "Member 'VarlistValueFloat_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.VendorActor.ApplyCartUpgrade
// 0x0001 (0x0001 - 0x0000)
struct VendorActor_ApplyCartUpgrade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_ApplyCartUpgrade) == 0x000001, "Wrong alignment on VendorActor_ApplyCartUpgrade");
static_assert(sizeof(VendorActor_ApplyCartUpgrade) == 0x000001, "Wrong size on VendorActor_ApplyCartUpgrade");
static_assert(offsetof(VendorActor_ApplyCartUpgrade, ReturnValue) == 0x000000, "Member 'VendorActor_ApplyCartUpgrade::ReturnValue' has a wrong offset!");

// Function man.VendorActor.BPAddXP
// 0x0004 (0x0004 - 0x0000)
struct VendorActor_BPAddXP final
{
public:
	float                                         Xp;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_BPAddXP) == 0x000004, "Wrong alignment on VendorActor_BPAddXP");
static_assert(sizeof(VendorActor_BPAddXP) == 0x000004, "Wrong size on VendorActor_BPAddXP");
static_assert(offsetof(VendorActor_BPAddXP, Xp) == 0x000000, "Member 'VendorActor_BPAddXP::Xp' has a wrong offset!");

// Function man.VendorActor.BPShowMiniMapIcon
// 0x0001 (0x0001 - 0x0000)
struct VendorActor_BPShowMiniMapIcon final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_BPShowMiniMapIcon) == 0x000001, "Wrong alignment on VendorActor_BPShowMiniMapIcon");
static_assert(sizeof(VendorActor_BPShowMiniMapIcon) == 0x000001, "Wrong size on VendorActor_BPShowMiniMapIcon");
static_assert(offsetof(VendorActor_BPShowMiniMapIcon, Result) == 0x000000, "Member 'VendorActor_BPShowMiniMapIcon::Result' has a wrong offset!");

// Function man.VendorActor.BuyItemFromVendor
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_BuyItemFromVendor final
{
public:
	class UVendorItemSlot*                        ItemSlot;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_BuyItemFromVendor) == 0x000008, "Wrong alignment on VendorActor_BuyItemFromVendor");
static_assert(sizeof(VendorActor_BuyItemFromVendor) == 0x000010, "Wrong size on VendorActor_BuyItemFromVendor");
static_assert(offsetof(VendorActor_BuyItemFromVendor, ItemSlot) == 0x000000, "Member 'VendorActor_BuyItemFromVendor::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorActor_BuyItemFromVendor, amount) == 0x000008, "Member 'VendorActor_BuyItemFromVendor::amount' has a wrong offset!");

// Function man.VendorActor.CanUseCartUpgrade
// 0x0001 (0x0001 - 0x0000)
struct VendorActor_CanUseCartUpgrade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_CanUseCartUpgrade) == 0x000001, "Wrong alignment on VendorActor_CanUseCartUpgrade");
static_assert(sizeof(VendorActor_CanUseCartUpgrade) == 0x000001, "Wrong size on VendorActor_CanUseCartUpgrade");
static_assert(offsetof(VendorActor_CanUseCartUpgrade, ReturnValue) == 0x000000, "Member 'VendorActor_CanUseCartUpgrade::ReturnValue' has a wrong offset!");

// Function man.VendorActor.CraftItem
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_CraftItem final
{
public:
	class UVendorItemSlot*                        CraftItem_0;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemAbility*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_CraftItem) == 0x000008, "Wrong alignment on VendorActor_CraftItem");
static_assert(sizeof(VendorActor_CraftItem) == 0x000018, "Wrong size on VendorActor_CraftItem");
static_assert(offsetof(VendorActor_CraftItem, CraftItem_0) == 0x000000, "Member 'VendorActor_CraftItem::CraftItem_0' has a wrong offset!");
static_assert(offsetof(VendorActor_CraftItem, amount) == 0x000008, "Member 'VendorActor_CraftItem::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_CraftItem, ReturnValue) == 0x000010, "Member 'VendorActor_CraftItem::ReturnValue' has a wrong offset!");

// Function man.VendorActor.DisenchantItem
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_DisenchantItem final
{
public:
	TSubclassOf<class UItemEnchantItemAbility>    EnchantType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ItemToDisenchant;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetEnchantment;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_DisenchantItem) == 0x000008, "Wrong alignment on VendorActor_DisenchantItem");
static_assert(sizeof(VendorActor_DisenchantItem) == 0x000018, "Wrong size on VendorActor_DisenchantItem");
static_assert(offsetof(VendorActor_DisenchantItem, EnchantType) == 0x000000, "Member 'VendorActor_DisenchantItem::EnchantType' has a wrong offset!");
static_assert(offsetof(VendorActor_DisenchantItem, ItemToDisenchant) == 0x000008, "Member 'VendorActor_DisenchantItem::ItemToDisenchant' has a wrong offset!");
static_assert(offsetof(VendorActor_DisenchantItem, bGetEnchantment) == 0x000010, "Member 'VendorActor_DisenchantItem::bGetEnchantment' has a wrong offset!");

// Function man.VendorActor.EnchantItem
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_EnchantItem final
{
public:
	class UManItemSlotBase*                       EnchantItem_0;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ItemToEnchant;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_EnchantItem) == 0x000008, "Wrong alignment on VendorActor_EnchantItem");
static_assert(sizeof(VendorActor_EnchantItem) == 0x000010, "Wrong size on VendorActor_EnchantItem");
static_assert(offsetof(VendorActor_EnchantItem, EnchantItem_0) == 0x000000, "Member 'VendorActor_EnchantItem::EnchantItem_0' has a wrong offset!");
static_assert(offsetof(VendorActor_EnchantItem, ItemToEnchant) == 0x000008, "Member 'VendorActor_EnchantItem::ItemToEnchant' has a wrong offset!");

// Function man.VendorActor.GetCraftItemCalculatedXP
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetCraftItemCalculatedXP final
{
public:
	class UVendorItemSlot*                        CraftItem;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetCraftItemCalculatedXP) == 0x000008, "Wrong alignment on VendorActor_GetCraftItemCalculatedXP");
static_assert(sizeof(VendorActor_GetCraftItemCalculatedXP) == 0x000010, "Wrong size on VendorActor_GetCraftItemCalculatedXP");
static_assert(offsetof(VendorActor_GetCraftItemCalculatedXP, CraftItem) == 0x000000, "Member 'VendorActor_GetCraftItemCalculatedXP::CraftItem' has a wrong offset!");
static_assert(offsetof(VendorActor_GetCraftItemCalculatedXP, amount) == 0x000008, "Member 'VendorActor_GetCraftItemCalculatedXP::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_GetCraftItemCalculatedXP, ReturnValue) == 0x00000C, "Member 'VendorActor_GetCraftItemCalculatedXP::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetCurrentExperience
// 0x0004 (0x0004 - 0x0000)
struct VendorActor_GetCurrentExperience final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetCurrentExperience) == 0x000004, "Wrong alignment on VendorActor_GetCurrentExperience");
static_assert(sizeof(VendorActor_GetCurrentExperience) == 0x000004, "Wrong size on VendorActor_GetCurrentExperience");
static_assert(offsetof(VendorActor_GetCurrentExperience, ReturnValue) == 0x000000, "Member 'VendorActor_GetCurrentExperience::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetEnchantItemCalculatedXP
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetEnchantItemCalculatedXP final
{
public:
	class UManItemSlotBase*                       EnchantItem;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_GetEnchantItemCalculatedXP) == 0x000008, "Wrong alignment on VendorActor_GetEnchantItemCalculatedXP");
static_assert(sizeof(VendorActor_GetEnchantItemCalculatedXP) == 0x000010, "Wrong size on VendorActor_GetEnchantItemCalculatedXP");
static_assert(offsetof(VendorActor_GetEnchantItemCalculatedXP, EnchantItem) == 0x000000, "Member 'VendorActor_GetEnchantItemCalculatedXP::EnchantItem' has a wrong offset!");
static_assert(offsetof(VendorActor_GetEnchantItemCalculatedXP, ReturnValue) == 0x000008, "Member 'VendorActor_GetEnchantItemCalculatedXP::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetExperienceForLevel
// 0x0008 (0x0008 - 0x0000)
struct VendorActor_GetExperienceForLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetExperienceForLevel) == 0x000004, "Wrong alignment on VendorActor_GetExperienceForLevel");
static_assert(sizeof(VendorActor_GetExperienceForLevel) == 0x000008, "Wrong size on VendorActor_GetExperienceForLevel");
static_assert(offsetof(VendorActor_GetExperienceForLevel, Level) == 0x000000, "Member 'VendorActor_GetExperienceForLevel::Level' has a wrong offset!");
static_assert(offsetof(VendorActor_GetExperienceForLevel, ReturnValue) == 0x000004, "Member 'VendorActor_GetExperienceForLevel::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetExperienceForNextLevel
// 0x0004 (0x0004 - 0x0000)
struct VendorActor_GetExperienceForNextLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetExperienceForNextLevel) == 0x000004, "Wrong alignment on VendorActor_GetExperienceForNextLevel");
static_assert(sizeof(VendorActor_GetExperienceForNextLevel) == 0x000004, "Wrong size on VendorActor_GetExperienceForNextLevel");
static_assert(offsetof(VendorActor_GetExperienceForNextLevel, ReturnValue) == 0x000000, "Member 'VendorActor_GetExperienceForNextLevel::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetHerbGarden
// 0x0008 (0x0008 - 0x0000)
struct VendorActor_GetHerbGarden final
{
public:
	class UVendorHerbGarden*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetHerbGarden) == 0x000008, "Wrong alignment on VendorActor_GetHerbGarden");
static_assert(sizeof(VendorActor_GetHerbGarden) == 0x000008, "Wrong size on VendorActor_GetHerbGarden");
static_assert(offsetof(VendorActor_GetHerbGarden, ReturnValue) == 0x000000, "Member 'VendorActor_GetHerbGarden::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetItemEnchantments
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetItemEnchantments final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetItemEnchantments) == 0x000008, "Wrong alignment on VendorActor_GetItemEnchantments");
static_assert(sizeof(VendorActor_GetItemEnchantments) == 0x000010, "Wrong size on VendorActor_GetItemEnchantments");
static_assert(offsetof(VendorActor_GetItemEnchantments, ReturnValue) == 0x000000, "Member 'VendorActor_GetItemEnchantments::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetItemPrice
// 0x0020 (0x0020 - 0x0000)
struct VendorActor_GetItemPrice final
{
public:
	class UManItemSlotBase*                       ItemSlot;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVendorActionQueryMode                        QueryMode;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVendorPriceData>               ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetItemPrice) == 0x000008, "Wrong alignment on VendorActor_GetItemPrice");
static_assert(sizeof(VendorActor_GetItemPrice) == 0x000020, "Wrong size on VendorActor_GetItemPrice");
static_assert(offsetof(VendorActor_GetItemPrice, ItemSlot) == 0x000000, "Member 'VendorActor_GetItemPrice::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorActor_GetItemPrice, QueryMode) == 0x000008, "Member 'VendorActor_GetItemPrice::QueryMode' has a wrong offset!");
static_assert(offsetof(VendorActor_GetItemPrice, amount) == 0x00000C, "Member 'VendorActor_GetItemPrice::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_GetItemPrice, ReturnValue) == 0x000010, "Member 'VendorActor_GetItemPrice::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetLearnableDiagrams
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetLearnableDiagrams final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetLearnableDiagrams) == 0x000008, "Wrong alignment on VendorActor_GetLearnableDiagrams");
static_assert(sizeof(VendorActor_GetLearnableDiagrams) == 0x000010, "Wrong size on VendorActor_GetLearnableDiagrams");
static_assert(offsetof(VendorActor_GetLearnableDiagrams, ReturnValue) == 0x000000, "Member 'VendorActor_GetLearnableDiagrams::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetLearnableMapFragments
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetLearnableMapFragments final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetLearnableMapFragments) == 0x000008, "Wrong alignment on VendorActor_GetLearnableMapFragments");
static_assert(sizeof(VendorActor_GetLearnableMapFragments) == 0x000010, "Wrong size on VendorActor_GetLearnableMapFragments");
static_assert(offsetof(VendorActor_GetLearnableMapFragments, ReturnValue) == 0x000000, "Member 'VendorActor_GetLearnableMapFragments::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetModifiedCraftingCost
// 0x0038 (0x0038 - 0x0000)
struct VendorActor_GetModifiedCraftingCost final
{
public:
	struct FCraftRecipe                           Recipe;                                            // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetModifiedCraftingCost) == 0x000008, "Wrong alignment on VendorActor_GetModifiedCraftingCost");
static_assert(sizeof(VendorActor_GetModifiedCraftingCost) == 0x000038, "Wrong size on VendorActor_GetModifiedCraftingCost");
static_assert(offsetof(VendorActor_GetModifiedCraftingCost, Recipe) == 0x000000, "Member 'VendorActor_GetModifiedCraftingCost::Recipe' has a wrong offset!");
static_assert(offsetof(VendorActor_GetModifiedCraftingCost, amount) == 0x000030, "Member 'VendorActor_GetModifiedCraftingCost::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_GetModifiedCraftingCost, ReturnValue) == 0x000034, "Member 'VendorActor_GetModifiedCraftingCost::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetSoldPlayerItems
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetSoldPlayerItems final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetSoldPlayerItems) == 0x000008, "Wrong alignment on VendorActor_GetSoldPlayerItems");
static_assert(sizeof(VendorActor_GetSoldPlayerItems) == 0x000010, "Wrong size on VendorActor_GetSoldPlayerItems");
static_assert(offsetof(VendorActor_GetSoldPlayerItems, ReturnValue) == 0x000000, "Member 'VendorActor_GetSoldPlayerItems::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetVendorCraftableItems
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetVendorCraftableItems final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetVendorCraftableItems) == 0x000008, "Wrong alignment on VendorActor_GetVendorCraftableItems");
static_assert(sizeof(VendorActor_GetVendorCraftableItems) == 0x000010, "Wrong size on VendorActor_GetVendorCraftableItems");
static_assert(offsetof(VendorActor_GetVendorCraftableItems, ReturnValue) == 0x000000, "Member 'VendorActor_GetVendorCraftableItems::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetVendorLevel
// 0x0004 (0x0004 - 0x0000)
struct VendorActor_GetVendorLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetVendorLevel) == 0x000004, "Wrong alignment on VendorActor_GetVendorLevel");
static_assert(sizeof(VendorActor_GetVendorLevel) == 0x000004, "Wrong size on VendorActor_GetVendorLevel");
static_assert(offsetof(VendorActor_GetVendorLevel, ReturnValue) == 0x000000, "Member 'VendorActor_GetVendorLevel::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetVendorTypeText
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_GetVendorTypeText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetVendorTypeText) == 0x000008, "Wrong alignment on VendorActor_GetVendorTypeText");
static_assert(sizeof(VendorActor_GetVendorTypeText) == 0x000018, "Wrong size on VendorActor_GetVendorTypeText");
static_assert(offsetof(VendorActor_GetVendorTypeText, ReturnValue) == 0x000000, "Member 'VendorActor_GetVendorTypeText::ReturnValue' has a wrong offset!");

// Function man.VendorActor.GetVendorWares
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_GetVendorWares final
{
public:
	TArray<class UManItemSlotBase*>               ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_GetVendorWares) == 0x000008, "Wrong alignment on VendorActor_GetVendorWares");
static_assert(sizeof(VendorActor_GetVendorWares) == 0x000010, "Wrong size on VendorActor_GetVendorWares");
static_assert(offsetof(VendorActor_GetVendorWares, ReturnValue) == 0x000000, "Member 'VendorActor_GetVendorWares::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsDiagramLearnable
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_IsDiagramLearnable final
{
public:
	class UDiagramItemAbility*                    Diagram;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsDiagramLearnable) == 0x000008, "Wrong alignment on VendorActor_IsDiagramLearnable");
static_assert(sizeof(VendorActor_IsDiagramLearnable) == 0x000010, "Wrong size on VendorActor_IsDiagramLearnable");
static_assert(offsetof(VendorActor_IsDiagramLearnable, Diagram) == 0x000000, "Member 'VendorActor_IsDiagramLearnable::Diagram' has a wrong offset!");
static_assert(offsetof(VendorActor_IsDiagramLearnable, ReturnValue) == 0x000008, "Member 'VendorActor_IsDiagramLearnable::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsIEnchantOnItem
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_IsIEnchantOnItem final
{
public:
	TSubclassOf<class UItemEnchantItemAbility>    EnchantType;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ItemSlot;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsIEnchantOnItem) == 0x000008, "Wrong alignment on VendorActor_IsIEnchantOnItem");
static_assert(sizeof(VendorActor_IsIEnchantOnItem) == 0x000018, "Wrong size on VendorActor_IsIEnchantOnItem");
static_assert(offsetof(VendorActor_IsIEnchantOnItem, EnchantType) == 0x000000, "Member 'VendorActor_IsIEnchantOnItem::EnchantType' has a wrong offset!");
static_assert(offsetof(VendorActor_IsIEnchantOnItem, ItemSlot) == 0x000008, "Member 'VendorActor_IsIEnchantOnItem::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorActor_IsIEnchantOnItem, ReturnValue) == 0x000010, "Member 'VendorActor_IsIEnchantOnItem::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsInCaravan
// 0x0001 (0x0001 - 0x0000)
struct VendorActor_IsInCaravan final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_IsInCaravan) == 0x000001, "Wrong alignment on VendorActor_IsInCaravan");
static_assert(sizeof(VendorActor_IsInCaravan) == 0x000001, "Wrong size on VendorActor_IsInCaravan");
static_assert(offsetof(VendorActor_IsInCaravan, ReturnValue) == 0x000000, "Member 'VendorActor_IsInCaravan::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsInvalidEnchantTarget
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_IsInvalidEnchantTarget final
{
public:
	class UManItemSlotBase*                       ItemToEnchant;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       EnchantItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsInvalidEnchantTarget) == 0x000008, "Wrong alignment on VendorActor_IsInvalidEnchantTarget");
static_assert(sizeof(VendorActor_IsInvalidEnchantTarget) == 0x000018, "Wrong size on VendorActor_IsInvalidEnchantTarget");
static_assert(offsetof(VendorActor_IsInvalidEnchantTarget, ItemToEnchant) == 0x000000, "Member 'VendorActor_IsInvalidEnchantTarget::ItemToEnchant' has a wrong offset!");
static_assert(offsetof(VendorActor_IsInvalidEnchantTarget, EnchantItem) == 0x000008, "Member 'VendorActor_IsInvalidEnchantTarget::EnchantItem' has a wrong offset!");
static_assert(offsetof(VendorActor_IsInvalidEnchantTarget, ReturnValue) == 0x000010, "Member 'VendorActor_IsInvalidEnchantTarget::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsItemCraftable
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_IsItemCraftable final
{
public:
	class UVendorItemSlot*                        CraftItem;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsItemCraftable) == 0x000008, "Wrong alignment on VendorActor_IsItemCraftable");
static_assert(sizeof(VendorActor_IsItemCraftable) == 0x000010, "Wrong size on VendorActor_IsItemCraftable");
static_assert(offsetof(VendorActor_IsItemCraftable, CraftItem) == 0x000000, "Member 'VendorActor_IsItemCraftable::CraftItem' has a wrong offset!");
static_assert(offsetof(VendorActor_IsItemCraftable, amount) == 0x000008, "Member 'VendorActor_IsItemCraftable::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_IsItemCraftable, ReturnValue) == 0x00000C, "Member 'VendorActor_IsItemCraftable::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsItemEnchantable
// 0x0018 (0x0018 - 0x0000)
struct VendorActor_IsItemEnchantable final
{
public:
	class UManItemSlotBase*                       ItemToEnchant;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       EnchantItem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsItemEnchantable) == 0x000008, "Wrong alignment on VendorActor_IsItemEnchantable");
static_assert(sizeof(VendorActor_IsItemEnchantable) == 0x000018, "Wrong size on VendorActor_IsItemEnchantable");
static_assert(offsetof(VendorActor_IsItemEnchantable, ItemToEnchant) == 0x000000, "Member 'VendorActor_IsItemEnchantable::ItemToEnchant' has a wrong offset!");
static_assert(offsetof(VendorActor_IsItemEnchantable, EnchantItem) == 0x000008, "Member 'VendorActor_IsItemEnchantable::EnchantItem' has a wrong offset!");
static_assert(offsetof(VendorActor_IsItemEnchantable, ReturnValue) == 0x000010, "Member 'VendorActor_IsItemEnchantable::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsItemEnchanted
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_IsItemEnchanted final
{
public:
	class UManItemSlotBase*                       ItemSlot;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_IsItemEnchanted) == 0x000008, "Wrong alignment on VendorActor_IsItemEnchanted");
static_assert(sizeof(VendorActor_IsItemEnchanted) == 0x000010, "Wrong size on VendorActor_IsItemEnchanted");
static_assert(offsetof(VendorActor_IsItemEnchanted, ItemSlot) == 0x000000, "Member 'VendorActor_IsItemEnchanted::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorActor_IsItemEnchanted, ReturnValue) == 0x000008, "Member 'VendorActor_IsItemEnchanted::ReturnValue' has a wrong offset!");

// Function man.VendorActor.IsMaxLevel
// 0x0001 (0x0001 - 0x0000)
struct VendorActor_IsMaxLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_IsMaxLevel) == 0x000001, "Wrong alignment on VendorActor_IsMaxLevel");
static_assert(sizeof(VendorActor_IsMaxLevel) == 0x000001, "Wrong size on VendorActor_IsMaxLevel");
static_assert(offsetof(VendorActor_IsMaxLevel, ReturnValue) == 0x000000, "Member 'VendorActor_IsMaxLevel::ReturnValue' has a wrong offset!");

// Function man.VendorActor.LearnDiagram
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_LearnDiagram final
{
public:
	class UDiagramItemAbility*                    Diagram;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGainXPForLearning;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeDiagram;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_LearnDiagram) == 0x000008, "Wrong alignment on VendorActor_LearnDiagram");
static_assert(sizeof(VendorActor_LearnDiagram) == 0x000010, "Wrong size on VendorActor_LearnDiagram");
static_assert(offsetof(VendorActor_LearnDiagram, Diagram) == 0x000000, "Member 'VendorActor_LearnDiagram::Diagram' has a wrong offset!");
static_assert(offsetof(VendorActor_LearnDiagram, bGainXPForLearning) == 0x000008, "Member 'VendorActor_LearnDiagram::bGainXPForLearning' has a wrong offset!");
static_assert(offsetof(VendorActor_LearnDiagram, bInitializeDiagram) == 0x000009, "Member 'VendorActor_LearnDiagram::bInitializeDiagram' has a wrong offset!");

// Function man.VendorActor.LearnMapFragment
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_LearnMapFragment final
{
public:
	class UMapFragmentItemAbility*                MapFragmentItem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGainXPForLearning;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_LearnMapFragment) == 0x000008, "Wrong alignment on VendorActor_LearnMapFragment");
static_assert(sizeof(VendorActor_LearnMapFragment) == 0x000010, "Wrong size on VendorActor_LearnMapFragment");
static_assert(offsetof(VendorActor_LearnMapFragment, MapFragmentItem) == 0x000000, "Member 'VendorActor_LearnMapFragment::MapFragmentItem' has a wrong offset!");
static_assert(offsetof(VendorActor_LearnMapFragment, bGainXPForLearning) == 0x000008, "Member 'VendorActor_LearnMapFragment::bGainXPForLearning' has a wrong offset!");

// Function man.VendorActor.SellItemToVendor
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_SellItemToVendor final
{
public:
	class UInventorySlot*                         ItemSlot;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_SellItemToVendor) == 0x000008, "Wrong alignment on VendorActor_SellItemToVendor");
static_assert(sizeof(VendorActor_SellItemToVendor) == 0x000010, "Wrong size on VendorActor_SellItemToVendor");
static_assert(offsetof(VendorActor_SellItemToVendor, ItemSlot) == 0x000000, "Member 'VendorActor_SellItemToVendor::ItemSlot' has a wrong offset!");
static_assert(offsetof(VendorActor_SellItemToVendor, amount) == 0x000008, "Member 'VendorActor_SellItemToVendor::amount' has a wrong offset!");

// Function man.VendorActor.SlotQuery
// 0x0028 (0x0028 - 0x0000)
struct VendorActor_SlotQuery final
{
public:
	class UManItemSlotBase*                       SlotToQuery;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVendorActionQueryMode                        QueryMode;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         amount;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ItemToEnchant;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EVendorActionQuery>                    ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorActor_SlotQuery) == 0x000008, "Wrong alignment on VendorActor_SlotQuery");
static_assert(sizeof(VendorActor_SlotQuery) == 0x000028, "Wrong size on VendorActor_SlotQuery");
static_assert(offsetof(VendorActor_SlotQuery, SlotToQuery) == 0x000000, "Member 'VendorActor_SlotQuery::SlotToQuery' has a wrong offset!");
static_assert(offsetof(VendorActor_SlotQuery, QueryMode) == 0x000008, "Member 'VendorActor_SlotQuery::QueryMode' has a wrong offset!");
static_assert(offsetof(VendorActor_SlotQuery, amount) == 0x00000C, "Member 'VendorActor_SlotQuery::amount' has a wrong offset!");
static_assert(offsetof(VendorActor_SlotQuery, ItemToEnchant) == 0x000010, "Member 'VendorActor_SlotQuery::ItemToEnchant' has a wrong offset!");
static_assert(offsetof(VendorActor_SlotQuery, ReturnValue) == 0x000018, "Member 'VendorActor_SlotQuery::ReturnValue' has a wrong offset!");

// Function man.VendorActor.TransmogrifyItem
// 0x0010 (0x0010 - 0x0000)
struct VendorActor_TransmogrifyItem final
{
public:
	class UItemAbility*                           ItemAbility;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     ItemSlotType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorActor_TransmogrifyItem) == 0x000008, "Wrong alignment on VendorActor_TransmogrifyItem");
static_assert(sizeof(VendorActor_TransmogrifyItem) == 0x000010, "Wrong size on VendorActor_TransmogrifyItem");
static_assert(offsetof(VendorActor_TransmogrifyItem, ItemAbility) == 0x000000, "Member 'VendorActor_TransmogrifyItem::ItemAbility' has a wrong offset!");
static_assert(offsetof(VendorActor_TransmogrifyItem, ItemSlotType) == 0x000008, "Member 'VendorActor_TransmogrifyItem::ItemSlotType' has a wrong offset!");
static_assert(offsetof(VendorActor_TransmogrifyItem, ReturnValue) == 0x000009, "Member 'VendorActor_TransmogrifyItem::ReturnValue' has a wrong offset!");

// Function man.VendorManager.GetVendorData
// 0x0010 (0x0010 - 0x0000)
struct VendorManager_GetVendorData final
{
public:
	TSubclassOf<class AVendorActor>               VendorClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVendorStateData*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorManager_GetVendorData) == 0x000008, "Wrong alignment on VendorManager_GetVendorData");
static_assert(sizeof(VendorManager_GetVendorData) == 0x000010, "Wrong size on VendorManager_GetVendorData");
static_assert(offsetof(VendorManager_GetVendorData, VendorClass) == 0x000000, "Member 'VendorManager_GetVendorData::VendorClass' has a wrong offset!");
static_assert(offsetof(VendorManager_GetVendorData, ReturnValue) == 0x000008, "Member 'VendorManager_GetVendorData::ReturnValue' has a wrong offset!");

// Function man.VendorBuyUserWidget.OnBuyItem
// 0x0008 (0x0008 - 0x0000)
struct VendorBuyUserWidget_OnBuyItem final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorBuyUserWidget_OnBuyItem) == 0x000008, "Wrong alignment on VendorBuyUserWidget_OnBuyItem");
static_assert(sizeof(VendorBuyUserWidget_OnBuyItem) == 0x000008, "Wrong size on VendorBuyUserWidget_OnBuyItem");
static_assert(offsetof(VendorBuyUserWidget_OnBuyItem, Icon) == 0x000000, "Member 'VendorBuyUserWidget_OnBuyItem::Icon' has a wrong offset!");

// Function man.VendorBuyUserWidget.OnFocusWidgetChangedEvent
// 0x0010 (0x0010 - 0x0000)
struct VendorBuyUserWidget_OnFocusWidgetChangedEvent final
{
public:
	class UWidget*                                OldFocusedWidget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                NewFocusedWidget;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorBuyUserWidget_OnFocusWidgetChangedEvent) == 0x000008, "Wrong alignment on VendorBuyUserWidget_OnFocusWidgetChangedEvent");
static_assert(sizeof(VendorBuyUserWidget_OnFocusWidgetChangedEvent) == 0x000010, "Wrong size on VendorBuyUserWidget_OnFocusWidgetChangedEvent");
static_assert(offsetof(VendorBuyUserWidget_OnFocusWidgetChangedEvent, OldFocusedWidget) == 0x000000, "Member 'VendorBuyUserWidget_OnFocusWidgetChangedEvent::OldFocusedWidget' has a wrong offset!");
static_assert(offsetof(VendorBuyUserWidget_OnFocusWidgetChangedEvent, NewFocusedWidget) == 0x000008, "Member 'VendorBuyUserWidget_OnFocusWidgetChangedEvent::NewFocusedWidget' has a wrong offset!");

// Function man.VendorBuyUserWidget.IsItemBtnsVisible
// 0x0001 (0x0001 - 0x0000)
struct VendorBuyUserWidget_IsItemBtnsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorBuyUserWidget_IsItemBtnsVisible) == 0x000001, "Wrong alignment on VendorBuyUserWidget_IsItemBtnsVisible");
static_assert(sizeof(VendorBuyUserWidget_IsItemBtnsVisible) == 0x000001, "Wrong size on VendorBuyUserWidget_IsItemBtnsVisible");
static_assert(offsetof(VendorBuyUserWidget_IsItemBtnsVisible, ReturnValue) == 0x000000, "Member 'VendorBuyUserWidget_IsItemBtnsVisible::ReturnValue' has a wrong offset!");

// Function man.VendorConfirmationUserWidget.Init
// 0x0020 (0x0020 - 0x0000)
struct VendorConfirmationUserWidget_Init final
{
public:
	class UManItemSlotBase*                       InManItemSlotBase;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           InItemAbility;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInBuyMode;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeroProperty                                 InPropertyType;                                    // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InSelectedCount;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InAllCount;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPricePerItem;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorConfirmationUserWidget_Init) == 0x000008, "Wrong alignment on VendorConfirmationUserWidget_Init");
static_assert(sizeof(VendorConfirmationUserWidget_Init) == 0x000020, "Wrong size on VendorConfirmationUserWidget_Init");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InManItemSlotBase) == 0x000000, "Member 'VendorConfirmationUserWidget_Init::InManItemSlotBase' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InItemAbility) == 0x000008, "Member 'VendorConfirmationUserWidget_Init::InItemAbility' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, bInBuyMode) == 0x000010, "Member 'VendorConfirmationUserWidget_Init::bInBuyMode' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InPropertyType) == 0x000011, "Member 'VendorConfirmationUserWidget_Init::InPropertyType' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InSelectedCount) == 0x000014, "Member 'VendorConfirmationUserWidget_Init::InSelectedCount' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InAllCount) == 0x000018, "Member 'VendorConfirmationUserWidget_Init::InAllCount' has a wrong offset!");
static_assert(offsetof(VendorConfirmationUserWidget_Init, InPricePerItem) == 0x00001C, "Member 'VendorConfirmationUserWidget_Init::InPricePerItem' has a wrong offset!");

// Function man.VendorConfirmationUserWidget.OnSetSelectedCount
// 0x0004 (0x0004 - 0x0000)
struct VendorConfirmationUserWidget_OnSetSelectedCount final
{
public:
	int32                                         InSelectedCount;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorConfirmationUserWidget_OnSetSelectedCount) == 0x000004, "Wrong alignment on VendorConfirmationUserWidget_OnSetSelectedCount");
static_assert(sizeof(VendorConfirmationUserWidget_OnSetSelectedCount) == 0x000004, "Wrong size on VendorConfirmationUserWidget_OnSetSelectedCount");
static_assert(offsetof(VendorConfirmationUserWidget_OnSetSelectedCount, InSelectedCount) == 0x000000, "Member 'VendorConfirmationUserWidget_OnSetSelectedCount::InSelectedCount' has a wrong offset!");

// Function man.VendorConfirmationUserWidget.SetSelectedCount
// 0x0004 (0x0004 - 0x0000)
struct VendorConfirmationUserWidget_SetSelectedCount final
{
public:
	int32                                         InSelectedCount;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorConfirmationUserWidget_SetSelectedCount) == 0x000004, "Wrong alignment on VendorConfirmationUserWidget_SetSelectedCount");
static_assert(sizeof(VendorConfirmationUserWidget_SetSelectedCount) == 0x000004, "Wrong size on VendorConfirmationUserWidget_SetSelectedCount");
static_assert(offsetof(VendorConfirmationUserWidget_SetSelectedCount, InSelectedCount) == 0x000000, "Member 'VendorConfirmationUserWidget_SetSelectedCount::InSelectedCount' has a wrong offset!");

// Function man.VendorCraftSlotUserWidget.OnSetItemRequirements
// 0x0018 (0x0018 - 0x0000)
struct VendorCraftSlotUserWidget_OnSetItemRequirements final
{
public:
	class FText                                   InItemRequirements;                                // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftSlotUserWidget_OnSetItemRequirements) == 0x000008, "Wrong alignment on VendorCraftSlotUserWidget_OnSetItemRequirements");
static_assert(sizeof(VendorCraftSlotUserWidget_OnSetItemRequirements) == 0x000018, "Wrong size on VendorCraftSlotUserWidget_OnSetItemRequirements");
static_assert(offsetof(VendorCraftSlotUserWidget_OnSetItemRequirements, InItemRequirements) == 0x000000, "Member 'VendorCraftSlotUserWidget_OnSetItemRequirements::InItemRequirements' has a wrong offset!");

// Function man.VendorCraftSlotUserWidget.OnSetItemType
// 0x0018 (0x0018 - 0x0000)
struct VendorCraftSlotUserWidget_OnSetItemType final
{
public:
	class FText                                   InItemType;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorCraftSlotUserWidget_OnSetItemType) == 0x000008, "Wrong alignment on VendorCraftSlotUserWidget_OnSetItemType");
static_assert(sizeof(VendorCraftSlotUserWidget_OnSetItemType) == 0x000018, "Wrong size on VendorCraftSlotUserWidget_OnSetItemType");
static_assert(offsetof(VendorCraftSlotUserWidget_OnSetItemType, InItemType) == 0x000000, "Member 'VendorCraftSlotUserWidget_OnSetItemType::InItemType' has a wrong offset!");

// Function man.VendorCraftSlotUserWidget.OnSetMaxCraftableNum
// 0x0020 (0x0020 - 0x0000)
struct VendorCraftSlotUserWidget_OnSetMaxCraftableNum final
{
public:
	class FText                                   InMaxCraftableNum;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInIsUnavailable;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorCraftSlotUserWidget_OnSetMaxCraftableNum) == 0x000008, "Wrong alignment on VendorCraftSlotUserWidget_OnSetMaxCraftableNum");
static_assert(sizeof(VendorCraftSlotUserWidget_OnSetMaxCraftableNum) == 0x000020, "Wrong size on VendorCraftSlotUserWidget_OnSetMaxCraftableNum");
static_assert(offsetof(VendorCraftSlotUserWidget_OnSetMaxCraftableNum, InMaxCraftableNum) == 0x000000, "Member 'VendorCraftSlotUserWidget_OnSetMaxCraftableNum::InMaxCraftableNum' has a wrong offset!");
static_assert(offsetof(VendorCraftSlotUserWidget_OnSetMaxCraftableNum, bInIsUnavailable) == 0x000018, "Member 'VendorCraftSlotUserWidget_OnSetMaxCraftableNum::bInIsUnavailable' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.OnSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct VendorFilterSlotUserWidget_OnSetEnabled final
{
public:
	bool                                          bInEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong alignment on VendorFilterSlotUserWidget_OnSetEnabled");
static_assert(sizeof(VendorFilterSlotUserWidget_OnSetEnabled) == 0x000001, "Wrong size on VendorFilterSlotUserWidget_OnSetEnabled");
static_assert(offsetof(VendorFilterSlotUserWidget_OnSetEnabled, bInEnabled) == 0x000000, "Member 'VendorFilterSlotUserWidget_OnSetEnabled::bInEnabled' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.OnSetItemIcon
// 0x0008 (0x0008 - 0x0000)
struct VendorFilterSlotUserWidget_OnSetItemIcon final
{
public:
	class UTexture2D*                             ItemIcon;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong alignment on VendorFilterSlotUserWidget_OnSetItemIcon");
static_assert(sizeof(VendorFilterSlotUserWidget_OnSetItemIcon) == 0x000008, "Wrong size on VendorFilterSlotUserWidget_OnSetItemIcon");
static_assert(offsetof(VendorFilterSlotUserWidget_OnSetItemIcon, ItemIcon) == 0x000000, "Member 'VendorFilterSlotUserWidget_OnSetItemIcon::ItemIcon' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.OnSetSelected
// 0x0001 (0x0001 - 0x0000)
struct VendorFilterSlotUserWidget_OnSetSelected final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong alignment on VendorFilterSlotUserWidget_OnSetSelected");
static_assert(sizeof(VendorFilterSlotUserWidget_OnSetSelected) == 0x000001, "Wrong size on VendorFilterSlotUserWidget_OnSetSelected");
static_assert(offsetof(VendorFilterSlotUserWidget_OnSetSelected, bInSelected) == 0x000000, "Member 'VendorFilterSlotUserWidget_OnSetSelected::bInSelected' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.OnSetVisible
// 0x0001 (0x0001 - 0x0000)
struct VendorFilterSlotUserWidget_OnSetVisible final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong alignment on VendorFilterSlotUserWidget_OnSetVisible");
static_assert(sizeof(VendorFilterSlotUserWidget_OnSetVisible) == 0x000001, "Wrong size on VendorFilterSlotUserWidget_OnSetVisible");
static_assert(offsetof(VendorFilterSlotUserWidget_OnSetVisible, bInVisible) == 0x000000, "Member 'VendorFilterSlotUserWidget_OnSetVisible::bInVisible' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.OnToggleNewItemWarning
// 0x0001 (0x0001 - 0x0000)
struct VendorFilterSlotUserWidget_OnToggleNewItemWarning final
{
public:
	bool                                          bInVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong alignment on VendorFilterSlotUserWidget_OnToggleNewItemWarning");
static_assert(sizeof(VendorFilterSlotUserWidget_OnToggleNewItemWarning) == 0x000001, "Wrong size on VendorFilterSlotUserWidget_OnToggleNewItemWarning");
static_assert(offsetof(VendorFilterSlotUserWidget_OnToggleNewItemWarning, bInVisible) == 0x000000, "Member 'VendorFilterSlotUserWidget_OnToggleNewItemWarning::bInVisible' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.GetSlotName
// 0x0018 (0x0018 - 0x0000)
struct VendorFilterSlotUserWidget_GetSlotName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_GetSlotName) == 0x000008, "Wrong alignment on VendorFilterSlotUserWidget_GetSlotName");
static_assert(sizeof(VendorFilterSlotUserWidget_GetSlotName) == 0x000018, "Wrong size on VendorFilterSlotUserWidget_GetSlotName");
static_assert(offsetof(VendorFilterSlotUserWidget_GetSlotName, ReturnValue) == 0x000000, "Member 'VendorFilterSlotUserWidget_GetSlotName::ReturnValue' has a wrong offset!");

// Function man.VendorFilterSlotUserWidget.IsFilterEnabled
// 0x0001 (0x0001 - 0x0000)
struct VendorFilterSlotUserWidget_IsFilterEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong alignment on VendorFilterSlotUserWidget_IsFilterEnabled");
static_assert(sizeof(VendorFilterSlotUserWidget_IsFilterEnabled) == 0x000001, "Wrong size on VendorFilterSlotUserWidget_IsFilterEnabled");
static_assert(offsetof(VendorFilterSlotUserWidget_IsFilterEnabled, ReturnValue) == 0x000000, "Member 'VendorFilterSlotUserWidget_IsFilterEnabled::ReturnValue' has a wrong offset!");

// Function man.VendorMapFragmentLabelUserWidget.OnUnlock
// 0x0001 (0x0001 - 0x0000)
struct VendorMapFragmentLabelUserWidget_OnUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentLabelUserWidget_OnUnlock) == 0x000001, "Wrong alignment on VendorMapFragmentLabelUserWidget_OnUnlock");
static_assert(sizeof(VendorMapFragmentLabelUserWidget_OnUnlock) == 0x000001, "Wrong size on VendorMapFragmentLabelUserWidget_OnUnlock");
static_assert(offsetof(VendorMapFragmentLabelUserWidget_OnUnlock, bAnimate) == 0x000000, "Member 'VendorMapFragmentLabelUserWidget_OnUnlock::bAnimate' has a wrong offset!");

// Function man.VendorMapFragmentSlotUserWidget.GetTexture
// 0x0008 (0x0008 - 0x0000)
struct VendorMapFragmentSlotUserWidget_GetTexture final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentSlotUserWidget_GetTexture) == 0x000008, "Wrong alignment on VendorMapFragmentSlotUserWidget_GetTexture");
static_assert(sizeof(VendorMapFragmentSlotUserWidget_GetTexture) == 0x000008, "Wrong size on VendorMapFragmentSlotUserWidget_GetTexture");
static_assert(offsetof(VendorMapFragmentSlotUserWidget_GetTexture, ReturnValue) == 0x000000, "Member 'VendorMapFragmentSlotUserWidget_GetTexture::ReturnValue' has a wrong offset!");

// Function man.VendorMapFragmentSlotUserWidget.OnSetTexture
// 0x0001 (0x0001 - 0x0000)
struct VendorMapFragmentSlotUserWidget_OnSetTexture final
{
public:
	bool                                          bSet;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentSlotUserWidget_OnSetTexture) == 0x000001, "Wrong alignment on VendorMapFragmentSlotUserWidget_OnSetTexture");
static_assert(sizeof(VendorMapFragmentSlotUserWidget_OnSetTexture) == 0x000001, "Wrong size on VendorMapFragmentSlotUserWidget_OnSetTexture");
static_assert(offsetof(VendorMapFragmentSlotUserWidget_OnSetTexture, bSet) == 0x000000, "Member 'VendorMapFragmentSlotUserWidget_OnSetTexture::bSet' has a wrong offset!");

// Function man.VendorMapFragmentSlotUserWidget.OnUnlock
// 0x0001 (0x0001 - 0x0000)
struct VendorMapFragmentSlotUserWidget_OnUnlock final
{
public:
	bool                                          bAnimate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentSlotUserWidget_OnUnlock) == 0x000001, "Wrong alignment on VendorMapFragmentSlotUserWidget_OnUnlock");
static_assert(sizeof(VendorMapFragmentSlotUserWidget_OnUnlock) == 0x000001, "Wrong size on VendorMapFragmentSlotUserWidget_OnUnlock");
static_assert(offsetof(VendorMapFragmentSlotUserWidget_OnUnlock, bAnimate) == 0x000000, "Member 'VendorMapFragmentSlotUserWidget_OnUnlock::bAnimate' has a wrong offset!");

// Function man.VendorMapFragmentUserWidget.GetVendorLevelByMapFragments
// 0x0004 (0x0004 - 0x0000)
struct VendorMapFragmentUserWidget_GetVendorLevelByMapFragments final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentUserWidget_GetVendorLevelByMapFragments) == 0x000004, "Wrong alignment on VendorMapFragmentUserWidget_GetVendorLevelByMapFragments");
static_assert(sizeof(VendorMapFragmentUserWidget_GetVendorLevelByMapFragments) == 0x000004, "Wrong size on VendorMapFragmentUserWidget_GetVendorLevelByMapFragments");
static_assert(offsetof(VendorMapFragmentUserWidget_GetVendorLevelByMapFragments, ReturnValue) == 0x000000, "Member 'VendorMapFragmentUserWidget_GetVendorLevelByMapFragments::ReturnValue' has a wrong offset!");

// Function man.VendorMapFragmentUserWidget.OnLearnMapFragment
// 0x0001 (0x0001 - 0x0000)
struct VendorMapFragmentUserWidget_OnLearnMapFragment final
{
public:
	bool                                          LevelUp;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentUserWidget_OnLearnMapFragment) == 0x000001, "Wrong alignment on VendorMapFragmentUserWidget_OnLearnMapFragment");
static_assert(sizeof(VendorMapFragmentUserWidget_OnLearnMapFragment) == 0x000001, "Wrong size on VendorMapFragmentUserWidget_OnLearnMapFragment");
static_assert(offsetof(VendorMapFragmentUserWidget_OnLearnMapFragment, LevelUp) == 0x000000, "Member 'VendorMapFragmentUserWidget_OnLearnMapFragment::LevelUp' has a wrong offset!");

// Function man.VendorMapFragmentUserWidget.OnMiniMapSegmentUnlocked
// 0x0008 (0x0008 - 0x0000)
struct VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked final
{
public:
	class UMapSegmentVolumeID*                    SegmentID;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked) == 0x000008, "Wrong alignment on VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked");
static_assert(sizeof(VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked) == 0x000008, "Wrong size on VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked");
static_assert(offsetof(VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked, SegmentID) == 0x000000, "Member 'VendorMapFragmentUserWidget_OnMiniMapSegmentUnlocked::SegmentID' has a wrong offset!");

// Function man.VendorMapFragmentUserWidget.OnSetMapFragmentParams
// 0x0038 (0x0038 - 0x0000)
struct VendorMapFragmentUserWidget_OnSetMapFragmentParams final
{
public:
	class FText                                   MapFragmentsNum;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   MapFragmentsXpText;                                // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MapFragmentsXpValue;                               // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapFragmentsAvailable;                            // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorMapFragmentUserWidget_OnSetMapFragmentParams) == 0x000008, "Wrong alignment on VendorMapFragmentUserWidget_OnSetMapFragmentParams");
static_assert(sizeof(VendorMapFragmentUserWidget_OnSetMapFragmentParams) == 0x000038, "Wrong size on VendorMapFragmentUserWidget_OnSetMapFragmentParams");
static_assert(offsetof(VendorMapFragmentUserWidget_OnSetMapFragmentParams, MapFragmentsNum) == 0x000000, "Member 'VendorMapFragmentUserWidget_OnSetMapFragmentParams::MapFragmentsNum' has a wrong offset!");
static_assert(offsetof(VendorMapFragmentUserWidget_OnSetMapFragmentParams, MapFragmentsXpText) == 0x000018, "Member 'VendorMapFragmentUserWidget_OnSetMapFragmentParams::MapFragmentsXpText' has a wrong offset!");
static_assert(offsetof(VendorMapFragmentUserWidget_OnSetMapFragmentParams, MapFragmentsXpValue) == 0x000030, "Member 'VendorMapFragmentUserWidget_OnSetMapFragmentParams::MapFragmentsXpValue' has a wrong offset!");
static_assert(offsetof(VendorMapFragmentUserWidget_OnSetMapFragmentParams, bMapFragmentsAvailable) == 0x000034, "Member 'VendorMapFragmentUserWidget_OnSetMapFragmentParams::bMapFragmentsAvailable' has a wrong offset!");

// Function man.VendorTransmogRowUserWidget.OnSetData
// 0x0030 (0x0030 - 0x0000)
struct VendorTransmogRowUserWidget_OnSetData final
{
public:
	class UTexture2D*                             InEquippedItemIcon;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             InTransmogItemIcon;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InTransmogItemName;                                // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInUnavailable;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorTransmogRowUserWidget_OnSetData) == 0x000008, "Wrong alignment on VendorTransmogRowUserWidget_OnSetData");
static_assert(sizeof(VendorTransmogRowUserWidget_OnSetData) == 0x000030, "Wrong size on VendorTransmogRowUserWidget_OnSetData");
static_assert(offsetof(VendorTransmogRowUserWidget_OnSetData, InEquippedItemIcon) == 0x000000, "Member 'VendorTransmogRowUserWidget_OnSetData::InEquippedItemIcon' has a wrong offset!");
static_assert(offsetof(VendorTransmogRowUserWidget_OnSetData, InTransmogItemIcon) == 0x000008, "Member 'VendorTransmogRowUserWidget_OnSetData::InTransmogItemIcon' has a wrong offset!");
static_assert(offsetof(VendorTransmogRowUserWidget_OnSetData, InTransmogItemName) == 0x000010, "Member 'VendorTransmogRowUserWidget_OnSetData::InTransmogItemName' has a wrong offset!");
static_assert(offsetof(VendorTransmogRowUserWidget_OnSetData, bInUnavailable) == 0x000028, "Member 'VendorTransmogRowUserWidget_OnSetData::bInUnavailable' has a wrong offset!");

// Function man.VendorTransmogUserWidget.GetSelectedVendorTransmogRowUserWidget
// 0x0008 (0x0008 - 0x0000)
struct VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget final
{
public:
	class UVendorTransmogRowUserWidget*           ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget) == 0x000008, "Wrong alignment on VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget");
static_assert(sizeof(VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget) == 0x000008, "Wrong size on VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget");
static_assert(offsetof(VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget, ReturnValue) == 0x000000, "Member 'VendorTransmogUserWidget_GetSelectedVendorTransmogRowUserWidget::ReturnValue' has a wrong offset!");

// Function man.VendorTransmogUserWidget.OnSetTransmogMode
// 0x0001 (0x0001 - 0x0000)
struct VendorTransmogUserWidget_OnSetTransmogMode final
{
public:
	bool                                          bInTransmogMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorTransmogUserWidget_OnSetTransmogMode) == 0x000001, "Wrong alignment on VendorTransmogUserWidget_OnSetTransmogMode");
static_assert(sizeof(VendorTransmogUserWidget_OnSetTransmogMode) == 0x000001, "Wrong size on VendorTransmogUserWidget_OnSetTransmogMode");
static_assert(offsetof(VendorTransmogUserWidget_OnSetTransmogMode, bInTransmogMode) == 0x000000, "Member 'VendorTransmogUserWidget_OnSetTransmogMode::bInTransmogMode' has a wrong offset!");

// Function man.VendorTransmogUserWidget.IsTransmogMode
// 0x0001 (0x0001 - 0x0000)
struct VendorTransmogUserWidget_IsTransmogMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorTransmogUserWidget_IsTransmogMode) == 0x000001, "Wrong alignment on VendorTransmogUserWidget_IsTransmogMode");
static_assert(sizeof(VendorTransmogUserWidget_IsTransmogMode) == 0x000001, "Wrong size on VendorTransmogUserWidget_IsTransmogMode");
static_assert(offsetof(VendorTransmogUserWidget_IsTransmogMode, ReturnValue) == 0x000000, "Member 'VendorTransmogUserWidget_IsTransmogMode::ReturnValue' has a wrong offset!");

// Function man.VendorUpgradeUserWidget.GetVendorLevelByDiagrams
// 0x0004 (0x0004 - 0x0000)
struct VendorUpgradeUserWidget_GetVendorLevelByDiagrams final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUpgradeUserWidget_GetVendorLevelByDiagrams) == 0x000004, "Wrong alignment on VendorUpgradeUserWidget_GetVendorLevelByDiagrams");
static_assert(sizeof(VendorUpgradeUserWidget_GetVendorLevelByDiagrams) == 0x000004, "Wrong size on VendorUpgradeUserWidget_GetVendorLevelByDiagrams");
static_assert(offsetof(VendorUpgradeUserWidget_GetVendorLevelByDiagrams, ReturnValue) == 0x000000, "Member 'VendorUpgradeUserWidget_GetVendorLevelByDiagrams::ReturnValue' has a wrong offset!");

// Function man.VendorUpgradeUserWidget.OnLearnDiagram
// 0x0001 (0x0001 - 0x0000)
struct VendorUpgradeUserWidget_OnLearnDiagram final
{
public:
	bool                                          LevelUp;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUpgradeUserWidget_OnLearnDiagram) == 0x000001, "Wrong alignment on VendorUpgradeUserWidget_OnLearnDiagram");
static_assert(sizeof(VendorUpgradeUserWidget_OnLearnDiagram) == 0x000001, "Wrong size on VendorUpgradeUserWidget_OnLearnDiagram");
static_assert(offsetof(VendorUpgradeUserWidget_OnLearnDiagram, LevelUp) == 0x000000, "Member 'VendorUpgradeUserWidget_OnLearnDiagram::LevelUp' has a wrong offset!");

// Function man.VendorUpgradeUserWidget.OnSetDiagramParams
// 0x0038 (0x0038 - 0x0000)
struct VendorUpgradeUserWidget_OnSetDiagramParams final
{
public:
	class FText                                   DiagramsNum;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   DiagramsXpText;                                    // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DiagramsXpValue;                                   // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiagramsAvailable;                                // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(VendorUpgradeUserWidget_OnSetDiagramParams) == 0x000008, "Wrong alignment on VendorUpgradeUserWidget_OnSetDiagramParams");
static_assert(sizeof(VendorUpgradeUserWidget_OnSetDiagramParams) == 0x000038, "Wrong size on VendorUpgradeUserWidget_OnSetDiagramParams");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetDiagramParams, DiagramsNum) == 0x000000, "Member 'VendorUpgradeUserWidget_OnSetDiagramParams::DiagramsNum' has a wrong offset!");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetDiagramParams, DiagramsXpText) == 0x000018, "Member 'VendorUpgradeUserWidget_OnSetDiagramParams::DiagramsXpText' has a wrong offset!");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetDiagramParams, DiagramsXpValue) == 0x000030, "Member 'VendorUpgradeUserWidget_OnSetDiagramParams::DiagramsXpValue' has a wrong offset!");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetDiagramParams, bDiagramsAvailable) == 0x000034, "Member 'VendorUpgradeUserWidget_OnSetDiagramParams::bDiagramsAvailable' has a wrong offset!");

// Function man.VendorUpgradeUserWidget.OnSetUpgradeCost
// 0x0008 (0x0008 - 0x0000)
struct VendorUpgradeUserWidget_OnSetUpgradeCost final
{
public:
	bool                                          bShowUpgradeCost;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpgradeCost;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUpgradeUserWidget_OnSetUpgradeCost) == 0x000004, "Wrong alignment on VendorUpgradeUserWidget_OnSetUpgradeCost");
static_assert(sizeof(VendorUpgradeUserWidget_OnSetUpgradeCost) == 0x000008, "Wrong size on VendorUpgradeUserWidget_OnSetUpgradeCost");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetUpgradeCost, bShowUpgradeCost) == 0x000000, "Member 'VendorUpgradeUserWidget_OnSetUpgradeCost::bShowUpgradeCost' has a wrong offset!");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetUpgradeCost, UpgradeCost) == 0x000004, "Member 'VendorUpgradeUserWidget_OnSetUpgradeCost::UpgradeCost' has a wrong offset!");

// Function man.VendorUpgradeUserWidget.OnSetUpgradeTitle
// 0x0018 (0x0018 - 0x0000)
struct VendorUpgradeUserWidget_OnSetUpgradeTitle final
{
public:
	class FText                                   UpgradeTitle;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VendorUpgradeUserWidget_OnSetUpgradeTitle) == 0x000008, "Wrong alignment on VendorUpgradeUserWidget_OnSetUpgradeTitle");
static_assert(sizeof(VendorUpgradeUserWidget_OnSetUpgradeTitle) == 0x000018, "Wrong size on VendorUpgradeUserWidget_OnSetUpgradeTitle");
static_assert(offsetof(VendorUpgradeUserWidget_OnSetUpgradeTitle, UpgradeTitle) == 0x000000, "Member 'VendorUpgradeUserWidget_OnSetUpgradeTitle::UpgradeTitle' has a wrong offset!");

// Function man.VfxComponentBase.BPPlayDamageBloodSplashVfx
// 0x0001 (0x0001 - 0x0000)
struct VfxComponentBase_BPPlayDamageBloodSplashVfx final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_BPPlayDamageBloodSplashVfx) == 0x000001, "Wrong alignment on VfxComponentBase_BPPlayDamageBloodSplashVfx");
static_assert(sizeof(VfxComponentBase_BPPlayDamageBloodSplashVfx) == 0x000001, "Wrong size on VfxComponentBase_BPPlayDamageBloodSplashVfx");
static_assert(offsetof(VfxComponentBase_BPPlayDamageBloodSplashVfx, ReturnValue) == 0x000000, "Member 'VfxComponentBase_BPPlayDamageBloodSplashVfx::ReturnValue' has a wrong offset!");

// Function man.VfxComponentBase.BPPlayDamageVfx
// 0x0001 (0x0001 - 0x0000)
struct VfxComponentBase_BPPlayDamageVfx final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_BPPlayDamageVfx) == 0x000001, "Wrong alignment on VfxComponentBase_BPPlayDamageVfx");
static_assert(sizeof(VfxComponentBase_BPPlayDamageVfx) == 0x000001, "Wrong size on VfxComponentBase_BPPlayDamageVfx");
static_assert(offsetof(VfxComponentBase_BPPlayDamageVfx, ReturnValue) == 0x000000, "Member 'VfxComponentBase_BPPlayDamageVfx::ReturnValue' has a wrong offset!");

// Function man.VfxComponentBase.BPTick
// 0x0004 (0x0004 - 0x0000)
struct VfxComponentBase_BPTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_BPTick) == 0x000004, "Wrong alignment on VfxComponentBase_BPTick");
static_assert(sizeof(VfxComponentBase_BPTick) == 0x000004, "Wrong size on VfxComponentBase_BPTick");
static_assert(offsetof(VfxComponentBase_BPTick, DeltaTime) == 0x000000, "Member 'VfxComponentBase_BPTick::DeltaTime' has a wrong offset!");

// Function man.VfxComponentBase.GetAbilityController
// 0x0008 (0x0008 - 0x0000)
struct VfxComponentBase_GetAbilityController final
{
public:
	class UAbilityController*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_GetAbilityController) == 0x000008, "Wrong alignment on VfxComponentBase_GetAbilityController");
static_assert(sizeof(VfxComponentBase_GetAbilityController) == 0x000008, "Wrong size on VfxComponentBase_GetAbilityController");
static_assert(offsetof(VfxComponentBase_GetAbilityController, ReturnValue) == 0x000000, "Member 'VfxComponentBase_GetAbilityController::ReturnValue' has a wrong offset!");

// Function man.VfxComponentBase.GetAttributeContainer
// 0x0008 (0x0008 - 0x0000)
struct VfxComponentBase_GetAttributeContainer final
{
public:
	class UAttributeContainer*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_GetAttributeContainer) == 0x000008, "Wrong alignment on VfxComponentBase_GetAttributeContainer");
static_assert(sizeof(VfxComponentBase_GetAttributeContainer) == 0x000008, "Wrong size on VfxComponentBase_GetAttributeContainer");
static_assert(offsetof(VfxComponentBase_GetAttributeContainer, ReturnValue) == 0x000000, "Member 'VfxComponentBase_GetAttributeContainer::ReturnValue' has a wrong offset!");

// Function man.VfxComponentBase.GetSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct VfxComponentBase_GetSkeletalMesh final
{
public:
	class USkeletalMesh*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_GetSkeletalMesh) == 0x000008, "Wrong alignment on VfxComponentBase_GetSkeletalMesh");
static_assert(sizeof(VfxComponentBase_GetSkeletalMesh) == 0x000008, "Wrong size on VfxComponentBase_GetSkeletalMesh");
static_assert(offsetof(VfxComponentBase_GetSkeletalMesh, ReturnValue) == 0x000000, "Member 'VfxComponentBase_GetSkeletalMesh::ReturnValue' has a wrong offset!");

// Function man.VfxComponentBase.OnSystemFinishedHandler
// 0x0008 (0x0008 - 0x0000)
struct VfxComponentBase_OnSystemFinishedHandler final
{
public:
	class UParticleSystemComponent*               PSystem;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VfxComponentBase_OnSystemFinishedHandler) == 0x000008, "Wrong alignment on VfxComponentBase_OnSystemFinishedHandler");
static_assert(sizeof(VfxComponentBase_OnSystemFinishedHandler) == 0x000008, "Wrong size on VfxComponentBase_OnSystemFinishedHandler");
static_assert(offsetof(VfxComponentBase_OnSystemFinishedHandler, PSystem) == 0x000000, "Member 'VfxComponentBase_OnSystemFinishedHandler::PSystem' has a wrong offset!");

// Function man.VLB_JumpAttackAbility.BPGetChandelierLocation
// 0x000C (0x000C - 0x0000)
struct VLB_JumpAttackAbility_BPGetChandelierLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VLB_JumpAttackAbility_BPGetChandelierLocation) == 0x000004, "Wrong alignment on VLB_JumpAttackAbility_BPGetChandelierLocation");
static_assert(sizeof(VLB_JumpAttackAbility_BPGetChandelierLocation) == 0x00000C, "Wrong size on VLB_JumpAttackAbility_BPGetChandelierLocation");
static_assert(offsetof(VLB_JumpAttackAbility_BPGetChandelierLocation, ReturnValue) == 0x000000, "Member 'VLB_JumpAttackAbility_BPGetChandelierLocation::ReturnValue' has a wrong offset!");

// Function man.VLB_JumpAttackAbility.BPGetTargetLocation
// 0x000C (0x000C - 0x0000)
struct VLB_JumpAttackAbility_BPGetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VLB_JumpAttackAbility_BPGetTargetLocation) == 0x000004, "Wrong alignment on VLB_JumpAttackAbility_BPGetTargetLocation");
static_assert(sizeof(VLB_JumpAttackAbility_BPGetTargetLocation) == 0x00000C, "Wrong size on VLB_JumpAttackAbility_BPGetTargetLocation");
static_assert(offsetof(VLB_JumpAttackAbility_BPGetTargetLocation, ReturnValue) == 0x000000, "Member 'VLB_JumpAttackAbility_BPGetTargetLocation::ReturnValue' has a wrong offset!");

// Function man.VLB_JumpAttackAbility.Chandelier_OnAnimEventBase
// 0x0030 (0x0030 - 0x0000)
struct VLB_JumpAttackAbility_Chandelier_OnAnimEventBase final
{
public:
	struct FAnimEventParam                        AnimEventParam;                                    // 0x0000(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VLB_JumpAttackAbility_Chandelier_OnAnimEventBase) == 0x000008, "Wrong alignment on VLB_JumpAttackAbility_Chandelier_OnAnimEventBase");
static_assert(sizeof(VLB_JumpAttackAbility_Chandelier_OnAnimEventBase) == 0x000030, "Wrong size on VLB_JumpAttackAbility_Chandelier_OnAnimEventBase");
static_assert(offsetof(VLB_JumpAttackAbility_Chandelier_OnAnimEventBase, AnimEventParam) == 0x000000, "Member 'VLB_JumpAttackAbility_Chandelier_OnAnimEventBase::AnimEventParam' has a wrong offset!");

// Function man.VWAnamorphosis.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct VWAnamorphosis_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VWAnamorphosis_BPGetTeleportLocation) == 0x000004, "Wrong alignment on VWAnamorphosis_BPGetTeleportLocation");
static_assert(sizeof(VWAnamorphosis_BPGetTeleportLocation) == 0x00000C, "Wrong size on VWAnamorphosis_BPGetTeleportLocation");
static_assert(offsetof(VWAnamorphosis_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'VWAnamorphosis_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.VoidWitchTeleport.BPGetStartLocation
// 0x000C (0x000C - 0x0000)
struct VoidWitchTeleport_BPGetStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidWitchTeleport_BPGetStartLocation) == 0x000004, "Wrong alignment on VoidWitchTeleport_BPGetStartLocation");
static_assert(sizeof(VoidWitchTeleport_BPGetStartLocation) == 0x00000C, "Wrong size on VoidWitchTeleport_BPGetStartLocation");
static_assert(offsetof(VoidWitchTeleport_BPGetStartLocation, ReturnValue) == 0x000000, "Member 'VoidWitchTeleport_BPGetStartLocation::ReturnValue' has a wrong offset!");

// Function man.VoidWitchTeleport.BPGetTeleportLocation
// 0x000C (0x000C - 0x0000)
struct VoidWitchTeleport_BPGetTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoidWitchTeleport_BPGetTeleportLocation) == 0x000004, "Wrong alignment on VoidWitchTeleport_BPGetTeleportLocation");
static_assert(sizeof(VoidWitchTeleport_BPGetTeleportLocation) == 0x00000C, "Wrong size on VoidWitchTeleport_BPGetTeleportLocation");
static_assert(offsetof(VoidWitchTeleport_BPGetTeleportLocation, ReturnValue) == 0x000000, "Member 'VoidWitchTeleport_BPGetTeleportLocation::ReturnValue' has a wrong offset!");

// Function man.VolatileConduit.OnAbilityAdded
// 0x0008 (0x0008 - 0x0000)
struct VolatileConduit_OnAbilityAdded final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VolatileConduit_OnAbilityAdded) == 0x000008, "Wrong alignment on VolatileConduit_OnAbilityAdded");
static_assert(sizeof(VolatileConduit_OnAbilityAdded) == 0x000008, "Wrong size on VolatileConduit_OnAbilityAdded");
static_assert(offsetof(VolatileConduit_OnAbilityAdded, Ability) == 0x000000, "Member 'VolatileConduit_OnAbilityAdded::Ability' has a wrong offset!");

// Function man.WallClimb.OnAnimToggled
// 0x0010 (0x0010 - 0x0000)
struct WallClimb_OnAnimToggled final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStart;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WallClimb_OnAnimToggled) == 0x000008, "Wrong alignment on WallClimb_OnAnimToggled");
static_assert(sizeof(WallClimb_OnAnimToggled) == 0x000010, "Wrong size on WallClimb_OnAnimToggled");
static_assert(offsetof(WallClimb_OnAnimToggled, AnimID) == 0x000000, "Member 'WallClimb_OnAnimToggled::AnimID' has a wrong offset!");
static_assert(offsetof(WallClimb_OnAnimToggled, bStart) == 0x000008, "Member 'WallClimb_OnAnimToggled::bStart' has a wrong offset!");

// Function man.WallClimb.OnTeleport
// 0x000C (0x000C - 0x0000)
struct WallClimb_OnTeleport final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WallClimb_OnTeleport) == 0x000004, "Wrong alignment on WallClimb_OnTeleport");
static_assert(sizeof(WallClimb_OnTeleport) == 0x00000C, "Wrong size on WallClimb_OnTeleport");
static_assert(offsetof(WallClimb_OnTeleport, NewLocation) == 0x000000, "Member 'WallClimb_OnTeleport::NewLocation' has a wrong offset!");

// Function man.EnergyAttunement.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct EnergyAttunement_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnergyAttunement_OnPostDamageCaused) == 0x000008, "Wrong alignment on EnergyAttunement_OnPostDamageCaused");
static_assert(sizeof(EnergyAttunement_OnPostDamageCaused) == 0x0002D8, "Wrong size on EnergyAttunement_OnPostDamageCaused");
static_assert(offsetof(EnergyAttunement_OnPostDamageCaused, Param) == 0x000000, "Member 'EnergyAttunement_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.Grounding.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct Grounding_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Grounding_OnPostDamageCaused) == 0x000008, "Wrong alignment on Grounding_OnPostDamageCaused");
static_assert(sizeof(Grounding_OnPostDamageCaused) == 0x0002D8, "Wrong size on Grounding_OnPostDamageCaused");
static_assert(offsetof(Grounding_OnPostDamageCaused, Param) == 0x000000, "Member 'Grounding_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.UnstableElements.BPGetTargetEnemyForDamageVfx
// 0x0008 (0x0008 - 0x0000)
struct UnstableElements_BPGetTargetEnemyForDamageVfx final
{
public:
	class AEnemyCharacter*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnstableElements_BPGetTargetEnemyForDamageVfx) == 0x000008, "Wrong alignment on UnstableElements_BPGetTargetEnemyForDamageVfx");
static_assert(sizeof(UnstableElements_BPGetTargetEnemyForDamageVfx) == 0x000008, "Wrong size on UnstableElements_BPGetTargetEnemyForDamageVfx");
static_assert(offsetof(UnstableElements_BPGetTargetEnemyForDamageVfx, ReturnValue) == 0x000000, "Member 'UnstableElements_BPGetTargetEnemyForDamageVfx::ReturnValue' has a wrong offset!");

// Function man.UnstableElements.OnPreDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct UnstableElements_OnPreDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UnstableElements_OnPreDamageCaused) == 0x000008, "Wrong alignment on UnstableElements_OnPreDamageCaused");
static_assert(sizeof(UnstableElements_OnPreDamageCaused) == 0x0002D8, "Wrong size on UnstableElements_OnPreDamageCaused");
static_assert(offsetof(UnstableElements_OnPreDamageCaused, Param) == 0x000000, "Member 'UnstableElements_OnPreDamageCaused::Param' has a wrong offset!");

// Function man.CycleOfLife.OnEntityKilled
// 0x0008 (0x0008 - 0x0000)
struct CycleOfLife_OnEntityKilled final
{
public:
	class AActor*                                 KilledActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CycleOfLife_OnEntityKilled) == 0x000008, "Wrong alignment on CycleOfLife_OnEntityKilled");
static_assert(sizeof(CycleOfLife_OnEntityKilled) == 0x000008, "Wrong size on CycleOfLife_OnEntityKilled");
static_assert(offsetof(CycleOfLife_OnEntityKilled, KilledActor) == 0x000000, "Member 'CycleOfLife_OnEntityKilled::KilledActor' has a wrong offset!");

// Function man.CycleOfLife.OnLootActorPickedUp
// 0x0008 (0x0008 - 0x0000)
struct CycleOfLife_OnLootActorPickedUp final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CycleOfLife_OnLootActorPickedUp) == 0x000008, "Wrong alignment on CycleOfLife_OnLootActorPickedUp");
static_assert(sizeof(CycleOfLife_OnLootActorPickedUp) == 0x000008, "Wrong size on CycleOfLife_OnLootActorPickedUp");
static_assert(offsetof(CycleOfLife_OnLootActorPickedUp, Actor) == 0x000000, "Member 'CycleOfLife_OnLootActorPickedUp::Actor' has a wrong offset!");

// Function man.Rejuvenation.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct Rejuvenation_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Rejuvenation_OnPostDamageCaused) == 0x000008, "Wrong alignment on Rejuvenation_OnPostDamageCaused");
static_assert(sizeof(Rejuvenation_OnPostDamageCaused) == 0x0002D8, "Wrong size on Rejuvenation_OnPostDamageCaused");
static_assert(offsetof(Rejuvenation_OnPostDamageCaused, Param) == 0x000000, "Member 'Rejuvenation_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.Thornskin.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct Thornskin_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Thornskin_OnPostDamaged) == 0x000008, "Wrong alignment on Thornskin_OnPostDamaged");
static_assert(sizeof(Thornskin_OnPostDamaged) == 0x0002D8, "Wrong size on Thornskin_OnPostDamaged");
static_assert(offsetof(Thornskin_OnPostDamaged, Param) == 0x000000, "Member 'Thornskin_OnPostDamaged::Param' has a wrong offset!");

// Function man.Thornskin.OnPreDamagedPriority
// 0x02D8 (0x02D8 - 0x0000)
struct Thornskin_OnPreDamagedPriority final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Thornskin_OnPreDamagedPriority) == 0x000008, "Wrong alignment on Thornskin_OnPreDamagedPriority");
static_assert(sizeof(Thornskin_OnPreDamagedPriority) == 0x0002D8, "Wrong size on Thornskin_OnPreDamagedPriority");
static_assert(offsetof(Thornskin_OnPreDamagedPriority, Param) == 0x000000, "Member 'Thornskin_OnPreDamagedPriority::Param' has a wrong offset!");

// Function man.SicEm.OnPostDamageCaused
// 0x02D8 (0x02D8 - 0x0000)
struct SicEm_OnPostDamageCaused final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SicEm_OnPostDamageCaused) == 0x000008, "Wrong alignment on SicEm_OnPostDamageCaused");
static_assert(sizeof(SicEm_OnPostDamageCaused) == 0x0002D8, "Wrong size on SicEm_OnPostDamageCaused");
static_assert(offsetof(SicEm_OnPostDamageCaused, Param) == 0x000000, "Member 'SicEm_OnPostDamageCaused::Param' has a wrong offset!");

// Function man.SicEm.OnProjectileShot
// 0x0008 (0x0008 - 0x0000)
struct SicEm_OnProjectileShot final
{
public:
	class AManProjectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SicEm_OnProjectileShot) == 0x000008, "Wrong alignment on SicEm_OnProjectileShot");
static_assert(sizeof(SicEm_OnProjectileShot) == 0x000008, "Wrong size on SicEm_OnProjectileShot");
static_assert(offsetof(SicEm_OnProjectileShot, Projectile) == 0x000000, "Member 'SicEm_OnProjectileShot::Projectile' has a wrong offset!");

// Function man.WyldEcho.BPGetDelayInSec
// 0x0004 (0x0004 - 0x0000)
struct WyldEcho_BPGetDelayInSec final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WyldEcho_BPGetDelayInSec) == 0x000004, "Wrong alignment on WyldEcho_BPGetDelayInSec");
static_assert(sizeof(WyldEcho_BPGetDelayInSec) == 0x000004, "Wrong size on WyldEcho_BPGetDelayInSec");
static_assert(offsetof(WyldEcho_BPGetDelayInSec, ReturnValue) == 0x000000, "Member 'WyldEcho_BPGetDelayInSec::ReturnValue' has a wrong offset!");

// Function man.WyldEcho.BPGetDelayTimerCurrentValue
// 0x0004 (0x0004 - 0x0000)
struct WyldEcho_BPGetDelayTimerCurrentValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WyldEcho_BPGetDelayTimerCurrentValue) == 0x000004, "Wrong alignment on WyldEcho_BPGetDelayTimerCurrentValue");
static_assert(sizeof(WyldEcho_BPGetDelayTimerCurrentValue) == 0x000004, "Wrong size on WyldEcho_BPGetDelayTimerCurrentValue");
static_assert(offsetof(WyldEcho_BPGetDelayTimerCurrentValue, ReturnValue) == 0x000000, "Member 'WyldEcho_BPGetDelayTimerCurrentValue::ReturnValue' has a wrong offset!");

// Function man.WyldEcho.OnAbilityAdded
// 0x0008 (0x0008 - 0x0000)
struct WyldEcho_OnAbilityAdded final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WyldEcho_OnAbilityAdded) == 0x000008, "Wrong alignment on WyldEcho_OnAbilityAdded");
static_assert(sizeof(WyldEcho_OnAbilityAdded) == 0x000008, "Wrong size on WyldEcho_OnAbilityAdded");
static_assert(offsetof(WyldEcho_OnAbilityAdded, Ability) == 0x000000, "Member 'WyldEcho_OnAbilityAdded::Ability' has a wrong offset!");

// Function man.WyldEcho.OnPostAbilityStarted
// 0x0010 (0x0010 - 0x0000)
struct WyldEcho_OnPostAbilityStarted final
{
public:
	class UAbilityBase*                           StartedAbility;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesired;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WyldEcho_OnPostAbilityStarted) == 0x000008, "Wrong alignment on WyldEcho_OnPostAbilityStarted");
static_assert(sizeof(WyldEcho_OnPostAbilityStarted) == 0x000010, "Wrong size on WyldEcho_OnPostAbilityStarted");
static_assert(offsetof(WyldEcho_OnPostAbilityStarted, StartedAbility) == 0x000000, "Member 'WyldEcho_OnPostAbilityStarted::StartedAbility' has a wrong offset!");
static_assert(offsetof(WyldEcho_OnPostAbilityStarted, bDesired) == 0x000008, "Member 'WyldEcho_OnPostAbilityStarted::bDesired' has a wrong offset!");

// Function man.VenomousThorns.OnStatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct VenomousThorns_OnStatusEffectCaused final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VenomousThorns_OnStatusEffectCaused) == 0x000008, "Wrong alignment on VenomousThorns_OnStatusEffectCaused");
static_assert(sizeof(VenomousThorns_OnStatusEffectCaused) == 0x000018, "Wrong size on VenomousThorns_OnStatusEffectCaused");
static_assert(offsetof(VenomousThorns_OnStatusEffectCaused, TargetActor) == 0x000000, "Member 'VenomousThorns_OnStatusEffectCaused::TargetActor' has a wrong offset!");
static_assert(offsetof(VenomousThorns_OnStatusEffectCaused, Type) == 0x000008, "Member 'VenomousThorns_OnStatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(VenomousThorns_OnStatusEffectCaused, IsNewEffect) == 0x000009, "Member 'VenomousThorns_OnStatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(VenomousThorns_OnStatusEffectCaused, Instance) == 0x000010, "Member 'VenomousThorns_OnStatusEffectCaused::Instance' has a wrong offset!");

// Function man.ExplosiveDecomposition.BPGetBurstDamageRadius
// 0x0004 (0x0004 - 0x0000)
struct ExplosiveDecomposition_BPGetBurstDamageRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosiveDecomposition_BPGetBurstDamageRadius) == 0x000004, "Wrong alignment on ExplosiveDecomposition_BPGetBurstDamageRadius");
static_assert(sizeof(ExplosiveDecomposition_BPGetBurstDamageRadius) == 0x000004, "Wrong size on ExplosiveDecomposition_BPGetBurstDamageRadius");
static_assert(offsetof(ExplosiveDecomposition_BPGetBurstDamageRadius, ReturnValue) == 0x000000, "Member 'ExplosiveDecomposition_BPGetBurstDamageRadius::ReturnValue' has a wrong offset!");

// Function man.ExplosiveDecomposition.OnStatusEffectCaused
// 0x0018 (0x0018 - 0x0000)
struct ExplosiveDecomposition_OnStatusEffectCaused final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             Type;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewEffect;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectInstance*                  Instance;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosiveDecomposition_OnStatusEffectCaused) == 0x000008, "Wrong alignment on ExplosiveDecomposition_OnStatusEffectCaused");
static_assert(sizeof(ExplosiveDecomposition_OnStatusEffectCaused) == 0x000018, "Wrong size on ExplosiveDecomposition_OnStatusEffectCaused");
static_assert(offsetof(ExplosiveDecomposition_OnStatusEffectCaused, TargetActor) == 0x000000, "Member 'ExplosiveDecomposition_OnStatusEffectCaused::TargetActor' has a wrong offset!");
static_assert(offsetof(ExplosiveDecomposition_OnStatusEffectCaused, Type) == 0x000008, "Member 'ExplosiveDecomposition_OnStatusEffectCaused::Type' has a wrong offset!");
static_assert(offsetof(ExplosiveDecomposition_OnStatusEffectCaused, IsNewEffect) == 0x000009, "Member 'ExplosiveDecomposition_OnStatusEffectCaused::IsNewEffect' has a wrong offset!");
static_assert(offsetof(ExplosiveDecomposition_OnStatusEffectCaused, Instance) == 0x000010, "Member 'ExplosiveDecomposition_OnStatusEffectCaused::Instance' has a wrong offset!");

// Function man.SpiritualFocus.OnAttributeChanged
// 0x0008 (0x0008 - 0x0000)
struct SpiritualFocus_OnAttributeChanged final
{
public:
	EAttribute                                    AttributeType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpiritualFocus_OnAttributeChanged) == 0x000004, "Wrong alignment on SpiritualFocus_OnAttributeChanged");
static_assert(sizeof(SpiritualFocus_OnAttributeChanged) == 0x000008, "Wrong size on SpiritualFocus_OnAttributeChanged");
static_assert(offsetof(SpiritualFocus_OnAttributeChanged, AttributeType) == 0x000000, "Member 'SpiritualFocus_OnAttributeChanged::AttributeType' has a wrong offset!");
static_assert(offsetof(SpiritualFocus_OnAttributeChanged, Value) == 0x000004, "Member 'SpiritualFocus_OnAttributeChanged::Value' has a wrong offset!");

// Function man.WeaponExpertPassive.RageChanged
// 0x0004 (0x0004 - 0x0000)
struct WeaponExpertPassive_RageChanged final
{
public:
	float                                         Delta;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponExpertPassive_RageChanged) == 0x000004, "Wrong alignment on WeaponExpertPassive_RageChanged");
static_assert(sizeof(WeaponExpertPassive_RageChanged) == 0x000004, "Wrong size on WeaponExpertPassive_RageChanged");
static_assert(offsetof(WeaponExpertPassive_RageChanged, Delta) == 0x000000, "Member 'WeaponExpertPassive_RageChanged::Delta' has a wrong offset!");

// Function man.WeaponModelActor.BPPostWeaponAttachToggle
// 0x0001 (0x0001 - 0x0000)
struct WeaponModelActor_BPPostWeaponAttachToggle final
{
public:
	bool                                          bAttached;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponModelActor_BPPostWeaponAttachToggle) == 0x000001, "Wrong alignment on WeaponModelActor_BPPostWeaponAttachToggle");
static_assert(sizeof(WeaponModelActor_BPPostWeaponAttachToggle) == 0x000001, "Wrong size on WeaponModelActor_BPPostWeaponAttachToggle");
static_assert(offsetof(WeaponModelActor_BPPostWeaponAttachToggle, bAttached) == 0x000000, "Member 'WeaponModelActor_BPPostWeaponAttachToggle::bAttached' has a wrong offset!");

// Function man.OneHandedSettings.GetEditorName
// 0x0010 (0x0010 - 0x0000)
struct OneHandedSettings_GetEditorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OneHandedSettings_GetEditorName) == 0x000008, "Wrong alignment on OneHandedSettings_GetEditorName");
static_assert(sizeof(OneHandedSettings_GetEditorName) == 0x000010, "Wrong size on OneHandedSettings_GetEditorName");
static_assert(offsetof(OneHandedSettings_GetEditorName, ReturnValue) == 0x000000, "Member 'OneHandedSettings_GetEditorName::ReturnValue' has a wrong offset!");

// Function man.WindowWarningUserWidget.OnSetWarningText
// 0x0030 (0x0030 - 0x0000)
struct WindowWarningUserWidget_OnSetWarningText final
{
public:
	bool                                          bInShow;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WarningText;                                       // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<EHasInventoryResourceResult>           InventoryResourceResults;                          // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindowWarningUserWidget_OnSetWarningText) == 0x000008, "Wrong alignment on WindowWarningUserWidget_OnSetWarningText");
static_assert(sizeof(WindowWarningUserWidget_OnSetWarningText) == 0x000030, "Wrong size on WindowWarningUserWidget_OnSetWarningText");
static_assert(offsetof(WindowWarningUserWidget_OnSetWarningText, bInShow) == 0x000000, "Member 'WindowWarningUserWidget_OnSetWarningText::bInShow' has a wrong offset!");
static_assert(offsetof(WindowWarningUserWidget_OnSetWarningText, WarningText) == 0x000008, "Member 'WindowWarningUserWidget_OnSetWarningText::WarningText' has a wrong offset!");
static_assert(offsetof(WindowWarningUserWidget_OnSetWarningText, InventoryResourceResults) == 0x000020, "Member 'WindowWarningUserWidget_OnSetWarningText::InventoryResourceResults' has a wrong offset!");

// Function man.WitchLanternPassiveLifesteal.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct WitchLanternPassiveLifesteal_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternPassiveLifesteal_DamageDealt) == 0x000008, "Wrong alignment on WitchLanternPassiveLifesteal_DamageDealt");
static_assert(sizeof(WitchLanternPassiveLifesteal_DamageDealt) == 0x0002D8, "Wrong size on WitchLanternPassiveLifesteal_DamageDealt");
static_assert(offsetof(WitchLanternPassiveLifesteal_DamageDealt, Param) == 0x000000, "Member 'WitchLanternPassiveLifesteal_DamageDealt::Param' has a wrong offset!");

// Function man.WitchLanternPassiveSpiritBond.RespawnPrime
// 0x0008 (0x0008 - 0x0000)
struct WitchLanternPassiveSpiritBond_RespawnPrime final
{
public:
	class AHeroBase*                              Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternPassiveSpiritBond_RespawnPrime) == 0x000008, "Wrong alignment on WitchLanternPassiveSpiritBond_RespawnPrime");
static_assert(sizeof(WitchLanternPassiveSpiritBond_RespawnPrime) == 0x000008, "Wrong size on WitchLanternPassiveSpiritBond_RespawnPrime");
static_assert(offsetof(WitchLanternPassiveSpiritBond_RespawnPrime, Hero) == 0x000000, "Member 'WitchLanternPassiveSpiritBond_RespawnPrime::Hero' has a wrong offset!");

// Function man.WitchLanternResourceUserWidget.OnSetValueColors
// 0x0004 (0x0004 - 0x0000)
struct WitchLanternResourceUserWidget_OnSetValueColors final
{
public:
	int32                                         EssenceCost;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternResourceUserWidget_OnSetValueColors) == 0x000004, "Wrong alignment on WitchLanternResourceUserWidget_OnSetValueColors");
static_assert(sizeof(WitchLanternResourceUserWidget_OnSetValueColors) == 0x000004, "Wrong size on WitchLanternResourceUserWidget_OnSetValueColors");
static_assert(offsetof(WitchLanternResourceUserWidget_OnSetValueColors, EssenceCost) == 0x000000, "Member 'WitchLanternResourceUserWidget_OnSetValueColors::EssenceCost' has a wrong offset!");

// Function man.WitchLanternResourceUserWidget.GetCost
// 0x0004 (0x0004 - 0x0000)
struct WitchLanternResourceUserWidget_GetCost final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitchLanternResourceUserWidget_GetCost) == 0x000004, "Wrong alignment on WitchLanternResourceUserWidget_GetCost");
static_assert(sizeof(WitchLanternResourceUserWidget_GetCost) == 0x000004, "Wrong size on WitchLanternResourceUserWidget_GetCost");
static_assert(offsetof(WitchLanternResourceUserWidget_GetCost, ReturnValue) == 0x000000, "Member 'WitchLanternResourceUserWidget_GetCost::ReturnValue' has a wrong offset!");

// Function man.WitherPassive.DamageDealt
// 0x02D8 (0x02D8 - 0x0000)
struct WitherPassive_DamageDealt final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WitherPassive_DamageDealt) == 0x000008, "Wrong alignment on WitherPassive_DamageDealt");
static_assert(sizeof(WitherPassive_DamageDealt) == 0x0002D8, "Wrong size on WitherPassive_DamageDealt");
static_assert(offsetof(WitherPassive_DamageDealt, Param) == 0x000000, "Member 'WitherPassive_DamageDealt::Param' has a wrong offset!");

// Function man.WraithAI.IsCollideSignature
// 0x0010 (0x0010 - 0x0000)
struct WraithAI_IsCollideSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollide;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WraithAI_IsCollideSignature) == 0x000008, "Wrong alignment on WraithAI_IsCollideSignature");
static_assert(sizeof(WraithAI_IsCollideSignature) == 0x000010, "Wrong size on WraithAI_IsCollideSignature");
static_assert(offsetof(WraithAI_IsCollideSignature, Actor) == 0x000000, "Member 'WraithAI_IsCollideSignature::Actor' has a wrong offset!");
static_assert(offsetof(WraithAI_IsCollideSignature, bOverride) == 0x000008, "Member 'WraithAI_IsCollideSignature::bOverride' has a wrong offset!");
static_assert(offsetof(WraithAI_IsCollideSignature, bCollide) == 0x000009, "Member 'WraithAI_IsCollideSignature::bCollide' has a wrong offset!");

// Function man.BodyPartsAbility.OnPostDamaged
// 0x02D8 (0x02D8 - 0x0000)
struct BodyPartsAbility_OnPostDamaged final
{
public:
	struct FPreDamagedEventParam                  Param;                                             // 0x0000(0x02D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BodyPartsAbility_OnPostDamaged) == 0x000008, "Wrong alignment on BodyPartsAbility_OnPostDamaged");
static_assert(sizeof(BodyPartsAbility_OnPostDamaged) == 0x0002D8, "Wrong size on BodyPartsAbility_OnPostDamaged");
static_assert(offsetof(BodyPartsAbility_OnPostDamaged, Param) == 0x000000, "Member 'BodyPartsAbility_OnPostDamaged::Param' has a wrong offset!");

}

