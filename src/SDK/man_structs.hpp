#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: man

#include "Basic.hpp"

#include "MovieScene_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum man.EInputDisplay
// NumValues: 0x000A
enum class EInputDisplay : uint8
{
	Unknown                                  = 0,
	Keyboard                                 = 1,
	XBoxOne                                  = 2,
	XboxSeriesX                              = 3,
	PS4                                      = 4,
	PS5                                      = 5,
	Switch                                   = 6,
	Mouse                                    = 7,
	Count                                    = 8,
	EInputDisplay_MAX                        = 9,
};

// Enum man.EDamageSubType
// NumValues: 0x0009
enum class EDamageSubType : uint8
{
	None                                     = 0,
	Astral                                   = 1,
	Fire                                     = 2,
	Frost                                    = 3,
	Physical                                 = 4,
	Poison                                   = 5,
	Void_Entropy                             = 6,
	Void_Purple                              = 7,
	EDamageSubType_MAX                       = 8,
};

// Enum man.EDamageType
// NumValues: 0x000F
enum class EDamageType : uint8
{
	Physical                                 = 0,
	Structure                                = 1,
	Arcane                                   = 2,
	Wild                                     = 3,
	Poison                                   = 4,
	Bleed                                    = 5,
	Fire                                     = 6,
	Void                                     = 7,
	Frost                                    = 8,
	Chaos                                    = 9,
	Fall                                     = 10,
	FloorStructure                           = 11,
	AllNonStructure                          = 12,
	AllDamage                                = 13,
	EDamageType_MAX                          = 14,
};

// Enum man.EDamageReactionType
// NumValues: 0x000A
enum class EDamageReactionType : uint8
{
	Nothing                                  = 0,
	Additive                                 = 1,
	VerySmall                                = 2,
	Mini                                     = 3,
	Small                                    = 4,
	Medium                                   = 5,
	Medium2                                  = 6,
	Large                                    = 7,
	SpikedWallPush                           = 8,
	EDamageReactionType_MAX                  = 9,
};

// Enum man.EDeathType
// NumValues: 0x0004
enum class EDeathType : uint8
{
	Default                                  = 0,
	FatalityBeheading                        = 1,
	Custom                                   = 2,
	EDeathType_MAX                           = 3,
};

// Enum man.EGeneralAbilityModifier
// NumValues: 0x0023
enum class EGeneralAbilityModifier : uint8
{
	None                                     = 0,
	ModifiedDamageFlat                       = 1,
	ModifiedDamageMulti                      = 2,
	ModifiedDurationFlat                     = 3,
	ModifiedDurationMulti                    = 4,
	ModifiedEnergyCostFlat                   = 5,
	ModifiedEnergyCostMulti                  = 6,
	ModifierEnergyPerSecCostFlat             = 7,
	ModifierStaminaPerSecCostFlat            = 8,
	ModifiedRageCostFlat                     = 9,
	ModifierRagePerSecCostFlat               = 10,
	ModifiedRageCostMulti                    = 11,
	ModifiedStaggerDurationFlat              = 12,
	ModifiedStaggerFlat                      = 13,
	ModifiedStaggerMulti                     = 14,
	ModifiedRangeMulti                       = 15,
	ModifiedWidthMulti                       = 16,
	ModifiedBurnChanceFlat                   = 17,
	ModifiedPoisonChanceFlat                 = 18,
	ModifiedCanDealCritical                  = 19,
	ModifiedCanDealStatusEffect              = 20,
	ModifiedIgnoreFireResistance             = 21,
	ModifiedDexterityScaling                 = 22,
	ModifiedStrengthScaling                  = 23,
	ModifiedStaggerWithPowerScaleMulti       = 24,
	ModifiedAnimationSpeedAdditiveMulti      = 25,
	ForceStagger                             = 26,
	ForceStrengthScaleOnDamage               = 27,
	ManProjectileAutoHoming                  = 28,
	ManProjectileActivateScaling             = 29,
	IgnoreWeaponQueryOffhandRequirement      = 30,
	SpellCritAddedToPhysicalCrit             = 31,
	ExtraAbility                             = 32,
	TriggerableAbilityToTriggerMode          = 33,
	EGeneralAbilityModifier_MAX              = 34,
};

// Enum man.EAnimEventType
// NumValues: 0x00B1
enum class EAnimEventType : uint8
{
	AnimEnd                                  = 0,
	Nothing                                  = 1,
	MoveEnd                                  = 2,
	PutWeaponLeftHand                        = 3,
	PutWeaponRightHand                       = 4,
	PutWeaponBack                            = 5,
	SwitchWeapon                             = 6,
	WeaponInvisible                          = 7,
	WeaponVisible                            = 8,
	RuneInvisible                            = 9,
	RuneVisible                              = 10,
	RunningLockEnd                           = 11,
	StartRagdoll                             = 12,
	FlipFacing                               = 13,
	SleepRagdoll                             = 14,
	StartRiseRagdoll                         = 15,
	StopRiseRagdoll                          = 16,
	EnableIK                                 = 17,
	DisableIK                                = 18,
	PickIdleBridge                           = 19,
	TransitionEnd                            = 20,
	ShouldTurnEnd                            = 21,
	ShowItem                                 = 22,
	HideItem                                 = 23,
	ShowInGame                               = 24,
	HideInGame                               = 25,
	ShowWeapons                              = 26,
	HideWeapons                              = 27,
	RestartLockEnd                           = 28,
	StaminaCondition                         = 29,
	LeftFootDown                             = 30,
	RightFootDown                            = 31,
	PriorityInterrupted                      = 32,
	VfxEvent                                 = 33,
	InstantSwitch                            = 34,
	InstantSwitchReset                       = 35,
	LeftFootDownInterval                     = 36,
	RightFootDownInterval                    = 37,
	IdleFootDownInterval                     = 38,
	FootLock                                 = 39,
	MoveStop01                               = 40,
	MoveStop02                               = 41,
	MoveStop03                               = 42,
	MoveStop04                               = 43,
	MoveStop05                               = 44,
	MoveStop06                               = 45,
	MoveStop07                               = 46,
	MoveStop08                               = 47,
	MoveStop09                               = 48,
	MoveStop10                               = 49,
	CharacterTurn_Start                      = 50,
	CharacterTurn_End                        = 51,
	AddToGameCamera                          = 52,
	RemoveFromGameCamera                     = 53,
	IgnoreAttackSpeed                        = 54,
	DetachLeftWeapon                         = 55,
	DetachRightWeapon                        = 56,
	TurnToTarget                             = 57,
	HitStart                                 = 58,
	HitEnd                                   = 59,
	HitStartLeft                             = 60,
	HitEndLeft                               = 61,
	HitStartRight                            = 62,
	HitEndRight                              = 63,
	HitStartLeftLeg                          = 64,
	HitEndLeftLeg                            = 65,
	HitStartRightLeg                         = 66,
	HitEndRightLeg                           = 67,
	HitStartBody                             = 68,
	HitEndBody                               = 69,
	HitStartGround                           = 70,
	HitEndGround                             = 71,
	HitStartBodyAlt                          = 72,
	HitEndBodyAlt                            = 73,
	HitStartHead                             = 74,
	HitEndHead                               = 75,
	HitStartTail                             = 76,
	HitEndTail                               = 77,
	HitStartCharge                           = 78,
	HitEndCharge                             = 79,
	HitStartJump                             = 80,
	HitEndJump                               = 81,
	HitStartCustom1                          = 82,
	HitEndCustom1                            = 83,
	HitStartCustom2                          = 84,
	HitEndCustom2                            = 85,
	HitStartCustom3                          = 86,
	HitEndCustom3                            = 87,
	ResetHit                                 = 88,
	ParryStart                               = 89,
	ParryEnd                                 = 90,
	ParryUpStart                             = 91,
	ParryDownStart                           = 92,
	EnableEarlyLockEnd                       = 93,
	DuckLockEnd                              = 94,
	LockEnd                                  = 95,
	LockEndLeft                              = 96,
	LockEndRight                             = 97,
	Teleport                                 = 98,
	Custom1                                  = 99,
	Custom2                                  = 100,
	Custom3                                  = 101,
	Custom4                                  = 102,
	Custom5                                  = 103,
	Shoot1                                   = 104,
	Shoot2                                   = 105,
	Shoot3                                   = 106,
	InteractCustom1                          = 107,
	CustomName                               = 108,
	ForceOffCombatStart                      = 109,
	ForceOffCombatEnd                        = 110,
	WeaponDamageTrailVFXEnd                  = 111,
	StartMarkTarget                          = 112,
	EndMarkTarget                            = 113,
	MarkTarget                               = 114,
	LoopStart                                = 115,
	AimEnd                                   = 116,
	AttackLockEnd                            = 117,
	FaceToTarget                             = 118,
	InterruptableByRoll_Remove               = 119,
	InterruptableByRoll_Add                  = 120,
	AIAllowPhaseChange_Remove                = 121,
	AIAllowPhaseChange_Add                   = 122,
	DisableEntitySleep_Remove                = 123,
	DisableEntitySleep_Add                   = 124,
	CharacterCollision_Remove                = 125,
	CharacterCollision_Add                   = 126,
	StaticCollision_Remove                   = 127,
	StaticCollision_Add                      = 128,
	Anchored_Remove                          = 129,
	Anchored_Add                             = 130,
	Uninterruptable_Remove                   = 131,
	Uninterruptable_Add                      = 132,
	UnStaggerable_Remove                     = 133,
	UnStaggerable_Add                        = 134,
	GoToStunWhenStaggered_Add                = 135,
	GoToStunWhenStaggered_Remove             = 136,
	DeathWard_Remove                         = 137,
	DeathWard_Add                            = 138,
	HitBoxProjection_End                     = 139,
	HitBoxProjection_Start                   = 140,
	HyperArmor_End                           = 141,
	HyperArmor_Start                         = 142,
	ReverseHitFacing_End                     = 143,
	ReverseHitFacing_Start                   = 144,
	RemoveFromWorld                          = 145,
	AddToWorld                               = 146,
	Invulnerability_Remove                   = 147,
	Invulnerability_Add                      = 148,
	NonTargetable_Remove                     = 149,
	NonTargetable_Add                        = 150,
	NonPushPullAble_Remove                   = 151,
	NonPushPullAble_Add                      = 152,
	OffCombatAnimMode_Remove                 = 153,
	OffCombatAnimMode_Add                    = 154,
	PushHero_Remove                          = 155,
	PushHero_Add                             = 156,
	LockPlayerControl_Remove                 = 157,
	LockPlayerControl_Add                    = 158,
	RootMotion_Disable                       = 159,
	RootMotion_Enable                        = 160,
	HealthBarOff                             = 161,
	HealthBarOn                              = 162,
	EventPairCustom1_Add                     = 163,
	EventPairCustom1_Remove                  = 164,
	LockStart                                = 165,
	LockTurn                                 = 166,
	SetCollision_Default                     = 167,
	SetCollision_Custom1                     = 168,
	SetCollision_Custom2                     = 169,
	SetCollision_Custom3                     = 170,
	SetCollisionVsCharacters_Clear           = 171,
	SetCollisionVsCharacters_Default         = 172,
	SetCollisionVsCharacters_Custom1         = 173,
	SetCollisionVsCharacters_Custom2         = 174,
	SetCollisionVsCharacters_Custom3         = 175,
	EAnimEventType_MAX                       = 176,
};

// Enum man.EAttribute
// NumValues: 0x0098
enum class EAttribute : uint8
{
	Unset                                    = 0,
	MoveSpeed                                = 1,
	AttackSpeed                              = 2,
	Health                                   = 3,
	Poise                                    = 4,
	PoiseBonusForward                        = 5,
	HyperArmor                               = 6,
	Stamina                                  = 7,
	StaminaRegen                             = 8,
	StaminaRegenDelay                        = 9,
	StaminaCostReduction                     = 10,
	StaminaDamage                            = 11,
	Haste                                    = 12,
	Gravity                                  = 13,
	MaxComboPoint                            = 14,
	MaxRage                                  = 15,
	DamageReceived_Physical                  = 16,
	DamageReceived_Structure                 = 17,
	DamageReceived_Arcane                    = 18,
	DamageReceived_Wild                      = 19,
	DamageReceived_Poison                    = 20,
	DamageReceived_Bleed                     = 21,
	DamageReceived_Fire                      = 22,
	DamageReceived_Void                      = 23,
	DamageReceived_Frost                     = 24,
	DamageReceived_Chaos                     = 25,
	DamageReceived_FloorStructure            = 26,
	Constitution                             = 27,
	Defense                                  = 28,
	Strength                                 = 29,
	Endurance                                = 30,
	Armor                                    = 31,
	ArmorPenetration                         = 32,
	EquipLoad                                = 33,
	EquipLoadModifier                        = 34,
	DamageDone_Physical                      = 35,
	DamageDone_Structure                     = 36,
	DamageDone_Arcane                        = 37,
	DamageDone_Wild                          = 38,
	DamageDone_Poison                        = 39,
	DamageDone_Bleed                         = 40,
	DamageDone_Fire                          = 41,
	DamageDone_Void                          = 42,
	DamageDone_Frost                         = 43,
	DamageDone_Chaos                         = 44,
	DamageDone_FloorStructure                = 45,
	Resistance_Physical                      = 46,
	Resistance_Structure                     = 47,
	Resistance_Arcane                        = 48,
	Resistance_Wild                          = 49,
	Resistance_Poison                        = 50,
	Resistance_Bleed                         = 51,
	Resistance_Fire                          = 52,
	Resistance_Void                          = 53,
	Resistance_Frost                         = 54,
	Resistance_Chaos                         = 55,
	Resistance_Physical_Final                = 56,
	Resistance_Structure_Final               = 57,
	Resistance_Arcane_Final                  = 58,
	Resistance_Wild_Final                    = 59,
	Resistance_Poison_Final                  = 60,
	Resistance_Bleed_Final                   = 61,
	Resistance_Fire_Final                    = 62,
	Resistance_Void_Final                    = 63,
	Resistance_Frost_Final                   = 64,
	Resistance_Chaos_Final                   = 65,
	Vigor                                    = 66,
	Dexterity                                = 67,
	CriticalChance                           = 68,
	CriticalDamage                           = 69,
	SpellCriticalChance                      = 70,
	BalanceModifierMul                       = 71,
	Power                                    = 72,
	Knowledge                                = 73,
	MaxEnergy                                = 74,
	EnergyCostReduction                      = 75,
	Spirit                                   = 76,
	SpellRange                               = 77,
	CooldownReduction                        = 78,
	OCHealthRegen                            = 79,
	OCEnergyRegen                            = 80,
	FallDamageReduction                      = 81,
	PhysicalWeaponDamageMultiplier           = 82,
	BurnStatusChance                         = 83,
	PoisonStatusChance                       = 84,
	BleedStatusChance                        = 85,
	FreezeStatusChance                       = 86,
	FearStatusChance                         = 87,
	RootStatusChance                         = 88,
	SuperchargedStatusChance                 = 89,
	WeaknessStatusChance                     = 90,
	LightBrandStatusChance                   = 91,
	BurnStatusLengthModifier                 = 92,
	PoisonStatusLengthModifier               = 93,
	BleedStatusLengthModifier                = 94,
	FreezeStatusLengthModifier               = 95,
	FearStatusLengthModifier                 = 96,
	RootStatusLengthModifier                 = 97,
	SuperchargedStatusLengthModifier         = 98,
	WeaknessStatusLengthModifier             = 99,
	WeaknessStatusPowerModifier              = 100,
	RageCostModifier                         = 101,
	PhysicalSkillEnergyCostModifier          = 102,
	ArcaneSkillEnergyCostModifier            = 103,
	WildSkillEnergyCostModifier              = 104,
	PoisionSkillEnergyCostModifier           = 105,
	BleedSkillEnergyCostModifier             = 106,
	FireSkillEnergyCostModifier              = 107,
	VoidSkillEnergyCostModifier              = 108,
	FrostSkillEnergyCostModifier             = 109,
	ChaosSkillEnergyCostModifier             = 110,
	Stagger                                  = 111,
	Noise                                    = 112,
	Visibility                               = 113,
	FlaskHealingToEnergy                     = 114,
	RootMotionSpeedX                         = 115,
	HealEffectivenessMul                     = 116,
	EnergyRestoreEffectivenessMul            = 117,
	ItemDropChancePercentage                 = 118,
	EntropyLifeAuraDrainModifier             = 119,
	EntropyLifeAuraDamageModifier            = 120,
	EntropyLifeAuraDamageStartDelay          = 121,
	EntropyLifeAuraCapacity                  = 122,
	EntropyLifeAuraRegen                     = 123,
	EntropyLifeAuraRegenMulti                = 124,
	EntropyLifeAuraGainModifierFromChests    = 125,
	EntropyHealthRegen                       = 126,
	EntropySpeedBonus                        = 127,
	EntropyDamageBonus                       = 128,
	EntropyRestoreHealth                     = 129,
	EntropyAoEDamage                         = 130,
	EntropyDarkAreaDrainReduction            = 131,
	EntropyDarkAreaDrainReductionMulti       = 132,
	EntropyLifeSteal                         = 133,
	WeaponMutiliate                          = 134,
	Mutiliate                                = 135,
	MutiliateResistance                      = 136,
	WeaponSmash                              = 137,
	Smash                                    = 138,
	SmashResistance                          = 139,
	SpellBuff                                = 140,
	ChaosFactor                              = 141,
	EssenceGainModifier                      = 142,
	RelicChargeGainModifier                  = 143,
	ShieldChargeGainModifier                 = 144,
	RageDecayModifier                        = 145,
	GoldDropQuantityModifier                 = 146,
	EssenceDropQuantityModifier              = 147,
	EntropicEssenceDropQuantityModifier      = 148,
	RageIncreaseModifier                     = 149,
	Num                                      = 150,
	EAttribute_MAX                           = 151,
};

// Enum man.EEntityProperty
// NumValues: 0x0009
enum class EEntityProperty : uint8
{
	Health                                   = 0,
	Stamina                                  = 1,
	Rage                                     = 2,
	Energy                                   = 3,
	ComboPoint                               = 4,
	EnergyPerSec                             = 5,
	RagePerSec                               = 6,
	None                                     = 255,
	EEntityProperty_MAX                      = 256,
};

// Enum man.EStatusEffectType
// NumValues: 0x000C
enum class EStatusEffectType : uint8
{
	None                                     = 0,
	Burn                                     = 1,
	Poisoned                                 = 2,
	Bleed                                    = 3,
	Freeze                                   = 4,
	Fear                                     = 5,
	Root                                     = 6,
	Weakness                                 = 7,
	Lightbrand                               = 8,
	Supercharged                             = 9,
	NumTotal                                 = 10,
	EStatusEffectType_MAX                    = 11,
};

// Enum man.EStatusEffectChange
// NumValues: 0x0008
enum class EStatusEffectChange : uint8
{
	Added                                    = 0,
	Removed                                  = 1,
	Refreshed                                = 2,
	UnaffectActivated                        = 3,
	UnaffectDeactivated                      = 4,
	ImmunityActivated                        = 5,
	ImmunityDeactivated                      = 6,
	EStatusEffectChange_MAX                  = 7,
};

// Enum man.EAbilityModifierIgnores
// NumValues: 0x0002
enum class EAbilityModifierIgnores : uint8
{
	DmgSetCompModifierIgnore                 = 0,
	EAbilityModifierIgnores_MAX              = 1,
};

// Enum man.ENumDisplayType
// NumValues: 0x0004
enum class ENumDisplayType : uint8
{
	Raw                                      = 0,
	AdditivePercentage                       = 1,
	PercentageMultiplier                     = 2,
	ENumDisplayType_MAX                      = 3,
};

// Enum man.ManTooltipNumericDataID
// NumValues: 0x0011
enum class EManTooltipNumericDataID : uint32
{
	None                                     = 0,
	Misc                                     = 1,
	Damage                                   = 2,
	Heal                                     = 3,
	Duration                                 = 4,
	Scale                                    = 5,
	Energy                                   = 6,
	ModifierAdd                              = 7,
	ModifierMul                              = 8,
	Charge                                   = 9,
	SizeScaleZ                               = 10,
	TrailTime                                = 11,
	SecondDamage                             = 12,
	SecondDamageScale                        = 13,
	Chance                                   = 14,
	FirstDamage                              = 15,
	ManTooltipNumericDataID_MAX              = 16,
};

// Enum man.EAbilityTag
// NumValues: 0x000D
enum class EAbilityTag : uint8
{
	None                                     = 0,
	Attack                                   = 1,
	Utility                                  = 2,
	Weapon                                   = 3,
	Spell                                    = 4,
	SingleTarget                             = 5,
	AOE                                      = 6,
	AIDodgeable                              = 7,
	Lightning                                = 8,
	DoSpellCritical                          = 9,
	DoWeaponCritical                         = 10,
	IgnoreWeaponCritical                     = 11,
	EAbilityTag_MAX                          = 12,
};

// Enum man.EWeaponType
// NumValues: 0x0018
enum class EWeaponType : uint8
{
	Empty                                    = 0,
	All                                      = 1,
	DoNotCheck                               = 2,
	Sword                                    = 3,
	Mace                                     = 4,
	Glaive                                   = 5,
	Shield                                   = 6,
	FireRelic                                = 7,
	ChaosRelic                               = 8,
	WyldRelic                                = 9,
	OrderRelic                               = 10,
	OrderChaosRelic                          = 11,
	WyldFireRelic                            = 12,
	WyldOrderRelic                           = 13,
	ChaosFireRelic                           = 14,
	FireOrderRelic                           = 15,
	WyldChaosRelic                           = 16,
	Crossbow                                 = 17,
	DualWieldMainHand                        = 18,
	DualWieldOffHand                         = 19,
	AnyOrderRelic                            = 20,
	PhysicalWeapons                          = 21,
	Num                                      = 22,
	EWeaponType_MAX                          = 23,
};

// Enum man.ELimitedEffectAbilityTag
// NumValues: 0x0005
enum class ELimitedEffectAbilityTag : uint8
{
	None                                     = 0,
	DefensivePotionEffect                    = 1,
	OffensivePotionEffect                    = 2,
	FoodEffect                               = 3,
	ELimitedEffectAbilityTag_MAX             = 4,
};

// Enum man.EVariableObject
// NumValues: 0x0006
enum class EVariableObject : uint8
{
	Auto                                     = 0,
	This                                     = 1,
	Entity                                   = 2,
	Ability                                  = 3,
	Component                                = 4,
	EVariableObject_MAX                      = 5,
};

// Enum man.EVariableType
// NumValues: 0x0006
enum class EVariableType : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	Varlist                                  = 2,
	Blueprint                                = 3,
	Native                                   = 4,
	EVariableType_MAX                        = 5,
};

// Enum man.EAbilityHand
// NumValues: 0x0004
enum class EAbilityHand : uint8
{
	RightHand                                = 0,
	LeftHand                                 = 1,
	BothHand                                 = 2,
	EAbilityHand_MAX                         = 3,
};

// Enum man.EAbilityCharacter
// NumValues: 0x000B
enum class EAbilityCharacter : uint8
{
	Owner                                    = 0,
	MasterOwner                              = 1,
	OnHitTarget                              = 2,
	Target                                   = 3,
	Caster                                   = 4,
	PlayerHero                               = 5,
	Summoner                                 = 6,
	ProjectileCurrentHitActor                = 7,
	Instigator                               = 8,
	None                                     = 9,
	EAbilityCharacter_MAX                    = 10,
};

// Enum man.EItemSlot
// NumValues: 0x001A
enum class EItemSlot : uint8
{
	OffHand                                  = 0,
	MainHand                                 = 1,
	TwoHand                                  = 2,
	AnyHand                                  = 3,
	Head                                     = 4,
	Shoulder                                 = 5,
	Neck                                     = 6,
	Chest                                    = 7,
	Hands                                    = 8,
	BodyGarment                              = 9,
	Misc                                     = 10,
	Waist                                    = 11,
	Back                                     = 12,
	Legs                                     = 13,
	Feet                                     = 14,
	Finger                                   = 15,
	Potion                                   = 16,
	Trinket                                  = 17,
	BackPack                                 = 18,
	QuickUse                                 = 19,
	BackPackUseable                          = 20,
	NoEquip                                  = 21,
	Material                                 = 22,
	QuestItem                                = 23,
	Num                                      = 24,
	EItemSlot_MAX                            = 25,
};

// Enum man.EQuickUseItemSubType
// NumValues: 0x000E
enum class EQuickUseItemSubType : uint8
{
	None                                     = 0,
	HealthPotion                             = 1,
	ManaPotion                               = 2,
	OtherPotion                              = 3,
	Bandage                                  = 4,
	ArmorKit                                 = 5,
	Oil                                      = 6,
	Stone                                    = 7,
	EntropicEssence                          = 8,
	ThrowingKnife                            = 9,
	MandrakeRoot                             = 10,
	Charm                                    = 11,
	Warpstone                                = 12,
	EQuickUseItemSubType_MAX                 = 13,
};

// Enum man.ESubItemType
// NumValues: 0x0020
enum class ESubItemType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Lockpick                                 = 2,
	Key                                      = 3,
	Cloth                                    = 4,
	Leather                                  = 5,
	Mail                                     = 6,
	Plate                                    = 7,
	SkillBook                                = 8,
	Mineral                                  = 9,
	Fabric                                   = 10,
	Herb                                     = 11,
	Occult                                   = 12,
	TowerShield                              = 13,
	Exploration                              = 14,
	ItemBuffs                                = 15,
	Food                                     = 16,
	OffensivePotions                         = 17,
	DefensivePotions                         = 18,
	Runestone                                = 19,
	Diagram_Armor                            = 20,
	Diagram_Weapon                           = 21,
	Diagram_Jewelry                          = 22,
	Diagram_Food                             = 23,
	Diagram_Occult                           = 24,
	Diagram_Alchemy                          = 25,
	MapFragment                              = 26,
	CoalescedEssence                         = 27,
	Relic                                    = 28,
	Misc                                     = 29,
	TransmogHidden                           = 30,
	ESubItemType_MAX                         = 31,
};

// Enum man.EMainItemType
// NumValues: 0x000C
enum class EMainItemType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Misc                                     = 2,
	Armor                                    = 3,
	Weapon                                   = 4,
	Jewelry                                  = 5,
	Consumable                               = 6,
	Diagram                                  = 7,
	CraftingMaterial                         = 8,
	QuestItem                                = 9,
	Gold                                     = 10,
	EMainItemType_MAX                        = 11,
};

// Enum man.EAbilityEventType
// NumValues: 0x0039
enum class EAbilityEventType : uint8
{
	Start                                    = 0,
	End                                      = 1,
	AnimEvent                                = 2,
	CharacterHit                             = 3,
	CharacterHitEffectiveDamage              = 4,
	LeftHandHit                              = 5,
	RightHandHit                             = 6,
	LeftLegHit                               = 7,
	RighLegHit                               = 8,
	BodyHit                                  = 9,
	TailHit                                  = 10,
	HeadHit                                  = 11,
	ChargeHit                                = 12,
	JumpHit                                  = 13,
	Custom1Hit                               = 14,
	Custom2Hit                               = 15,
	Custom3Hit                               = 16,
	AITargetLost                             = 17,
	CustomName                               = 18,
	EndSucceed                               = 19,
	EndInterrupted                           = 20,
	PostEndSucceed                           = 21,
	PostEndInterrupted                       = 22,
	Nothing                                  = 23,
	PreKill                                  = 24,
	PostKill                                 = 25,
	Ambush                                   = 26,
	OnAdded                                  = 27,
	OnRemoved                                = 28,
	Custom1                                  = 29,
	Custom2                                  = 30,
	Custom3                                  = 31,
	Custom4                                  = 32,
	Custom5                                  = 33,
	Custom6                                  = 34,
	Custom7                                  = 35,
	Custom8                                  = 36,
	Custom9                                  = 37,
	EffectiveDamageCaused                    = 38,
	EffectiveDamageCausedOnEnemy             = 39,
	Dummy                                    = 40,
	PreDamageReceived                        = 41,
	DamageCaused                             = 42,
	DamageTaken                              = 43,
	CriticalDamageCaused                     = 44,
	Switch                                   = 45,
	CharacterCollide_Remove                  = 46,
	CharacterCollide_Add                     = 47,
	OnEntityTeleportPost                     = 48,
	StatusEffectReceived                     = 49,
	StatusEffectRemoved                      = 50,
	UseLever                                 = 51,
	ResetHit                                 = 52,
	LoopAnimEnd                              = 53,
	SetSlotItemVisible                       = 54,
	SetSlotItemHide                          = 55,
	EAbilityEventType_MAX                    = 56,
};

// Enum man.EManProjectileEventType
// NumValues: 0x0003
enum class EManProjectileEventType : uint8
{
	CharacterHit                             = 0,
	Bounced                                  = 1,
	EManProjectileEventType_MAX              = 2,
};

// Enum man.EFlyComponentTargetMode
// NumValues: 0x0006
enum class EFlyComponentTargetMode : uint32
{
	Center                                   = 0,
	Feet                                     = 1,
	Head                                     = 2,
	StandingHeadPosition                     = 3,
	HomingMarkedHurtBox                      = 4,
	EFlyComponentTargetMode_MAX              = 5,
};

// Enum man.ManExtentType
// NumValues: 0x0006
enum class EManExtentType : uint32
{
	All                                      = 0,
	General                                  = 1,
	ManBoundingBox                           = 2,
	ManHitBox                                = 3,
	ManEnemyBox                              = 4,
	ManExtentType_MAX                        = 5,
};

// Enum man.EFlyComponentMode
// NumValues: 0x0004
enum class EFlyComponentMode : uint32
{
	Simple                                   = 0,
	Homing                                   = 1,
	Swing                                    = 2,
	EFlyComponentMode_MAX                    = 3,
};

// Enum man.EManDLC
// NumValues: 0x000B
enum class EManDLC : uint8
{
	None                                     = 0,
	KickstarterPetFollower                   = 1,
	KickstarterArmorTransmogSet              = 2,
	DeluxePetFollower                        = 3,
	DeluxeArmorTransmogSet                   = 4,
	PreorderPetFollower                      = 5,
	PreorderArmorTransmogSet                 = 6,
	PreorderQuest                            = 7,
	DigitalSoundtrack                        = 8,
	DigitalArtbook                           = 9,
	EManDLC_MAX                              = 10,
};

// Enum man.EHudMessage
// NumValues: 0x0002
enum class EHudMessage : uint8
{
	CharacterStandUp                         = 0,
	EHudMessage_MAX                          = 1,
};

// Enum man.EHeroProperty
// NumValues: 0x0048
enum class EHeroProperty : uint8
{
	Health                                   = 0,
	HealthMax                                = 1,
	Stamina                                  = 2,
	StaminaMax                               = 3,
	Rage                                     = 4,
	RageMax                                  = 5,
	Gold                                     = 6,
	Essence                                  = 7,
	Constitution                             = 8,
	Defense                                  = 9,
	Strength                                 = 10,
	Endurance                                = 11,
	Armor                                    = 12,
	HUDAttribute                             = 13,
	HUDSkillPoint                            = 14,
	HUDLanternSkillPoint                     = 15,
	RequiredEssence                          = 16,
	EssenceNeededForLevelUpRemain            = 17,
	LevelAfterConfirm                        = 18,
	HeroLevel                                = 19,
	CarryLoad                                = 20,
	Poise                                    = 21,
	WeaponDamage                             = 22,
	PhysicalResistance                       = 23,
	Resistance_Magical                       = 24,
	Resistance_Structure                     = 25,
	Resistance_Arcane                        = 26,
	Resistance_Wild                          = 27,
	Resistance_Poison                        = 28,
	Resistance_Bleed                         = 29,
	Resistance_Fire                          = 30,
	Resistance_Void                          = 31,
	Resistance_Frost                         = 32,
	Resistance_Chaos                         = 33,
	Evasion                                  = 34,
	Vigor                                    = 35,
	CarryWeight                              = 36,
	Dexterity                                = 37,
	EquipLoad                                = 38,
	Power                                    = 39,
	Knowledge                                = 40,
	Energy                                   = 41,
	EnergyMax                                = 42,
	Spirit                                   = 43,
	StaminaRegeneration                      = 44,
	Stagger                                  = 45,
	CriticalChance                           = 46,
	SpellCriticalChance                      = 47,
	CriticalDamage                           = 48,
	EvasionChance                            = 49,
	FallDamageReduction                      = 50,
	CCEffectReduction                        = 51,
	OffHandDamage                            = 52,
	BurnStatusChance                         = 53,
	PoisonStatusChance                       = 54,
	BleedStatusChance                        = 55,
	FreezeStatusChance                       = 56,
	FearStatusChance                         = 57,
	RootStatusChance                         = 58,
	SuperchargedStatusChance                 = 59,
	WeaknessStatusChance                     = 60,
	LightBrandStatusChance                   = 61,
	PriorityHealthPool                       = 62,
	EntropicEssence                          = 63,
	TemporaryEntropicEssence                 = 64,
	UISpellPower                             = 65,
	UISpiritPower                            = 66,
	HealthDamageBuffer                       = 67,
	ComboPoint                               = 68,
	ComboPointMax                            = 69,
	Num                                      = 70,
	EHeroProperty_MAX                        = 71,
};

// Enum man.EGameplayVFXEvent
// NumValues: 0x0003
enum class EGameplayVFXEvent : uint8
{
	Interrupted                              = 0,
	Ended                                    = 1,
	EGameplayVFXEvent_MAX                    = 2,
};

// Enum man.EFadeState
// NumValues: 0x0005
enum class EFadeState : uint8
{
	Inactive                                 = 0,
	FadeIn                                   = 1,
	Waiting                                  = 2,
	FadeOut                                  = 3,
	EFadeState_MAX                           = 4,
};

// Enum man.EAbilityCostUseType
// NumValues: 0x0004
enum class EAbilityCostUseType : uint8
{
	Fixed                                    = 0,
	PerSec                                   = 1,
	Minimum                                  = 2,
	EAbilityCostUseType_MAX                  = 3,
};

// Enum man.EAnimAttackHeightType
// NumValues: 0x0004
enum class EAnimAttackHeightType : uint8
{
	NoInformation                            = 0,
	UpperBodyAttack                          = 1,
	LowerBodyAttack                          = 2,
	EAnimAttackHeightType_MAX                = 3,
};

// Enum man.EpropertyType
// NumValues: 0x0003
enum class EpropertyType : uint8
{
	Damage                                   = 0,
	None                                     = 1,
	EpropertyType_MAX                        = 2,
};

// Enum man.EClassType
// NumValues: 0x0005
enum class EClassType : uint8
{
	Ability                                  = 0,
	Character                                = 1,
	WeaponIC                                 = 2,
	None                                     = 3,
	EClassType_MAX                           = 4,
};

// Enum man.EQuestAction
// NumValues: 0x0006
enum class EQuestAction : uint8
{
	AddQuest                                 = 0,
	CompleteQuest                            = 1,
	CompleteQuestObjective                   = 2,
	ForceComplete                            = 3,
	None                                     = 255,
	EQuestAction_MAX                         = 256,
};

// Enum man.EPlayAnimComponentNodeCondition
// NumValues: 0x0005
enum class EPlayAnimComponentNodeCondition : uint8
{
	Auto                                     = 0,
	MoveStop01                               = 1,
	MoveStop02                               = 2,
	TargetDistGreater                        = 3,
	EPlayAnimComponentNodeCondition_MAX      = 4,
};

// Enum man.UStatusManagementChoice
// NumValues: 0x0005
enum class EUStatusManagementChoice : uint32
{
	Add                                      = 0,
	Remove                                   = 1,
	Immunity                                 = 2,
	Unaffect                                 = 3,
	UStatusManagementChoice_MAX              = 4,
};

// Enum man.EAirAIAttackPositionSideCheck
// NumValues: 0x0004
enum class EAirAIAttackPositionSideCheck : uint8
{
	Both                                     = 0,
	FrontalOnly                              = 1,
	BackOnly                                 = 2,
	EAirAIAttackPositionSideCheck_MAX        = 3,
};

// Enum man.EAirAIReturnStates
// NumValues: 0x0004
enum class EAirAIReturnStates : uint8
{
	StartReady                               = 0,
	Idle                                     = 1,
	PreCombat                                = 2,
	EAirAIReturnStates_MAX                   = 3,
};

// Enum man.EAnimDebugModeType
// NumValues: 0x0006
enum class EAnimDebugModeType : uint8
{
	None                                     = 0,
	Movement                                 = 1,
	Knockback                                = 2,
	Push                                     = 3,
	Hit                                      = 4,
	EAnimDebugModeType_MAX                   = 5,
};

// Enum man.EAnimTurnType
// NumValues: 0x0005
enum class EAnimTurnType : uint8
{
	Nowhere                                  = 0,
	Inwards                                  = 1,
	Outwards                                 = 2,
	FlipFacing                               = 3,
	EAnimTurnType_MAX                        = 4,
};

// Enum man.EAnimImpulseType
// NumValues: 0x0004
enum class EAnimImpulseType : uint8
{
	Knockback                                = 0,
	Push                                     = 1,
	Hit                                      = 2,
	EAnimImpulseType_MAX                     = 3,
};

// Enum man.EAnimNotifyStateType
// NumValues: 0x0003
enum class EAnimNotifyStateType : uint8
{
	LockMove                                 = 0,
	TurnInwards                              = 1,
	EAnimNotifyStateType_MAX                 = 2,
};

// Enum man.ERightHandAnimationType
// NumValues: 0x0004
enum class ERightHandAnimationType : uint8
{
	Default                                  = 0,
	Mace                                     = 1,
	Cup                                      = 2,
	ERightHandAnimationType_MAX              = 3,
};

// Enum man.ELeftHandAnimationType
// NumValues: 0x0004
enum class ELeftHandAnimationType : uint8
{
	Default                                  = 0,
	Rune                                     = 1,
	Shield                                   = 2,
	ELeftHandAnimationType_MAX               = 3,
};

// Enum man.EWeaponHolderType
// NumValues: 0x0006
enum class EWeaponHolderType : uint8
{
	LeftHand                                 = 0,
	RightHand                                = 1,
	Back                                     = 2,
	BackSecond                               = 3,
	RightHandStaff                           = 4,
	EWeaponHolderType_MAX                    = 5,
};

// Enum man.ECombatModeType
// NumValues: 0x0006
enum class ECombatModeType : uint8
{
	OffCombat                                = 0,
	OneHanded                                = 1,
	TwoHandedSword                           = 2,
	TwoHandedMace                            = 3,
	DualWield                                = 4,
	ECombatModeType_MAX                      = 5,
};

// Enum man.EHealthBarTypeModifier
// NumValues: 0x0004
enum class EHealthBarTypeModifier : uint8
{
	Nothing                                  = 0,
	Gold                                     = 1,
	Purple                                   = 2,
	EHealthBarTypeModifier_MAX               = 3,
};

// Enum man.EAbilityFailReason
// NumValues: 0x0014
enum class EAbilityFailReason : uint8
{
	Undefined                                = 0,
	NoTarget                                 = 1,
	NoResources                              = 2,
	NoResources_Stamina                      = 3,
	NotReady                                 = 4,
	CannotDo                                 = 5,
	CannotDo_Stunned                         = 6,
	OneHandedWeapon                          = 7,
	AnyOffhand                               = 8,
	NonDWOneHandedWeapon                     = 9,
	TwoHandedWeapon                          = 10,
	TwoHandedSword                           = 11,
	TwoHandedMace                            = 12,
	Shield                                   = 13,
	FireRelic                                = 14,
	OrderRelic                               = 15,
	WyldRelic                                = 16,
	ChaosRelic                               = 17,
	MixedRelic                               = 18,
	EAbilityFailReason_MAX                   = 19,
};

// Enum man.EWeaponLayoutIgnores
// NumValues: 0x0004
enum class EWeaponLayoutIgnores : uint8
{
	None                                     = 0,
	IgnoreOffhandRule                        = 1,
	IgnoreMainhandRule                       = 2,
	EWeaponLayoutIgnores_MAX                 = 3,
};

// Enum man.EAimInputMode
// NumValues: 0x0004
enum class EAimInputMode : uint8
{
	KeyboardAndMouse                         = 0,
	KeyboardOnly                             = 1,
	MouseOnly                                = 2,
	EAimInputMode_MAX                        = 3,
};

// Enum man.EMiniMapGatewayState
// NumValues: 0x0004
enum class EMiniMapGatewayState : uint8
{
	Hidden                                   = 0,
	Closed                                   = 1,
	Open                                     = 2,
	EMiniMapGatewayState_MAX                 = 3,
};

// Enum man.EMiniMapGatewaySide
// NumValues: 0x0006
enum class EMiniMapGatewaySide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Bottom                                   = 3,
	Top                                      = 4,
	EMiniMapGatewaySide_MAX                  = 5,
};

// Enum man.EMiniMapActorState
// NumValues: 0x0006
enum class EMiniMapActorState : uint8
{
	Default                                  = 0,
	Hidden                                   = 1,
	Open                                     = 2,
	KeyLocked                                = 3,
	Dead                                     = 4,
	EMiniMapActorState_MAX                   = 5,
};

// Enum man.ERotationSelector
// NumValues: 0x0006
enum class ERotationSelector : uint8
{
	DontRotate                               = 0,
	RotateToAttachParent                     = 1,
	LeftForearmDirection                     = 2,
	EntityFacing                             = 3,
	EntityOwnerFacing                        = 4,
	ERotationSelector_MAX                    = 5,
};

// Enum man.EAttachTarget
// NumValues: 0x0005
enum class EAttachTarget : uint8
{
	SMSocket                                 = 0,
	ActorComponent                           = 1,
	CenterSocket                             = 2,
	NoAttach                                 = 3,
	EAttachTarget_MAX                        = 4,
};

// Enum man.EEnemyMoveType
// NumValues: 0x0005
enum class EEnemyMoveType : uint8
{
	GroundEnemy                              = 0,
	HoveringEnemy                            = 1,
	FlyingEnemy                              = 2,
	All                                      = 3,
	EEnemyMoveType_MAX                       = 4,
};

// Enum man.EFrontBackSide
// NumValues: 0x0004
enum class EFrontBackSide : uint8
{
	Both                                     = 0,
	Front                                    = 1,
	Back                                     = 2,
	EFrontBackSide_MAX                       = 3,
};

// Enum man.ESideGroups
// NumValues: 0x0006
enum class ESideGroups : uint8
{
	None                                     = 0,
	LeftSide                                 = 1,
	RightSide                                = 2,
	BothSides                                = 3,
	Other                                    = 4,
	ESideGroups_MAX                          = 5,
};

// Enum man.EAttributeAffectType
// NumValues: 0x0004
enum class EAttributeAffectType : uint8
{
	AffectRatio                              = 0,
	SpecialFormula                           = 1,
	ModifierTable                            = 2,
	EAttributeAffectType_MAX                 = 3,
};

// Enum man.EEntityTag
// NumValues: 0x000C
enum class EEntityTag : uint8
{
	Custom                                   = 0,
	None                                     = 1,
	Parried                                  = 2,
	Staggered                                = 3,
	Stunned                                  = 4,
	Meltdowned                               = 5,
	Opened                                   = 6,
	KeyLocked                                = 7,
	DoNotTarget                              = 8,
	PlayerCharacter                          = 9,
	Num                                      = 10,
	EEntityTag_MAX                           = 11,
};

// Enum man.EItemEquipQuery
// NumValues: 0x000D
enum class EItemEquipQuery : uint8
{
	LevelRequirementFail                     = 0,
	StrengthRequirementFail                  = 1,
	DexterityRequirementFail                 = 2,
	PowerRequirementFail                     = 3,
	KnowledgeRequirementFail                 = 4,
	SpiritRequirementFail                    = 5,
	ConstitutionRequirementFail              = 6,
	CarryWeightFail                          = 7,
	InvalidWeaponForAbilities                = 8,
	ItemTypeLocked                           = 9,
	ItemNotEquippable                        = 10,
	NoInventoryResource                      = 11,
	EItemEquipQuery_MAX                      = 12,
};

// Enum man.EEquipLoadGroupType
// NumValues: 0x0004
enum class EEquipLoadGroupType : uint8
{
	None                                     = 0,
	LightEquipLoad                           = 1,
	HeavyEquipLoad                           = 2,
	EEquipLoadGroupType_MAX                  = 3,
};

// Enum man.EEquipLoadIndicator
// NumValues: 0x0009
enum class EEquipLoadIndicator : uint8
{
	Default                                  = 0,
	Blue                                     = 1,
	Green                                    = 2,
	Yellow                                   = 3,
	Orange                                   = 4,
	Red                                      = 5,
	Black                                    = 6,
	Invalid                                  = 7,
	EEquipLoadIndicator_MAX                  = 8,
};

// Enum man.EFreezeStatusEffectState
// NumValues: 0x0004
enum class EFreezeStatusEffectState : uint8
{
	None                                     = 0,
	Chill                                    = 1,
	Frozen                                   = 2,
	EFreezeStatusEffectState_MAX             = 3,
};

// Enum man.ECompare
// NumValues: 0x0007
enum class ECompare : uint8
{
	None                                     = 0,
	Equal                                    = 1,
	Greater                                  = 2,
	GreaterEqual                             = 3,
	Less                                     = 4,
	LessEqual                                = 5,
	ECompare_MAX                             = 6,
};

// Enum man.EScreenSideEffect
// NumValues: 0x000A
enum class EScreenSideEffect : uint8
{
	None                                     = 0,
	LowMana                                  = 1,
	LowLife                                  = 2,
	Stun                                     = 3,
	LowRage                                  = 4,
	LowComboPoint                            = 5,
	LowStamina                               = 6,
	PurgingRainLeft                          = 7,
	PurgingRainRight                         = 8,
	EScreenSideEffect_MAX                    = 9,
};

// Enum man.EHitBType
// NumValues: 0x0007
enum class EHitBType : uint8
{
	WeaponRight                              = 0,
	WeaponLeft                               = 1,
	BodyRight                                = 2,
	BodyLeft                                 = 3,
	Other                                    = 4,
	None                                     = 5,
	EHitBType_MAX                            = 6,
};

// Enum man.EInteractType
// NumValues: 0x0006
enum class EInteractType : uint8
{
	None                                     = 0,
	Gather                                   = 1,
	LeverPull                                = 2,
	DoorEnter                                = 3,
	NPCInteract                              = 4,
	EInteractType_MAX                        = 5,
};

// Enum man.EBuffType
// NumValues: 0x0004
enum class EBuffType : uint8
{
	Buff                                     = 0,
	Debuff                                   = 1,
	Other                                    = 2,
	EBuffType_MAX                            = 3,
};

// Enum man.EDamageCollectionType
// NumValues: 0x0007
enum class EDamageCollectionType : uint8
{
	Empty                                    = 0,
	All                                      = 1,
	Physical                                 = 2,
	Elemental                                = 3,
	Magic                                    = 4,
	Ailments                                 = 5,
	EDamageCollectionType_MAX                = 6,
};

// Enum man.EDamageScale
// NumValues: 0x0007
enum class EDamageScale : uint8
{
	None                                     = 0,
	StrengthScale                            = 1,
	DexterityScale                           = 2,
	PowerScale                               = 3,
	SpiritScale                              = 4,
	ConstitutionScale                        = 5,
	EDamageScale_MAX                         = 6,
};

// Enum man.EItemAttribute
// NumValues: 0x0006
enum class EItemAttribute : uint8
{
	None                                     = 0,
	ItemWeight                               = 1,
	ItemBalance                              = 2,
	ItemLength                               = 3,
	ItemStaminaCost                          = 4,
	EItemAttribute_MAX                       = 5,
};

// Enum man.EAttributeVariable
// NumValues: 0x0011
enum class EAttributeVariable : uint8
{
	Unset                                    = 0,
	InputCommandTime_GlobalModifier          = 1,
	InputCommandTime_Uncategorized           = 2,
	InputCommandTime_Attack                  = 3,
	InputCommandTime_Inventory               = 4,
	InputCommandTime_Stunned                 = 5,
	InputCommandTime_FallDamageSpeedReduction = 6,
	FallDamageSpeedReduction                 = 7,
	RageCostModifier                         = 8,
	AddArmorToPhysicalDamage                 = 9,
	ItemWeightModify_Chest                   = 10,
	ItemWeightModify_Head                    = 11,
	ItemWeightModify_Hands                   = 12,
	ItemWeightModify_Legs                    = 13,
	ItemWeightModify_Weapon                  = 14,
	Num                                      = 15,
	EAttributeVariable_MAX                   = 16,
};

// Enum man.EAIMoveSetType
// NumValues: 0x0006
enum class EAIMoveSetType : uint8
{
	Nothing                                  = 0,
	OffCombat                                = 1,
	Combat                                   = 2,
	Run                                      = 3,
	DefensiveStance                          = 4,
	EAIMoveSetType_MAX                       = 5,
};

// Enum man.EBasicAIReturnStates
// NumValues: 0x0004
enum class EBasicAIReturnStates : uint8
{
	StartReady                               = 0,
	PreCombat                                = 1,
	Idle                                     = 2,
	EBasicAIReturnStates_MAX                 = 3,
};

// Enum man.EBlinkAbilityMode
// NumValues: 0x0003
enum class EBlinkAbilityMode : uint8
{
	TimerBlink                               = 0,
	AnimEventBlink                           = 1,
	EBlinkAbilityMode_MAX                    = 2,
};

// Enum man.EBlinkState
// NumValues: 0x0006
enum class EBlinkState : uint8
{
	BlinkStandBy                             = 0,
	BlinkStart                               = 1,
	BlinkPrecursor                           = 2,
	BlinkReappear                            = 3,
	BlinkPostReappear                        = 4,
	EBlinkState_MAX                          = 5,
};

// Enum man.ELookType
// NumValues: 0x0016
enum class ELookType : uint8
{
	FwMid                                    = 0,
	FwUp                                     = 1,
	FwDown                                   = 2,
	BwMid                                    = 3,
	BwUp                                     = 4,
	BwDown                                   = 5,
	FwMidToFwUp                              = 6,
	FwMidToFwDown                            = 7,
	FwMidToBwMid                             = 8,
	FwMidToBwUp                              = 9,
	FwMidToBwDown                            = 10,
	FwUpToBwUp                               = 11,
	BwMidToBwUp                              = 12,
	BwMidToBwDown                            = 13,
	FwDownToBwDown                           = 14,
	FwUpToBwDown                             = 15,
	BwUpToFwDown                             = 16,
	FwUpToBwMid                              = 17,
	FwDownToBwMid                            = 18,
	FwUpToFwDown                             = 19,
	BwUpToBwDown                             = 20,
	ELookType_MAX                            = 21,
};

// Enum man.EBuffBarElementType
// NumValues: 0x0019
enum class EBuffBarElementType : uint8
{
	None                                     = 0,
	Duration                                 = 1,
	Cooldown                                 = 2,
	TimerDuration                            = 3,
	StackNum                                 = 4,
	HitCounter                               = 5,
	ControlledExplosion                      = 6,
	ChaoticEnergies                          = 7,
	HeightenedSenses                         = 8,
	EntropyLantern                           = 9,
	HealOverTime                             = 10,
	TimedAbilityManager                      = 11,
	PreventFatalDamage                       = 12,
	FreezeStatusEffectStack                  = 13,
	TriggerableAbilityMaxTD                  = 14,
	TriggerableAbilityMinTD                  = 15,
	TrinityAbilityDuration                   = 16,
	BeamCharge                               = 17,
	PrismCharge                              = 18,
	FocalizedManaPassive                     = 19,
	DivineAegisBuff                          = 20,
	BlessedWeapon                            = 21,
	DivineWeapon                             = 22,
	Custom                                   = 23,
	EBuffBarElementType_MAX                  = 24,
};

// Enum man.EChannelBaseResourceConsume
// NumValues: 0x0005
enum class EChannelBaseResourceConsume : uint8
{
	ConsumeOnStart                           = 0,
	ConsumeOnFirstUpkeepCostConsume          = 1,
	ConsumeOnTrigger                         = 2,
	ConsumeOnHitStart                        = 3,
	EChannelBaseResourceConsume_MAX          = 4,
};

// Enum man.EChannelAbilityMode
// NumValues: 0x0004
enum class EChannelAbilityMode : uint8
{
	PreChargeThenAttack                      = 0,
	ChargeDuringAttack                       = 1,
	Empty                                    = 2,
	EChannelAbilityMode_MAX                  = 3,
};

// Enum man.EAnimType
// NumValues: 0x0002
enum class EAnimType : uint8
{
	Attack1                                  = 0,
	EAnimType_MAX                            = 1,
};

// Enum man.ECharacterClass
// NumValues: 0x0009
enum class ECharacterClass : uint8
{
	Empty                                    = 0,
	All                                      = 1,
	Larcenist                                = 2,
	Charlatan                                = 3,
	Heretic                                  = 4,
	Warden                                   = 5,
	Priest                                   = 6,
	Armsman                                  = 7,
	ECharacterClass_MAX                      = 8,
};

// Enum man.EManCheatCommandType
// NumValues: 0x0005
enum class EManCheatCommandType : uint8
{
	Default                                  = 0,
	Load                                     = 1,
	Save                                     = 2,
	ForceLoad                                = 3,
	EManCheatCommandType_MAX                 = 4,
};

// Enum man.EManCheatType
// NumValues: 0x0005
enum class EManCheatType : uint8
{
	Unknown                                  = 0,
	Bool                                     = 1,
	Int                                      = 2,
	Action                                   = 3,
	EManCheatType_MAX                        = 4,
};

// Enum man.ELootableChestType
// NumValues: 0x0008
enum class ELootableChestType : uint8
{
	Unspecified                              = 0,
	Wood                                     = 1,
	Bronze                                   = 2,
	Silver                                   = 3,
	Gold                                     = 4,
	Rift                                     = 5,
	Num                                      = 6,
	ELootableChestType_MAX                   = 7,
};

// Enum man.ECreditsScroolSpeed
// NumValues: 0x0003
enum class ECreditsScroolSpeed : uint8
{
	Normal                                   = 0,
	Fast                                     = 1,
	ECreditsScroolSpeed_MAX                  = 2,
};

// Enum man.EAIPhaseFlags
// NumValues: 0x000A
enum class EAIPhaseFlags : uint8
{
	NONE                                     = 0,
	AllPhase                                 = 1,
	Phase1                                   = 2,
	Phase2                                   = 4,
	Phase3                                   = 8,
	Phase4                                   = 16,
	Phase5                                   = 32,
	Phase6                                   = 64,
	Phase7                                   = 128,
	EAIPhaseFlags_MAX                        = 129,
};

// Enum man.EModifyDamageTakenStackType
// NumValues: 0x0004
enum class EModifyDamageTakenStackType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	Num                                      = 2,
	EModifyDamageTakenStackType_MAX          = 3,
};

// Enum man.EDamageMatrixVEForceRotation
// NumValues: 0x0004
enum class EDamageMatrixVEForceRotation : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	EDamageMatrixVEForceRotation_MAX         = 3,
};

// Enum man.EDamageMAtrixType
// NumValues: 0x0004
enum class EDamageMAtrixType : uint8
{
	Causer                                   = 0,
	Taker                                    = 1,
	DamagePosition                           = 2,
	EDamageMAtrixType_MAX                    = 3,
};

// Enum man.EBlockResource
// NumValues: 0x0003
enum class EBlockResource : uint16
{
	BRStamina                                = 0,
	BREnergy                                 = 1,
	EBlockResource_MAX                       = 2,
};

// Enum man.EInfoScreenType
// NumValues: 0x0007
enum class EInfoScreenType : uint8
{
	CopperPlate                              = 0,
	BackersObelisk                           = 1,
	BackersStatue                            = 2,
	BackersGravestone                        = 3,
	Parchment                                = 4,
	BackersPoem                              = 5,
	EInfoScreenType_MAX                      = 6,
};

// Enum man.EAINavTargetType
// NumValues: 0x0004
enum class EAINavTargetType : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	Location                                 = 2,
	EAINavTargetType_MAX                     = 3,
};

// Enum man.EFadeRequester
// NumValues: 0x0010
enum class EFadeRequester : uint8
{
	SkipCutscene                             = 0,
	Cutscene                                 = 1,
	IngameCustomFade                         = 2,
	HeroDeathAbility                         = 3,
	Credits                                  = 4,
	ExitToMainMenu                           = 5,
	ExitToDesktop                            = 6,
	TeleportHelperAbilityQuick               = 7,
	TeleportHelperAbilityNormal              = 8,
	ForcedLoadingScreen                      = 9,
	LoadingScreenQuick                       = 10,
	LoadingScreenNormal                      = 11,
	LevelVisualManagerQuick                  = 12,
	LevelVisualManagerNormal                 = 13,
	Max_None                                 = 14,
	EFadeRequester_MAX                       = 15,
};

// Enum man.EGrabType
// NumValues: 0x0006
enum class EGrabType : uint8
{
	Auto                                     = 0,
	CliffHanging                             = 1,
	HangingWithLeg                           = 2,
	LedgeHanging                             = 3,
	NoGrab                                   = 4,
	EGrabType_MAX                            = 5,
};

// Enum man.EGrabJumpType
// NumValues: 0x0004
enum class EGrabJumpType : uint8
{
	Normal                                   = 0,
	Branch                                   = 1,
	Ledge                                    = 2,
	EGrabJumpType_MAX                        = 3,
};

// Enum man.EGrabSide
// NumValues: 0x0005
enum class EGrabSide : uint8
{
	Auto                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Ledge                                    = 3,
	EGrabSide_MAX                            = 4,
};

// Enum man.EAbilitySlotQuery
// NumValues: 0x000B
enum class EAbilitySlotQuery : uint8
{
	LevelRequirementFail                     = 0,
	StrengthRequirementFail                  = 1,
	DexterityRequirementFail                 = 2,
	PowerRequirementFail                     = 3,
	KnowledgeRequirementFail                 = 4,
	SpiritRequirementFail                    = 5,
	ConstitutionRequirementFail              = 6,
	AbilityNotLearned                        = 7,
	WrongSlot                                = 8,
	QueryFail                                = 9,
	EAbilitySlotQuery_MAX                    = 10,
};

// Enum man.EHeroAbilityShootMode
// NumValues: 0x0003
enum class EHeroAbilityShootMode : uint32
{
	HitStartShoot                            = 0,
	TimedShoot                               = 1,
	EHeroAbilityShootMode_MAX                = 2,
};

// Enum man.EHitBoxType
// NumValues: 0x0005
enum class EHitBoxType : uint8
{
	Default                                  = 0,
	WeaponLine                               = 1,
	FatDepth                                 = 2,
	True3D                                   = 3,
	EHitBoxType_MAX                          = 4,
};

// Enum man.EHotkeyVisibleType
// NumValues: 0x0004
enum class EHotkeyVisibleType : uint8
{
	Automatic                                = 0,
	OnlyController                           = 1,
	OnlyKeyboard                             = 2,
	EHotkeyVisibleType_MAX                   = 3,
};

// Enum man.EHasInventoryResourceResult
// NumValues: 0x000A
enum class EHasInventoryResourceResult : uint8
{
	Succeed                                  = 0,
	Combat                                   = 1,
	Air                                      = 2,
	Ladder                                   = 3,
	Ability                                  = 4,
	Anim                                     = 5,
	AirAnim                                  = 6,
	Stunned                                  = 7,
	CannotDo                                 = 8,
	EHasInventoryResourceResult_MAX          = 9,
};

// Enum man.EEnchantType
// NumValues: 0x0005
enum class EEnchantType : uint8
{
	None                                     = 0,
	SpellEnchant                             = 1,
	ConsumableEnchant                        = 2,
	RuneEnchant                              = 3,
	EEnchantType_MAX                         = 4,
};

// Enum man.EInventorySlot
// NumValues: 0x0017
enum class EInventorySlot : uint8
{
	OffHand                                  = 0,
	MainHand                                 = 1,
	Head                                     = 2,
	Shoulder                                 = 3,
	Neck                                     = 4,
	Chest                                    = 5,
	Hands                                    = 6,
	BodyGarment                              = 7,
	Misc                                     = 8,
	Waist                                    = 9,
	Back                                     = 10,
	Legs                                     = 11,
	Feet                                     = 12,
	Finger1                                  = 13,
	Finger2                                  = 14,
	Finger3                                  = 15,
	Finger4                                  = 16,
	Trinket                                  = 17,
	QuickUse                                 = 18,
	Num                                      = 19,
	BackPack                                 = 20,
	None                                     = 21,
	EInventorySlot_MAX                       = 22,
};

// Enum man.EKingPriestVoidPlatformType
// NumValues: 0x0006
enum class EKingPriestVoidPlatformType : uint8
{
	Nothing                                  = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	EKingPriestVoidPlatformType_MAX          = 5,
};

// Enum man.ELadderType
// NumValues: 0x0004
enum class ELadderType : uint8
{
	Uninitialized                            = 0,
	Ground                                   = 1,
	Air                                      = 2,
	ELadderType_MAX                          = 3,
};

// Enum man.ELootFragmentType
// NumValues: 0x0004
enum class ELootFragmentType : uint8
{
	Essence                                  = 0,
	EntropicEssence                          = 1,
	Gold                                     = 2,
	ELootFragmentType_MAX                    = 3,
};

// Enum man.EMainMenuRequest
// NumValues: 0x0007
enum class EMainMenuRequest : uint8
{
	None                                     = 0,
	Quit                                     = 1,
	StartGamePlayDemo                        = 2,
	ShowNewGame                              = 3,
	ShowLoadGame                             = 4,
	ContinueGame                             = 5,
	EMainMenuRequest_MAX                     = 6,
};

// Enum man.EPetFollower
// NumValues: 0x0005
enum class EPetFollower : uint8
{
	Off                                      = 0,
	CraftyKitling                            = 1,
	NimbleDoeling                            = 2,
	CuriousOttling                           = 3,
	MAX                                      = 4,
};

// Enum man.EFloatingTextType
// NumValues: 0x0006
enum class EFloatingTextType : uint8
{
	Damage                                   = 0,
	Heal                                     = 1,
	Dot                                      = 2,
	Gold                                     = 3,
	Essence                                  = 4,
	EFloatingTextType_MAX                    = 5,
};

// Enum man.ESmallScreenMode
// NumValues: 0x0005
enum class ESmallScreenMode : uint8
{
	Off                                      = 0,
	Large                                    = 1,
	SteamDeck                                = 2,
	Switch                                   = 3,
	ESmallScreenMode_MAX                     = 4,
};

// Enum man.EDemoMode
// NumValues: 0x000C
enum class EDemoMode : uint8
{
	None                                     = 0,
	GCDemo2023                               = 1,
	KSDemo2023                               = 2,
	Playtest                                 = 3,
	GCDemo2024                               = 4,
	PressDemo2024                            = 5,
	PublicDemo2024                           = 6,
	KSBeta2024                               = 7,
	EarlyAccess2024                          = 8,
	Preview2                                 = 9,
	Demo25                                   = 10,
	EDemoMode_MAX                            = 11,
};

// Enum man.EInputMode
// NumValues: 0x0007
enum class EInputMode : uint8
{
	Unknown                                  = 0,
	Keyboard                                 = 1,
	XboxSeriesX                              = 2,
	PS5                                      = 3,
	Switch                                   = 4,
	Count                                    = 5,
	EInputMode_MAX                           = 6,
};

// Enum man.ECharacterSide
// NumValues: 0x0004
enum class ECharacterSide : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Any                                      = 2,
	ECharacterSide_MAX                       = 3,
};

// Enum man.EQuestState
// NumValues: 0x0006
enum class EQuestState : uint8
{
	Inactive                                 = 0,
	ActiveTracked                            = 1,
	Active                                   = 2,
	Completed                                = 3,
	Failed                                   = 4,
	EQuestState_MAX                          = 5,
};

// Enum man.EQuestEvent
// NumValues: 0x0007
enum class EQuestEvent : uint8
{
	EntityKilled                             = 0,
	AreaReached                              = 1,
	ItemAquired                              = 2,
	ItemEquipped                             = 3,
	GlobalVariableChanged                    = 4,
	None                                     = 5,
	EQuestEvent_MAX                          = 6,
};

// Enum man.ESavePackageType
// NumValues: 0x0005
enum class ESavePackageType : uint8
{
	Null                                     = 0,
	Hero                                     = 1,
	Level                                    = 2,
	Unified                                  = 3,
	ESavePackageType_MAX                     = 4,
};

// Enum man.EManSkillTreeNodeType
// NumValues: 0x0007
enum class EManSkillTreeNodeType : uint8
{
	Empty                                    = 0,
	Start                                    = 1,
	Attribute1                               = 2,
	Attribute3                               = 3,
	Attribute5                               = 4,
	Ability                                  = 5,
	EManSkillTreeNodeType_MAX                = 6,
};

// Enum man.EManSkillTreeNodeState
// NumValues: 0x0005
enum class EManSkillTreeNodeState : uint8
{
	Accessible                               = 0,
	InAccessible                             = 1,
	Unlocked                                 = 2,
	InvalidNodeStage                         = 3,
	EManSkillTreeNodeState_MAX               = 4,
};

// Enum man.EMapExplorationTileEdgeType
// NumValues: 0x0004
enum class EMapExplorationTileEdgeType : uint8
{
	None                                     = 0,
	Wall                                     = 1,
	GatewayOpen                              = 2,
	EMapExplorationTileEdgeType_MAX          = 3,
};

// Enum man.EMapExplorationTileFlag
// NumValues: 0x000F
enum class EMapExplorationTileFlag : uint32
{
	CornerLeftTop                            = 256,
	CornerRightTop                           = 512,
	CornerRightBottom                        = 1024,
	CornerLeftBottom                         = 2048,
	ExplorableTop                            = 4096,
	ExplorableRight                          = 8192,
	ExplorableBottom                         = 16384,
	ExplorableLeft                           = 32768,
	HiddenSelf                               = 65536,
	HiddenTop                                = 131072,
	HiddenRight                              = 262144,
	HiddenBottom                             = 524288,
	HiddenLeft                               = 1048576,
	ExploreWhenSegmentUnlocked               = 268435456,
	EMapExplorationTileFlag_MAX              = 268435457,
};

// Enum man.EMarionetteTeleportType
// NumValues: 0x0004
enum class EMarionetteTeleportType : uint8
{
	Invalid                                  = 0,
	TeleportToVolley                         = 1,
	TeleportToNeedleStrike                   = 2,
	EMarionetteTeleportType_MAX              = 3,
};

// Enum man.EMarionetteSide
// NumValues: 0x0004
enum class EMarionetteSide : uint8
{
	Left                                     = 0,
	Middle                                   = 1,
	Right                                    = 2,
	EMarionetteSide_MAX                      = 3,
};

// Enum man.EMapExplorationTileEdgeOverride
// NumValues: 0x0005
enum class EMapExplorationTileEdgeOverride : uint8
{
	Keep                                     = 0,
	NoWall                                   = 1,
	Wall                                     = 2,
	GatewayOpen                              = 3,
	EMapExplorationTileEdgeOverride_MAX      = 4,
};

// Enum man.ENpcAnimType
// NumValues: 0x0007
enum class ENpcAnimType : uint8
{
	Idle                                     = 0,
	IdleBridge                               = 1,
	Conversation                             = 2,
	IdleToConversation                       = 3,
	ConversationToIdle                       = 4,
	IdleBridgeToConversation                 = 5,
	ENpcAnimType_MAX                         = 6,
};

// Enum man.EObjectContainerNotifyType
// NumValues: 0x0004
enum class EObjectContainerNotifyType : uint8
{
	None                                     = 0,
	ChildrenOnly                             = 1,
	SubObjects                               = 2,
	EObjectContainerNotifyType_MAX           = 3,
};

// Enum man.EOptionsType
// NumValues: 0x0048
enum class EOptionsType : uint8
{
	None                                     = 0,
	MasterVolume                             = 1,
	MusicVolume                              = 2,
	DialogueVolume                           = 3,
	SoundEffectsVolume                       = 4,
	SubtitleEnable                           = 5,
	SubtitleSize                             = 6,
	SubtitleBackground                       = 7,
	SubtitleSpeakerNameVisible               = 8,
	ScreenResolution                         = 9,
	DisplayMode                              = 10,
	ResolutionScale                          = 11,
	VSync                                    = 12,
	Brightness                               = 13,
	FPSLimit                                 = 14,
	AdvancedGraphics                         = 15,
	MotionBlur                               = 16,
	ShadowQuality                            = 17,
	TextureQuality                           = 18,
	PostProcessQuality                       = 19,
	EffectsQuality                           = 20,
	CameraShake                              = 21,
	ControlDisplay                           = 22,
	SprintToggleMode                         = 23,
	KeyboardMapping                          = 24,
	ControllerMapping                        = 25,
	XAxis                                    = 26,
	YAxis                                    = 27,
	SwapLeftAndRightSticks                   = 28,
	Vibration                                = 29,
	Language                                 = 30,
	AudioPlayInBackground                    = 31,
	LockCursorToWindow                       = 32,
	UIVolume                                 = 33,
	BackgroundFPSLimit                       = 34,
	CombineSkillAndWeaponSets                = 35,
	VolumetricFogQuality                     = 36,
	EdgeScreenLowResourceFeedback            = 37,
	AbilitiesAndResourcesDownPosition        = 38,
	DisplayPercentageOnResourceBars          = 39,
	QuestTracking                            = 40,
	TextLanguage                             = 41,
	VoiceLanguage                            = 42,
	KSBackerPetFollower                      = 43,
	Monitor                                  = 44,
	Adapter                                  = 45,
	LeftClickToBuySellSelectedItem           = 46,
	CinematicVolume                          = 47,
	InvertMousePan                           = 48,
	MouseCursorSpeed                         = 49,
	MouseAimSpeed                            = 50,
	DepthOfFieldQuality                      = 51,
	AntiAliasingQuality                      = 52,
	ChangeKeyBindings                        = 53,
	GraphicsMode                             = 54,
	EnemyHealthBars                          = 55,
	BossHealthBars                           = 56,
	ActionQueuing                            = 57,
	Difficulty_EnemyHealth                   = 58,
	Difficulty_EnemyDamage                   = 59,
	Difficulty_SkillStaminaCost              = 60,
	ColorBlindMode                           = 61,
	ColorBlindStrength                       = 62,
	DepthOfFieldConsole                      = 63,
	DisplayErrorMessages                     = 64,
	UserInterfaceScale                       = 65,
	UpscaleMethod                            = 66,
	UpscaleQuality                           = 67,
	UpscaleSharpness                         = 68,
	FrameGeneration                          = 69,
	NVIDIAReflexLowLatency                   = 70,
	EOptionsType_MAX                         = 71,
};

// Enum man.UPlatfromMoverState
// NumValues: 0x0007
enum class EUPlatfromMoverState : uint8
{
	Idle                                     = 0,
	Wait                                     = 1,
	Move                                     = 2,
	WaitForTriggerBox                        = 3,
	Break                                    = 4,
	Deactivated                              = 5,
	UPlatfromMoverState_MAX                  = 6,
};

// Enum man.EMovingPlatformType
// NumValues: 0x0005
enum class EMovingPlatformType : uint8
{
	AutomaticCircle                          = 0,
	AutomaticBackAndForth                    = 1,
	ControlledCircle                         = 2,
	ControlledBackAndForth                   = 3,
	EMovingPlatformType_MAX                  = 4,
};

// Enum man.EShiftingPlatformType
// NumValues: 0x0003
enum class EShiftingPlatformType : uint8
{
	Periodic                                 = 0,
	Pressure                                 = 1,
	EShiftingPlatformType_MAX                = 2,
};

// Enum man.EShootValidityError
// NumValues: 0x0005
enum class EShootValidityError : uint8
{
	TargetingSideError                       = 0,
	TargetingAngleError                      = 1,
	PositionToPositionError                  = 2,
	NoAmmunitionError                        = 3,
	EShootValidityError_MAX                  = 4,
};

// Enum man.EShootTargetMode
// NumValues: 0x000A
enum class EShootTargetMode : uint8
{
	AimFeet                                  = 0,
	AimCenter                                = 1,
	AimHead                                  = 2,
	AimStandingHeadPosition                  = 3,
	AimRotation                              = 4,
	AimHorizontal                            = 5,
	AimAdaptiveHorizontal                    = 6,
	AimRandomAngle                           = 7,
	AimCustomPattern                         = 8,
	EShootTargetMode_MAX                     = 9,
};

// Enum man.EShootComponentState
// NumValues: 0x0003
enum class EShootComponentState : uint8
{
	StandBy                                  = 0,
	ShootPreparation                         = 1,
	EShootComponentState_MAX                 = 2,
};

// Enum man.ESkillTreeNodeUnlockQuery
// NumValues: 0x000C
enum class ESkillTreeNodeUnlockQuery : uint8
{
	SkillPointRequirementFail                = 0,
	NeighbourRequirementFail                 = 1,
	AlreadyUnlocked                          = 2,
	Inaccessible                             = 3,
	InvalidNodeType                          = 4,
	InvalidStageType                         = 5,
	InvalidSkillTree                         = 6,
	ItemRequirementFail                      = 7,
	EssenceRequirementFail                   = 8,
	RewardSelector                           = 9,
	LevelRequirement                         = 10,
	ESkillTreeNodeUnlockQuery_MAX            = 11,
};

// Enum man.EStatusEffectState
// NumValues: 0x0005
enum class EStatusEffectState : uint8
{
	Active                                   = 0,
	Inactive                                 = 1,
	Unaffected                               = 2,
	Immune                                   = 3,
	EStatusEffectState_MAX                   = 4,
};

// Enum man.EStickAngleIputSizeType
// NumValues: 0x0005
enum class EStickAngleIputSizeType : uint8
{
	Auto                                     = 0,
	Vector                                   = 1,
	Horizontal                               = 2,
	Vertical                                 = 3,
	EStickAngleIputSizeType_MAX              = 4,
};

// Enum man.ESurfaceSamplingID
// NumValues: 0x000A
enum class ESurfaceSamplingID : uint8
{
	FootFrontRight                           = 0,
	FootFrontLeft                            = 1,
	FootBackRight                            = 2,
	FootBackLeft                             = 3,
	Custom1                                  = 4,
	Custom2                                  = 5,
	Custom3                                  = 6,
	Custom4                                  = 7,
	All                                      = 8,
	ESurfaceSamplingID_MAX                   = 9,
};

// Enum man.ETrapMode
// NumValues: 0x0003
enum class ETrapMode : uint8
{
	OneShotMode                              = 0,
	AutomaticMode                            = 1,
	ETrapMode_MAX                            = 2,
};

// Enum man.ETriggerableAbilityMode
// NumValues: 0x0003
enum class ETriggerableAbilityMode : uint8
{
	NormalExecution                          = 0,
	TriggerableExecution                     = 1,
	ETriggerableAbilityMode_MAX              = 2,
};

// Enum man.ETutorialActionIcon
// NumValues: 0x000B
enum class ETutorialActionIcon : uint8
{
	AttackIcon                               = 0,
	Jump                                     = 1,
	OpenDoor                                 = 2,
	ClimbLadder                              = 3,
	OpenChest                                = 4,
	JumpDownLedge                            = 5,
	Dodge                                    = 6,
	Roll                                     = 7,
	FireBolt                                 = 8,
	Inquisitor_MultiAttack                   = 9,
	ETutorialActionIcon_MAX                  = 10,
};

// Enum man.EMapObjectIconZOrder
// NumValues: 0x0006
enum class EMapObjectIconZOrder : uint8
{
	Default                                  = 0,
	QuestObjective                           = 2,
	Checkpoint                               = 3,
	Marker                                   = 4,
	Character                                = 5,
	MAX                                      = 6,
};

// Enum man.EMapQuestObjectiveType
// NumValues: 0x0006
enum class EMapQuestObjectiveType : uint8
{
	Large                                    = 0,
	Medium                                   = 1,
	Small                                    = 2,
	VeryLarge                                = 3,
	Max_None                                 = 4,
	EMapQuestObjectiveType_MAX               = 5,
};

// Enum man.EHoldState
// NumValues: 0x0005
enum class EHoldState : uint8
{
	Started                                  = 0,
	Finished                                 = 1,
	Canceled                                 = 2,
	Max_None                                 = 3,
	EHoldState_MAX                           = 4,
};

// Enum man.ESkillUpgradeConnectionType
// NumValues: 0x0005
enum class ESkillUpgradeConnectionType : uint8
{
	Left                                     = 0,
	LeftUp                                   = 1,
	Up                                       = 2,
	Max_None                                 = 3,
	ESkillUpgradeConnectionType_MAX          = 4,
};

// Enum man.EBestiaryCategory
// NumValues: 0x0007
enum class EBestiaryCategory : uint8
{
	BasicEnemy                               = 0,
	EliteEnemy                               = 1,
	MiniBoss                                 = 2,
	Boss                                     = 3,
	EntropicEnemy                            = 4,
	Max_None                                 = 5,
	EBestiaryCategory_MAX                    = 6,
};

// Enum man.EInventorySortType
// NumValues: 0x000C
enum class EInventorySortType : uint8
{
	Recency                                  = 0,
	Price                                    = 1,
	Weight                                   = 2,
	Quantity                                 = 3,
	Craftable                                = 4,
	RecipeLevel                              = 5,
	Type                                     = 6,
	ItemLevel                                = 7,
	Alphabetical                             = 8,
	GrowthTime                               = 9,
	CollectionItemLevel                      = 10,
	EInventorySortType_MAX                   = 11,
};

// Enum man.EInventoryType
// NumValues: 0x000B
enum class EInventoryType : uint8
{
	Standard                                 = 0,
	Trade                                    = 1,
	CraftingMaterials                        = 2,
	VendorBuy                                = 3,
	VendorCraft                              = 4,
	Seeds                                    = 5,
	VendorEnchant                            = 6,
	UpgradeableItems                         = 7,
	Transmog                                 = 8,
	Collection                               = 9,
	EInventoryType_MAX                       = 10,
};

// Enum man.EDisplayPercentageOnResourceBarsType
// NumValues: 0x0004
enum class EDisplayPercentageOnResourceBarsType : uint8
{
	Off                                      = 0,
	Percentage                               = 1,
	Value                                    = 2,
	EDisplayPercentageOnResourceBarsType_MAX = 3,
};

// Enum man.ESideEffectWarningType
// NumValues: 0x0004
enum class ESideEffectWarningType : uint8
{
	Off                                      = 0,
	Reduced                                  = 1,
	Strong                                   = 2,
	ESideEffectWarningType_MAX               = 3,
};

// Enum man.EUIRequest
// NumValues: 0x0005
enum class EUIRequest : uint8
{
	None                                     = 0,
	BackToCreateCharacter                    = 1,
	StartNewGame                             = 2,
	ShowCutsceneCinematic                    = 3,
	EUIRequest_MAX                           = 4,
};

// Enum man.ECutsceneCinematicType
// NumValues: 0x0004
enum class ECutsceneCinematicType : uint8
{
	Unskippable                              = 0,
	SkippableByAnyKey                        = 1,
	SkippableByHoldKey                       = 2,
	ECutsceneCinematicType_MAX               = 3,
};

// Enum man.EHUDNotificationType
// NumValues: 0x0006
enum class EHUDNotificationType : uint8
{
	Pickup                                   = 0,
	UseItem                                  = 1,
	Unlock                                   = 2,
	SkillLearn                               = 3,
	TalentPoint                              = 4,
	EHUDNotificationType_MAX                 = 5,
};

// Enum man.EDialogueButtonType
// NumValues: 0x0008
enum class EDialogueButtonType : uint8
{
	Empty                                    = 0,
	Yes                                      = 1,
	No                                       = 2,
	Ok                                       = 3,
	Upgrade                                  = 4,
	Cancel                                   = 5,
	Revert                                   = 6,
	EDialogueButtonType_MAX                  = 7,
};

// Enum man.EDialogueType
// NumValues: 0x0012
enum class EDialogueType : uint8
{
	Default                                  = 0,
	OptionsSaveChanges                       = 1,
	OptionsKeepResolution                    = 2,
	CreaterCharacterStartGame                = 3,
	CreateCharacterBackToMainMenu            = 4,
	OverwriteSavedGame                       = 5,
	DeleteSavedGame                          = 6,
	HotkeyConflict                           = 7,
	HotkeyUnboundAction                      = 8,
	EntropyRiftLeave                         = 9,
	OptionsResetToDefault                    = 10,
	OptionsResetToDefaultHotkey              = 11,
	HotkeyBindingsNotAllowedKey              = 12,
	SaveGameFailed                           = 13,
	LoadGameMissingContent                   = 14,
	UserInterfaceScaleChanged                = 15,
	ControllerConnection                     = 16,
	EDialogueType_MAX                        = 17,
};

// Enum man.ESkillTreeTooltipPosition
// NumValues: 0x0003
enum class ESkillTreeTooltipPosition : uint8
{
	BottomRight                              = 0,
	BottomLeft                               = 1,
	ESkillTreeTooltipPosition_MAX            = 2,
};

// Enum man.ESkillTreeNodeState
// NumValues: 0x0006
enum class ESkillTreeNodeState : uint8
{
	Accessible                               = 0,
	Inaccessible                             = 1,
	Unlocked                                 = 2,
	Unlocking                                = 3,
	Unlearnable                              = 4,
	MAX                                      = 5,
};

// Enum man.EHUDPopupType
// NumValues: 0x000F
enum class EHUDPopupType : uint8
{
	SpecialMovementUlnocked                  = 0,
	QuestObjectiveFailed                     = 1,
	QuestObjectiveComplete                   = 2,
	QuestComplete                            = 3,
	QuestObjectiveUpdate                     = 4,
	QuestObjectiveAdd                        = 5,
	QuestAdd                                 = 6,
	SkillLearn                               = 7,
	TalentPoint                              = 8,
	WitchLanternAcquired                     = 9,
	NewAreaDiscovered                        = 10,
	FlaskNumberUpgraded                      = 11,
	FlaskPotencyUpgraded                     = 12,
	VendorUnlocked                           = 13,
	MAX                                      = 14,
};

// Enum man.EHUDBarType
// NumValues: 0x0011
enum class EHUDBarType : uint8
{
	Health                                   = 0,
	Stamina                                  = 1,
	Rage                                     = 2,
	Energy                                   = 3,
	VendorXp                                 = 4,
	PriorityHealthPool                       = 5,
	BossHP                                   = 6,
	BossHP2                                  = 7,
	GlideWings                               = 8,
	Entropy                                  = 9,
	HeavyAttack                              = 10,
	HealthDamageBuffer                       = 11,
	BossLightBarrier                         = 12,
	KillingField                             = 13,
	HealthMagicArmor                         = 14,
	PlayerXp                                 = 15,
	EHUDBarType_MAX                          = 16,
};

// Enum man.EQuickUseCommand
// NumValues: 0x0005
enum class EQuickUseCommand : uint8
{
	ShiftLeft                                = 0,
	ShiftRight                               = 1,
	UseItem                                  = 2,
	UpdateSlots                              = 3,
	EQuickUseCommand_MAX                     = 4,
};

// Enum man.EDiagramLevelType
// NumValues: 0x0006
enum class EDiagramLevelType : uint8
{
	Lowest                                   = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Num                                      = 4,
	EDiagramLevelType_MAX                    = 5,
};

// Enum man.EDialogueBubbleType
// NumValues: 0x0006
enum class EDialogueBubbleType : uint8
{
	CalculateDynamic                         = 0,
	ShowOnlyIcon                             = 1,
	ShowIconAndText                          = 2,
	ShowOnlySubtitle                         = 3,
	ShowOnlyText                             = 4,
	EDialogueBubbleType_MAX                  = 5,
};

// Enum man.EConversationSpeakerPosition
// NumValues: 0x0008
enum class EConversationSpeakerPosition : uint8
{
	LeftTop                                  = 0,
	LeftMiddle                               = 1,
	LeftBottom                               = 2,
	RightTop                                 = 3,
	RightMiddle                              = 4,
	RightBottom                              = 5,
	Max_None                                 = 6,
	EConversationSpeakerPosition_MAX         = 7,
};

// Enum man.ESpecialMovementType
// NumValues: 0x0006
enum class ESpecialMovementType : uint8
{
	GroundSlam                               = 0,
	GrapplingHook                            = 1,
	DoubleJump                               = 2,
	Glide                                    = 3,
	Max_None                                 = 4,
	ESpecialMovementType_MAX                 = 5,
};

// Enum man.EAbilityUpgradeSlotsState
// NumValues: 0x0005
enum class EAbilityUpgradeSlotsState : uint8
{
	OneInMiddleRow                           = 0,
	TwoInMiddleRow_TwoRightSideInBottomRow   = 1,
	TwoInMiddleRow_TwoLeftSideInBottomRow    = 2,
	TwoInMiddleRow_OneCommonMiddleInBottomRow = 3,
	EAbilityUpgradeSlotsState_MAX            = 4,
};

// Enum man.EAbilityUpgradeState
// NumValues: 0x0006
enum class EAbilityUpgradeState : uint8
{
	Invisible                                = 0,
	Base                                     = 1,
	Learned                                  = 2,
	Available                                = 3,
	Unavailable                              = 4,
	EAbilityUpgradeState_MAX                 = 5,
};

// Enum man.ESubtitleBackground
// NumValues: 0x0004
enum class ESubtitleBackground : uint8
{
	Light                                    = 0,
	Medium                                   = 1,
	Strong                                   = 2,
	ESubtitleBackground_MAX                  = 3,
};

// Enum man.ESubtitleSize
// NumValues: 0x0004
enum class ESubtitleSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	ESubtitleSize_MAX                        = 3,
};

// Enum man.ETabButtonType
// NumValues: 0x0020
enum class ETabButtonType : uint8
{
	Conversation                             = 0,
	VendorBuy                                = 1,
	VendorSell                               = 2,
	VendorCraft                              = 3,
	VendorAlchemist                          = 4,
	VendorUpgrade                            = 5,
	VendorMapFragment                        = 6,
	VendorEnchant                            = 7,
	VendorTransmog                           = 8,
	NPCBestiary                              = 9,
	CharacterWindow                          = 10,
	InventoryWindow                          = 11,
	Abilities                                = 12,
	Attributes                               = 13,
	Quests                                   = 14,
	Map                                      = 15,
	LevelUp                                  = 16,
	WitchLantern                             = 17,
	Options_General                          = 18,
	Options_Video                            = 19,
	Options_Video_Advanced                   = 20,
	Options_Audio                            = 21,
	Options_Controls                         = 22,
	Options_Accessibility                    = 23,
	Options_Visual                           = 24,
	SkillUpgrade                             = 25,
	Retalent                                 = 26,
	Collection                               = 27,
	Statistics                               = 28,
	Options_Controller                       = 29,
	Max_None                                 = 30,
	ETabButtonType_MAX                       = 31,
};

// Enum man.EHudCommand
// NumValues: 0x000A
enum class EHudCommand : uint8
{
	OpenCheckPointMenu                       = 0,
	OpenLevelUpPanel                         = 1,
	OpenIngameMenu                           = 2,
	OpenInventory                            = 3,
	OpenVendorMenu                           = 4,
	OpenMap                                  = 5,
	OpenVendorAlchemistWindow                = 6,
	OpenBountyBoard                          = 7,
	OpenCollection                           = 8,
	EHudCommand_MAX                          = 9,
};

// Enum man.EWidgetsZorder
// NumValues: 0x0061
enum class EWidgetsZorder : uint8
{
	HUD                                      = 0,
	WideScreen                               = 1,
	CutsceneCinematic                        = 2,
	PlayerMonologue                          = 3,
	VendorPortraits                          = 4,
	CutsceneCinematic_Subtitle               = 5,
	Subtitle                                 = 6,
	SkipCutscene                             = 7,
	PopUp_NewQuestWindow                     = 8,
	PopUp_QuestUpdatedWindow                 = 9,
	PopUp_QuestCompletedWindow               = 10,
	PopUp_NewAreaWindow                      = 11,
	PopUp_SpecialMovementUlnocked            = 12,
	PopUp_SkillLearn                         = 13,
	PopUp_TalentPoint                        = 14,
	PopUp_WitchLanternAcquired               = 15,
	PopUp_FlaskNumberUpgraded                = 16,
	PopUp_FlaskPotencyUpgraded               = 17,
	PopUp_VendorUnlocked                     = 18,
	WitchLanternWindow                       = 19,
	RetalentWindow                           = 20,
	QuestWindow                              = 21,
	MapWindow                                = 22,
	CharacterWindow                          = 23,
	InventoryWindow                          = 24,
	ActiveAbilitiesWindow                    = 25,
	ActiveAbilitiesUpgradeWindow             = 26,
	SkillUpgradeWindow                       = 27,
	SkillTreeWindow                          = 28,
	LevelUpWindow                            = 29,
	Conversation                             = 30,
	NewItem                                  = 31,
	VendorCraft                              = 32,
	VendorBuy                                = 33,
	VendorSell                               = 34,
	VendorAlchemist                          = 35,
	VendorUpgrade                            = 36,
	VendorMapFragment                        = 37,
	VendorEnchant                            = 38,
	VendorTransmog                           = 39,
	NPCBestiary                              = 40,
	CopperPlate                              = 41,
	BackersObelisk                           = 42,
	BackersStatue                            = 43,
	BackersGravestone                        = 44,
	Parchment                                = 45,
	BackersPoem                              = 46,
	BountyBoard                              = 47,
	BountyBoardDetails                       = 48,
	Collection                               = 49,
	Statistics                               = 50,
	UIPopupWindow                            = 51,
	HUDTimer                                 = 52,
	TutorialScreen                           = 53,
	DeathScreen                              = 54,
	BossScreen                               = 55,
	PauseMenu                                = 56,
	GlossaryWindow                           = 57,
	DemoEndScreen                            = 58,
	MainMenuBackground                       = 59,
	MainMenu                                 = 60,
	Options_General                          = 61,
	Options_Video                            = 62,
	Options_Video_Advanced                   = 63,
	Options_Audio                            = 64,
	Options_Subtitle                         = 65,
	Options_Controls                         = 66,
	Options_Controls_KeyBindings             = 67,
	Options_Controls_SelectHotkey            = 68,
	Options_Controller                       = 69,
	Options_Accessibility                    = 70,
	Options_Visual                           = 71,
	Options_HotkeyBindingsNotAllowedKey      = 72,
	LoadGame                                 = 73,
	NewGame                                  = 74,
	CreateCharacter                          = 75,
	CreateCharacter_Accessibility            = 76,
	CharacterName                            = 77,
	LoadMap                                  = 78,
	Credits                                  = 79,
	Artbook                                  = 80,
	SoundTrack                               = 81,
	DialogueWindow                           = 82,
	WindowWarning                            = 83,
	SubLevelTransition                       = 84,
	FastTravelTransition                     = 85,
	DemoStartScreen                          = 86,
	Disclaimer                               = 87,
	EULAScreen                               = 88,
	PrivacyPolicyScreen                      = 89,
	FadeManager                              = 90,
	ShaderGeneratorScreen                    = 91,
	SaveGameScreen                           = 92,
	DialogueWindow_SaveGameFailed            = 93,
	AutosaveScreen                           = 94,
	DebugFontAvailability                    = 95,
	EWidgetsZorder_MAX                       = 96,
};

// Enum man.EVariableDialogueDataAsset
// NumValues: 0x0004
enum class EVariableDialogueDataAsset : uint8
{
	None                                     = 0,
	InteractBubbleNeedKey                    = 1,
	InteractBubbleUnopenable                 = 2,
	EVariableDialogueDataAsset_MAX           = 3,
};

// Enum man.EVendorType
// NumValues: 0x0009
enum class EVendorType : uint8
{
	Blacksmith                               = 0,
	Alchemist                                = 1,
	Cook                                     = 2,
	Goldsmith                                = 3,
	Tailor                                   = 4,
	Occultist                                = 5,
	Adventurer                               = 6,
	Max_None                                 = 7,
	EVendorType_MAX                          = 8,
};

// Enum man.EVendorActionQueryMode
// NumValues: 0x0006
enum class EVendorActionQueryMode : uint8
{
	Buy                                      = 0,
	Sell                                     = 1,
	BuyBack                                  = 2,
	Craft                                    = 3,
	Enchant                                  = 4,
	EVendorActionQueryMode_MAX               = 5,
};

// Enum man.EVendorActionQuery
// NumValues: 0x000B
enum class EVendorActionQuery : uint8
{
	MissingGold                              = 0,
	MissingEssence                           = 1,
	MissingMaterials                         = 2,
	MissingVendorLevel                       = 3,
	MissingSlot                              = 4,
	MissingItemStackNum                      = 5,
	InvalidEnchantTarget                     = 6,
	InvalidSlot                              = 7,
	AtMaximumAcquirableCapacity              = 8,
	OtherError                               = 9,
	EVendorActionQuery_MAX                   = 10,
};

// Enum man.EVendorMenu
// NumValues: 0x0007
enum class EVendorMenu : uint8
{
	OpenTradeMenu                            = 0,
	OpenCraftMenu                            = 1,
	OpenTeachMenu                            = 2,
	OpenAlchemistMenu                        = 3,
	OpenUpgradeMenu                          = 4,
	OpenBestiaryMenu                         = 5,
	EVendorMenu_MAX                          = 6,
};

// Enum man.EVisualEntityKillCondition
// NumValues: 0x0004
enum class EVisualEntityKillCondition : uint8
{
	WaitDeathFade                            = 0,
	WaitParticleCompleted                    = 1,
	WaitDeathFadeAndWaitParticleCompleted    = 2,
	EVisualEntityKillCondition_MAX           = 3,
};

// Enum man.EWildSeedAbilityState
// NumValues: 0x0003
enum class EWildSeedAbilityState : uint8
{
	DetonationInactive                       = 0,
	DetonationActive                         = 1,
	EWildSeedAbilityState_MAX                = 2,
};

// Enum man.EWitchLanternResourceType
// NumValues: 0x0003
enum class EWitchLanternResourceType : uint8
{
	MandrakeRoot                             = 0,
	Essence                                  = 1,
	EWitchLanternResourceType_MAX            = 2,
};

// ScriptStruct man.AirAttackVariantByItemFilter
// 0x0020 (0x0020 - 0x0000)
struct FAirAttackVariantByItemFilter final
{
public:
	class UWeaponQuery*                           WeaponLayout;                                      // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                AttackAnim;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                PostAttackFallLoop;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                AttackAnimLanding;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAirAttackVariantByItemFilter) == 0x000008, "Wrong alignment on FAirAttackVariantByItemFilter");
static_assert(sizeof(FAirAttackVariantByItemFilter) == 0x000020, "Wrong size on FAirAttackVariantByItemFilter");
static_assert(offsetof(FAirAttackVariantByItemFilter, WeaponLayout) == 0x000000, "Member 'FAirAttackVariantByItemFilter::WeaponLayout' has a wrong offset!");
static_assert(offsetof(FAirAttackVariantByItemFilter, AttackAnim) == 0x000008, "Member 'FAirAttackVariantByItemFilter::AttackAnim' has a wrong offset!");
static_assert(offsetof(FAirAttackVariantByItemFilter, PostAttackFallLoop) == 0x000010, "Member 'FAirAttackVariantByItemFilter::PostAttackFallLoop' has a wrong offset!");
static_assert(offsetof(FAirAttackVariantByItemFilter, AttackAnimLanding) == 0x000018, "Member 'FAirAttackVariantByItemFilter::AttackAnimLanding' has a wrong offset!");

// ScriptStruct man.BlendDurationByCombatMode
// 0x0018 (0x0018 - 0x0000)
struct FBlendDurationByCombatMode final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration_OH;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration_THM;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration_THS;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration_DW;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendDurationByCombatMode) == 0x000008, "Wrong alignment on FBlendDurationByCombatMode");
static_assert(sizeof(FBlendDurationByCombatMode) == 0x000018, "Wrong size on FBlendDurationByCombatMode");
static_assert(offsetof(FBlendDurationByCombatMode, AnimID) == 0x000000, "Member 'FBlendDurationByCombatMode::AnimID' has a wrong offset!");
static_assert(offsetof(FBlendDurationByCombatMode, BlendDuration_OH) == 0x000008, "Member 'FBlendDurationByCombatMode::BlendDuration_OH' has a wrong offset!");
static_assert(offsetof(FBlendDurationByCombatMode, BlendDuration_THM) == 0x00000C, "Member 'FBlendDurationByCombatMode::BlendDuration_THM' has a wrong offset!");
static_assert(offsetof(FBlendDurationByCombatMode, BlendDuration_THS) == 0x000010, "Member 'FBlendDurationByCombatMode::BlendDuration_THS' has a wrong offset!");
static_assert(offsetof(FBlendDurationByCombatMode, BlendDuration_DW) == 0x000014, "Member 'FBlendDurationByCombatMode::BlendDuration_DW' has a wrong offset!");

// ScriptStruct man.TooltipVarData
// 0x0058 (0x0058 - 0x0000)
struct FTooltipVarData final
{
public:
	class FString                                 ShortID;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               TargetAbility;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACharacterBase>             TargetCharacter;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActorBase>                 TargetActorBase;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityUpgradeID;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityUpgradeModifierIndex;                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EManTooltipNumericDataID                      ID;                                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENumDisplayType                               NumDisplayType;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegateValues;                                     // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsValues;                                        // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideMaxDecimals;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAbilityModifierIgnores>               ModifierIgnores;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTooltipVarData) == 0x000008, "Wrong alignment on FTooltipVarData");
static_assert(sizeof(FTooltipVarData) == 0x000058, "Wrong size on FTooltipVarData");
static_assert(offsetof(FTooltipVarData, ShortID) == 0x000000, "Member 'FTooltipVarData::ShortID' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, TargetAbility) == 0x000010, "Member 'FTooltipVarData::TargetAbility' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, ComponentName) == 0x000018, "Member 'FTooltipVarData::ComponentName' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, TargetCharacter) == 0x000020, "Member 'FTooltipVarData::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, TargetActorBase) == 0x000028, "Member 'FTooltipVarData::TargetActorBase' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, AbilityUpgradeID) == 0x000030, "Member 'FTooltipVarData::AbilityUpgradeID' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, AbilityUpgradeModifierIndex) == 0x000038, "Member 'FTooltipVarData::AbilityUpgradeModifierIndex' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, ID) == 0x00003C, "Member 'FTooltipVarData::ID' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, NumDisplayType) == 0x000040, "Member 'FTooltipVarData::NumDisplayType' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, bNegateValues) == 0x000041, "Member 'FTooltipVarData::bNegateValues' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, bAbsValues) == 0x000042, "Member 'FTooltipVarData::bAbsValues' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, OverrideMaxDecimals) == 0x000044, "Member 'FTooltipVarData::OverrideMaxDecimals' has a wrong offset!");
static_assert(offsetof(FTooltipVarData, ModifierIgnores) == 0x000048, "Member 'FTooltipVarData::ModifierIgnores' has a wrong offset!");

// ScriptStruct man.SlotMaterialTextureParameter
// 0x0010 (0x0010 - 0x0000)
struct FSlotMaterialTextureParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Value;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotMaterialTextureParameter) == 0x000008, "Wrong alignment on FSlotMaterialTextureParameter");
static_assert(sizeof(FSlotMaterialTextureParameter) == 0x000010, "Wrong size on FSlotMaterialTextureParameter");
static_assert(offsetof(FSlotMaterialTextureParameter, Name) == 0x000000, "Member 'FSlotMaterialTextureParameter::Name' has a wrong offset!");
static_assert(offsetof(FSlotMaterialTextureParameter, Value) == 0x000008, "Member 'FSlotMaterialTextureParameter::Value' has a wrong offset!");

// ScriptStruct man.ACOnHitPatam
// 0x0003 (0x0003 - 0x0000)
struct FACOnHitPatam final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FACOnHitPatam) == 0x000001, "Wrong alignment on FACOnHitPatam");
static_assert(sizeof(FACOnHitPatam) == 0x000003, "Wrong size on FACOnHitPatam");

// ScriptStruct man.CharacterVisualSlotInfoCacheRef
// 0x0020 (0x0020 - 0x0000)
struct FCharacterVisualSlotInfoCacheRef final
{
public:
	int32                                         Counter;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterVisualSlotInfo*               VisualSlotInfo;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  SkeletalMeshList;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterVisualSlotInfoCacheRef) == 0x000008, "Wrong alignment on FCharacterVisualSlotInfoCacheRef");
static_assert(sizeof(FCharacterVisualSlotInfoCacheRef) == 0x000020, "Wrong size on FCharacterVisualSlotInfoCacheRef");
static_assert(offsetof(FCharacterVisualSlotInfoCacheRef, Counter) == 0x000000, "Member 'FCharacterVisualSlotInfoCacheRef::Counter' has a wrong offset!");
static_assert(offsetof(FCharacterVisualSlotInfoCacheRef, VisualSlotInfo) == 0x000008, "Member 'FCharacterVisualSlotInfoCacheRef::VisualSlotInfo' has a wrong offset!");
static_assert(offsetof(FCharacterVisualSlotInfoCacheRef, SkeletalMeshList) == 0x000010, "Member 'FCharacterVisualSlotInfoCacheRef::SkeletalMeshList' has a wrong offset!");

// ScriptStruct man.DamageFlags
// 0x0024 (0x0024 - 0x0000)
struct FDamageFlags final
{
public:
	bool                                          NotDodgeable;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dodgeable;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeParried;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotParryable;                                      // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeEvaded;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDealCritical;                                  // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoAdditiveStaggerAnim;                            // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStagger;                                     // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeleeDamage;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDamage;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseNonStaggerPushEffect;                        // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySpellBuffAttributeForWeaponDamage;           // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDOT;                                              // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAOE;                                              // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDefendedDamageMatrix;                       // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoStaggerIfTargetInAir;                           // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveHitreactionFromFront;                      // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceHitreactionForwardToSource;                  // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceHitreactionBackwardToSource;                 // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDelayedKill;                                      // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefendable;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDamageSource;                                  // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseStatusEffect;                             // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStatusEffect;                                // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggersDamageMatrix;                             // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHitImpactPointForFacing;                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseNonAdditiveHitreactionsOnLadder;             // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAIForceAggro;                                     // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRedirected;                                       // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmash;                                            // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotCountTowardsHits;                            // 0x001E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForcedDamageFacing;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageFlags) == 0x000004, "Wrong alignment on FDamageFlags");
static_assert(sizeof(FDamageFlags) == 0x000024, "Wrong size on FDamageFlags");
static_assert(offsetof(FDamageFlags, NotDodgeable) == 0x000000, "Member 'FDamageFlags::NotDodgeable' has a wrong offset!");
static_assert(offsetof(FDamageFlags, Dodgeable) == 0x000001, "Member 'FDamageFlags::Dodgeable' has a wrong offset!");
static_assert(offsetof(FDamageFlags, CanBeParried) == 0x000002, "Member 'FDamageFlags::CanBeParried' has a wrong offset!");
static_assert(offsetof(FDamageFlags, NotParryable) == 0x000003, "Member 'FDamageFlags::NotParryable' has a wrong offset!");
static_assert(offsetof(FDamageFlags, CanBeEvaded) == 0x000004, "Member 'FDamageFlags::CanBeEvaded' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bCanDealCritical) == 0x000005, "Member 'FDamageFlags::bCanDealCritical' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bNoAdditiveStaggerAnim) == 0x000006, "Member 'FDamageFlags::bNoAdditiveStaggerAnim' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bForceStagger) == 0x000007, "Member 'FDamageFlags::bForceStagger' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bMeleeDamage) == 0x000008, "Member 'FDamageFlags::bMeleeDamage' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bWeaponDamage) == 0x000009, "Member 'FDamageFlags::bWeaponDamage' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bCauseNonStaggerPushEffect) == 0x00000A, "Member 'FDamageFlags::bCauseNonStaggerPushEffect' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bApplySpellBuffAttributeForWeaponDamage) == 0x00000B, "Member 'FDamageFlags::bApplySpellBuffAttributeForWeaponDamage' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bDOT) == 0x00000C, "Member 'FDamageFlags::bDOT' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bAOE) == 0x00000D, "Member 'FDamageFlags::bAOE' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bIgnoreDefendedDamageMatrix) == 0x00000E, "Member 'FDamageFlags::bIgnoreDefendedDamageMatrix' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bNoStaggerIfTargetInAir) == 0x00000F, "Member 'FDamageFlags::bNoStaggerIfTargetInAir' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bReceiveHitreactionFromFront) == 0x000010, "Member 'FDamageFlags::bReceiveHitreactionFromFront' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bForceHitreactionForwardToSource) == 0x000011, "Member 'FDamageFlags::bForceHitreactionForwardToSource' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bForceHitreactionBackwardToSource) == 0x000012, "Member 'FDamageFlags::bForceHitreactionBackwardToSource' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bDelayedKill) == 0x000013, "Member 'FDamageFlags::bDelayedKill' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bDefendable) == 0x000014, "Member 'FDamageFlags::bDefendable' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bCanDamageSource) == 0x000015, "Member 'FDamageFlags::bCanDamageSource' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bCanCauseStatusEffect) == 0x000016, "Member 'FDamageFlags::bCanCauseStatusEffect' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bForceStatusEffect) == 0x000017, "Member 'FDamageFlags::bForceStatusEffect' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bTriggersDamageMatrix) == 0x000018, "Member 'FDamageFlags::bTriggersDamageMatrix' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bUseHitImpactPointForFacing) == 0x000019, "Member 'FDamageFlags::bUseHitImpactPointForFacing' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bCauseNonAdditiveHitreactionsOnLadder) == 0x00001A, "Member 'FDamageFlags::bCauseNonAdditiveHitreactionsOnLadder' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bAIForceAggro) == 0x00001B, "Member 'FDamageFlags::bAIForceAggro' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bRedirected) == 0x00001C, "Member 'FDamageFlags::bRedirected' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bSmash) == 0x00001D, "Member 'FDamageFlags::bSmash' has a wrong offset!");
static_assert(offsetof(FDamageFlags, bDoNotCountTowardsHits) == 0x00001E, "Member 'FDamageFlags::bDoNotCountTowardsHits' has a wrong offset!");
static_assert(offsetof(FDamageFlags, ForcedDamageFacing) == 0x000020, "Member 'FDamageFlags::ForcedDamageFacing' has a wrong offset!");

// ScriptStruct man.ActorTrackerData
// 0x0030 (0x0030 - 0x0000)
struct FActorTrackerData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           AbilityOneOnTarget;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityBase*                           AbilityTwoOnTarget;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorTrackerData) == 0x000008, "Wrong alignment on FActorTrackerData");
static_assert(sizeof(FActorTrackerData) == 0x000030, "Wrong size on FActorTrackerData");
static_assert(offsetof(FActorTrackerData, Target) == 0x000000, "Member 'FActorTrackerData::Target' has a wrong offset!");
static_assert(offsetof(FActorTrackerData, AbilityOneOnTarget) == 0x000008, "Member 'FActorTrackerData::AbilityOneOnTarget' has a wrong offset!");
static_assert(offsetof(FActorTrackerData, AbilityTwoOnTarget) == 0x000010, "Member 'FActorTrackerData::AbilityTwoOnTarget' has a wrong offset!");

// ScriptStruct man.RunStop
// 0x0030 (0x0030 - 0x0000)
struct FRunStop final
{
public:
	class UAnimID*                                SlideAnim;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                StopAnim;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRunTime;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopEventTreshold;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFreeSpace;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRunStop) == 0x000008, "Wrong alignment on FRunStop");
static_assert(sizeof(FRunStop) == 0x000030, "Wrong size on FRunStop");
static_assert(offsetof(FRunStop, SlideAnim) == 0x000000, "Member 'FRunStop::SlideAnim' has a wrong offset!");
static_assert(offsetof(FRunStop, StopAnim) == 0x000008, "Member 'FRunStop::StopAnim' has a wrong offset!");
static_assert(offsetof(FRunStop, MinRunTime) == 0x000010, "Member 'FRunStop::MinRunTime' has a wrong offset!");
static_assert(offsetof(FRunStop, StopEventTreshold) == 0x000014, "Member 'FRunStop::StopEventTreshold' has a wrong offset!");
static_assert(offsetof(FRunStop, MinFreeSpace) == 0x000018, "Member 'FRunStop::MinFreeSpace' has a wrong offset!");
static_assert(offsetof(FRunStop, Timeout) == 0x00001C, "Member 'FRunStop::Timeout' has a wrong offset!");

// ScriptStruct man.ObjectArray
// 0x0010 (0x0010 - 0x0000)
struct FObjectArray final
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectArray) == 0x000008, "Wrong alignment on FObjectArray");
static_assert(sizeof(FObjectArray) == 0x000010, "Wrong size on FObjectArray");
static_assert(offsetof(FObjectArray, Objects) == 0x000000, "Member 'FObjectArray::Objects' has a wrong offset!");

// ScriptStruct man.CreateCharacterDialogueLine
// 0x0010 (0x0010 - 0x0000)
struct FCreateCharacterDialogueLine final
{
public:
	class UDialogueDataAsset*                     Asset;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LineID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateCharacterDialogueLine) == 0x000008, "Wrong alignment on FCreateCharacterDialogueLine");
static_assert(sizeof(FCreateCharacterDialogueLine) == 0x000010, "Wrong size on FCreateCharacterDialogueLine");
static_assert(offsetof(FCreateCharacterDialogueLine, Asset) == 0x000000, "Member 'FCreateCharacterDialogueLine::Asset' has a wrong offset!");
static_assert(offsetof(FCreateCharacterDialogueLine, LineID) == 0x000008, "Member 'FCreateCharacterDialogueLine::LineID' has a wrong offset!");

// ScriptStruct man.DamageAnimationAndVFXData
// 0x0028 (0x0028 - 0x0000)
struct FDamageAnimationAndVFXData final
{
public:
	class UAnimID*                                HitBackAnimOverride;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                HitFrontAnimOverride;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                CustomDeathAnim;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCauserVFXDataAsset*              DamageCauserVFXDataAsset;                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomDeathAnimAlwaysDieFacingTheKiller;          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageAnimationAndVFXData) == 0x000008, "Wrong alignment on FDamageAnimationAndVFXData");
static_assert(sizeof(FDamageAnimationAndVFXData) == 0x000028, "Wrong size on FDamageAnimationAndVFXData");
static_assert(offsetof(FDamageAnimationAndVFXData, HitBackAnimOverride) == 0x000000, "Member 'FDamageAnimationAndVFXData::HitBackAnimOverride' has a wrong offset!");
static_assert(offsetof(FDamageAnimationAndVFXData, HitFrontAnimOverride) == 0x000008, "Member 'FDamageAnimationAndVFXData::HitFrontAnimOverride' has a wrong offset!");
static_assert(offsetof(FDamageAnimationAndVFXData, CustomDeathAnim) == 0x000010, "Member 'FDamageAnimationAndVFXData::CustomDeathAnim' has a wrong offset!");
static_assert(offsetof(FDamageAnimationAndVFXData, DamageCauserVFXDataAsset) == 0x000018, "Member 'FDamageAnimationAndVFXData::DamageCauserVFXDataAsset' has a wrong offset!");
static_assert(offsetof(FDamageAnimationAndVFXData, bCustomDeathAnimAlwaysDieFacingTheKiller) == 0x000020, "Member 'FDamageAnimationAndVFXData::bCustomDeathAnimAlwaysDieFacingTheKiller' has a wrong offset!");

// ScriptStruct man.BasicDamageData
// 0x0050 (0x0050 - 0x0000)
struct FBasicDamageData final
{
public:
	float                                         Stagger;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaggerDuration;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDurationOverride;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeathType                                    DeathType;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DeathTags;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EDamageReactionType                           ReactionType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmorPenetration;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeStealRatio;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiledDamagedValue;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                vLocation;                                         // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x003C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         pHitComponent;                                     // 0x0048(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicDamageData) == 0x000008, "Wrong alignment on FBasicDamageData");
static_assert(sizeof(FBasicDamageData) == 0x000050, "Wrong size on FBasicDamageData");
static_assert(offsetof(FBasicDamageData, Stagger) == 0x000000, "Member 'FBasicDamageData::Stagger' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, StaggerDuration) == 0x000004, "Member 'FBasicDamageData::StaggerDuration' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, StunDurationOverride) == 0x000008, "Member 'FBasicDamageData::StunDurationOverride' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, DeathType) == 0x00000C, "Member 'FBasicDamageData::DeathType' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, DeathTags) == 0x000010, "Member 'FBasicDamageData::DeathTags' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, ReactionType) == 0x000020, "Member 'FBasicDamageData::ReactionType' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, ArmorPenetration) == 0x000024, "Member 'FBasicDamageData::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, LifeStealRatio) == 0x000028, "Member 'FBasicDamageData::LifeStealRatio' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, ShiledDamagedValue) == 0x00002C, "Member 'FBasicDamageData::ShiledDamagedValue' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, vLocation) == 0x000030, "Member 'FBasicDamageData::vLocation' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, ImpactVelocity) == 0x00003C, "Member 'FBasicDamageData::ImpactVelocity' has a wrong offset!");
static_assert(offsetof(FBasicDamageData, pHitComponent) == 0x000048, "Member 'FBasicDamageData::pHitComponent' has a wrong offset!");

// ScriptStruct man.DamageGroupData
// 0x0018 (0x0018 - 0x0000)
struct FDamageGroupData final
{
public:
	bool                                          bGrouppedDamage;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageGroupID;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDamageType>                           DamageGroupTypesWithSE;                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageGroupData) == 0x000008, "Wrong alignment on FDamageGroupData");
static_assert(sizeof(FDamageGroupData) == 0x000018, "Wrong size on FDamageGroupData");
static_assert(offsetof(FDamageGroupData, bGrouppedDamage) == 0x000000, "Member 'FDamageGroupData::bGrouppedDamage' has a wrong offset!");
static_assert(offsetof(FDamageGroupData, DamageGroupID) == 0x000004, "Member 'FDamageGroupData::DamageGroupID' has a wrong offset!");
static_assert(offsetof(FDamageGroupData, DamageGroupTypesWithSE) == 0x000008, "Member 'FDamageGroupData::DamageGroupTypesWithSE' has a wrong offset!");

// ScriptStruct man.DamageValue
// 0x0138 (0x0138 - 0x0000)
struct FDamageValue final
{
public:
	struct FDamageFlags                           DamageFlags;                                       // 0x0000(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageAnimationAndVFXData             AnimationAndVFXData;                               // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBasicDamageData                       DamageSettings;                                    // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDamageGroupData                       GroupData;                                         // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   Type;                                              // 0x00BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageSubType                                SubType;                                           // 0x00BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StatusEffectChance;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectLength;                                // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectBaseValue;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalChance;                                    // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageMulAdd;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryStatusEffectChance;                       // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreResistancePercent;                           // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDotAudioMode;                                     // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DotAudioInterval;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x14];                                      // 0x00E4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponIC*                              CauserWeapon;                                      // 0x00F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCarrierActor;                                // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimaryDamage;                                    // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaggerOrStun;                                    // 0x0109(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x26];                                     // 0x010A(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageTakenVFXDataAsset*               TakenVFXDataAssetOverride;                         // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageValue) == 0x000008, "Wrong alignment on FDamageValue");
static_assert(sizeof(FDamageValue) == 0x000138, "Wrong size on FDamageValue");
static_assert(offsetof(FDamageValue, DamageFlags) == 0x000000, "Member 'FDamageValue::DamageFlags' has a wrong offset!");
static_assert(offsetof(FDamageValue, AnimationAndVFXData) == 0x000028, "Member 'FDamageValue::AnimationAndVFXData' has a wrong offset!");
static_assert(offsetof(FDamageValue, DamageSettings) == 0x000050, "Member 'FDamageValue::DamageSettings' has a wrong offset!");
static_assert(offsetof(FDamageValue, GroupData) == 0x0000A0, "Member 'FDamageValue::GroupData' has a wrong offset!");
static_assert(offsetof(FDamageValue, Value) == 0x0000B8, "Member 'FDamageValue::Value' has a wrong offset!");
static_assert(offsetof(FDamageValue, Type) == 0x0000BC, "Member 'FDamageValue::Type' has a wrong offset!");
static_assert(offsetof(FDamageValue, SubType) == 0x0000BD, "Member 'FDamageValue::SubType' has a wrong offset!");
static_assert(offsetof(FDamageValue, StatusEffectChance) == 0x0000C0, "Member 'FDamageValue::StatusEffectChance' has a wrong offset!");
static_assert(offsetof(FDamageValue, StatusEffectLength) == 0x0000C4, "Member 'FDamageValue::StatusEffectLength' has a wrong offset!");
static_assert(offsetof(FDamageValue, StatusEffectBaseValue) == 0x0000C8, "Member 'FDamageValue::StatusEffectBaseValue' has a wrong offset!");
static_assert(offsetof(FDamageValue, CriticalChance) == 0x0000CC, "Member 'FDamageValue::CriticalChance' has a wrong offset!");
static_assert(offsetof(FDamageValue, CriticalDamageMulAdd) == 0x0000D0, "Member 'FDamageValue::CriticalDamageMulAdd' has a wrong offset!");
static_assert(offsetof(FDamageValue, SecondaryStatusEffectChance) == 0x0000D4, "Member 'FDamageValue::SecondaryStatusEffectChance' has a wrong offset!");
static_assert(offsetof(FDamageValue, IgnoreResistancePercent) == 0x0000D8, "Member 'FDamageValue::IgnoreResistancePercent' has a wrong offset!");
static_assert(offsetof(FDamageValue, bDotAudioMode) == 0x0000DC, "Member 'FDamageValue::bDotAudioMode' has a wrong offset!");
static_assert(offsetof(FDamageValue, DotAudioInterval) == 0x0000E0, "Member 'FDamageValue::DotAudioInterval' has a wrong offset!");
static_assert(offsetof(FDamageValue, CauserWeapon) == 0x0000F8, "Member 'FDamageValue::CauserWeapon' has a wrong offset!");
static_assert(offsetof(FDamageValue, DamageCarrierActor) == 0x000100, "Member 'FDamageValue::DamageCarrierActor' has a wrong offset!");
static_assert(offsetof(FDamageValue, bPrimaryDamage) == 0x000108, "Member 'FDamageValue::bPrimaryDamage' has a wrong offset!");
static_assert(offsetof(FDamageValue, bStaggerOrStun) == 0x000109, "Member 'FDamageValue::bStaggerOrStun' has a wrong offset!");
static_assert(offsetof(FDamageValue, TakenVFXDataAssetOverride) == 0x000130, "Member 'FDamageValue::TakenVFXDataAssetOverride' has a wrong offset!");

// ScriptStruct man.PreDamagedEventParam
// 0x02D8 (0x02D8 - 0x0000)
struct alignas(0x08) FPreDamagedEventParam final
{
public:
	uint8                                         Pad_0[0x2D8];                                      // 0x0000(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreDamagedEventParam) == 0x000008, "Wrong alignment on FPreDamagedEventParam");
static_assert(sizeof(FPreDamagedEventParam) == 0x0002D8, "Wrong size on FPreDamagedEventParam");

// ScriptStruct man.SwitchActorNode
// 0x0010 (0x0010 - 0x0000)
struct FSwitchActorNode final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwitchActorNode) == 0x000008, "Wrong alignment on FSwitchActorNode");
static_assert(sizeof(FSwitchActorNode) == 0x000010, "Wrong size on FSwitchActorNode");
static_assert(offsetof(FSwitchActorNode, Actor) == 0x000000, "Member 'FSwitchActorNode::Actor' has a wrong offset!");
static_assert(offsetof(FSwitchActorNode, AbilityClass) == 0x000008, "Member 'FSwitchActorNode::AbilityClass' has a wrong offset!");

// ScriptStruct man.AbilityModifier
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FAbilityModifier final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityModifier) == 0x000008, "Wrong alignment on FAbilityModifier");
static_assert(sizeof(FAbilityModifier) == 0x0000A0, "Wrong size on FAbilityModifier");

// ScriptStruct man.AnimNode_Tentacle
// 0x0078 (0x0088 - 0x0010)
struct FAnimNode_Tentacle final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ArmBoneNames;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CatchBoneNames;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   RootedCurveName;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightCurveName;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimRange;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAngleLimit;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Tentacle) == 0x000008, "Wrong alignment on FAnimNode_Tentacle");
static_assert(sizeof(FAnimNode_Tentacle) == 0x000088, "Wrong size on FAnimNode_Tentacle");
static_assert(offsetof(FAnimNode_Tentacle, BasePose) == 0x000010, "Member 'FAnimNode_Tentacle::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, Target) == 0x000020, "Member 'FAnimNode_Tentacle::Target' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, Alpha) == 0x00002C, "Member 'FAnimNode_Tentacle::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, ArmBoneNames) == 0x000030, "Member 'FAnimNode_Tentacle::ArmBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, CatchBoneNames) == 0x000040, "Member 'FAnimNode_Tentacle::CatchBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, RootedCurveName) == 0x000050, "Member 'FAnimNode_Tentacle::RootedCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, WeightCurveName) == 0x000058, "Member 'FAnimNode_Tentacle::WeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, AimRange) == 0x000060, "Member 'FAnimNode_Tentacle::AimRange' has a wrong offset!");
static_assert(offsetof(FAnimNode_Tentacle, AimAngleLimit) == 0x000064, "Member 'FAnimNode_Tentacle::AimAngleLimit' has a wrong offset!");

// ScriptStruct man.StatusEffectCauserDamage
// 0x000C (0x000C - 0x0000)
struct FStatusEffectCauserDamage final
{
public:
	bool                                          bLastSEWasCausedByDamage;                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageValue;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimpleDir;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectCauserDamage) == 0x000004, "Wrong alignment on FStatusEffectCauserDamage");
static_assert(sizeof(FStatusEffectCauserDamage) == 0x00000C, "Wrong size on FStatusEffectCauserDamage");
static_assert(offsetof(FStatusEffectCauserDamage, bLastSEWasCausedByDamage) == 0x000000, "Member 'FStatusEffectCauserDamage::bLastSEWasCausedByDamage' has a wrong offset!");
static_assert(offsetof(FStatusEffectCauserDamage, DamageValue) == 0x000004, "Member 'FStatusEffectCauserDamage::DamageValue' has a wrong offset!");
static_assert(offsetof(FStatusEffectCauserDamage, SimpleDir) == 0x000008, "Member 'FStatusEffectCauserDamage::SimpleDir' has a wrong offset!");

// ScriptStruct man.AnimEventParam
// 0x0030 (0x0030 - 0x0000)
struct FAnimEventParam final
{
public:
	class UAnimID*                                BaseAnimID;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                AnimID;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimEventTime;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotify*                            AnimNotify;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimEventParam) == 0x000008, "Wrong alignment on FAnimEventParam");
static_assert(sizeof(FAnimEventParam) == 0x000030, "Wrong size on FAnimEventParam");
static_assert(offsetof(FAnimEventParam, BaseAnimID) == 0x000000, "Member 'FAnimEventParam::BaseAnimID' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, AnimID) == 0x000008, "Member 'FAnimEventParam::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, AnimEventType) == 0x000010, "Member 'FAnimEventParam::AnimEventType' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, AnimEventTime) == 0x000014, "Member 'FAnimEventParam::AnimEventTime' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, AnimSequence) == 0x000018, "Member 'FAnimEventParam::AnimSequence' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, AnimNotify) == 0x000020, "Member 'FAnimEventParam::AnimNotify' has a wrong offset!");
static_assert(offsetof(FAnimEventParam, CustomName) == 0x000028, "Member 'FAnimEventParam::CustomName' has a wrong offset!");

// ScriptStruct man.MapExplorationTile
// 0x0008 (0x0008 - 0x0000)
struct FMapExplorationTile final
{
public:
	uint32                                        Flags;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapExplorationTile) == 0x000004, "Wrong alignment on FMapExplorationTile");
static_assert(sizeof(FMapExplorationTile) == 0x000008, "Wrong size on FMapExplorationTile");
static_assert(offsetof(FMapExplorationTile, Flags) == 0x000000, "Member 'FMapExplorationTile::Flags' has a wrong offset!");
static_assert(offsetof(FMapExplorationTile, Color) == 0x000004, "Member 'FMapExplorationTile::Color' has a wrong offset!");

// ScriptStruct man.HeroAbilitySubSlot
// 0x0010 (0x0010 - 0x0000)
struct FHeroAbilitySubSlot final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroAbilitySubSlot) == 0x000008, "Wrong alignment on FHeroAbilitySubSlot");
static_assert(sizeof(FHeroAbilitySubSlot) == 0x000010, "Wrong size on FHeroAbilitySubSlot");
static_assert(offsetof(FHeroAbilitySubSlot, AbilityType) == 0x000000, "Member 'FHeroAbilitySubSlot::AbilityType' has a wrong offset!");

// ScriptStruct man.DLCTransmogItemsData
// 0x0018 (0x0018 - 0x0000)
struct FDLCTransmogItemsData final
{
public:
	EManDLC                                       Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCTransmogItemsData) == 0x000008, "Wrong alignment on FDLCTransmogItemsData");
static_assert(sizeof(FDLCTransmogItemsData) == 0x000018, "Wrong size on FDLCTransmogItemsData");
static_assert(offsetof(FDLCTransmogItemsData, Type) == 0x000000, "Member 'FDLCTransmogItemsData::Type' has a wrong offset!");
static_assert(offsetof(FDLCTransmogItemsData, Items) == 0x000008, "Member 'FDLCTransmogItemsData::Items' has a wrong offset!");

// ScriptStruct man.DamageAttributeScaleData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FDamageAttributeScaleData final
{
public:
	float                                         StrengthScale;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DexterityScale;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerScale;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpiritScale;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstitutionScale;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x24];                                      // 0x0014(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageAttributeScaleData) == 0x000008, "Wrong alignment on FDamageAttributeScaleData");
static_assert(sizeof(FDamageAttributeScaleData) == 0x000038, "Wrong size on FDamageAttributeScaleData");
static_assert(offsetof(FDamageAttributeScaleData, StrengthScale) == 0x000000, "Member 'FDamageAttributeScaleData::StrengthScale' has a wrong offset!");
static_assert(offsetof(FDamageAttributeScaleData, DexterityScale) == 0x000004, "Member 'FDamageAttributeScaleData::DexterityScale' has a wrong offset!");
static_assert(offsetof(FDamageAttributeScaleData, PowerScale) == 0x000008, "Member 'FDamageAttributeScaleData::PowerScale' has a wrong offset!");
static_assert(offsetof(FDamageAttributeScaleData, SpiritScale) == 0x00000C, "Member 'FDamageAttributeScaleData::SpiritScale' has a wrong offset!");
static_assert(offsetof(FDamageAttributeScaleData, ConstitutionScale) == 0x000010, "Member 'FDamageAttributeScaleData::ConstitutionScale' has a wrong offset!");

// ScriptStruct man.WeaponDamageData
// 0x0058 (0x0058 - 0x0000)
struct FWeaponDamageData final
{
public:
	float                                         DamageValue;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageStaggerValue;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StatusEffectChance;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomAttributeScaling;                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageAttributeScaleData              CustomAttributeScaleData;                          // 0x0018(0x0038)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponDamageData) == 0x000008, "Wrong alignment on FWeaponDamageData");
static_assert(sizeof(FWeaponDamageData) == 0x000058, "Wrong size on FWeaponDamageData");
static_assert(offsetof(FWeaponDamageData, DamageValue) == 0x000000, "Member 'FWeaponDamageData::DamageValue' has a wrong offset!");
static_assert(offsetof(FWeaponDamageData, DamageStaggerValue) == 0x000004, "Member 'FWeaponDamageData::DamageStaggerValue' has a wrong offset!");
static_assert(offsetof(FWeaponDamageData, DamageType) == 0x000008, "Member 'FWeaponDamageData::DamageType' has a wrong offset!");
static_assert(offsetof(FWeaponDamageData, StatusEffectChance) == 0x00000C, "Member 'FWeaponDamageData::StatusEffectChance' has a wrong offset!");
static_assert(offsetof(FWeaponDamageData, bUseCustomAttributeScaling) == 0x000010, "Member 'FWeaponDamageData::bUseCustomAttributeScaling' has a wrong offset!");
static_assert(offsetof(FWeaponDamageData, CustomAttributeScaleData) == 0x000018, "Member 'FWeaponDamageData::CustomAttributeScaleData' has a wrong offset!");

// ScriptStruct man.AbilityEventEditor
// 0x0030 (0x0030 - 0x0000)
struct FAbilityEventEditor final
{
public:
	EAbilityEventType                             AbilityEvent;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEvent;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomName;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayEventID*                       CustomEventID;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActorSoul*                             ActorSoul;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                SpecificAnimID;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalAnimMode;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityEventEditor) == 0x000008, "Wrong alignment on FAbilityEventEditor");
static_assert(sizeof(FAbilityEventEditor) == 0x000030, "Wrong size on FAbilityEventEditor");
static_assert(offsetof(FAbilityEventEditor, AbilityEvent) == 0x000000, "Member 'FAbilityEventEditor::AbilityEvent' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, AnimEvent) == 0x000001, "Member 'FAbilityEventEditor::AnimEvent' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, CustomName) == 0x000004, "Member 'FAbilityEventEditor::CustomName' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, CustomEventID) == 0x000010, "Member 'FAbilityEventEditor::CustomEventID' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, ActorSoul) == 0x000018, "Member 'FAbilityEventEditor::ActorSoul' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, SpecificAnimID) == 0x000020, "Member 'FAbilityEventEditor::SpecificAnimID' has a wrong offset!");
static_assert(offsetof(FAbilityEventEditor, bGlobalAnimMode) == 0x000028, "Member 'FAbilityEventEditor::bGlobalAnimMode' has a wrong offset!");

// ScriptStruct man.WeaponHand
// 0x0050 (0x0050 - 0x0000)
struct FWeaponHand final
{
public:
	class UItemAbility*                           WeaponAbility;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponIC*                              WeaponIC;                                          // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponID*                              Weapon;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponModelActor*                      WeaponActor;                                       // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponHand) == 0x000008, "Wrong alignment on FWeaponHand");
static_assert(sizeof(FWeaponHand) == 0x000050, "Wrong size on FWeaponHand");
static_assert(offsetof(FWeaponHand, WeaponAbility) == 0x000000, "Member 'FWeaponHand::WeaponAbility' has a wrong offset!");
static_assert(offsetof(FWeaponHand, WeaponIC) == 0x000008, "Member 'FWeaponHand::WeaponIC' has a wrong offset!");
static_assert(offsetof(FWeaponHand, Weapon) == 0x000010, "Member 'FWeaponHand::Weapon' has a wrong offset!");
static_assert(offsetof(FWeaponHand, WeaponActor) == 0x000040, "Member 'FWeaponHand::WeaponActor' has a wrong offset!");

// ScriptStruct man.VendorStageInfo
// 0x0030 (0x0030 - 0x0000)
struct FVendorStageInfo final
{
public:
	struct FSoftObjectPath                        VisibleLevel;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AudioLevel;                                        // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendorStageInfo) == 0x000008, "Wrong alignment on FVendorStageInfo");
static_assert(sizeof(FVendorStageInfo) == 0x000030, "Wrong size on FVendorStageInfo");
static_assert(offsetof(FVendorStageInfo, VisibleLevel) == 0x000000, "Member 'FVendorStageInfo::VisibleLevel' has a wrong offset!");
static_assert(offsetof(FVendorStageInfo, AudioLevel) == 0x000018, "Member 'FVendorStageInfo::AudioLevel' has a wrong offset!");

// ScriptStruct man.VendorDecorationInfo
// 0x0048 (0x0048 - 0x0000)
struct FVendorDecorationInfo final
{
public:
	class FName                                   VendorStageVariable;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftVendorClass;                                   // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSoftAndNameMatch;                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVendorStageInfo>               VendorStages;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendorDecorationInfo) == 0x000008, "Wrong alignment on FVendorDecorationInfo");
static_assert(sizeof(FVendorDecorationInfo) == 0x000048, "Wrong size on FVendorDecorationInfo");
static_assert(offsetof(FVendorDecorationInfo, VendorStageVariable) == 0x000000, "Member 'FVendorDecorationInfo::VendorStageVariable' has a wrong offset!");
static_assert(offsetof(FVendorDecorationInfo, SoftVendorClass) == 0x000008, "Member 'FVendorDecorationInfo::SoftVendorClass' has a wrong offset!");
static_assert(offsetof(FVendorDecorationInfo, bIgnoreSoftAndNameMatch) == 0x000030, "Member 'FVendorDecorationInfo::bIgnoreSoftAndNameMatch' has a wrong offset!");
static_assert(offsetof(FVendorDecorationInfo, VendorStages) == 0x000038, "Member 'FVendorDecorationInfo::VendorStages' has a wrong offset!");

// ScriptStruct man.UpdatedAnimSequenceInfo
// 0x0018 (0x0018 - 0x0000)
struct FUpdatedAnimSequenceInfo final
{
public:
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUpdatedAnimSequenceInfo) == 0x000008, "Wrong alignment on FUpdatedAnimSequenceInfo");
static_assert(sizeof(FUpdatedAnimSequenceInfo) == 0x000018, "Wrong size on FUpdatedAnimSequenceInfo");
static_assert(offsetof(FUpdatedAnimSequenceInfo, AnimSequence) == 0x000000, "Member 'FUpdatedAnimSequenceInfo::AnimSequence' has a wrong offset!");

// ScriptStruct man.SplineHitBoxNode
// 0x0020 (0x0020 - 0x0000)
struct FSplineHitBoxNode final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineHitBox*                          Component;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineHitBoxNode) == 0x000008, "Wrong alignment on FSplineHitBoxNode");
static_assert(sizeof(FSplineHitBoxNode) == 0x000020, "Wrong size on FSplineHitBoxNode");
static_assert(offsetof(FSplineHitBoxNode, SplineComponent) == 0x000008, "Member 'FSplineHitBoxNode::SplineComponent' has a wrong offset!");
static_assert(offsetof(FSplineHitBoxNode, Component) == 0x000018, "Member 'FSplineHitBoxNode::Component' has a wrong offset!");

// ScriptStruct man.DieVariantAbilities
// 0x0018 (0x0018 - 0x0000)
struct FDieVariantAbilities final
{
public:
	class FName                                   VariantName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               EffectsToProjectileOnEnemyCollide;                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollWeight;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDieVariantAbilities) == 0x000008, "Wrong alignment on FDieVariantAbilities");
static_assert(sizeof(FDieVariantAbilities) == 0x000018, "Wrong size on FDieVariantAbilities");
static_assert(offsetof(FDieVariantAbilities, VariantName) == 0x000000, "Member 'FDieVariantAbilities::VariantName' has a wrong offset!");
static_assert(offsetof(FDieVariantAbilities, EffectsToProjectileOnEnemyCollide) == 0x000008, "Member 'FDieVariantAbilities::EffectsToProjectileOnEnemyCollide' has a wrong offset!");
static_assert(offsetof(FDieVariantAbilities, RollWeight) == 0x000010, "Member 'FDieVariantAbilities::RollWeight' has a wrong offset!");

// ScriptStruct man.AttributeChangeDataInstance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FAttributeChangeDataInstance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeChangeDataInstance) == 0x000008, "Wrong alignment on FAttributeChangeDataInstance");
static_assert(sizeof(FAttributeChangeDataInstance) == 0x000008, "Wrong size on FAttributeChangeDataInstance");

// ScriptStruct man.ObjectGrowthElement
// 0x0030 (0x0030 - 0x0000)
struct FObjectGrowthElement final
{
public:
	float                                         GrowthPercent;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectGrowthElement) == 0x000008, "Wrong alignment on FObjectGrowthElement");
static_assert(sizeof(FObjectGrowthElement) == 0x000030, "Wrong size on FObjectGrowthElement");
static_assert(offsetof(FObjectGrowthElement, GrowthPercent) == 0x000000, "Member 'FObjectGrowthElement::GrowthPercent' has a wrong offset!");
static_assert(offsetof(FObjectGrowthElement, StaticMesh) == 0x000008, "Member 'FObjectGrowthElement::StaticMesh' has a wrong offset!");

// ScriptStruct man.SmartText
// 0x0010 (0x0010 - 0x0000)
struct FSmartText final
{
public:
	TArray<class USmartTextTemplateBase*>         SmartTexts;                                        // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSmartText) == 0x000008, "Wrong alignment on FSmartText");
static_assert(sizeof(FSmartText) == 0x000010, "Wrong size on FSmartText");
static_assert(offsetof(FSmartText, SmartTexts) == 0x000000, "Member 'FSmartText::SmartTexts' has a wrong offset!");

// ScriptStruct man.AbilityModifierEditor
// 0x00A0 (0x00A0 - 0x0000)
struct FAbilityModifierEditor final
{
public:
	EGeneralAbilityModifier                       ModifierID;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomModifierID;                                  // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatModifierValue;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACharacterBase>>     CharacterTypes;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActorBase>>         ActorBaseTypes;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       OnlyAbilityTypes;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           OnlyAbilityComponentsByName;                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       IgnoreAbilityTypes;                                // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreAbilityComponentsByName;                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAbilityTag>                           SpecifierTags;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EDamageType>                           DamageTypeTags;                                    // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       AdditionalAbilityTypes;                            // 0x0090(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityModifierEditor) == 0x000008, "Wrong alignment on FAbilityModifierEditor");
static_assert(sizeof(FAbilityModifierEditor) == 0x0000A0, "Wrong size on FAbilityModifierEditor");
static_assert(offsetof(FAbilityModifierEditor, ModifierID) == 0x000000, "Member 'FAbilityModifierEditor::ModifierID' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, CustomModifierID) == 0x000004, "Member 'FAbilityModifierEditor::CustomModifierID' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, FloatModifierValue) == 0x00000C, "Member 'FAbilityModifierEditor::FloatModifierValue' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, CharacterTypes) == 0x000010, "Member 'FAbilityModifierEditor::CharacterTypes' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, ActorBaseTypes) == 0x000020, "Member 'FAbilityModifierEditor::ActorBaseTypes' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, OnlyAbilityTypes) == 0x000030, "Member 'FAbilityModifierEditor::OnlyAbilityTypes' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, OnlyAbilityComponentsByName) == 0x000040, "Member 'FAbilityModifierEditor::OnlyAbilityComponentsByName' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, IgnoreAbilityTypes) == 0x000050, "Member 'FAbilityModifierEditor::IgnoreAbilityTypes' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, IgnoreAbilityComponentsByName) == 0x000060, "Member 'FAbilityModifierEditor::IgnoreAbilityComponentsByName' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, SpecifierTags) == 0x000070, "Member 'FAbilityModifierEditor::SpecifierTags' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, DamageTypeTags) == 0x000080, "Member 'FAbilityModifierEditor::DamageTypeTags' has a wrong offset!");
static_assert(offsetof(FAbilityModifierEditor, AdditionalAbilityTypes) == 0x000090, "Member 'FAbilityModifierEditor::AdditionalAbilityTypes' has a wrong offset!");

// ScriptStruct man.AbilityModifierTreeElement
// 0x0078 (0x0078 - 0x0000)
struct FAbilityModifierTreeElement final
{
public:
	class FName                                   UpgradeID;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpgradePosition;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpgradeIconID;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UpgradeDescription;                                // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSmartText                             UpgradeDescriptionSmartText;                       // 0x0028(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UpgradeCost;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalManaCostForAbility;                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalManaCostPerSecForAbility;                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalRageCostForAbility;                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalRageCostPerSecForAbility;                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalStaminaCostForAbility;                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalStaminaCostPerSecForAbility;             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalComboPointCostForAbility;                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           UnlockIDRequirements;                              // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAbilityModifierEditor>         Modifiers;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityModifierTreeElement) == 0x000008, "Wrong alignment on FAbilityModifierTreeElement");
static_assert(sizeof(FAbilityModifierTreeElement) == 0x000078, "Wrong size on FAbilityModifierTreeElement");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradeID) == 0x000000, "Member 'FAbilityModifierTreeElement::UpgradeID' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradePosition) == 0x000008, "Member 'FAbilityModifierTreeElement::UpgradePosition' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradeIconID) == 0x00000C, "Member 'FAbilityModifierTreeElement::UpgradeIconID' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradeDescription) == 0x000010, "Member 'FAbilityModifierTreeElement::UpgradeDescription' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradeDescriptionSmartText) == 0x000028, "Member 'FAbilityModifierTreeElement::UpgradeDescriptionSmartText' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UpgradeCost) == 0x000038, "Member 'FAbilityModifierTreeElement::UpgradeCost' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalManaCostForAbility) == 0x00003C, "Member 'FAbilityModifierTreeElement::AdditionalManaCostForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalManaCostPerSecForAbility) == 0x000040, "Member 'FAbilityModifierTreeElement::AdditionalManaCostPerSecForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalRageCostForAbility) == 0x000044, "Member 'FAbilityModifierTreeElement::AdditionalRageCostForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalRageCostPerSecForAbility) == 0x000048, "Member 'FAbilityModifierTreeElement::AdditionalRageCostPerSecForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalStaminaCostForAbility) == 0x00004C, "Member 'FAbilityModifierTreeElement::AdditionalStaminaCostForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalStaminaCostPerSecForAbility) == 0x000050, "Member 'FAbilityModifierTreeElement::AdditionalStaminaCostPerSecForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, AdditionalComboPointCostForAbility) == 0x000054, "Member 'FAbilityModifierTreeElement::AdditionalComboPointCostForAbility' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, UnlockIDRequirements) == 0x000058, "Member 'FAbilityModifierTreeElement::UnlockIDRequirements' has a wrong offset!");
static_assert(offsetof(FAbilityModifierTreeElement, Modifiers) == 0x000068, "Member 'FAbilityModifierTreeElement::Modifiers' has a wrong offset!");

// ScriptStruct man.PlayAnimAbilityComponentNode
// 0x0040 (0x0040 - 0x0000)
struct FPlayAnimAbilityComponentNode final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                AnimID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayAnimComponentNodeCondition               Condition;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EntityTag;                                         // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAbilityBase>               FollowUpObject;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               AbilityEndFollowUp;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityScriptNode*                     ConditionNode;                                     // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayAnimAbilityComponentNode) == 0x000008, "Wrong alignment on FPlayAnimAbilityComponentNode");
static_assert(sizeof(FPlayAnimAbilityComponentNode) == 0x000040, "Wrong size on FPlayAnimAbilityComponentNode");
static_assert(offsetof(FPlayAnimAbilityComponentNode, Rate) == 0x000000, "Member 'FPlayAnimAbilityComponentNode::Rate' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, Priority) == 0x000004, "Member 'FPlayAnimAbilityComponentNode::Priority' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, AnimID) == 0x000008, "Member 'FPlayAnimAbilityComponentNode::AnimID' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, Condition) == 0x000010, "Member 'FPlayAnimAbilityComponentNode::Condition' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, EntityTag) == 0x000014, "Member 'FPlayAnimAbilityComponentNode::EntityTag' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, FollowUpObject) == 0x000020, "Member 'FPlayAnimAbilityComponentNode::FollowUpObject' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, AbilityEndFollowUp) == 0x000028, "Member 'FPlayAnimAbilityComponentNode::AbilityEndFollowUp' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, ConditionNode) == 0x000030, "Member 'FPlayAnimAbilityComponentNode::ConditionNode' has a wrong offset!");
static_assert(offsetof(FPlayAnimAbilityComponentNode, Value) == 0x000038, "Member 'FPlayAnimAbilityComponentNode::Value' has a wrong offset!");

// ScriptStruct man.ItemCategory
// 0x0030 (0x0030 - 0x0000)
struct FItemCategory final
{
public:
	TArray<EItemSlot>                             ItemSlotTypes;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EMainItemType                                 ItemType;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     EquipSlot;                                         // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubItemType                                  ItemSubType;                                       // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoldItem;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemCategoryText;                                  // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemCategory) == 0x000008, "Wrong alignment on FItemCategory");
static_assert(sizeof(FItemCategory) == 0x000030, "Wrong size on FItemCategory");
static_assert(offsetof(FItemCategory, ItemSlotTypes) == 0x000000, "Member 'FItemCategory::ItemSlotTypes' has a wrong offset!");
static_assert(offsetof(FItemCategory, ItemType) == 0x000010, "Member 'FItemCategory::ItemType' has a wrong offset!");
static_assert(offsetof(FItemCategory, WeaponType) == 0x000011, "Member 'FItemCategory::WeaponType' has a wrong offset!");
static_assert(offsetof(FItemCategory, EquipSlot) == 0x000012, "Member 'FItemCategory::EquipSlot' has a wrong offset!");
static_assert(offsetof(FItemCategory, ItemSubType) == 0x000013, "Member 'FItemCategory::ItemSubType' has a wrong offset!");
static_assert(offsetof(FItemCategory, bSoldItem) == 0x000014, "Member 'FItemCategory::bSoldItem' has a wrong offset!");
static_assert(offsetof(FItemCategory, ItemCategoryText) == 0x000018, "Member 'FItemCategory::ItemCategoryText' has a wrong offset!");

// ScriptStruct man.EntityCustomTag
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FEntityCustomTag final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityCustomTag) == 0x000004, "Wrong alignment on FEntityCustomTag");
static_assert(sizeof(FEntityCustomTag) == 0x00000C, "Wrong size on FEntityCustomTag");

// ScriptStruct man.AnimAssignment
// 0x0010 (0x0010 - 0x0000)
struct FAnimAssignment final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimAssignment) == 0x000008, "Wrong alignment on FAnimAssignment");
static_assert(sizeof(FAnimAssignment) == 0x000010, "Wrong size on FAnimAssignment");
static_assert(offsetof(FAnimAssignment, AnimID) == 0x000000, "Member 'FAnimAssignment::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimAssignment, AnimSequence) == 0x000008, "Member 'FAnimAssignment::AnimSequence' has a wrong offset!");

// ScriptStruct man.GroundMovecollideIsCollideSignatureParam
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FGroundMovecollideIsCollideSignatureParam final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroundMovecollideIsCollideSignatureParam) == 0x000008, "Wrong alignment on FGroundMovecollideIsCollideSignatureParam");
static_assert(sizeof(FGroundMovecollideIsCollideSignatureParam) == 0x000030, "Wrong size on FGroundMovecollideIsCollideSignatureParam");

// ScriptStruct man.KingPriestAttackCatharsisProjectileDataInAWave
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestAttackCatharsisProjectileDataInAWave final
{
public:
	TArray<int32>                                 DeltaAngleMultipliers;                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestAttackCatharsisProjectileDataInAWave) == 0x000008, "Wrong alignment on FKingPriestAttackCatharsisProjectileDataInAWave");
static_assert(sizeof(FKingPriestAttackCatharsisProjectileDataInAWave) == 0x000010, "Wrong size on FKingPriestAttackCatharsisProjectileDataInAWave");
static_assert(offsetof(FKingPriestAttackCatharsisProjectileDataInAWave, DeltaAngleMultipliers) == 0x000000, "Member 'FKingPriestAttackCatharsisProjectileDataInAWave::DeltaAngleMultipliers' has a wrong offset!");

// ScriptStruct man.KingPriestAttackCatharsisProjectileData
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestAttackCatharsisProjectileData final
{
public:
	TArray<struct FKingPriestAttackCatharsisProjectileDataInAWave> Wave;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestAttackCatharsisProjectileData) == 0x000008, "Wrong alignment on FKingPriestAttackCatharsisProjectileData");
static_assert(sizeof(FKingPriestAttackCatharsisProjectileData) == 0x000010, "Wrong size on FKingPriestAttackCatharsisProjectileData");
static_assert(offsetof(FKingPriestAttackCatharsisProjectileData, Wave) == 0x000000, "Member 'FKingPriestAttackCatharsisProjectileData::Wave' has a wrong offset!");

// ScriptStruct man.MaterialSlotReferenced
// 0x0018 (0x0018 - 0x0000)
struct FMaterialSlotReferenced final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialSlotReferenced) == 0x000008, "Wrong alignment on FMaterialSlotReferenced");
static_assert(sizeof(FMaterialSlotReferenced) == 0x000018, "Wrong size on FMaterialSlotReferenced");
static_assert(offsetof(FMaterialSlotReferenced, Mesh) == 0x000000, "Member 'FMaterialSlotReferenced::Mesh' has a wrong offset!");
static_assert(offsetof(FMaterialSlotReferenced, Material) == 0x000008, "Member 'FMaterialSlotReferenced::Material' has a wrong offset!");

// ScriptStruct man.AnimIdOverrideNode
// 0x0010 (0x0010 - 0x0000)
struct FAnimIdOverrideNode final
{
public:
	class UAnimID*                                GameplayAnimId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                VisualAnimID;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimIdOverrideNode) == 0x000008, "Wrong alignment on FAnimIdOverrideNode");
static_assert(sizeof(FAnimIdOverrideNode) == 0x000010, "Wrong size on FAnimIdOverrideNode");
static_assert(offsetof(FAnimIdOverrideNode, GameplayAnimId) == 0x000000, "Member 'FAnimIdOverrideNode::GameplayAnimId' has a wrong offset!");
static_assert(offsetof(FAnimIdOverrideNode, VisualAnimID) == 0x000008, "Member 'FAnimIdOverrideNode::VisualAnimID' has a wrong offset!");

// ScriptStruct man.AbilityDescription
// 0x0060 (0x0060 - 0x0000)
struct FAbilityDescription final
{
public:
	class FText                                   AbilityName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AbilityDescription;                                // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSmartText                             AbilityDescriptionSmartText;                       // 0x0030(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   AbilityFlavorText;                                 // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             AbilityIcon;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDescription) == 0x000008, "Wrong alignment on FAbilityDescription");
static_assert(sizeof(FAbilityDescription) == 0x000060, "Wrong size on FAbilityDescription");
static_assert(offsetof(FAbilityDescription, AbilityName) == 0x000000, "Member 'FAbilityDescription::AbilityName' has a wrong offset!");
static_assert(offsetof(FAbilityDescription, AbilityDescription) == 0x000018, "Member 'FAbilityDescription::AbilityDescription' has a wrong offset!");
static_assert(offsetof(FAbilityDescription, AbilityDescriptionSmartText) == 0x000030, "Member 'FAbilityDescription::AbilityDescriptionSmartText' has a wrong offset!");
static_assert(offsetof(FAbilityDescription, AbilityFlavorText) == 0x000040, "Member 'FAbilityDescription::AbilityFlavorText' has a wrong offset!");
static_assert(offsetof(FAbilityDescription, AbilityIcon) == 0x000058, "Member 'FAbilityDescription::AbilityIcon' has a wrong offset!");

// ScriptStruct man.AchSaveValues
// 0x0018 (0x0018 - 0x0000)
struct FAchSaveValues final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FlagsString;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchSaveValues) == 0x000008, "Wrong alignment on FAchSaveValues");
static_assert(sizeof(FAchSaveValues) == 0x000018, "Wrong size on FAchSaveValues");
static_assert(offsetof(FAchSaveValues, Value) == 0x000000, "Member 'FAchSaveValues::Value' has a wrong offset!");
static_assert(offsetof(FAchSaveValues, FlagsString) == 0x000008, "Member 'FAchSaveValues::FlagsString' has a wrong offset!");

// ScriptStruct man.LevelUserIntefaceSceneCaptureSkyLightOverride
// 0x0014 (0x0014 - 0x0000)
struct FLevelUserIntefaceSceneCaptureSkyLightOverride final
{
public:
	float                                         Intensity;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LowerHemisphereColor;                              // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelUserIntefaceSceneCaptureSkyLightOverride) == 0x000004, "Wrong alignment on FLevelUserIntefaceSceneCaptureSkyLightOverride");
static_assert(sizeof(FLevelUserIntefaceSceneCaptureSkyLightOverride) == 0x000014, "Wrong size on FLevelUserIntefaceSceneCaptureSkyLightOverride");
static_assert(offsetof(FLevelUserIntefaceSceneCaptureSkyLightOverride, Intensity) == 0x000000, "Member 'FLevelUserIntefaceSceneCaptureSkyLightOverride::Intensity' has a wrong offset!");
static_assert(offsetof(FLevelUserIntefaceSceneCaptureSkyLightOverride, LowerHemisphereColor) == 0x000004, "Member 'FLevelUserIntefaceSceneCaptureSkyLightOverride::LowerHemisphereColor' has a wrong offset!");

// ScriptStruct man.SPPatternData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSPPatternData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSPPatternData) == 0x000008, "Wrong alignment on FSPPatternData");
static_assert(sizeof(FSPPatternData) == 0x000028, "Wrong size on FSPPatternData");

// ScriptStruct man.Variable
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FVariable
{
public:
	EVariableType                                 VariableType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVariableObject                               VariableObject;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x24];                                       // 0x000C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariable) == 0x000008, "Wrong alignment on FVariable");
static_assert(sizeof(FVariable) == 0x000030, "Wrong size on FVariable");
static_assert(offsetof(FVariable, VariableType) == 0x000000, "Member 'FVariable::VariableType' has a wrong offset!");
static_assert(offsetof(FVariable, VariableObject) == 0x000001, "Member 'FVariable::VariableObject' has a wrong offset!");
static_assert(offsetof(FVariable, Name) == 0x000004, "Member 'FVariable::Name' has a wrong offset!");

// ScriptStruct man.VoidWitchAnamorphosisRayData
// 0x0010 (0x0010 - 0x0000)
struct FVoidWitchAnamorphosisRayData final
{
public:
	float                                         WaitBeforeSpawnTime;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeltaLocation;                                     // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoidWitchAnamorphosisRayData) == 0x000004, "Wrong alignment on FVoidWitchAnamorphosisRayData");
static_assert(sizeof(FVoidWitchAnamorphosisRayData) == 0x000010, "Wrong size on FVoidWitchAnamorphosisRayData");
static_assert(offsetof(FVoidWitchAnamorphosisRayData, WaitBeforeSpawnTime) == 0x000000, "Member 'FVoidWitchAnamorphosisRayData::WaitBeforeSpawnTime' has a wrong offset!");
static_assert(offsetof(FVoidWitchAnamorphosisRayData, DeltaLocation) == 0x000004, "Member 'FVoidWitchAnamorphosisRayData::DeltaLocation' has a wrong offset!");

// ScriptStruct man.OrbitData
// 0x0028 (0x0028 - 0x0000)
struct FOrbitData final
{
public:
	class AActor*                                 OrbitingActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrbitData) == 0x000008, "Wrong alignment on FOrbitData");
static_assert(sizeof(FOrbitData) == 0x000028, "Wrong size on FOrbitData");
static_assert(offsetof(FOrbitData, OrbitingActor) == 0x000000, "Member 'FOrbitData::OrbitingActor' has a wrong offset!");

// ScriptStruct man.VariableFloat
// 0x0018 (0x0048 - 0x0030)
struct FVariableFloat final : public FVariable
{
public:
	float                                         Value;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableFloat) == 0x000008, "Wrong alignment on FVariableFloat");
static_assert(sizeof(FVariableFloat) == 0x000048, "Wrong size on FVariableFloat");
static_assert(offsetof(FVariableFloat, Value) == 0x000030, "Member 'FVariableFloat::Value' has a wrong offset!");

// ScriptStruct man.ComponentScaleData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FComponentScaleData final
{
public:
	struct FComponentReference                    Component;                                         // 0x0000(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                StartScale;                                        // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndScale;                                          // 0x0034(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartOffset;                                       // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndOffset;                                         // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleTime;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x34];                                      // 0x005C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComponentScaleData) == 0x000010, "Wrong alignment on FComponentScaleData");
static_assert(sizeof(FComponentScaleData) == 0x000090, "Wrong size on FComponentScaleData");
static_assert(offsetof(FComponentScaleData, Component) == 0x000000, "Member 'FComponentScaleData::Component' has a wrong offset!");
static_assert(offsetof(FComponentScaleData, StartScale) == 0x000028, "Member 'FComponentScaleData::StartScale' has a wrong offset!");
static_assert(offsetof(FComponentScaleData, EndScale) == 0x000034, "Member 'FComponentScaleData::EndScale' has a wrong offset!");
static_assert(offsetof(FComponentScaleData, StartOffset) == 0x000040, "Member 'FComponentScaleData::StartOffset' has a wrong offset!");
static_assert(offsetof(FComponentScaleData, EndOffset) == 0x00004C, "Member 'FComponentScaleData::EndOffset' has a wrong offset!");
static_assert(offsetof(FComponentScaleData, ScaleTime) == 0x000058, "Member 'FComponentScaleData::ScaleTime' has a wrong offset!");

// ScriptStruct man.PrimalSlotItem
// 0x0018 (0x0018 - 0x0000)
struct FPrimalSlotItem final
{
public:
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ActorComponents;                                   // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimalSlotItem) == 0x000008, "Wrong alignment on FPrimalSlotItem");
static_assert(sizeof(FPrimalSlotItem) == 0x000018, "Wrong size on FPrimalSlotItem");
static_assert(offsetof(FPrimalSlotItem, MaterialInstance) == 0x000000, "Member 'FPrimalSlotItem::MaterialInstance' has a wrong offset!");
static_assert(offsetof(FPrimalSlotItem, ActorComponents) == 0x000008, "Member 'FPrimalSlotItem::ActorComponents' has a wrong offset!");

// ScriptStruct man.PrimalSlot
// 0x0028 (0x0028 - 0x0000)
struct FPrimalSlot final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimalSlotItem>                Items;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      DefaultSlotMaterialInstance;                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      DefaultFemaleSlotMaterialInstance;                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimalSlot) == 0x000008, "Wrong alignment on FPrimalSlot");
static_assert(sizeof(FPrimalSlot) == 0x000028, "Wrong size on FPrimalSlot");
static_assert(offsetof(FPrimalSlot, Name) == 0x000000, "Member 'FPrimalSlot::Name' has a wrong offset!");
static_assert(offsetof(FPrimalSlot, Items) == 0x000008, "Member 'FPrimalSlot::Items' has a wrong offset!");
static_assert(offsetof(FPrimalSlot, DefaultSlotMaterialInstance) == 0x000018, "Member 'FPrimalSlot::DefaultSlotMaterialInstance' has a wrong offset!");
static_assert(offsetof(FPrimalSlot, DefaultFemaleSlotMaterialInstance) == 0x000020, "Member 'FPrimalSlot::DefaultFemaleSlotMaterialInstance' has a wrong offset!");

// ScriptStruct man.AbilityUnlockRequirements
// 0x001C (0x001C - 0x0000)
struct FAbilityUnlockRequirements final
{
public:
	int32                                         LevelRequirement;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrengthRequirement;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DexterityRequirement;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PowerRequirement;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeRequirement;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritRequirement;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConstitutionRequirement;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityUnlockRequirements) == 0x000004, "Wrong alignment on FAbilityUnlockRequirements");
static_assert(sizeof(FAbilityUnlockRequirements) == 0x00001C, "Wrong size on FAbilityUnlockRequirements");
static_assert(offsetof(FAbilityUnlockRequirements, LevelRequirement) == 0x000000, "Member 'FAbilityUnlockRequirements::LevelRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, StrengthRequirement) == 0x000004, "Member 'FAbilityUnlockRequirements::StrengthRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, DexterityRequirement) == 0x000008, "Member 'FAbilityUnlockRequirements::DexterityRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, PowerRequirement) == 0x00000C, "Member 'FAbilityUnlockRequirements::PowerRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, KnowledgeRequirement) == 0x000010, "Member 'FAbilityUnlockRequirements::KnowledgeRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, SpiritRequirement) == 0x000014, "Member 'FAbilityUnlockRequirements::SpiritRequirement' has a wrong offset!");
static_assert(offsetof(FAbilityUnlockRequirements, ConstitutionRequirement) == 0x000018, "Member 'FAbilityUnlockRequirements::ConstitutionRequirement' has a wrong offset!");

// ScriptStruct man.Progress2PeriodNode
// 0x0018 (0x0018 - 0x0000)
struct FProgress2PeriodNode final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetAnimProgress;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartProgress;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndProgress;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgress2PeriodNode) == 0x000008, "Wrong alignment on FProgress2PeriodNode");
static_assert(sizeof(FProgress2PeriodNode) == 0x000018, "Wrong size on FProgress2PeriodNode");
static_assert(offsetof(FProgress2PeriodNode, AnimID) == 0x000000, "Member 'FProgress2PeriodNode::AnimID' has a wrong offset!");
static_assert(offsetof(FProgress2PeriodNode, bSetAnimProgress) == 0x000008, "Member 'FProgress2PeriodNode::bSetAnimProgress' has a wrong offset!");
static_assert(offsetof(FProgress2PeriodNode, StartProgress) == 0x00000C, "Member 'FProgress2PeriodNode::StartProgress' has a wrong offset!");
static_assert(offsetof(FProgress2PeriodNode, EndProgress) == 0x000010, "Member 'FProgress2PeriodNode::EndProgress' has a wrong offset!");

// ScriptStruct man.VortexItemScalePair
// 0x0030 (0x0030 - 0x0000)
struct FVortexItemScalePair final
{
public:
	TSoftClassPtr<class UClass>                   Item;                                              // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScaleValue;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVortexItemScalePair) == 0x000008, "Wrong alignment on FVortexItemScalePair");
static_assert(sizeof(FVortexItemScalePair) == 0x000030, "Wrong size on FVortexItemScalePair");
static_assert(offsetof(FVortexItemScalePair, Item) == 0x000000, "Member 'FVortexItemScalePair::Item' has a wrong offset!");
static_assert(offsetof(FVortexItemScalePair, DamageScaleValue) == 0x000028, "Member 'FVortexItemScalePair::DamageScaleValue' has a wrong offset!");

// ScriptStruct man.VOrtexLootTableElement
// 0x0020 (0x0020 - 0x0000)
struct FVOrtexLootTableElement final
{
public:
	class UEntityLootTable*                       Table;                                             // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScoreMinMax;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVortexItemScalePair>           ItemScalePair;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVOrtexLootTableElement) == 0x000008, "Wrong alignment on FVOrtexLootTableElement");
static_assert(sizeof(FVOrtexLootTableElement) == 0x000020, "Wrong size on FVOrtexLootTableElement");
static_assert(offsetof(FVOrtexLootTableElement, Table) == 0x000000, "Member 'FVOrtexLootTableElement::Table' has a wrong offset!");
static_assert(offsetof(FVOrtexLootTableElement, ScoreMinMax) == 0x000008, "Member 'FVOrtexLootTableElement::ScoreMinMax' has a wrong offset!");
static_assert(offsetof(FVOrtexLootTableElement, ItemScalePair) == 0x000010, "Member 'FVOrtexLootTableElement::ItemScalePair' has a wrong offset!");

// ScriptStruct man.ManSaveBundle
// 0x0018 (0x0018 - 0x0000)
struct FManSaveBundle final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UManSaveGame*                           SaveGame;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManSaveGamePreview*                    SaveGamePreview;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManSaveBundle) == 0x000008, "Wrong alignment on FManSaveBundle");
static_assert(sizeof(FManSaveBundle) == 0x000018, "Wrong size on FManSaveBundle");
static_assert(offsetof(FManSaveBundle, Slot) == 0x000000, "Member 'FManSaveBundle::Slot' has a wrong offset!");
static_assert(offsetof(FManSaveBundle, SaveGame) == 0x000008, "Member 'FManSaveBundle::SaveGame' has a wrong offset!");
static_assert(offsetof(FManSaveBundle, SaveGamePreview) == 0x000010, "Member 'FManSaveBundle::SaveGamePreview' has a wrong offset!");

// ScriptStruct man.SoftUIItemAbility
// 0x0048 (0x0048 - 0x0000)
struct FSoftUIItemAbility
{
public:
	TSoftClassPtr<class UClass>                   SoftItem;                                          // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetPathName;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemNameSourceString;                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoftUIItemAbility) == 0x000008, "Wrong alignment on FSoftUIItemAbility");
static_assert(sizeof(FSoftUIItemAbility) == 0x000048, "Wrong size on FSoftUIItemAbility");
static_assert(offsetof(FSoftUIItemAbility, SoftItem) == 0x000000, "Member 'FSoftUIItemAbility::SoftItem' has a wrong offset!");
static_assert(offsetof(FSoftUIItemAbility, AssetPathName) == 0x000028, "Member 'FSoftUIItemAbility::AssetPathName' has a wrong offset!");
static_assert(offsetof(FSoftUIItemAbility, ItemNameSourceString) == 0x000030, "Member 'FSoftUIItemAbility::ItemNameSourceString' has a wrong offset!");

// ScriptStruct man.ItemDLCSettings
// 0x0003 (0x0003 - 0x0000)
struct FItemDLCSettings final
{
public:
	bool                                          bBaseGame;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersonalCart;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAchivement;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDLCSettings) == 0x000001, "Wrong alignment on FItemDLCSettings");
static_assert(sizeof(FItemDLCSettings) == 0x000003, "Wrong size on FItemDLCSettings");
static_assert(offsetof(FItemDLCSettings, bBaseGame) == 0x000000, "Member 'FItemDLCSettings::bBaseGame' has a wrong offset!");
static_assert(offsetof(FItemDLCSettings, bPersonalCart) == 0x000001, "Member 'FItemDLCSettings::bPersonalCart' has a wrong offset!");
static_assert(offsetof(FItemDLCSettings, bAchivement) == 0x000002, "Member 'FItemDLCSettings::bAchivement' has a wrong offset!");

// ScriptStruct man.StatusForStatusData
// 0x0018 (0x0018 - 0x0000)
struct FStatusForStatusData final
{
public:
	EStatusEffectType                             StatusEffectTypeToReact;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffectTemplateData*>      StatusEffectTypesToAdd;                            // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusForStatusData) == 0x000008, "Wrong alignment on FStatusForStatusData");
static_assert(sizeof(FStatusForStatusData) == 0x000018, "Wrong size on FStatusForStatusData");
static_assert(offsetof(FStatusForStatusData, StatusEffectTypeToReact) == 0x000000, "Member 'FStatusForStatusData::StatusEffectTypeToReact' has a wrong offset!");
static_assert(offsetof(FStatusForStatusData, StatusEffectTypesToAdd) == 0x000008, "Member 'FStatusForStatusData::StatusEffectTypesToAdd' has a wrong offset!");

// ScriptStruct man.CharacterMaterialModifier
// 0x0020 (0x0020 - 0x0000)
struct FCharacterMaterialModifier final
{
public:
	TSubclassOf<class ACharacterBase>             CharacterClass;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseMultiplier;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFresnel;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FresnelColor;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMaterialModifier) == 0x000008, "Wrong alignment on FCharacterMaterialModifier");
static_assert(sizeof(FCharacterMaterialModifier) == 0x000020, "Wrong size on FCharacterMaterialModifier");
static_assert(offsetof(FCharacterMaterialModifier, CharacterClass) == 0x000000, "Member 'FCharacterMaterialModifier::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialModifier, DiffuseMultiplier) == 0x000008, "Member 'FCharacterMaterialModifier::DiffuseMultiplier' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialModifier, bOverrideFresnel) == 0x00000C, "Member 'FCharacterMaterialModifier::bOverrideFresnel' has a wrong offset!");
static_assert(offsetof(FCharacterMaterialModifier, FresnelColor) == 0x000010, "Member 'FCharacterMaterialModifier::FresnelColor' has a wrong offset!");

// ScriptStruct man.DamageSet
// 0x0100 (0x0100 - 0x0000)
struct FDamageSet final
{
public:
	bool                                          bForceUseAnimationAndVFXData;                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyWeaponDamage;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightHandWeaponRate;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandWeaponRate;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponStaggerValueMultiplier;                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponStaggerDurationMultiplier;                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDamageSetComponent*>            Damages;                                           // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDamageFlags                           DamageFlags;                                       // 0x0028(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageAnimationAndVFXData             AnimationAndVFXData;                               // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBasicDamageData                       BasicDamageSettings;                               // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponIC*                              DamageWeaponIC;                                    // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityBase*                           DamagingAbility;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageSet) == 0x000008, "Wrong alignment on FDamageSet");
static_assert(sizeof(FDamageSet) == 0x000100, "Wrong size on FDamageSet");
static_assert(offsetof(FDamageSet, bForceUseAnimationAndVFXData) == 0x000000, "Member 'FDamageSet::bForceUseAnimationAndVFXData' has a wrong offset!");
static_assert(offsetof(FDamageSet, bApplyWeaponDamage) == 0x000001, "Member 'FDamageSet::bApplyWeaponDamage' has a wrong offset!");
static_assert(offsetof(FDamageSet, RightHandWeaponRate) == 0x000004, "Member 'FDamageSet::RightHandWeaponRate' has a wrong offset!");
static_assert(offsetof(FDamageSet, LeftHandWeaponRate) == 0x000008, "Member 'FDamageSet::LeftHandWeaponRate' has a wrong offset!");
static_assert(offsetof(FDamageSet, WeaponStaggerValueMultiplier) == 0x00000C, "Member 'FDamageSet::WeaponStaggerValueMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageSet, WeaponStaggerDurationMultiplier) == 0x000010, "Member 'FDamageSet::WeaponStaggerDurationMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageSet, Damages) == 0x000018, "Member 'FDamageSet::Damages' has a wrong offset!");
static_assert(offsetof(FDamageSet, DamageFlags) == 0x000028, "Member 'FDamageSet::DamageFlags' has a wrong offset!");
static_assert(offsetof(FDamageSet, AnimationAndVFXData) == 0x000050, "Member 'FDamageSet::AnimationAndVFXData' has a wrong offset!");
static_assert(offsetof(FDamageSet, BasicDamageSettings) == 0x000078, "Member 'FDamageSet::BasicDamageSettings' has a wrong offset!");
static_assert(offsetof(FDamageSet, DamageWeaponIC) == 0x0000E0, "Member 'FDamageSet::DamageWeaponIC' has a wrong offset!");
static_assert(offsetof(FDamageSet, DamagingAbility) == 0x0000E8, "Member 'FDamageSet::DamagingAbility' has a wrong offset!");

// ScriptStruct man.SpineBone
// 0x0010 (0x0010 - 0x0000)
struct FSpineBone final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Translation;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineBone) == 0x000004, "Wrong alignment on FSpineBone");
static_assert(sizeof(FSpineBone) == 0x000010, "Wrong size on FSpineBone");
static_assert(offsetof(FSpineBone, SocketName) == 0x000000, "Member 'FSpineBone::SocketName' has a wrong offset!");
static_assert(offsetof(FSpineBone, Translation) == 0x000008, "Member 'FSpineBone::Translation' has a wrong offset!");
static_assert(offsetof(FSpineBone, Rotation) == 0x00000C, "Member 'FSpineBone::Rotation' has a wrong offset!");

// ScriptStruct man.DebugValues
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FDebugValues final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugValues) == 0x000004, "Wrong alignment on FDebugValues");
static_assert(sizeof(FDebugValues) == 0x000020, "Wrong size on FDebugValues");

// ScriptStruct man.ManSoftVisualEntityClass
// 0x0030 (0x0030 - 0x0000)
struct FManSoftVisualEntityClass final
{
public:
	TSoftClassPtr<class UClass>                   VisualEntityClass;                                 // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVisualEntity>              VisualEntityClassLoaded;                           // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManSoftVisualEntityClass) == 0x000008, "Wrong alignment on FManSoftVisualEntityClass");
static_assert(sizeof(FManSoftVisualEntityClass) == 0x000030, "Wrong size on FManSoftVisualEntityClass");
static_assert(offsetof(FManSoftVisualEntityClass, VisualEntityClass) == 0x000000, "Member 'FManSoftVisualEntityClass::VisualEntityClass' has a wrong offset!");
static_assert(offsetof(FManSoftVisualEntityClass, VisualEntityClassLoaded) == 0x000028, "Member 'FManSoftVisualEntityClass::VisualEntityClassLoaded' has a wrong offset!");

// ScriptStruct man.CustomEventByDistanceNode
// 0x000C (0x000C - 0x0000)
struct FCustomEventByDistanceNode final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Event;                                             // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomEventByDistanceNode) == 0x000004, "Wrong alignment on FCustomEventByDistanceNode");
static_assert(sizeof(FCustomEventByDistanceNode) == 0x00000C, "Wrong size on FCustomEventByDistanceNode");
static_assert(offsetof(FCustomEventByDistanceNode, Distance) == 0x000000, "Member 'FCustomEventByDistanceNode::Distance' has a wrong offset!");
static_assert(offsetof(FCustomEventByDistanceNode, Event) == 0x000004, "Member 'FCustomEventByDistanceNode::Event' has a wrong offset!");

// ScriptStruct man.AccessibilityDifficultyNode
// 0x0010 (0x0010 - 0x0000)
struct FAccessibilityDifficultyNode final
{
public:
	TSubclassOf<class UAbilityBase>               EnemyModifier;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               HeroModifier;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessibilityDifficultyNode) == 0x000008, "Wrong alignment on FAccessibilityDifficultyNode");
static_assert(sizeof(FAccessibilityDifficultyNode) == 0x000010, "Wrong size on FAccessibilityDifficultyNode");
static_assert(offsetof(FAccessibilityDifficultyNode, EnemyModifier) == 0x000000, "Member 'FAccessibilityDifficultyNode::EnemyModifier' has a wrong offset!");
static_assert(offsetof(FAccessibilityDifficultyNode, HeroModifier) == 0x000008, "Member 'FAccessibilityDifficultyNode::HeroModifier' has a wrong offset!");

// ScriptStruct man.VEProjectileFlags
// 0x0010 (0x0010 - 0x0000)
struct FVEProjectileFlags final
{
public:
	class AActor*                                 ProjectileKiller;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   KillerDmgType;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEProjectileFlags) == 0x000008, "Wrong alignment on FVEProjectileFlags");
static_assert(sizeof(FVEProjectileFlags) == 0x000010, "Wrong size on FVEProjectileFlags");
static_assert(offsetof(FVEProjectileFlags, ProjectileKiller) == 0x000000, "Member 'FVEProjectileFlags::ProjectileKiller' has a wrong offset!");
static_assert(offsetof(FVEProjectileFlags, KillerDmgType) == 0x000008, "Member 'FVEProjectileFlags::KillerDmgType' has a wrong offset!");

// ScriptStruct man.LevelTeleportData
// 0x0030 (0x0030 - 0x0000)
struct FLevelTeleportData
{
public:
	TSoftObjectPtr<class UWorld>                  LevelReference;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportTargetName;                                // 0x0028(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelTeleportData) == 0x000008, "Wrong alignment on FLevelTeleportData");
static_assert(sizeof(FLevelTeleportData) == 0x000030, "Wrong size on FLevelTeleportData");
static_assert(offsetof(FLevelTeleportData, LevelReference) == 0x000000, "Member 'FLevelTeleportData::LevelReference' has a wrong offset!");
static_assert(offsetof(FLevelTeleportData, TeleportTargetName) == 0x000028, "Member 'FLevelTeleportData::TeleportTargetName' has a wrong offset!");

// ScriptStruct man.EntropicFissureGeneratorNode
// 0x0014 (0x0014 - 0x0000)
struct FEntropicFissureGeneratorNode final
{
public:
	bool                                          bUseTargetLocation;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistMin;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistMax;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDelayMin;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDelayMax;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntropicFissureGeneratorNode) == 0x000004, "Wrong alignment on FEntropicFissureGeneratorNode");
static_assert(sizeof(FEntropicFissureGeneratorNode) == 0x000014, "Wrong size on FEntropicFissureGeneratorNode");
static_assert(offsetof(FEntropicFissureGeneratorNode, bUseTargetLocation) == 0x000000, "Member 'FEntropicFissureGeneratorNode::bUseTargetLocation' has a wrong offset!");
static_assert(offsetof(FEntropicFissureGeneratorNode, DistMin) == 0x000004, "Member 'FEntropicFissureGeneratorNode::DistMin' has a wrong offset!");
static_assert(offsetof(FEntropicFissureGeneratorNode, DistMax) == 0x000008, "Member 'FEntropicFissureGeneratorNode::DistMax' has a wrong offset!");
static_assert(offsetof(FEntropicFissureGeneratorNode, SpawnDelayMin) == 0x00000C, "Member 'FEntropicFissureGeneratorNode::SpawnDelayMin' has a wrong offset!");
static_assert(offsetof(FEntropicFissureGeneratorNode, SpawnDelayMax) == 0x000010, "Member 'FEntropicFissureGeneratorNode::SpawnDelayMax' has a wrong offset!");

// ScriptStruct man.Progress2EventNode
// 0x0038 (0x0038 - 0x0000)
struct FProgress2EventNode final
{
public:
	struct FAbilityEventEditor                    Event;                                             // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgress2EventNode) == 0x000008, "Wrong alignment on FProgress2EventNode");
static_assert(sizeof(FProgress2EventNode) == 0x000038, "Wrong size on FProgress2EventNode");
static_assert(offsetof(FProgress2EventNode, Event) == 0x000000, "Member 'FProgress2EventNode::Event' has a wrong offset!");
static_assert(offsetof(FProgress2EventNode, Progress) == 0x000030, "Member 'FProgress2EventNode::Progress' has a wrong offset!");

// ScriptStruct man.QuestItemReward
// 0x0010 (0x0010 - 0x0000)
struct FQuestItemReward final
{
public:
	int32                                         amount;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UItemAbility>               Item;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestItemReward) == 0x000008, "Wrong alignment on FQuestItemReward");
static_assert(sizeof(FQuestItemReward) == 0x000010, "Wrong size on FQuestItemReward");
static_assert(offsetof(FQuestItemReward, amount) == 0x000000, "Member 'FQuestItemReward::amount' has a wrong offset!");
static_assert(offsetof(FQuestItemReward, Item) == 0x000008, "Member 'FQuestItemReward::Item' has a wrong offset!");

// ScriptStruct man.ManAchBundle
// 0x0050 (0x0050 - 0x0000)
struct FManAchBundle final
{
public:
	TMap<class FString, struct FAchSaveValues>    AchMap;                                            // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FManAchBundle) == 0x000008, "Wrong alignment on FManAchBundle");
static_assert(sizeof(FManAchBundle) == 0x000050, "Wrong size on FManAchBundle");
static_assert(offsetof(FManAchBundle, AchMap) == 0x000000, "Member 'FManAchBundle::AchMap' has a wrong offset!");

// ScriptStruct man.SaveGameSlot
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSaveGameSlot final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameSlot) == 0x000008, "Wrong alignment on FSaveGameSlot");
static_assert(sizeof(FSaveGameSlot) == 0x000010, "Wrong size on FSaveGameSlot");

// ScriptStruct man.DamageConvertData
// 0x000C (0x000C - 0x0000)
struct FDamageConvertData final
{
public:
	EDamageType                                   SourceDamageType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   TargetDamageType;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConversionPercent;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateNewConvertedDamage;                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageConvertData) == 0x000004, "Wrong alignment on FDamageConvertData");
static_assert(sizeof(FDamageConvertData) == 0x00000C, "Wrong size on FDamageConvertData");
static_assert(offsetof(FDamageConvertData, SourceDamageType) == 0x000000, "Member 'FDamageConvertData::SourceDamageType' has a wrong offset!");
static_assert(offsetof(FDamageConvertData, TargetDamageType) == 0x000001, "Member 'FDamageConvertData::TargetDamageType' has a wrong offset!");
static_assert(offsetof(FDamageConvertData, ConversionPercent) == 0x000004, "Member 'FDamageConvertData::ConversionPercent' has a wrong offset!");
static_assert(offsetof(FDamageConvertData, bCreateNewConvertedDamage) == 0x000008, "Member 'FDamageConvertData::bCreateNewConvertedDamage' has a wrong offset!");

// ScriptStruct man.EntityAbilityOverride
// 0x0010 (0x0010 - 0x0000)
struct FEntityAbilityOverride final
{
public:
	TSubclassOf<class UAbilityBase>               SourceAbility;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               TargetAbility;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntityAbilityOverride) == 0x000008, "Wrong alignment on FEntityAbilityOverride");
static_assert(sizeof(FEntityAbilityOverride) == 0x000010, "Wrong size on FEntityAbilityOverride");
static_assert(offsetof(FEntityAbilityOverride, SourceAbility) == 0x000000, "Member 'FEntityAbilityOverride::SourceAbility' has a wrong offset!");
static_assert(offsetof(FEntityAbilityOverride, TargetAbility) == 0x000008, "Member 'FEntityAbilityOverride::TargetAbility' has a wrong offset!");

// ScriptStruct man.AbilityCostTextData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAbilityCostTextData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityCostTextData) == 0x000004, "Wrong alignment on FAbilityCostTextData");
static_assert(sizeof(FAbilityCostTextData) == 0x00000C, "Wrong size on FAbilityCostTextData");

// ScriptStruct man.PersonalCartItemNode
// 0x0010 (0x0058 - 0x0048)
struct FPersonalCartItemNode final : public FSoftUIItemAbility
{
public:
	int32                                         ItemLevel;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainItemType                                 ItemType;                                          // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     EquipSlot;                                         // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemDLCSettings                       DLCSettings;                                       // 0x004F(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPersonalCartItemNode) == 0x000008, "Wrong alignment on FPersonalCartItemNode");
static_assert(sizeof(FPersonalCartItemNode) == 0x000058, "Wrong size on FPersonalCartItemNode");
static_assert(offsetof(FPersonalCartItemNode, ItemLevel) == 0x000048, "Member 'FPersonalCartItemNode::ItemLevel' has a wrong offset!");
static_assert(offsetof(FPersonalCartItemNode, ItemType) == 0x00004C, "Member 'FPersonalCartItemNode::ItemType' has a wrong offset!");
static_assert(offsetof(FPersonalCartItemNode, EquipSlot) == 0x00004D, "Member 'FPersonalCartItemNode::EquipSlot' has a wrong offset!");
static_assert(offsetof(FPersonalCartItemNode, WeaponType) == 0x00004E, "Member 'FPersonalCartItemNode::WeaponType' has a wrong offset!");
static_assert(offsetof(FPersonalCartItemNode, DLCSettings) == 0x00004F, "Member 'FPersonalCartItemNode::DLCSettings' has a wrong offset!");

// ScriptStruct man.HitBoxHitEventSettingsNode
// 0x00C0 (0x00C0 - 0x0000)
struct FHitBoxHitEventSettingsNode final
{
public:
	struct FAbilityEventEditor                    StartEvent;                                        // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAbilityEventEditor                    EndEvent;                                          // 0x0030(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAbilityEventEditor                    HitEvent;                                          // 0x0060(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAbilityEventEditor                    MissEvent;                                         // 0x0090(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitBoxHitEventSettingsNode) == 0x000008, "Wrong alignment on FHitBoxHitEventSettingsNode");
static_assert(sizeof(FHitBoxHitEventSettingsNode) == 0x0000C0, "Wrong size on FHitBoxHitEventSettingsNode");
static_assert(offsetof(FHitBoxHitEventSettingsNode, StartEvent) == 0x000000, "Member 'FHitBoxHitEventSettingsNode::StartEvent' has a wrong offset!");
static_assert(offsetof(FHitBoxHitEventSettingsNode, EndEvent) == 0x000030, "Member 'FHitBoxHitEventSettingsNode::EndEvent' has a wrong offset!");
static_assert(offsetof(FHitBoxHitEventSettingsNode, HitEvent) == 0x000060, "Member 'FHitBoxHitEventSettingsNode::HitEvent' has a wrong offset!");
static_assert(offsetof(FHitBoxHitEventSettingsNode, MissEvent) == 0x000090, "Member 'FHitBoxHitEventSettingsNode::MissEvent' has a wrong offset!");

// ScriptStruct man.GuardedAnimEventNode
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGuardedAnimEventNode final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardedAnimEventNode) == 0x000008, "Wrong alignment on FGuardedAnimEventNode");
static_assert(sizeof(FGuardedAnimEventNode) == 0x000010, "Wrong size on FGuardedAnimEventNode");

// ScriptStruct man.CustomEventWithWeightData
// 0x000C (0x000C - 0x0000)
struct FCustomEventWithWeightData final
{
public:
	class FName                                   CustomEventToEmit;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomEventWithWeightData) == 0x000004, "Wrong alignment on FCustomEventWithWeightData");
static_assert(sizeof(FCustomEventWithWeightData) == 0x00000C, "Wrong size on FCustomEventWithWeightData");
static_assert(offsetof(FCustomEventWithWeightData, CustomEventToEmit) == 0x000000, "Member 'FCustomEventWithWeightData::CustomEventToEmit' has a wrong offset!");
static_assert(offsetof(FCustomEventWithWeightData, Weight) == 0x000008, "Member 'FCustomEventWithWeightData::Weight' has a wrong offset!");

// ScriptStruct man.HitBoxCollideEntry
// 0x0018 (0x0018 - 0x0000)
struct FHitBoxCollideEntry final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitBoxCollideEntry) == 0x000008, "Wrong alignment on FHitBoxCollideEntry");
static_assert(sizeof(FHitBoxCollideEntry) == 0x000018, "Wrong size on FHitBoxCollideEntry");
static_assert(offsetof(FHitBoxCollideEntry, Actor) == 0x000000, "Member 'FHitBoxCollideEntry::Actor' has a wrong offset!");

// ScriptStruct man.GlobalAbilityAnimEventData
// 0x0018 (0x0018 - 0x0000)
struct FGlobalAbilityAnimEventData final
{
public:
	class UAbilityBase*                           Ability;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                Anim;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimEventType                                AnimEventType;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalAbilityAnimEventData) == 0x000008, "Wrong alignment on FGlobalAbilityAnimEventData");
static_assert(sizeof(FGlobalAbilityAnimEventData) == 0x000018, "Wrong size on FGlobalAbilityAnimEventData");
static_assert(offsetof(FGlobalAbilityAnimEventData, Ability) == 0x000000, "Member 'FGlobalAbilityAnimEventData::Ability' has a wrong offset!");
static_assert(offsetof(FGlobalAbilityAnimEventData, Anim) == 0x000008, "Member 'FGlobalAbilityAnimEventData::Anim' has a wrong offset!");
static_assert(offsetof(FGlobalAbilityAnimEventData, AnimEventType) == 0x000010, "Member 'FGlobalAbilityAnimEventData::AnimEventType' has a wrong offset!");

// ScriptStruct man.GenerateRandomEventNode
// 0x000C (0x000C - 0x0000)
struct FGenerateRandomEventNode final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomName;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenerateRandomEventNode) == 0x000004, "Wrong alignment on FGenerateRandomEventNode");
static_assert(sizeof(FGenerateRandomEventNode) == 0x00000C, "Wrong size on FGenerateRandomEventNode");
static_assert(offsetof(FGenerateRandomEventNode, Rate) == 0x000000, "Member 'FGenerateRandomEventNode::Rate' has a wrong offset!");
static_assert(offsetof(FGenerateRandomEventNode, CustomName) == 0x000004, "Member 'FGenerateRandomEventNode::CustomName' has a wrong offset!");

// ScriptStruct man.AbilityResourceEditor
// 0x000F (0x000F - 0x0000)
struct FAbilityResourceEditor final
{
public:
	bool                                          All;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Move;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Jump;                                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Roll;                                              // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attack;                                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttackControlOnly;                                 // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttackOnly;                                        // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefendControl;                                     // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemSet;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          QuickUse;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RootMotion;                                        // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ducking;                                           // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Interact;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Input;                                             // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Stun;                                              // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityResourceEditor) == 0x000001, "Wrong alignment on FAbilityResourceEditor");
static_assert(sizeof(FAbilityResourceEditor) == 0x00000F, "Wrong size on FAbilityResourceEditor");
static_assert(offsetof(FAbilityResourceEditor, All) == 0x000000, "Member 'FAbilityResourceEditor::All' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Move) == 0x000001, "Member 'FAbilityResourceEditor::Move' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Jump) == 0x000002, "Member 'FAbilityResourceEditor::Jump' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Roll) == 0x000003, "Member 'FAbilityResourceEditor::Roll' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Attack) == 0x000004, "Member 'FAbilityResourceEditor::Attack' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, AttackControlOnly) == 0x000005, "Member 'FAbilityResourceEditor::AttackControlOnly' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, AttackOnly) == 0x000006, "Member 'FAbilityResourceEditor::AttackOnly' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, DefendControl) == 0x000007, "Member 'FAbilityResourceEditor::DefendControl' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, ItemSet) == 0x000008, "Member 'FAbilityResourceEditor::ItemSet' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, QuickUse) == 0x000009, "Member 'FAbilityResourceEditor::QuickUse' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, RootMotion) == 0x00000A, "Member 'FAbilityResourceEditor::RootMotion' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Ducking) == 0x00000B, "Member 'FAbilityResourceEditor::Ducking' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Interact) == 0x00000C, "Member 'FAbilityResourceEditor::Interact' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Input) == 0x00000D, "Member 'FAbilityResourceEditor::Input' has a wrong offset!");
static_assert(offsetof(FAbilityResourceEditor, Stun) == 0x00000E, "Member 'FAbilityResourceEditor::Stun' has a wrong offset!");

// ScriptStruct man.ModificationData
// 0x0008 (0x0008 - 0x0000)
struct FModificationData final
{
public:
	float                                         DamageMultiplier;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatModifier;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModificationData) == 0x000004, "Wrong alignment on FModificationData");
static_assert(sizeof(FModificationData) == 0x000008, "Wrong size on FModificationData");
static_assert(offsetof(FModificationData, DamageMultiplier) == 0x000000, "Member 'FModificationData::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FModificationData, FlatModifier) == 0x000004, "Member 'FModificationData::FlatModifier' has a wrong offset!");

// ScriptStruct man.ModifyAttributeAbilityComponent_ScaleNode
// 0x0008 (0x0008 - 0x0000)
struct FModifyAttributeAbilityComponent_ScaleNode final
{
public:
	EAttribute                                    AttributeScale;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifyAttributeAbilityComponent_ScaleNode) == 0x000004, "Wrong alignment on FModifyAttributeAbilityComponent_ScaleNode");
static_assert(sizeof(FModifyAttributeAbilityComponent_ScaleNode) == 0x000008, "Wrong size on FModifyAttributeAbilityComponent_ScaleNode");
static_assert(offsetof(FModifyAttributeAbilityComponent_ScaleNode, AttributeScale) == 0x000000, "Member 'FModifyAttributeAbilityComponent_ScaleNode::AttributeScale' has a wrong offset!");
static_assert(offsetof(FModifyAttributeAbilityComponent_ScaleNode, Scale) == 0x000004, "Member 'FModifyAttributeAbilityComponent_ScaleNode::Scale' has a wrong offset!");

// ScriptStruct man.NotificationInstanceData
// 0x0010 (0x0010 - 0x0000)
struct FNotificationInstanceData final
{
public:
	class AVisualEntity*                          VisualEntityInstance;                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotificationPriority;                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotificationHalfHeight;                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotificationInstanceData) == 0x000008, "Wrong alignment on FNotificationInstanceData");
static_assert(sizeof(FNotificationInstanceData) == 0x000010, "Wrong size on FNotificationInstanceData");
static_assert(offsetof(FNotificationInstanceData, VisualEntityInstance) == 0x000000, "Member 'FNotificationInstanceData::VisualEntityInstance' has a wrong offset!");
static_assert(offsetof(FNotificationInstanceData, NotificationPriority) == 0x000008, "Member 'FNotificationInstanceData::NotificationPriority' has a wrong offset!");
static_assert(offsetof(FNotificationInstanceData, NotificationHalfHeight) == 0x00000C, "Member 'FNotificationInstanceData::NotificationHalfHeight' has a wrong offset!");

// ScriptStruct man.NotificationData
// 0x0048 (0x0048 - 0x0000)
struct FNotificationData final
{
public:
	struct FManSoftVisualEntityClass              VisualEntityType;                                  // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   NotificationStart;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotificationEnd;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotificationHalfHeight;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotificationPriority;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotificationData) == 0x000008, "Wrong alignment on FNotificationData");
static_assert(sizeof(FNotificationData) == 0x000048, "Wrong size on FNotificationData");
static_assert(offsetof(FNotificationData, VisualEntityType) == 0x000000, "Member 'FNotificationData::VisualEntityType' has a wrong offset!");
static_assert(offsetof(FNotificationData, NotificationStart) == 0x000030, "Member 'FNotificationData::NotificationStart' has a wrong offset!");
static_assert(offsetof(FNotificationData, NotificationEnd) == 0x000038, "Member 'FNotificationData::NotificationEnd' has a wrong offset!");
static_assert(offsetof(FNotificationData, NotificationHalfHeight) == 0x000040, "Member 'FNotificationData::NotificationHalfHeight' has a wrong offset!");
static_assert(offsetof(FNotificationData, NotificationPriority) == 0x000044, "Member 'FNotificationData::NotificationPriority' has a wrong offset!");

// ScriptStruct man.DefaultWeaponConfig
// 0x0020 (0x0020 - 0x0000)
struct FDefaultWeaponConfig final
{
public:
	TSubclassOf<class UItemAbility>               LeftHand;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               RightHand;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           LeftHandInstance;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           RightHandInstance;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultWeaponConfig) == 0x000008, "Wrong alignment on FDefaultWeaponConfig");
static_assert(sizeof(FDefaultWeaponConfig) == 0x000020, "Wrong size on FDefaultWeaponConfig");
static_assert(offsetof(FDefaultWeaponConfig, LeftHand) == 0x000000, "Member 'FDefaultWeaponConfig::LeftHand' has a wrong offset!");
static_assert(offsetof(FDefaultWeaponConfig, RightHand) == 0x000008, "Member 'FDefaultWeaponConfig::RightHand' has a wrong offset!");
static_assert(offsetof(FDefaultWeaponConfig, LeftHandInstance) == 0x000010, "Member 'FDefaultWeaponConfig::LeftHandInstance' has a wrong offset!");
static_assert(offsetof(FDefaultWeaponConfig, RightHandInstance) == 0x000018, "Member 'FDefaultWeaponConfig::RightHandInstance' has a wrong offset!");

// ScriptStruct man.AIHelperRatePerDistanceNode
// 0x0020 (0x0020 - 0x0000)
struct FAIHelperRatePerDistanceNode final
{
public:
	float                                         NeedBlockedPathBackWard;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForward;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackward;                                         // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceGreaterCondition;                         // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAbilityBase>               LastAbilityEndedCondition;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseFlags;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIHelperRatePerDistanceNode) == 0x000008, "Wrong alignment on FAIHelperRatePerDistanceNode");
static_assert(sizeof(FAIHelperRatePerDistanceNode) == 0x000020, "Wrong size on FAIHelperRatePerDistanceNode");
static_assert(offsetof(FAIHelperRatePerDistanceNode, NeedBlockedPathBackWard) == 0x000000, "Member 'FAIHelperRatePerDistanceNode::NeedBlockedPathBackWard' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, Distance) == 0x000004, "Member 'FAIHelperRatePerDistanceNode::Distance' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, Rate) == 0x000008, "Member 'FAIHelperRatePerDistanceNode::Rate' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, bForward) == 0x00000C, "Member 'FAIHelperRatePerDistanceNode::bForward' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, bBackward) == 0x00000D, "Member 'FAIHelperRatePerDistanceNode::bBackward' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, bDistanceGreaterCondition) == 0x00000E, "Member 'FAIHelperRatePerDistanceNode::bDistanceGreaterCondition' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, LastAbilityEndedCondition) == 0x000010, "Member 'FAIHelperRatePerDistanceNode::LastAbilityEndedCondition' has a wrong offset!");
static_assert(offsetof(FAIHelperRatePerDistanceNode, PhaseFlags) == 0x000018, "Member 'FAIHelperRatePerDistanceNode::PhaseFlags' has a wrong offset!");

// ScriptStruct man.AIBaseRoomEnterNode
// 0x0010 (0x0010 - 0x0000)
struct FAIBaseRoomEnterNode final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenInPreRoomEnter;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvulnerableDuringRoomEnter;                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCantBeHitDuringPreRoomEnter;                      // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontCollideDuringRoomEnter;                       // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomSelectable;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBaseRoomEnterNode) == 0x000008, "Wrong alignment on FAIBaseRoomEnterNode");
static_assert(sizeof(FAIBaseRoomEnterNode) == 0x000010, "Wrong size on FAIBaseRoomEnterNode");
static_assert(offsetof(FAIBaseRoomEnterNode, AnimID) == 0x000000, "Member 'FAIBaseRoomEnterNode::AnimID' has a wrong offset!");
static_assert(offsetof(FAIBaseRoomEnterNode, bHiddenInPreRoomEnter) == 0x000008, "Member 'FAIBaseRoomEnterNode::bHiddenInPreRoomEnter' has a wrong offset!");
static_assert(offsetof(FAIBaseRoomEnterNode, bInvulnerableDuringRoomEnter) == 0x000009, "Member 'FAIBaseRoomEnterNode::bInvulnerableDuringRoomEnter' has a wrong offset!");
static_assert(offsetof(FAIBaseRoomEnterNode, bCantBeHitDuringPreRoomEnter) == 0x00000A, "Member 'FAIBaseRoomEnterNode::bCantBeHitDuringPreRoomEnter' has a wrong offset!");
static_assert(offsetof(FAIBaseRoomEnterNode, bDontCollideDuringRoomEnter) == 0x00000B, "Member 'FAIBaseRoomEnterNode::bDontCollideDuringRoomEnter' has a wrong offset!");
static_assert(offsetof(FAIBaseRoomEnterNode, bRandomSelectable) == 0x00000C, "Member 'FAIBaseRoomEnterNode::bRandomSelectable' has a wrong offset!");

// ScriptStruct man.AINavPath
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAINavPath final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAINavPath) == 0x000008, "Wrong alignment on FAINavPath");
static_assert(sizeof(FAINavPath) == 0x000010, "Wrong size on FAINavPath");

// ScriptStruct man.AINavBox
// 0x0038 (0x0038 - 0x0000)
struct FAINavBox final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AAINavPoint*>                    NavPoints;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAINavBox) == 0x000008, "Wrong alignment on FAINavBox");
static_assert(sizeof(FAINavBox) == 0x000038, "Wrong size on FAINavBox");
static_assert(offsetof(FAINavBox, Actor) == 0x000020, "Member 'FAINavBox::Actor' has a wrong offset!");
static_assert(offsetof(FAINavBox, NavPoints) == 0x000028, "Member 'FAINavBox::NavPoints' has a wrong offset!");

// ScriptStruct man.BodyPart
// 0x0018 (0x0018 - 0x0000)
struct FBodyPart final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hidden;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBodyPart) == 0x000004, "Wrong alignment on FBodyPart");
static_assert(sizeof(FBodyPart) == 0x000018, "Wrong size on FBodyPart");
static_assert(offsetof(FBodyPart, BoneName) == 0x000000, "Member 'FBodyPart::BoneName' has a wrong offset!");
static_assert(offsetof(FBodyPart, BlendDuration) == 0x000008, "Member 'FBodyPart::BlendDuration' has a wrong offset!");
static_assert(offsetof(FBodyPart, Hidden) == 0x00000C, "Member 'FBodyPart::Hidden' has a wrong offset!");
static_assert(offsetof(FBodyPart, Weight) == 0x000010, "Member 'FBodyPart::Weight' has a wrong offset!");

// ScriptStruct man.RopeBone
// 0x0020 (0x0020 - 0x0000)
struct FRopeBone final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRopeBone) == 0x000004, "Wrong alignment on FRopeBone");
static_assert(sizeof(FRopeBone) == 0x000020, "Wrong size on FRopeBone");
static_assert(offsetof(FRopeBone, SocketName) == 0x000000, "Member 'FRopeBone::SocketName' has a wrong offset!");
static_assert(offsetof(FRopeBone, Translation) == 0x000008, "Member 'FRopeBone::Translation' has a wrong offset!");
static_assert(offsetof(FRopeBone, Rotation) == 0x000014, "Member 'FRopeBone::Rotation' has a wrong offset!");

// ScriptStruct man.RootSlope
// 0x0024 (0x0024 - 0x0000)
struct FRootSlope final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootSlope) == 0x000004, "Wrong alignment on FRootSlope");
static_assert(sizeof(FRootSlope) == 0x000024, "Wrong size on FRootSlope");
static_assert(offsetof(FRootSlope, BoneName) == 0x000000, "Member 'FRootSlope::BoneName' has a wrong offset!");
static_assert(offsetof(FRootSlope, Translation) == 0x000008, "Member 'FRootSlope::Translation' has a wrong offset!");
static_assert(offsetof(FRootSlope, Rotation) == 0x000014, "Member 'FRootSlope::Rotation' has a wrong offset!");
static_assert(offsetof(FRootSlope, Alpha) == 0x000020, "Member 'FRootSlope::Alpha' has a wrong offset!");

// ScriptStruct man.FootBone
// 0x0044 (0x0044 - 0x0000)
struct FFootBone final
{
public:
	class FName                                   AnkleBoneName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FootSocketName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector;                                          // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x18];                                      // 0x002C(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootBone) == 0x000004, "Wrong alignment on FFootBone");
static_assert(sizeof(FFootBone) == 0x000044, "Wrong size on FFootBone");
static_assert(offsetof(FFootBone, AnkleBoneName) == 0x000000, "Member 'FFootBone::AnkleBoneName' has a wrong offset!");
static_assert(offsetof(FFootBone, FootSocketName) == 0x000008, "Member 'FFootBone::FootSocketName' has a wrong offset!");
static_assert(offsetof(FFootBone, Effector) == 0x000010, "Member 'FFootBone::Effector' has a wrong offset!");
static_assert(offsetof(FFootBone, Rotation) == 0x00001C, "Member 'FFootBone::Rotation' has a wrong offset!");
static_assert(offsetof(FFootBone, Alpha) == 0x000028, "Member 'FFootBone::Alpha' has a wrong offset!");

// ScriptStruct man.AnimReplacement
// 0x0010 (0x0010 - 0x0000)
struct FAnimReplacement final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                ReplacementAnimID;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimReplacement) == 0x000008, "Wrong alignment on FAnimReplacement");
static_assert(sizeof(FAnimReplacement) == 0x000010, "Wrong size on FAnimReplacement");
static_assert(offsetof(FAnimReplacement, AnimID) == 0x000000, "Member 'FAnimReplacement::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimReplacement, ReplacementAnimID) == 0x000008, "Member 'FAnimReplacement::ReplacementAnimID' has a wrong offset!");

// ScriptStruct man.AnimDescriptor
// 0x0018 (0x0018 - 0x0000)
struct FAnimDescriptor final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RootMotion;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IKEnabled;                                         // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstantSwitchAnimIx;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimDescriptor) == 0x000008, "Wrong alignment on FAnimDescriptor");
static_assert(sizeof(FAnimDescriptor) == 0x000018, "Wrong size on FAnimDescriptor");
static_assert(offsetof(FAnimDescriptor, AnimID) == 0x000000, "Member 'FAnimDescriptor::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimDescriptor, Priority) == 0x000008, "Member 'FAnimDescriptor::Priority' has a wrong offset!");
static_assert(offsetof(FAnimDescriptor, RootMotion) == 0x00000C, "Member 'FAnimDescriptor::RootMotion' has a wrong offset!");
static_assert(offsetof(FAnimDescriptor, IKEnabled) == 0x00000D, "Member 'FAnimDescriptor::IKEnabled' has a wrong offset!");
static_assert(offsetof(FAnimDescriptor, InstantSwitchAnimIx) == 0x000010, "Member 'FAnimDescriptor::InstantSwitchAnimIx' has a wrong offset!");

// ScriptStruct man.AnimNode_BlendCloth
// 0x0058 (0x0068 - 0x0010)
struct FAnimNode_BlendCloth final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Modifier;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ClothBones;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MainBoneIndices;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 ClothBoneIndices;                                  // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_BlendCloth) == 0x000008, "Wrong alignment on FAnimNode_BlendCloth");
static_assert(sizeof(FAnimNode_BlendCloth) == 0x000068, "Wrong size on FAnimNode_BlendCloth");
static_assert(offsetof(FAnimNode_BlendCloth, BasePose) == 0x000010, "Member 'FAnimNode_BlendCloth::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendCloth, Modifier) == 0x000020, "Member 'FAnimNode_BlendCloth::Modifier' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendCloth, Alpha) == 0x000030, "Member 'FAnimNode_BlendCloth::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendCloth, ClothBones) == 0x000038, "Member 'FAnimNode_BlendCloth::ClothBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendCloth, MainBoneIndices) == 0x000048, "Member 'FAnimNode_BlendCloth::MainBoneIndices' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendCloth, ClothBoneIndices) == 0x000058, "Member 'FAnimNode_BlendCloth::ClothBoneIndices' has a wrong offset!");

// ScriptStruct man.AnimNode_BrawlerCloth
// 0x0058 (0x0068 - 0x0010)
struct FAnimNode_BrawlerCloth final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ClothBoneNames;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BaseBoneIndices;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BaseTransforms;                                    // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_BrawlerCloth) == 0x000008, "Wrong alignment on FAnimNode_BrawlerCloth");
static_assert(sizeof(FAnimNode_BrawlerCloth) == 0x000068, "Wrong size on FAnimNode_BrawlerCloth");
static_assert(offsetof(FAnimNode_BrawlerCloth, BasePose) == 0x000010, "Member 'FAnimNode_BrawlerCloth::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_BrawlerCloth, Additive) == 0x000020, "Member 'FAnimNode_BrawlerCloth::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_BrawlerCloth, Alpha) == 0x000030, "Member 'FAnimNode_BrawlerCloth::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_BrawlerCloth, ClothBoneNames) == 0x000038, "Member 'FAnimNode_BrawlerCloth::ClothBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_BrawlerCloth, BaseBoneIndices) == 0x000048, "Member 'FAnimNode_BrawlerCloth::BaseBoneIndices' has a wrong offset!");
static_assert(offsetof(FAnimNode_BrawlerCloth, BaseTransforms) == 0x000058, "Member 'FAnimNode_BrawlerCloth::BaseTransforms' has a wrong offset!");

// ScriptStruct man.CloneBoneInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCloneBoneInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloneBoneInfo) == 0x000004, "Wrong alignment on FCloneBoneInfo");
static_assert(sizeof(FCloneBoneInfo) == 0x000010, "Wrong size on FCloneBoneInfo");

// ScriptStruct man.AnimNode_CloneBones
// 0x0058 (0x0068 - 0x0010)
struct FAnimNode_CloneBones final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SourceBones;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SourcePrefix;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetPrefix;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCloneBoneInfo>                 CloneBoneInfoList;                                 // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_CloneBones) == 0x000008, "Wrong alignment on FAnimNode_CloneBones");
static_assert(sizeof(FAnimNode_CloneBones) == 0x000068, "Wrong size on FAnimNode_CloneBones");
static_assert(offsetof(FAnimNode_CloneBones, BasePose) == 0x000010, "Member 'FAnimNode_CloneBones::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_CloneBones, Alpha) == 0x000020, "Member 'FAnimNode_CloneBones::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_CloneBones, SourceBones) == 0x000028, "Member 'FAnimNode_CloneBones::SourceBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_CloneBones, SourcePrefix) == 0x000038, "Member 'FAnimNode_CloneBones::SourcePrefix' has a wrong offset!");
static_assert(offsetof(FAnimNode_CloneBones, TargetPrefix) == 0x000048, "Member 'FAnimNode_CloneBones::TargetPrefix' has a wrong offset!");
static_assert(offsetof(FAnimNode_CloneBones, CloneBoneInfoList) == 0x000058, "Member 'FAnimNode_CloneBones::CloneBoneInfoList' has a wrong offset!");

// ScriptStruct man.ExcludedBoneInfo
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FExcludedBoneInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExcludedBoneInfo) == 0x000010, "Wrong alignment on FExcludedBoneInfo");
static_assert(sizeof(FExcludedBoneInfo) == 0x000040, "Wrong size on FExcludedBoneInfo");

// ScriptStruct man.AnimNode_HitReaction
// 0x00D8 (0x00E8 - 0x0010)
struct FAnimNode_HitReaction final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExcludedBones;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftAnkleBoneName;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftJointTarget;                                   // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightAnkleBoneName;                                // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightJointTarget;                                  // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStretchRatio;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightCurveName;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExcludedBones;                                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisabledBones;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SpineHighJointBoneName;                            // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExcludeWeaponCurveName;                            // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExcludeWeaponHitWeight;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x24];                                      // 0x00A4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExcludedBoneInfo>              ExcludedBoneInfoList;                              // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FExcludedBoneInfo>              DisabledBoneInfoList;                              // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HitReaction) == 0x000008, "Wrong alignment on FAnimNode_HitReaction");
static_assert(sizeof(FAnimNode_HitReaction) == 0x0000E8, "Wrong size on FAnimNode_HitReaction");
static_assert(offsetof(FAnimNode_HitReaction, BasePose) == 0x000010, "Member 'FAnimNode_HitReaction::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, Additive) == 0x000020, "Member 'FAnimNode_HitReaction::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, Alpha) == 0x000030, "Member 'FAnimNode_HitReaction::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, bUseExcludedBones) == 0x000034, "Member 'FAnimNode_HitReaction::bUseExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, LeftAnkleBoneName) == 0x000038, "Member 'FAnimNode_HitReaction::LeftAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, LeftJointTarget) == 0x000040, "Member 'FAnimNode_HitReaction::LeftJointTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, RightAnkleBoneName) == 0x00004C, "Member 'FAnimNode_HitReaction::RightAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, RightJointTarget) == 0x000054, "Member 'FAnimNode_HitReaction::RightJointTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, StartStretchRatio) == 0x000060, "Member 'FAnimNode_HitReaction::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, MaxStretchScale) == 0x000064, "Member 'FAnimNode_HitReaction::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, WeightCurveName) == 0x000068, "Member 'FAnimNode_HitReaction::WeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, ExcludedBones) == 0x000070, "Member 'FAnimNode_HitReaction::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, DisabledBones) == 0x000080, "Member 'FAnimNode_HitReaction::DisabledBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, SpineHighJointBoneName) == 0x000090, "Member 'FAnimNode_HitReaction::SpineHighJointBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, ExcludeWeaponCurveName) == 0x000098, "Member 'FAnimNode_HitReaction::ExcludeWeaponCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, ExcludeWeaponHitWeight) == 0x0000A0, "Member 'FAnimNode_HitReaction::ExcludeWeaponHitWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, ExcludedBoneInfoList) == 0x0000C8, "Member 'FAnimNode_HitReaction::ExcludedBoneInfoList' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReaction, DisabledBoneInfoList) == 0x0000D8, "Member 'FAnimNode_HitReaction::DisabledBoneInfoList' has a wrong offset!");

// ScriptStruct man.HitReactionLegInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FHitReactionLegInfo final
{
public:
	class FName                                   AnkleBoneName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PollVectorBoneName;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightCurveName;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x48];                                      // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionLegInfo) == 0x000010, "Wrong alignment on FHitReactionLegInfo");
static_assert(sizeof(FHitReactionLegInfo) == 0x000060, "Wrong size on FHitReactionLegInfo");
static_assert(offsetof(FHitReactionLegInfo, AnkleBoneName) == 0x000000, "Member 'FHitReactionLegInfo::AnkleBoneName' has a wrong offset!");
static_assert(offsetof(FHitReactionLegInfo, PollVectorBoneName) == 0x000008, "Member 'FHitReactionLegInfo::PollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FHitReactionLegInfo, WeightCurveName) == 0x000010, "Member 'FHitReactionLegInfo::WeightCurveName' has a wrong offset!");

// ScriptStruct man.AnimNode_HitReactionAnyLegs
// 0x0080 (0x0090 - 0x0010)
struct FAnimNode_HitReactionAnyLegs final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitReactionLegInfo>            Legs;                                              // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         StartStretchRatio;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExcludedBones;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExcludedBoneInfo>              ExcludedBoneInfoList;                              // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HitReactionAnyLegs) == 0x000008, "Wrong alignment on FAnimNode_HitReactionAnyLegs");
static_assert(sizeof(FAnimNode_HitReactionAnyLegs) == 0x000090, "Wrong size on FAnimNode_HitReactionAnyLegs");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, BasePose) == 0x000010, "Member 'FAnimNode_HitReactionAnyLegs::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, Additive) == 0x000020, "Member 'FAnimNode_HitReactionAnyLegs::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, Alpha) == 0x000030, "Member 'FAnimNode_HitReactionAnyLegs::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, Legs) == 0x000038, "Member 'FAnimNode_HitReactionAnyLegs::Legs' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, StartStretchRatio) == 0x000048, "Member 'FAnimNode_HitReactionAnyLegs::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, MaxStretchScale) == 0x00004C, "Member 'FAnimNode_HitReactionAnyLegs::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, ExcludedBones) == 0x000050, "Member 'FAnimNode_HitReactionAnyLegs::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionAnyLegs, ExcludedBoneInfoList) == 0x000080, "Member 'FAnimNode_HitReactionAnyLegs::ExcludedBoneInfoList' has a wrong offset!");

// ScriptStruct man.AnimNode_HitReactionFourLegs
// 0x0210 (0x0220 - 0x0010)
struct alignas(0x10) FAnimNode_HitReactionFourLegs final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontAnkleBoneName;                            // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontPollVectorBoneName;                       // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontWeightCurveName;                          // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontAnkleBoneName;                           // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontPollVectorBoneName;                      // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontWeightCurveName;                         // 0x005C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackAnkleBoneName;                             // 0x0064(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackPollVectorBoneName;                        // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackWeightCurveName;                           // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackAnkleBoneName;                            // 0x007C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackPollVectorBoneName;                       // 0x0084(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackWeightCurveName;                          // 0x008C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStretchRatio;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedBones;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x160];                                     // 0x00B0(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExcludedBoneInfo>              ExcludedBoneInfoList;                              // 0x0210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HitReactionFourLegs) == 0x000010, "Wrong alignment on FAnimNode_HitReactionFourLegs");
static_assert(sizeof(FAnimNode_HitReactionFourLegs) == 0x000220, "Wrong size on FAnimNode_HitReactionFourLegs");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, BasePose) == 0x000010, "Member 'FAnimNode_HitReactionFourLegs::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, Additive) == 0x000020, "Member 'FAnimNode_HitReactionFourLegs::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, Alpha) == 0x000030, "Member 'FAnimNode_HitReactionFourLegs::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftFrontAnkleBoneName) == 0x000034, "Member 'FAnimNode_HitReactionFourLegs::LeftFrontAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftFrontPollVectorBoneName) == 0x00003C, "Member 'FAnimNode_HitReactionFourLegs::LeftFrontPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftFrontWeightCurveName) == 0x000044, "Member 'FAnimNode_HitReactionFourLegs::LeftFrontWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightFrontAnkleBoneName) == 0x00004C, "Member 'FAnimNode_HitReactionFourLegs::RightFrontAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightFrontPollVectorBoneName) == 0x000054, "Member 'FAnimNode_HitReactionFourLegs::RightFrontPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightFrontWeightCurveName) == 0x00005C, "Member 'FAnimNode_HitReactionFourLegs::RightFrontWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftBackAnkleBoneName) == 0x000064, "Member 'FAnimNode_HitReactionFourLegs::LeftBackAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftBackPollVectorBoneName) == 0x00006C, "Member 'FAnimNode_HitReactionFourLegs::LeftBackPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, LeftBackWeightCurveName) == 0x000074, "Member 'FAnimNode_HitReactionFourLegs::LeftBackWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightBackAnkleBoneName) == 0x00007C, "Member 'FAnimNode_HitReactionFourLegs::RightBackAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightBackPollVectorBoneName) == 0x000084, "Member 'FAnimNode_HitReactionFourLegs::RightBackPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, RightBackWeightCurveName) == 0x00008C, "Member 'FAnimNode_HitReactionFourLegs::RightBackWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, StartStretchRatio) == 0x000094, "Member 'FAnimNode_HitReactionFourLegs::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, MaxStretchScale) == 0x000098, "Member 'FAnimNode_HitReactionFourLegs::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, ExcludedBones) == 0x0000A0, "Member 'FAnimNode_HitReactionFourLegs::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionFourLegs, ExcludedBoneInfoList) == 0x000210, "Member 'FAnimNode_HitReactionFourLegs::ExcludedBoneInfoList' has a wrong offset!");

// ScriptStruct man.AnimNode_HitReactionMandragora
// 0x00F0 (0x0100 - 0x0010)
struct FAnimNode_HitReactionMandragora final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAlpha;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftAnkleBoneName;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftJointTarget;                                   // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightAnkleBoneName;                                // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightJointTarget;                                  // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStretchRatio;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftWristBoneName;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightWristBoneName;                                // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumArmBones;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedBones;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LeftArmBoneIndices;                                // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 RightArmBoneIndices;                               // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ArmBoneTransforms;                                 // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FExcludedBoneInfo>              ExcludedBoneInfoList;                              // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FExcludedBoneInfo>              ExcludedHandBoneInfoList;                          // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HitReactionMandragora) == 0x000008, "Wrong alignment on FAnimNode_HitReactionMandragora");
static_assert(sizeof(FAnimNode_HitReactionMandragora) == 0x000100, "Wrong size on FAnimNode_HitReactionMandragora");
static_assert(offsetof(FAnimNode_HitReactionMandragora, BasePose) == 0x000010, "Member 'FAnimNode_HitReactionMandragora::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, Additive) == 0x000020, "Member 'FAnimNode_HitReactionMandragora::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, Alpha) == 0x000030, "Member 'FAnimNode_HitReactionMandragora::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, HandAlpha) == 0x000034, "Member 'FAnimNode_HitReactionMandragora::HandAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, LeftAnkleBoneName) == 0x000038, "Member 'FAnimNode_HitReactionMandragora::LeftAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, LeftJointTarget) == 0x000040, "Member 'FAnimNode_HitReactionMandragora::LeftJointTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, RightAnkleBoneName) == 0x00004C, "Member 'FAnimNode_HitReactionMandragora::RightAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, RightJointTarget) == 0x000054, "Member 'FAnimNode_HitReactionMandragora::RightJointTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, StartStretchRatio) == 0x000060, "Member 'FAnimNode_HitReactionMandragora::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, MaxStretchScale) == 0x000064, "Member 'FAnimNode_HitReactionMandragora::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, LeftWristBoneName) == 0x000068, "Member 'FAnimNode_HitReactionMandragora::LeftWristBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, RightWristBoneName) == 0x000070, "Member 'FAnimNode_HitReactionMandragora::RightWristBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, NumArmBones) == 0x000078, "Member 'FAnimNode_HitReactionMandragora::NumArmBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, ExcludedBones) == 0x000080, "Member 'FAnimNode_HitReactionMandragora::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, LeftArmBoneIndices) == 0x0000B0, "Member 'FAnimNode_HitReactionMandragora::LeftArmBoneIndices' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, RightArmBoneIndices) == 0x0000C0, "Member 'FAnimNode_HitReactionMandragora::RightArmBoneIndices' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, ArmBoneTransforms) == 0x0000D0, "Member 'FAnimNode_HitReactionMandragora::ArmBoneTransforms' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, ExcludedBoneInfoList) == 0x0000E0, "Member 'FAnimNode_HitReactionMandragora::ExcludedBoneInfoList' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionMandragora, ExcludedHandBoneInfoList) == 0x0000F0, "Member 'FAnimNode_HitReactionMandragora::ExcludedHandBoneInfoList' has a wrong offset!");

// ScriptStruct man.AnimNode_HitReactionSixLegs
// 0x02D0 (0x02E0 - 0x0010)
struct alignas(0x10) FAnimNode_HitReactionSixLegs final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontAnkleBoneName;                            // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontPollVectorBoneName;                       // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftFrontWeightCurveName;                          // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontAnkleBoneName;                           // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontPollVectorBoneName;                      // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightFrontWeightCurveName;                         // 0x005C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftMiddleAnkleBoneName;                           // 0x0064(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftMiddlePollVectorBoneName;                      // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftMiddleWeightCurveName;                         // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightMiddleAnkleBoneName;                          // 0x007C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightMiddlePollVectorBoneName;                     // 0x0084(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightMiddleWeightCurveName;                        // 0x008C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackAnkleBoneName;                             // 0x0094(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackPollVectorBoneName;                        // 0x009C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftBackWeightCurveName;                           // 0x00A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackAnkleBoneName;                            // 0x00AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackPollVectorBoneName;                       // 0x00B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightBackWeightCurveName;                          // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartStretchRatio;                                 // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedBones;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x1F0];                                     // 0x00E0(0x01F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExcludedBoneInfo>              ExcludedBoneInfoList;                              // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_HitReactionSixLegs) == 0x000010, "Wrong alignment on FAnimNode_HitReactionSixLegs");
static_assert(sizeof(FAnimNode_HitReactionSixLegs) == 0x0002E0, "Wrong size on FAnimNode_HitReactionSixLegs");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, BasePose) == 0x000010, "Member 'FAnimNode_HitReactionSixLegs::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, Additive) == 0x000020, "Member 'FAnimNode_HitReactionSixLegs::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, Alpha) == 0x000030, "Member 'FAnimNode_HitReactionSixLegs::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftFrontAnkleBoneName) == 0x000034, "Member 'FAnimNode_HitReactionSixLegs::LeftFrontAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftFrontPollVectorBoneName) == 0x00003C, "Member 'FAnimNode_HitReactionSixLegs::LeftFrontPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftFrontWeightCurveName) == 0x000044, "Member 'FAnimNode_HitReactionSixLegs::LeftFrontWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightFrontAnkleBoneName) == 0x00004C, "Member 'FAnimNode_HitReactionSixLegs::RightFrontAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightFrontPollVectorBoneName) == 0x000054, "Member 'FAnimNode_HitReactionSixLegs::RightFrontPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightFrontWeightCurveName) == 0x00005C, "Member 'FAnimNode_HitReactionSixLegs::RightFrontWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftMiddleAnkleBoneName) == 0x000064, "Member 'FAnimNode_HitReactionSixLegs::LeftMiddleAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftMiddlePollVectorBoneName) == 0x00006C, "Member 'FAnimNode_HitReactionSixLegs::LeftMiddlePollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftMiddleWeightCurveName) == 0x000074, "Member 'FAnimNode_HitReactionSixLegs::LeftMiddleWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightMiddleAnkleBoneName) == 0x00007C, "Member 'FAnimNode_HitReactionSixLegs::RightMiddleAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightMiddlePollVectorBoneName) == 0x000084, "Member 'FAnimNode_HitReactionSixLegs::RightMiddlePollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightMiddleWeightCurveName) == 0x00008C, "Member 'FAnimNode_HitReactionSixLegs::RightMiddleWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftBackAnkleBoneName) == 0x000094, "Member 'FAnimNode_HitReactionSixLegs::LeftBackAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftBackPollVectorBoneName) == 0x00009C, "Member 'FAnimNode_HitReactionSixLegs::LeftBackPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, LeftBackWeightCurveName) == 0x0000A4, "Member 'FAnimNode_HitReactionSixLegs::LeftBackWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightBackAnkleBoneName) == 0x0000AC, "Member 'FAnimNode_HitReactionSixLegs::RightBackAnkleBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightBackPollVectorBoneName) == 0x0000B4, "Member 'FAnimNode_HitReactionSixLegs::RightBackPollVectorBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, RightBackWeightCurveName) == 0x0000BC, "Member 'FAnimNode_HitReactionSixLegs::RightBackWeightCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, StartStretchRatio) == 0x0000C4, "Member 'FAnimNode_HitReactionSixLegs::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, MaxStretchScale) == 0x0000C8, "Member 'FAnimNode_HitReactionSixLegs::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, ExcludedBones) == 0x0000D0, "Member 'FAnimNode_HitReactionSixLegs::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_HitReactionSixLegs, ExcludedBoneInfoList) == 0x0002D0, "Member 'FAnimNode_HitReactionSixLegs::ExcludedBoneInfoList' has a wrong offset!");

// ScriptStruct man.MirrorBoneInfo
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FMirrorBoneInfo final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMirrorBoneInfo) == 0x000010, "Wrong alignment on FMirrorBoneInfo");
static_assert(sizeof(FMirrorBoneInfo) == 0x000090, "Wrong size on FMirrorBoneInfo");

// ScriptStruct man.AnimNode_MirrorBones
// 0x0038 (0x0048 - 0x0010)
struct FAnimNode_MirrorBones final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedBones;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMirrorBoneInfo>                MirrorBoneInfoList;                                // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_MirrorBones) == 0x000008, "Wrong alignment on FAnimNode_MirrorBones");
static_assert(sizeof(FAnimNode_MirrorBones) == 0x000048, "Wrong size on FAnimNode_MirrorBones");
static_assert(offsetof(FAnimNode_MirrorBones, BasePose) == 0x000010, "Member 'FAnimNode_MirrorBones::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_MirrorBones, Alpha) == 0x000020, "Member 'FAnimNode_MirrorBones::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_MirrorBones, ExcludedBones) == 0x000028, "Member 'FAnimNode_MirrorBones::ExcludedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_MirrorBones, MirrorBoneInfoList) == 0x000038, "Member 'FAnimNode_MirrorBones::MirrorBoneInfoList' has a wrong offset!");

// ScriptStruct man.AnimNode_MixBones
// 0x0058 (0x0068 - 0x0010)
struct FAnimNode_MixBones final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Modifier;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Takeover;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMixTranslation;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMixRotation;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMixScale;                                         // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TakeoverBlendTime;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MixedBones;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MixedBoneIndices;                                  // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MixBones) == 0x000008, "Wrong alignment on FAnimNode_MixBones");
static_assert(sizeof(FAnimNode_MixBones) == 0x000068, "Wrong size on FAnimNode_MixBones");
static_assert(offsetof(FAnimNode_MixBones, BasePose) == 0x000010, "Member 'FAnimNode_MixBones::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, Modifier) == 0x000020, "Member 'FAnimNode_MixBones::Modifier' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, Takeover) == 0x000030, "Member 'FAnimNode_MixBones::Takeover' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, Alpha) == 0x000034, "Member 'FAnimNode_MixBones::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, bMixTranslation) == 0x000038, "Member 'FAnimNode_MixBones::bMixTranslation' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, bMixRotation) == 0x000039, "Member 'FAnimNode_MixBones::bMixRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, bMixScale) == 0x00003A, "Member 'FAnimNode_MixBones::bMixScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, TakeoverBlendTime) == 0x00003C, "Member 'FAnimNode_MixBones::TakeoverBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, MixedBones) == 0x000040, "Member 'FAnimNode_MixBones::MixedBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_MixBones, MixedBoneIndices) == 0x000050, "Member 'FAnimNode_MixBones::MixedBoneIndices' has a wrong offset!");

// ScriptStruct man.AnimNode_RopeSimulation
// 0x0048 (0x0058 - 0x0010)
struct FAnimNode_RopeSimulation final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RopeAngle;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeLength;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRopeBones;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PivotDirection;                                    // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RopeBoneIndices;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_RopeSimulation) == 0x000008, "Wrong alignment on FAnimNode_RopeSimulation");
static_assert(sizeof(FAnimNode_RopeSimulation) == 0x000058, "Wrong size on FAnimNode_RopeSimulation");
static_assert(offsetof(FAnimNode_RopeSimulation, BasePose) == 0x000010, "Member 'FAnimNode_RopeSimulation::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, RopeAngle) == 0x000020, "Member 'FAnimNode_RopeSimulation::RopeAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, RopeLength) == 0x000024, "Member 'FAnimNode_RopeSimulation::RopeLength' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, Alpha) == 0x000028, "Member 'FAnimNode_RopeSimulation::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, TargetBoneName) == 0x00002C, "Member 'FAnimNode_RopeSimulation::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, NumRopeBones) == 0x000034, "Member 'FAnimNode_RopeSimulation::NumRopeBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, PivotDirection) == 0x000038, "Member 'FAnimNode_RopeSimulation::PivotDirection' has a wrong offset!");
static_assert(offsetof(FAnimNode_RopeSimulation, RopeBoneIndices) == 0x000048, "Member 'FAnimNode_RopeSimulation::RopeBoneIndices' has a wrong offset!");

// ScriptStruct man.AnimNode_SetWeapon
// 0x0050 (0x0060 - 0x0010)
struct FAnimNode_SetWeapon final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              Modifier;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpineBoneName;                                     // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeadBoneName;                                      // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpineBoneIndices;                                  // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SetWeapon) == 0x000008, "Wrong alignment on FAnimNode_SetWeapon");
static_assert(sizeof(FAnimNode_SetWeapon) == 0x000060, "Wrong size on FAnimNode_SetWeapon");
static_assert(offsetof(FAnimNode_SetWeapon, BasePose) == 0x000010, "Member 'FAnimNode_SetWeapon::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_SetWeapon, Modifier) == 0x000020, "Member 'FAnimNode_SetWeapon::Modifier' has a wrong offset!");
static_assert(offsetof(FAnimNode_SetWeapon, Alpha) == 0x000030, "Member 'FAnimNode_SetWeapon::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_SetWeapon, SpineBoneName) == 0x000034, "Member 'FAnimNode_SetWeapon::SpineBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_SetWeapon, HeadBoneName) == 0x00003C, "Member 'FAnimNode_SetWeapon::HeadBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_SetWeapon, SpineBoneIndices) == 0x000048, "Member 'FAnimNode_SetWeapon::SpineBoneIndices' has a wrong offset!");

// ScriptStruct man.SlimeFootInfo
// 0x002C (0x002C - 0x0000)
struct FSlimeFootInfo final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x24];                                       // 0x0008(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlimeFootInfo) == 0x000004, "Wrong alignment on FSlimeFootInfo");
static_assert(sizeof(FSlimeFootInfo) == 0x00002C, "Wrong size on FSlimeFootInfo");
static_assert(offsetof(FSlimeFootInfo, BoneName) == 0x000000, "Member 'FSlimeFootInfo::BoneName' has a wrong offset!");

// ScriptStruct man.AnimNode_SlimeSlope
// 0x0040 (0x0050 - 0x0010)
struct FAnimNode_SlimeSlope final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSlimeFootInfo>                 FootBones;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceStart;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEnd;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFactorUp;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleFactorDown;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SlimeSlope) == 0x000008, "Wrong alignment on FAnimNode_SlimeSlope");
static_assert(sizeof(FAnimNode_SlimeSlope) == 0x000050, "Wrong size on FAnimNode_SlimeSlope");
static_assert(offsetof(FAnimNode_SlimeSlope, BasePose) == 0x000010, "Member 'FAnimNode_SlimeSlope::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, Alpha) == 0x000020, "Member 'FAnimNode_SlimeSlope::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, FootBones) == 0x000028, "Member 'FAnimNode_SlimeSlope::FootBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, TraceStart) == 0x000038, "Member 'FAnimNode_SlimeSlope::TraceStart' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, TraceEnd) == 0x00003C, "Member 'FAnimNode_SlimeSlope::TraceEnd' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, ScaleFactorUp) == 0x000040, "Member 'FAnimNode_SlimeSlope::ScaleFactorUp' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, ScaleFactorDown) == 0x000044, "Member 'FAnimNode_SlimeSlope::ScaleFactorDown' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlimeSlope, Falloff) == 0x000048, "Member 'FAnimNode_SlimeSlope::Falloff' has a wrong offset!");

// ScriptStruct man.AnimNode_WeaponTransform
// 0x00A0 (0x00B0 - 0x0010)
struct FAnimNode_WeaponTransform final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftWeaponBoneName;                                // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftWeaponTransform;                               // 0x0030(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   RightWeaponBoneName;                               // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightWeaponTransform;                              // 0x0070(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_WeaponTransform) == 0x000010, "Wrong alignment on FAnimNode_WeaponTransform");
static_assert(sizeof(FAnimNode_WeaponTransform) == 0x0000B0, "Wrong size on FAnimNode_WeaponTransform");
static_assert(offsetof(FAnimNode_WeaponTransform, BasePose) == 0x000010, "Member 'FAnimNode_WeaponTransform::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponTransform, Alpha) == 0x000020, "Member 'FAnimNode_WeaponTransform::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponTransform, LeftWeaponBoneName) == 0x000024, "Member 'FAnimNode_WeaponTransform::LeftWeaponBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponTransform, LeftWeaponTransform) == 0x000030, "Member 'FAnimNode_WeaponTransform::LeftWeaponTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponTransform, RightWeaponBoneName) == 0x000060, "Member 'FAnimNode_WeaponTransform::RightWeaponBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponTransform, RightWeaponTransform) == 0x000070, "Member 'FAnimNode_WeaponTransform::RightWeaponTransform' has a wrong offset!");

// ScriptStruct man.ManSoftAkAudioEventProxy
// 0x0010 (0x0010 - 0x0000)
struct FManSoftAkAudioEventProxy final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          EventLoaded;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManSoftAkAudioEventProxy) == 0x000008, "Wrong alignment on FManSoftAkAudioEventProxy");
static_assert(sizeof(FManSoftAkAudioEventProxy) == 0x000010, "Wrong size on FManSoftAkAudioEventProxy");
static_assert(offsetof(FManSoftAkAudioEventProxy, EventLoaded) == 0x000008, "Member 'FManSoftAkAudioEventProxy::EventLoaded' has a wrong offset!");

// ScriptStruct man.AdvancedAkEventGearWeightBasedSound
// 0x0070 (0x0070 - 0x0000)
struct FAdvancedAkEventGearWeightBasedSound final
{
public:
	TSoftObjectPtr<class UAkAudioEvent>           LightEquipLoad;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           HighEquipLoad;                                     // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManSoftAkAudioEventProxy              LightEquipLoadRef;                                 // 0x0050(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FManSoftAkAudioEventProxy              HighEquipLoadRef;                                  // 0x0060(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdvancedAkEventGearWeightBasedSound) == 0x000008, "Wrong alignment on FAdvancedAkEventGearWeightBasedSound");
static_assert(sizeof(FAdvancedAkEventGearWeightBasedSound) == 0x000070, "Wrong size on FAdvancedAkEventGearWeightBasedSound");
static_assert(offsetof(FAdvancedAkEventGearWeightBasedSound, LightEquipLoad) == 0x000000, "Member 'FAdvancedAkEventGearWeightBasedSound::LightEquipLoad' has a wrong offset!");
static_assert(offsetof(FAdvancedAkEventGearWeightBasedSound, HighEquipLoad) == 0x000028, "Member 'FAdvancedAkEventGearWeightBasedSound::HighEquipLoad' has a wrong offset!");
static_assert(offsetof(FAdvancedAkEventGearWeightBasedSound, LightEquipLoadRef) == 0x000050, "Member 'FAdvancedAkEventGearWeightBasedSound::LightEquipLoadRef' has a wrong offset!");
static_assert(offsetof(FAdvancedAkEventGearWeightBasedSound, HighEquipLoadRef) == 0x000060, "Member 'FAdvancedAkEventGearWeightBasedSound::HighEquipLoadRef' has a wrong offset!");

// ScriptStruct man.Alma
// 0x0030 (0x0030 - 0x0000)
struct FAlma final
{
public:
	TSoftObjectPtr<class UAkAudioEvent>           AKEventRef;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Korte;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAlma) == 0x000008, "Wrong alignment on FAlma");
static_assert(sizeof(FAlma) == 0x000030, "Wrong size on FAlma");
static_assert(offsetof(FAlma, AKEventRef) == 0x000000, "Member 'FAlma::AKEventRef' has a wrong offset!");
static_assert(offsetof(FAlma, Korte) == 0x000028, "Member 'FAlma::Korte' has a wrong offset!");

// ScriptStruct man.AnimImpulseDescriptor
// 0x0010 (0x0010 - 0x0000)
struct FAnimImpulseDescriptor final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Impulse;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimImpulseDescriptor) == 0x000008, "Wrong alignment on FAnimImpulseDescriptor");
static_assert(sizeof(FAnimImpulseDescriptor) == 0x000010, "Wrong size on FAnimImpulseDescriptor");
static_assert(offsetof(FAnimImpulseDescriptor, AnimID) == 0x000000, "Member 'FAnimImpulseDescriptor::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimImpulseDescriptor, Impulse) == 0x000008, "Member 'FAnimImpulseDescriptor::Impulse' has a wrong offset!");

// ScriptStruct man.ExplosiveDecompositionRootedEnemyData
// 0x0028 (0x0028 - 0x0000)
struct FExplosiveDecompositionRootedEnemyData final
{
public:
	class AEnemyCharacter*                        EnemyCharacter;                                    // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectStartTime;                             // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownLocation;                                 // 0x000C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GroundLocation;                                    // 0x0018(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarketToRemove;                                   // 0x0024(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplosiveDecompositionRootedEnemyData) == 0x000008, "Wrong alignment on FExplosiveDecompositionRootedEnemyData");
static_assert(sizeof(FExplosiveDecompositionRootedEnemyData) == 0x000028, "Wrong size on FExplosiveDecompositionRootedEnemyData");
static_assert(offsetof(FExplosiveDecompositionRootedEnemyData, EnemyCharacter) == 0x000000, "Member 'FExplosiveDecompositionRootedEnemyData::EnemyCharacter' has a wrong offset!");
static_assert(offsetof(FExplosiveDecompositionRootedEnemyData, StatusEffectStartTime) == 0x000008, "Member 'FExplosiveDecompositionRootedEnemyData::StatusEffectStartTime' has a wrong offset!");
static_assert(offsetof(FExplosiveDecompositionRootedEnemyData, LastKnownLocation) == 0x00000C, "Member 'FExplosiveDecompositionRootedEnemyData::LastKnownLocation' has a wrong offset!");
static_assert(offsetof(FExplosiveDecompositionRootedEnemyData, GroundLocation) == 0x000018, "Member 'FExplosiveDecompositionRootedEnemyData::GroundLocation' has a wrong offset!");
static_assert(offsetof(FExplosiveDecompositionRootedEnemyData, bMarketToRemove) == 0x000024, "Member 'FExplosiveDecompositionRootedEnemyData::bMarketToRemove' has a wrong offset!");

// ScriptStruct man.ArcaneCultistAttackTorrentData
// 0x0010 (0x0010 - 0x0000)
struct FArcaneCultistAttackTorrentData final
{
public:
	float                                         WaitBeforeSpawnTime;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleScale;                                      // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcaneCultistAttackTorrentData) == 0x000004, "Wrong alignment on FArcaneCultistAttackTorrentData");
static_assert(sizeof(FArcaneCultistAttackTorrentData) == 0x000010, "Wrong size on FArcaneCultistAttackTorrentData");
static_assert(offsetof(FArcaneCultistAttackTorrentData, WaitBeforeSpawnTime) == 0x000000, "Member 'FArcaneCultistAttackTorrentData::WaitBeforeSpawnTime' has a wrong offset!");
static_assert(offsetof(FArcaneCultistAttackTorrentData, CapsuleScale) == 0x000004, "Member 'FArcaneCultistAttackTorrentData::CapsuleScale' has a wrong offset!");

// ScriptStruct man.AttributeInstance
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FAttributeInstance final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeInstance) == 0x000008, "Wrong alignment on FAttributeInstance");
static_assert(sizeof(FAttributeInstance) == 0x000040, "Wrong size on FAttributeInstance");

// ScriptStruct man.RiftStageData
// 0x000C (0x000C - 0x0000)
struct FRiftStageData final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRiftStageData) == 0x000004, "Wrong alignment on FRiftStageData");
static_assert(sizeof(FRiftStageData) == 0x00000C, "Wrong size on FRiftStageData");
static_assert(offsetof(FRiftStageData, Length) == 0x000000, "Member 'FRiftStageData::Length' has a wrong offset!");

// ScriptStruct man.ResourceReservation
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FResourceReservation final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourceReservation) == 0x000004, "Wrong alignment on FResourceReservation");
static_assert(sizeof(FResourceReservation) == 0x000010, "Wrong size on FResourceReservation");

// ScriptStruct man.EntityTags
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FEntityTags final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityTags) == 0x000008, "Wrong alignment on FEntityTags");
static_assert(sizeof(FEntityTags) == 0x000060, "Wrong size on FEntityTags");

// ScriptStruct man.NameAndColor
// 0x000C (0x000C - 0x0000)
struct FNameAndColor final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameAndColor) == 0x000004, "Wrong alignment on FNameAndColor");
static_assert(sizeof(FNameAndColor) == 0x00000C, "Wrong size on FNameAndColor");
static_assert(offsetof(FNameAndColor, Name) == 0x000000, "Member 'FNameAndColor::Name' has a wrong offset!");
static_assert(offsetof(FNameAndColor, Color) == 0x000008, "Member 'FNameAndColor::Color' has a wrong offset!");

// ScriptStruct man.AttributeAndFloat
// 0x0008 (0x0008 - 0x0000)
struct FAttributeAndFloat final
{
public:
	EAttribute                                    Attibute;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeAndFloat) == 0x000004, "Wrong alignment on FAttributeAndFloat");
static_assert(sizeof(FAttributeAndFloat) == 0x000008, "Wrong size on FAttributeAndFloat");
static_assert(offsetof(FAttributeAndFloat, Attibute) == 0x000000, "Member 'FAttributeAndFloat::Attibute' has a wrong offset!");
static_assert(offsetof(FAttributeAndFloat, Value) == 0x000004, "Member 'FAttributeAndFloat::Value' has a wrong offset!");

// ScriptStruct man.SoftAbilityAndCount
// 0x0030 (0x0030 - 0x0000)
struct FSoftAbilityAndCount final
{
public:
	TSoftClassPtr<class UClass>                   AbilityType;                                       // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoftAbilityAndCount) == 0x000008, "Wrong alignment on FSoftAbilityAndCount");
static_assert(sizeof(FSoftAbilityAndCount) == 0x000030, "Wrong size on FSoftAbilityAndCount");
static_assert(offsetof(FSoftAbilityAndCount, AbilityType) == 0x000000, "Member 'FSoftAbilityAndCount::AbilityType' has a wrong offset!");
static_assert(offsetof(FSoftAbilityAndCount, Count) == 0x000028, "Member 'FSoftAbilityAndCount::Count' has a wrong offset!");

// ScriptStruct man.VendorPermanentBuffs
// 0x0038 (0x0038 - 0x0000)
struct FVendorPermanentBuffs final
{
public:
	TSoftClassPtr<class UClass>                   VendorType;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftAbilityAndCount>           BuffsAndCartLvlReq;                                // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendorPermanentBuffs) == 0x000008, "Wrong alignment on FVendorPermanentBuffs");
static_assert(sizeof(FVendorPermanentBuffs) == 0x000038, "Wrong size on FVendorPermanentBuffs");
static_assert(offsetof(FVendorPermanentBuffs, VendorType) == 0x000000, "Member 'FVendorPermanentBuffs::VendorType' has a wrong offset!");
static_assert(offsetof(FVendorPermanentBuffs, BuffsAndCartLvlReq) == 0x000028, "Member 'FVendorPermanentBuffs::BuffsAndCartLvlReq' has a wrong offset!");

// ScriptStruct man.AbilityAndCount
// 0x0010 (0x0010 - 0x0000)
struct FAbilityAndCount final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityType;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      Compare;                                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityAndCount) == 0x000008, "Wrong alignment on FAbilityAndCount");
static_assert(sizeof(FAbilityAndCount) == 0x000010, "Wrong size on FAbilityAndCount");
static_assert(offsetof(FAbilityAndCount, AbilityType) == 0x000000, "Member 'FAbilityAndCount::AbilityType' has a wrong offset!");
static_assert(offsetof(FAbilityAndCount, Count) == 0x000008, "Member 'FAbilityAndCount::Count' has a wrong offset!");
static_assert(offsetof(FAbilityAndCount, Compare) == 0x000009, "Member 'FAbilityAndCount::Compare' has a wrong offset!");

// ScriptStruct man.VEDamageFlags
// 0x000C (0x000C - 0x0000)
struct FVEDamageFlags final
{
public:
	bool                                          bCriticalDamage;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefended;                                         // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParried;                                          // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimpleDirection;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillingBlow;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVEDamageFlags) == 0x000004, "Wrong alignment on FVEDamageFlags");
static_assert(sizeof(FVEDamageFlags) == 0x00000C, "Wrong size on FVEDamageFlags");
static_assert(offsetof(FVEDamageFlags, bCriticalDamage) == 0x000000, "Member 'FVEDamageFlags::bCriticalDamage' has a wrong offset!");
static_assert(offsetof(FVEDamageFlags, bDefended) == 0x000001, "Member 'FVEDamageFlags::bDefended' has a wrong offset!");
static_assert(offsetof(FVEDamageFlags, bParried) == 0x000002, "Member 'FVEDamageFlags::bParried' has a wrong offset!");
static_assert(offsetof(FVEDamageFlags, SimpleDirection) == 0x000004, "Member 'FVEDamageFlags::SimpleDirection' has a wrong offset!");
static_assert(offsetof(FVEDamageFlags, bKillingBlow) == 0x000008, "Member 'FVEDamageFlags::bKillingBlow' has a wrong offset!");

// ScriptStruct man.TutorialPrompt
// 0x0020 (0x0020 - 0x0000)
struct FTutorialPrompt final
{
public:
	class FText                                   PromptText;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	ETutorialActionIcon                           ActionIcon;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialPrompt) == 0x000008, "Wrong alignment on FTutorialPrompt");
static_assert(sizeof(FTutorialPrompt) == 0x000020, "Wrong size on FTutorialPrompt");
static_assert(offsetof(FTutorialPrompt, PromptText) == 0x000000, "Member 'FTutorialPrompt::PromptText' has a wrong offset!");
static_assert(offsetof(FTutorialPrompt, ActionIcon) == 0x000018, "Member 'FTutorialPrompt::ActionIcon' has a wrong offset!");

// ScriptStruct man.TutorialAction
// 0x0030 (0x0030 - 0x0000)
struct FTutorialAction final
{
public:
	float                                         PreIdleTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActionTime;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionCounter;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTutorialPrompt                        Promp;                                             // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialAction) == 0x000008, "Wrong alignment on FTutorialAction");
static_assert(sizeof(FTutorialAction) == 0x000030, "Wrong size on FTutorialAction");
static_assert(offsetof(FTutorialAction, PreIdleTime) == 0x000000, "Member 'FTutorialAction::PreIdleTime' has a wrong offset!");
static_assert(offsetof(FTutorialAction, MaxActionTime) == 0x000004, "Member 'FTutorialAction::MaxActionTime' has a wrong offset!");
static_assert(offsetof(FTutorialAction, ActionCounter) == 0x000008, "Member 'FTutorialAction::ActionCounter' has a wrong offset!");
static_assert(offsetof(FTutorialAction, Promp) == 0x000010, "Member 'FTutorialAction::Promp' has a wrong offset!");

// ScriptStruct man.DmgScaleData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDmgScaleData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDmgScaleData) == 0x000004, "Wrong alignment on FDmgScaleData");
static_assert(sizeof(FDmgScaleData) == 0x000008, "Wrong size on FDmgScaleData");

// ScriptStruct man.ActorVEPair
// 0x0010 (0x0010 - 0x0000)
struct FActorVEPair final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVisualEntity*                          VE;                                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorVEPair) == 0x000008, "Wrong alignment on FActorVEPair");
static_assert(sizeof(FActorVEPair) == 0x000010, "Wrong size on FActorVEPair");
static_assert(offsetof(FActorVEPair, Target) == 0x000000, "Member 'FActorVEPair::Target' has a wrong offset!");
static_assert(offsetof(FActorVEPair, VE) == 0x000008, "Member 'FActorVEPair::VE' has a wrong offset!");

// ScriptStruct man.SmartTextKeyWord
// 0x0028 (0x0028 - 0x0000)
struct FSmartTextKeyWord final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0010(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartTextKeyWord) == 0x000008, "Wrong alignment on FSmartTextKeyWord");
static_assert(sizeof(FSmartTextKeyWord) == 0x000028, "Wrong size on FSmartTextKeyWord");
static_assert(offsetof(FSmartTextKeyWord, Key) == 0x000000, "Member 'FSmartTextKeyWord::Key' has a wrong offset!");
static_assert(offsetof(FSmartTextKeyWord, Text) == 0x000010, "Member 'FSmartTextKeyWord::Text' has a wrong offset!");

// ScriptStruct man.ItemFilterData
// 0x0028 (0x0028 - 0x0000)
struct FItemFilterData final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainItemType                                 ItemType;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubItemType                                  ItemSubType;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAbilityBase>>       StrictTypes;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EWeaponType>                           BannedWeaponTypes;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemFilterData) == 0x000008, "Wrong alignment on FItemFilterData");
static_assert(sizeof(FItemFilterData) == 0x000028, "Wrong size on FItemFilterData");
static_assert(offsetof(FItemFilterData, WeaponType) == 0x000000, "Member 'FItemFilterData::WeaponType' has a wrong offset!");
static_assert(offsetof(FItemFilterData, ItemType) == 0x000001, "Member 'FItemFilterData::ItemType' has a wrong offset!");
static_assert(offsetof(FItemFilterData, ItemSubType) == 0x000002, "Member 'FItemFilterData::ItemSubType' has a wrong offset!");
static_assert(offsetof(FItemFilterData, StrictTypes) == 0x000008, "Member 'FItemFilterData::StrictTypes' has a wrong offset!");
static_assert(offsetof(FItemFilterData, BannedWeaponTypes) == 0x000018, "Member 'FItemFilterData::BannedWeaponTypes' has a wrong offset!");

// ScriptStruct man.AbilityFilterData
// 0x0058 (0x0058 - 0x0000)
struct FAbilityFilterData final
{
public:
	TArray<EAbilityTag>                           AbilitySpecifierTagFilters;                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EDamageType>                           AbilityDamageTypeFilters;                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EWeaponType>                           WeaponTypeFilter;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       AbilityTypeFilter;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       AbilityTypeFilterNot;                              // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityFilterData) == 0x000008, "Wrong alignment on FAbilityFilterData");
static_assert(sizeof(FAbilityFilterData) == 0x000058, "Wrong size on FAbilityFilterData");
static_assert(offsetof(FAbilityFilterData, AbilitySpecifierTagFilters) == 0x000000, "Member 'FAbilityFilterData::AbilitySpecifierTagFilters' has a wrong offset!");
static_assert(offsetof(FAbilityFilterData, AbilityDamageTypeFilters) == 0x000010, "Member 'FAbilityFilterData::AbilityDamageTypeFilters' has a wrong offset!");
static_assert(offsetof(FAbilityFilterData, WeaponTypeFilter) == 0x000020, "Member 'FAbilityFilterData::WeaponTypeFilter' has a wrong offset!");
static_assert(offsetof(FAbilityFilterData, AbilityTypeFilter) == 0x000030, "Member 'FAbilityFilterData::AbilityTypeFilter' has a wrong offset!");
static_assert(offsetof(FAbilityFilterData, AbilityTypeFilterNot) == 0x000040, "Member 'FAbilityFilterData::AbilityTypeFilterNot' has a wrong offset!");

// ScriptStruct man.TextBubbleAutoTimeSettings
// 0x0010 (0x0010 - 0x0000)
struct FTextBubbleAutoTimeSettings final
{
public:
	float                                         MinTime;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCharacter;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusTimePerCharacter;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextBubbleAutoTimeSettings) == 0x000004, "Wrong alignment on FTextBubbleAutoTimeSettings");
static_assert(sizeof(FTextBubbleAutoTimeSettings) == 0x000010, "Wrong size on FTextBubbleAutoTimeSettings");
static_assert(offsetof(FTextBubbleAutoTimeSettings, MinTime) == 0x000000, "Member 'FTextBubbleAutoTimeSettings::MinTime' has a wrong offset!");
static_assert(offsetof(FTextBubbleAutoTimeSettings, MaxTime) == 0x000004, "Member 'FTextBubbleAutoTimeSettings::MaxTime' has a wrong offset!");
static_assert(offsetof(FTextBubbleAutoTimeSettings, MinCharacter) == 0x000008, "Member 'FTextBubbleAutoTimeSettings::MinCharacter' has a wrong offset!");
static_assert(offsetof(FTextBubbleAutoTimeSettings, BonusTimePerCharacter) == 0x00000C, "Member 'FTextBubbleAutoTimeSettings::BonusTimePerCharacter' has a wrong offset!");

// ScriptStruct man.DropQuantityModifier
// 0x0040 (0x0040 - 0x0000)
struct FDropQuantityModifier final
{
public:
	TSubclassOf<class UItemAbility>               ItemType;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainItemType                                 MainItemTypeFilter;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubItemType                                  SubItemType;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEssence;                                          // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEntropicEssence;                                  // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveFlatQuantityModifier;                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveMultiplierQuantityModifier;                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChanceBasedModifier;                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToApply;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             SourceExceptions;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             SourceFilter;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropQuantityModifier) == 0x000008, "Wrong alignment on FDropQuantityModifier");
static_assert(sizeof(FDropQuantityModifier) == 0x000040, "Wrong size on FDropQuantityModifier");
static_assert(offsetof(FDropQuantityModifier, ItemType) == 0x000000, "Member 'FDropQuantityModifier::ItemType' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, MainItemTypeFilter) == 0x000008, "Member 'FDropQuantityModifier::MainItemTypeFilter' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, SubItemType) == 0x000009, "Member 'FDropQuantityModifier::SubItemType' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, bEssence) == 0x00000A, "Member 'FDropQuantityModifier::bEssence' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, bEntropicEssence) == 0x00000B, "Member 'FDropQuantityModifier::bEntropicEssence' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, AdditiveFlatQuantityModifier) == 0x00000C, "Member 'FDropQuantityModifier::AdditiveFlatQuantityModifier' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, AdditiveMultiplierQuantityModifier) == 0x000010, "Member 'FDropQuantityModifier::AdditiveMultiplierQuantityModifier' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, bChanceBasedModifier) == 0x000014, "Member 'FDropQuantityModifier::bChanceBasedModifier' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, ChanceToApply) == 0x000018, "Member 'FDropQuantityModifier::ChanceToApply' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, SourceExceptions) == 0x000020, "Member 'FDropQuantityModifier::SourceExceptions' has a wrong offset!");
static_assert(offsetof(FDropQuantityModifier, SourceFilter) == 0x000030, "Member 'FDropQuantityModifier::SourceFilter' has a wrong offset!");

// ScriptStruct man.RedirectDamageAttributeScale
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FRedirectDamageAttributeScale final
{
public:
	EAttribute                                    SourceAttribute;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribute                                    TargetAttribute;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0xA];                                        // 0x0002(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRedirectDamageAttributeScale) == 0x000004, "Wrong alignment on FRedirectDamageAttributeScale");
static_assert(sizeof(FRedirectDamageAttributeScale) == 0x00000C, "Wrong size on FRedirectDamageAttributeScale");
static_assert(offsetof(FRedirectDamageAttributeScale, SourceAttribute) == 0x000000, "Member 'FRedirectDamageAttributeScale::SourceAttribute' has a wrong offset!");
static_assert(offsetof(FRedirectDamageAttributeScale, TargetAttribute) == 0x000001, "Member 'FRedirectDamageAttributeScale::TargetAttribute' has a wrong offset!");

// ScriptStruct man.TutorialCastAction
// 0x0030 (0x0030 - 0x0000)
struct FTutorialCastAction final
{
public:
	TSubclassOf<class UAbilityBase>               AbilityClass;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestCast;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequestDefend;                                    // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefillRage;                                       // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefillEnergy;                                     // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefillComboPoints;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreConditions;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTutorialPrompt                        Promp;                                             // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialCastAction) == 0x000008, "Wrong alignment on FTutorialCastAction");
static_assert(sizeof(FTutorialCastAction) == 0x000030, "Wrong size on FTutorialCastAction");
static_assert(offsetof(FTutorialCastAction, AbilityClass) == 0x000000, "Member 'FTutorialCastAction::AbilityClass' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bRequestCast) == 0x000008, "Member 'FTutorialCastAction::bRequestCast' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bRequestDefend) == 0x000009, "Member 'FTutorialCastAction::bRequestDefend' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bRefillRage) == 0x00000A, "Member 'FTutorialCastAction::bRefillRage' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bRefillEnergy) == 0x00000B, "Member 'FTutorialCastAction::bRefillEnergy' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bRefillComboPoints) == 0x00000C, "Member 'FTutorialCastAction::bRefillComboPoints' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, bIgnoreConditions) == 0x00000D, "Member 'FTutorialCastAction::bIgnoreConditions' has a wrong offset!");
static_assert(offsetof(FTutorialCastAction, Promp) == 0x000010, "Member 'FTutorialCastAction::Promp' has a wrong offset!");

// ScriptStruct man.AttributeAffectData
// 0x0018 (0x0018 - 0x0000)
struct FAttributeAffectData final
{
public:
	EAttribute                                    AttributeToAffect;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeAffectType                          AffectType;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UManIntTable*                           ModifierTable;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AffectRatio;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAttribReqToAffect;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeAffectData) == 0x000008, "Wrong alignment on FAttributeAffectData");
static_assert(sizeof(FAttributeAffectData) == 0x000018, "Wrong size on FAttributeAffectData");
static_assert(offsetof(FAttributeAffectData, AttributeToAffect) == 0x000000, "Member 'FAttributeAffectData::AttributeToAffect' has a wrong offset!");
static_assert(offsetof(FAttributeAffectData, AffectType) == 0x000001, "Member 'FAttributeAffectData::AffectType' has a wrong offset!");
static_assert(offsetof(FAttributeAffectData, ModifierTable) == 0x000008, "Member 'FAttributeAffectData::ModifierTable' has a wrong offset!");
static_assert(offsetof(FAttributeAffectData, AffectRatio) == 0x000010, "Member 'FAttributeAffectData::AffectRatio' has a wrong offset!");
static_assert(offsetof(FAttributeAffectData, MinAttribReqToAffect) == 0x000014, "Member 'FAttributeAffectData::MinAttribReqToAffect' has a wrong offset!");

// ScriptStruct man.ManLootData
// 0x0010 (0x0010 - 0x0000)
struct FManLootData final
{
public:
	TSubclassOf<class UItemAbility>               Loot;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinAmount;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmount;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManLootData) == 0x000008, "Wrong alignment on FManLootData");
static_assert(sizeof(FManLootData) == 0x000010, "Wrong size on FManLootData");
static_assert(offsetof(FManLootData, Loot) == 0x000000, "Member 'FManLootData::Loot' has a wrong offset!");
static_assert(offsetof(FManLootData, MinAmount) == 0x000008, "Member 'FManLootData::MinAmount' has a wrong offset!");
static_assert(offsetof(FManLootData, MaxAmount) == 0x00000C, "Member 'FManLootData::MaxAmount' has a wrong offset!");

// ScriptStruct man.EntityTag
// 0x000C (0x000C - 0x0000)
struct FEntityTag final
{
public:
	EEntityTag                                    Tag;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   customTag;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntityTag) == 0x000004, "Wrong alignment on FEntityTag");
static_assert(sizeof(FEntityTag) == 0x00000C, "Wrong size on FEntityTag");
static_assert(offsetof(FEntityTag, Tag) == 0x000000, "Member 'FEntityTag::Tag' has a wrong offset!");
static_assert(offsetof(FEntityTag, customTag) == 0x000004, "Member 'FEntityTag::customTag' has a wrong offset!");

// ScriptStruct man.InventorySet
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FInventorySet final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySet) == 0x000008, "Wrong alignment on FInventorySet");
static_assert(sizeof(FInventorySet) == 0x000010, "Wrong size on FInventorySet");

// ScriptStruct man.AttributeModifier
// 0x0010 (0x0010 - 0x0000)
struct FAttributeModifier final
{
public:
	float                                         Add;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mul;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MulMul;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlaggedAsTemp;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeModifier) == 0x000004, "Wrong alignment on FAttributeModifier");
static_assert(sizeof(FAttributeModifier) == 0x000010, "Wrong size on FAttributeModifier");
static_assert(offsetof(FAttributeModifier, Add) == 0x000000, "Member 'FAttributeModifier::Add' has a wrong offset!");
static_assert(offsetof(FAttributeModifier, Mul) == 0x000004, "Member 'FAttributeModifier::Mul' has a wrong offset!");
static_assert(offsetof(FAttributeModifier, MulMul) == 0x000008, "Member 'FAttributeModifier::MulMul' has a wrong offset!");
static_assert(offsetof(FAttributeModifier, bFlaggedAsTemp) == 0x00000C, "Member 'FAttributeModifier::bFlaggedAsTemp' has a wrong offset!");

// ScriptStruct man.LevelTeleportNode
// 0x0030 (0x0030 - 0x0000)
struct FLevelTeleportNode final
{
public:
	TSoftObjectPtr<class UWorld>                  LevelReference;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLevelTeleportRate;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportRate;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelTeleportNode) == 0x000008, "Wrong alignment on FLevelTeleportNode");
static_assert(sizeof(FLevelTeleportNode) == 0x000030, "Wrong size on FLevelTeleportNode");
static_assert(offsetof(FLevelTeleportNode, LevelReference) == 0x000000, "Member 'FLevelTeleportNode::LevelReference' has a wrong offset!");
static_assert(offsetof(FLevelTeleportNode, CurrentLevelTeleportRate) == 0x000028, "Member 'FLevelTeleportNode::CurrentLevelTeleportRate' has a wrong offset!");
static_assert(offsetof(FLevelTeleportNode, TeleportRate) == 0x00002C, "Member 'FLevelTeleportNode::TeleportRate' has a wrong offset!");

// ScriptStruct man.HurtComponentHitVfxInfo
// 0x0010 (0x0010 - 0x0000)
struct FHurtComponentHitVfxInfo final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NormalPriority;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefendPriority;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParryPriority;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHurtComponentHitVfxInfo) == 0x000004, "Wrong alignment on FHurtComponentHitVfxInfo");
static_assert(sizeof(FHurtComponentHitVfxInfo) == 0x000010, "Wrong size on FHurtComponentHitVfxInfo");
static_assert(offsetof(FHurtComponentHitVfxInfo, bEnabled) == 0x000000, "Member 'FHurtComponentHitVfxInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(FHurtComponentHitVfxInfo, NormalPriority) == 0x000004, "Member 'FHurtComponentHitVfxInfo::NormalPriority' has a wrong offset!");
static_assert(offsetof(FHurtComponentHitVfxInfo, DefendPriority) == 0x000008, "Member 'FHurtComponentHitVfxInfo::DefendPriority' has a wrong offset!");
static_assert(offsetof(FHurtComponentHitVfxInfo, ParryPriority) == 0x00000C, "Member 'FHurtComponentHitVfxInfo::ParryPriority' has a wrong offset!");

// ScriptStruct man.BasicAICombatCache
// 0x0078 (0x0078 - 0x0000)
struct FBasicAICombatCache final
{
public:
	class ACharacterBase*                         Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         HitFriendly;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         BlockerFriendly;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x50];                                      // 0x0018(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAINavConnect*>                  TargetPlatformConnects;                            // 0x0068(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicAICombatCache) == 0x000008, "Wrong alignment on FBasicAICombatCache");
static_assert(sizeof(FBasicAICombatCache) == 0x000078, "Wrong size on FBasicAICombatCache");
static_assert(offsetof(FBasicAICombatCache, Target) == 0x000000, "Member 'FBasicAICombatCache::Target' has a wrong offset!");
static_assert(offsetof(FBasicAICombatCache, HitFriendly) == 0x000008, "Member 'FBasicAICombatCache::HitFriendly' has a wrong offset!");
static_assert(offsetof(FBasicAICombatCache, BlockerFriendly) == 0x000010, "Member 'FBasicAICombatCache::BlockerFriendly' has a wrong offset!");
static_assert(offsetof(FBasicAICombatCache, TargetPlatformConnects) == 0x000068, "Member 'FBasicAICombatCache::TargetPlatformConnects' has a wrong offset!");

// ScriptStruct man.BasicAIShotPosTarget
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FBasicAIShotPosTarget final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBasicAIShotPosTarget) == 0x000004, "Wrong alignment on FBasicAIShotPosTarget");
static_assert(sizeof(FBasicAIShotPosTarget) == 0x000020, "Wrong size on FBasicAIShotPosTarget");

// ScriptStruct man.RequiredMaterial
// 0x0010 (0x0010 - 0x0000)
struct FRequiredMaterial final
{
public:
	TSubclassOf<class UItemAbility>               Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequiredMaterial) == 0x000008, "Wrong alignment on FRequiredMaterial");
static_assert(sizeof(FRequiredMaterial) == 0x000010, "Wrong size on FRequiredMaterial");
static_assert(offsetof(FRequiredMaterial, Material) == 0x000000, "Member 'FRequiredMaterial::Material' has a wrong offset!");
static_assert(offsetof(FRequiredMaterial, Number) == 0x000008, "Member 'FRequiredMaterial::Number' has a wrong offset!");

// ScriptStruct man.AIMoveSet
// 0x0040 (0x0040 - 0x0000)
struct FAIMoveSet final
{
public:
	bool                                          bForward;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMoveSetType                                Type;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimID*                                AnimID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimID*>                        MoveStopAnims;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAnimEventType>                        MoveStopAnimEvents;                                // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAnimEventType>                        UnlockAnimEvents;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIMoveSet) == 0x000008, "Wrong alignment on FAIMoveSet");
static_assert(sizeof(FAIMoveSet) == 0x000040, "Wrong size on FAIMoveSet");
static_assert(offsetof(FAIMoveSet, bForward) == 0x000000, "Member 'FAIMoveSet::bForward' has a wrong offset!");
static_assert(offsetof(FAIMoveSet, Type) == 0x000001, "Member 'FAIMoveSet::Type' has a wrong offset!");
static_assert(offsetof(FAIMoveSet, AnimID) == 0x000008, "Member 'FAIMoveSet::AnimID' has a wrong offset!");
static_assert(offsetof(FAIMoveSet, MoveStopAnims) == 0x000010, "Member 'FAIMoveSet::MoveStopAnims' has a wrong offset!");
static_assert(offsetof(FAIMoveSet, MoveStopAnimEvents) == 0x000020, "Member 'FAIMoveSet::MoveStopAnimEvents' has a wrong offset!");
static_assert(offsetof(FAIMoveSet, UnlockAnimEvents) == 0x000030, "Member 'FAIMoveSet::UnlockAnimEvents' has a wrong offset!");

// ScriptStruct man.AbilityQueueNode
// 0x0010 (0x0010 - 0x0000)
struct FAbilityQueueNode final
{
public:
	TArray<class UAbilityBase*>                   RollAbilities;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityQueueNode) == 0x000008, "Wrong alignment on FAbilityQueueNode");
static_assert(sizeof(FAbilityQueueNode) == 0x000010, "Wrong size on FAbilityQueueNode");
static_assert(offsetof(FAbilityQueueNode, RollAbilities) == 0x000000, "Member 'FAbilityQueueNode::RollAbilities' has a wrong offset!");

// ScriptStruct man.ItemTooltipAttributeText
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FItemTooltipAttributeText final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTooltipAttributeText) == 0x000008, "Wrong alignment on FItemTooltipAttributeText");
static_assert(sizeof(FItemTooltipAttributeText) == 0x000018, "Wrong size on FItemTooltipAttributeText");

// ScriptStruct man.BasicAIPhase
// 0x0030 (0x0030 - 0x0000)
struct FBasicAIPhase final
{
public:
	TSubclassOf<class UAbilityBase>               PhaseEffect;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               PhaseTransitionAbility;                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       AddPhaseAbilities;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         PhaseChangeHealthPercentageCondition;              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalCooldownMultiplier;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalCooldownChanceModifier;                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalAnimPlayRateMultiplier;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicAIPhase) == 0x000008, "Wrong alignment on FBasicAIPhase");
static_assert(sizeof(FBasicAIPhase) == 0x000030, "Wrong size on FBasicAIPhase");
static_assert(offsetof(FBasicAIPhase, PhaseEffect) == 0x000000, "Member 'FBasicAIPhase::PhaseEffect' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, PhaseTransitionAbility) == 0x000008, "Member 'FBasicAIPhase::PhaseTransitionAbility' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, AddPhaseAbilities) == 0x000010, "Member 'FBasicAIPhase::AddPhaseAbilities' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, PhaseChangeHealthPercentageCondition) == 0x000020, "Member 'FBasicAIPhase::PhaseChangeHealthPercentageCondition' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, GlobalCooldownMultiplier) == 0x000024, "Member 'FBasicAIPhase::GlobalCooldownMultiplier' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, GlobalCooldownChanceModifier) == 0x000028, "Member 'FBasicAIPhase::GlobalCooldownChanceModifier' has a wrong offset!");
static_assert(offsetof(FBasicAIPhase, GlobalAnimPlayRateMultiplier) == 0x00002C, "Member 'FBasicAIPhase::GlobalAnimPlayRateMultiplier' has a wrong offset!");

// ScriptStruct man.BAHitBoxGroupElement
// 0x0010 (0x0010 - 0x0000)
struct FBAHitBoxGroupElement final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBAHitBoxGroupElement) == 0x000008, "Wrong alignment on FBAHitBoxGroupElement");
static_assert(sizeof(FBAHitBoxGroupElement) == 0x000010, "Wrong size on FBAHitBoxGroupElement");
static_assert(offsetof(FBAHitBoxGroupElement, Actor) == 0x000000, "Member 'FBAHitBoxGroupElement::Actor' has a wrong offset!");

// ScriptStruct man.StatusEffectText
// 0x0020 (0x0020 - 0x0000)
struct FStatusEffectText final
{
public:
	EStatusEffectType                             StatusEffectType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NativeText;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectText) == 0x000008, "Wrong alignment on FStatusEffectText");
static_assert(sizeof(FStatusEffectText) == 0x000020, "Wrong size on FStatusEffectText");
static_assert(offsetof(FStatusEffectText, StatusEffectType) == 0x000000, "Member 'FStatusEffectText::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectText, NativeText) == 0x000008, "Member 'FStatusEffectText::NativeText' has a wrong offset!");

// ScriptStruct man.BountyBoardItem
// 0x0010 (0x0010 - 0x0000)
struct FBountyBoardItem final
{
public:
	TSubclassOf<class UManQuest>                  QuestBlueprint;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelRequirement;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBountyBoardItem) == 0x000008, "Wrong alignment on FBountyBoardItem");
static_assert(sizeof(FBountyBoardItem) == 0x000010, "Wrong size on FBountyBoardItem");
static_assert(offsetof(FBountyBoardItem, QuestBlueprint) == 0x000000, "Member 'FBountyBoardItem::QuestBlueprint' has a wrong offset!");
static_assert(offsetof(FBountyBoardItem, LevelRequirement) == 0x000008, "Member 'FBountyBoardItem::LevelRequirement' has a wrong offset!");

// ScriptStruct man.ItemAcquisitionData
// 0x0010 (0x0010 - 0x0000)
struct FItemAcquisitionData final
{
public:
	TSubclassOf<class UItemAbility>               ItemType;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemAcquisitionData) == 0x000008, "Wrong alignment on FItemAcquisitionData");
static_assert(sizeof(FItemAcquisitionData) == 0x000010, "Wrong size on FItemAcquisitionData");
static_assert(offsetof(FItemAcquisitionData, ItemType) == 0x000000, "Member 'FItemAcquisitionData::ItemType' has a wrong offset!");

// ScriptStruct man.LadderIdleAnim
// 0x0010 (0x0010 - 0x0000)
struct FLadderIdleAnim final
{
public:
	float                                         Frame;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Anim;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLadderIdleAnim) == 0x000008, "Wrong alignment on FLadderIdleAnim");
static_assert(sizeof(FLadderIdleAnim) == 0x000010, "Wrong size on FLadderIdleAnim");
static_assert(offsetof(FLadderIdleAnim, Frame) == 0x000000, "Member 'FLadderIdleAnim::Frame' has a wrong offset!");
static_assert(offsetof(FLadderIdleAnim, Anim) == 0x000008, "Member 'FLadderIdleAnim::Anim' has a wrong offset!");

// ScriptStruct man.BuffBarElementData
// 0x0018 (0x0018 - 0x0000)
struct FBuffBarElementData final
{
public:
	class UAbilityBase*                           SourceAbility;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAbilityComponent*>              SourceComponents;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuffBarElementData) == 0x000008, "Wrong alignment on FBuffBarElementData");
static_assert(sizeof(FBuffBarElementData) == 0x000018, "Wrong size on FBuffBarElementData");
static_assert(offsetof(FBuffBarElementData, SourceAbility) == 0x000000, "Member 'FBuffBarElementData::SourceAbility' has a wrong offset!");
static_assert(offsetof(FBuffBarElementData, SourceComponents) == 0x000008, "Member 'FBuffBarElementData::SourceComponents' has a wrong offset!");

// ScriptStruct man.ItemSubTypeText
// 0x0020 (0x0020 - 0x0000)
struct FItemSubTypeText final
{
public:
	ESubItemType                                  ItemSubType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemSubTypeText;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSubTypeText) == 0x000008, "Wrong alignment on FItemSubTypeText");
static_assert(sizeof(FItemSubTypeText) == 0x000020, "Wrong size on FItemSubTypeText");
static_assert(offsetof(FItemSubTypeText, ItemSubType) == 0x000000, "Member 'FItemSubTypeText::ItemSubType' has a wrong offset!");
static_assert(offsetof(FItemSubTypeText, ItemSubTypeText) == 0x000008, "Member 'FItemSubTypeText::ItemSubTypeText' has a wrong offset!");

// ScriptStruct man.StaticSpawnVisualEntityAbilityComponent
// 0x0050 (0x0050 - 0x0000)
struct FStaticSpawnVisualEntityAbilityComponent final
{
public:
	int32                                         EquipSlot;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ItemAbilityClass;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VisualEntityClass;                                 // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 VisualEntityClassLoaded;                           // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachTargetName;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVisualEntity*                          VEntity;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticSpawnVisualEntityAbilityComponent) == 0x000008, "Wrong alignment on FStaticSpawnVisualEntityAbilityComponent");
static_assert(sizeof(FStaticSpawnVisualEntityAbilityComponent) == 0x000050, "Wrong size on FStaticSpawnVisualEntityAbilityComponent");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, EquipSlot) == 0x000000, "Member 'FStaticSpawnVisualEntityAbilityComponent::EquipSlot' has a wrong offset!");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, ItemAbilityClass) == 0x000008, "Member 'FStaticSpawnVisualEntityAbilityComponent::ItemAbilityClass' has a wrong offset!");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, VisualEntityClass) == 0x000010, "Member 'FStaticSpawnVisualEntityAbilityComponent::VisualEntityClass' has a wrong offset!");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, VisualEntityClassLoaded) == 0x000038, "Member 'FStaticSpawnVisualEntityAbilityComponent::VisualEntityClassLoaded' has a wrong offset!");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, AttachTargetName) == 0x000040, "Member 'FStaticSpawnVisualEntityAbilityComponent::AttachTargetName' has a wrong offset!");
static_assert(offsetof(FStaticSpawnVisualEntityAbilityComponent, VEntity) == 0x000048, "Member 'FStaticSpawnVisualEntityAbilityComponent::VEntity' has a wrong offset!");

// ScriptStruct man.CharacterPerWeaponTypeNonStaggerPushSettings
// 0x0018 (0x0018 - 0x0000)
struct FCharacterPerWeaponTypeNonStaggerPushSettings final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Decceleration;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMinDistance;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMinDistanceRate;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaxDistance;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaxDistanceRate;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPerWeaponTypeNonStaggerPushSettings) == 0x000004, "Wrong alignment on FCharacterPerWeaponTypeNonStaggerPushSettings");
static_assert(sizeof(FCharacterPerWeaponTypeNonStaggerPushSettings) == 0x000018, "Wrong size on FCharacterPerWeaponTypeNonStaggerPushSettings");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, Speed) == 0x000000, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::Speed' has a wrong offset!");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, Decceleration) == 0x000004, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::Decceleration' has a wrong offset!");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, SourceMinDistance) == 0x000008, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::SourceMinDistance' has a wrong offset!");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, SourceMinDistanceRate) == 0x00000C, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::SourceMinDistanceRate' has a wrong offset!");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, SourceMaxDistance) == 0x000010, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::SourceMaxDistance' has a wrong offset!");
static_assert(offsetof(FCharacterPerWeaponTypeNonStaggerPushSettings, SourceMaxDistanceRate) == 0x000014, "Member 'FCharacterPerWeaponTypeNonStaggerPushSettings::SourceMaxDistanceRate' has a wrong offset!");

// ScriptStruct man.KingPriestVoidEntropicCatharsisProjectileDataInAWave
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidEntropicCatharsisProjectileDataInAWave final
{
public:
	TArray<int32>                                 DeltaAngleMultipliers;                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidEntropicCatharsisProjectileDataInAWave) == 0x000008, "Wrong alignment on FKingPriestVoidEntropicCatharsisProjectileDataInAWave");
static_assert(sizeof(FKingPriestVoidEntropicCatharsisProjectileDataInAWave) == 0x000010, "Wrong size on FKingPriestVoidEntropicCatharsisProjectileDataInAWave");
static_assert(offsetof(FKingPriestVoidEntropicCatharsisProjectileDataInAWave, DeltaAngleMultipliers) == 0x000000, "Member 'FKingPriestVoidEntropicCatharsisProjectileDataInAWave::DeltaAngleMultipliers' has a wrong offset!");

// ScriptStruct man.SkinPreset
// 0x0008 (0x0008 - 0x0000)
struct FSkinPreset final
{
public:
	float                                         DiffuseMultiplier;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HueShift;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinPreset) == 0x000004, "Wrong alignment on FSkinPreset");
static_assert(sizeof(FSkinPreset) == 0x000008, "Wrong size on FSkinPreset");
static_assert(offsetof(FSkinPreset, DiffuseMultiplier) == 0x000000, "Member 'FSkinPreset::DiffuseMultiplier' has a wrong offset!");
static_assert(offsetof(FSkinPreset, HueShift) == 0x000004, "Member 'FSkinPreset::HueShift' has a wrong offset!");

// ScriptStruct man.BodypartPhysics
// 0x0058 (0x0058 - 0x0000)
struct FBodypartPhysics final
{
public:
	class FName                                   ConstraintName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MaterialSlotsToHide;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           MaterialSlotsToShow;                               // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FComponentReference>            GameplayComponents;                                // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bFatalLoss;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthPercentageToFall;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnRemoveCustomEvent;                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodypartPhysics) == 0x000008, "Wrong alignment on FBodypartPhysics");
static_assert(sizeof(FBodypartPhysics) == 0x000058, "Wrong size on FBodypartPhysics");
static_assert(offsetof(FBodypartPhysics, ConstraintName) == 0x000000, "Member 'FBodypartPhysics::ConstraintName' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, BoneName) == 0x000008, "Member 'FBodypartPhysics::BoneName' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, MaterialSlotName) == 0x000010, "Member 'FBodypartPhysics::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, MaterialSlotsToHide) == 0x000018, "Member 'FBodypartPhysics::MaterialSlotsToHide' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, MaterialSlotsToShow) == 0x000028, "Member 'FBodypartPhysics::MaterialSlotsToShow' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, GameplayComponents) == 0x000038, "Member 'FBodypartPhysics::GameplayComponents' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, bFatalLoss) == 0x000048, "Member 'FBodypartPhysics::bFatalLoss' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, HealthPercentageToFall) == 0x00004C, "Member 'FBodypartPhysics::HealthPercentageToFall' has a wrong offset!");
static_assert(offsetof(FBodypartPhysics, OnRemoveCustomEvent) == 0x000050, "Member 'FBodypartPhysics::OnRemoveCustomEvent' has a wrong offset!");

// ScriptStruct man.ActiveHeroAbilityDataElement
// 0x0030 (0x0030 - 0x0000)
struct FActiveHeroAbilityDataElement final
{
public:
	TSoftClassPtr<class UClass>                   AbilityType;                                       // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultUnlocked;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveHeroAbilityDataElement) == 0x000008, "Wrong alignment on FActiveHeroAbilityDataElement");
static_assert(sizeof(FActiveHeroAbilityDataElement) == 0x000030, "Wrong size on FActiveHeroAbilityDataElement");
static_assert(offsetof(FActiveHeroAbilityDataElement, AbilityType) == 0x000000, "Member 'FActiveHeroAbilityDataElement::AbilityType' has a wrong offset!");
static_assert(offsetof(FActiveHeroAbilityDataElement, bDefaultUnlocked) == 0x000028, "Member 'FActiveHeroAbilityDataElement::bDefaultUnlocked' has a wrong offset!");

// ScriptStruct man.AttributeText
// 0x0058 (0x0058 - 0x0000)
struct FAttributeText final
{
public:
	EAttribute                                    attribute;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NativeText;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AddText;                                           // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MulText;                                           // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowPercentage;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeText) == 0x000008, "Wrong alignment on FAttributeText");
static_assert(sizeof(FAttributeText) == 0x000058, "Wrong size on FAttributeText");
static_assert(offsetof(FAttributeText, attribute) == 0x000000, "Member 'FAttributeText::attribute' has a wrong offset!");
static_assert(offsetof(FAttributeText, NativeText) == 0x000008, "Member 'FAttributeText::NativeText' has a wrong offset!");
static_assert(offsetof(FAttributeText, AddText) == 0x000020, "Member 'FAttributeText::AddText' has a wrong offset!");
static_assert(offsetof(FAttributeText, MulText) == 0x000038, "Member 'FAttributeText::MulText' has a wrong offset!");
static_assert(offsetof(FAttributeText, bShowPercentage) == 0x000050, "Member 'FAttributeText::bShowPercentage' has a wrong offset!");

// ScriptStruct man.AttributeTemplateData
// 0x0020 (0x0020 - 0x0000)
struct FAttributeTemplateData final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIValue;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleInCharacterCreationWindow;                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeAffectData>           AffectedAttributes;                                // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeTemplateData) == 0x000008, "Wrong alignment on FAttributeTemplateData");
static_assert(sizeof(FAttributeTemplateData) == 0x000020, "Wrong size on FAttributeTemplateData");
static_assert(offsetof(FAttributeTemplateData, BaseValue) == 0x000000, "Member 'FAttributeTemplateData::BaseValue' has a wrong offset!");
static_assert(offsetof(FAttributeTemplateData, UIValue) == 0x000004, "Member 'FAttributeTemplateData::UIValue' has a wrong offset!");
static_assert(offsetof(FAttributeTemplateData, VisibleInCharacterCreationWindow) == 0x000008, "Member 'FAttributeTemplateData::VisibleInCharacterCreationWindow' has a wrong offset!");
static_assert(offsetof(FAttributeTemplateData, AffectedAttributes) == 0x000010, "Member 'FAttributeTemplateData::AffectedAttributes' has a wrong offset!");

// ScriptStruct man.TemplateAbilitySlot
// 0x0018 (0x0018 - 0x0000)
struct FTemplateAbilitySlot final
{
public:
	int32                                         SlotLevelunlock;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SubSlotLevelUnlock;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTemplateAbilitySlot) == 0x000008, "Wrong alignment on FTemplateAbilitySlot");
static_assert(sizeof(FTemplateAbilitySlot) == 0x000018, "Wrong size on FTemplateAbilitySlot");
static_assert(offsetof(FTemplateAbilitySlot, SlotLevelunlock) == 0x000000, "Member 'FTemplateAbilitySlot::SlotLevelunlock' has a wrong offset!");
static_assert(offsetof(FTemplateAbilitySlot, SubSlotLevelUnlock) == 0x000008, "Member 'FTemplateAbilitySlot::SubSlotLevelUnlock' has a wrong offset!");

// ScriptStruct man.DefaultInventoryItem
// 0x0018 (0x0018 - 0x0000)
struct FDefaultInventoryItem final
{
public:
	TSubclassOf<class UItemAbility>               Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          DefaultAudioState;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDefaultInventoryItem) == 0x000008, "Wrong alignment on FDefaultInventoryItem");
static_assert(sizeof(FDefaultInventoryItem) == 0x000018, "Wrong size on FDefaultInventoryItem");
static_assert(offsetof(FDefaultInventoryItem, Item) == 0x000000, "Member 'FDefaultInventoryItem::Item' has a wrong offset!");
static_assert(offsetof(FDefaultInventoryItem, DefaultAudioState) == 0x000008, "Member 'FDefaultInventoryItem::DefaultAudioState' has a wrong offset!");
static_assert(offsetof(FDefaultInventoryItem, Stack) == 0x000010, "Member 'FDefaultInventoryItem::Stack' has a wrong offset!");

// ScriptStruct man.ConversationPortraitVideoIdleBridge
// 0x0018 (0x0018 - 0x0000)
struct FConversationPortraitVideoIdleBridge final
{
public:
	struct FFilePath                              PortraitVideoIdleBridge;                           // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         Chance;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConversationPortraitVideoIdleBridge) == 0x000008, "Wrong alignment on FConversationPortraitVideoIdleBridge");
static_assert(sizeof(FConversationPortraitVideoIdleBridge) == 0x000018, "Wrong size on FConversationPortraitVideoIdleBridge");
static_assert(offsetof(FConversationPortraitVideoIdleBridge, PortraitVideoIdleBridge) == 0x000000, "Member 'FConversationPortraitVideoIdleBridge::PortraitVideoIdleBridge' has a wrong offset!");
static_assert(offsetof(FConversationPortraitVideoIdleBridge, Chance) == 0x000010, "Member 'FConversationPortraitVideoIdleBridge::Chance' has a wrong offset!");

// ScriptStruct man.ConversationSpeakerInfo
// 0x0050 (0x0050 - 0x0000)
struct FConversationSpeakerInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UPrimalConversationSpeaker*             Speaker;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PortraitVideoUrl;                                  // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConversationSpeakerPosition                  position;                                          // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConversationPortraitVideoIdleBridge> PortraitVideosIdleBridge;                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IdleBridgeVideoInterval;                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConversationSpeakerInfo) == 0x000008, "Wrong alignment on FConversationSpeakerInfo");
static_assert(sizeof(FConversationSpeakerInfo) == 0x000050, "Wrong size on FConversationSpeakerInfo");
static_assert(offsetof(FConversationSpeakerInfo, DisplayName) == 0x000000, "Member 'FConversationSpeakerInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FConversationSpeakerInfo, Speaker) == 0x000018, "Member 'FConversationSpeakerInfo::Speaker' has a wrong offset!");
static_assert(offsetof(FConversationSpeakerInfo, PortraitVideoUrl) == 0x000020, "Member 'FConversationSpeakerInfo::PortraitVideoUrl' has a wrong offset!");
static_assert(offsetof(FConversationSpeakerInfo, position) == 0x000030, "Member 'FConversationSpeakerInfo::position' has a wrong offset!");
static_assert(offsetof(FConversationSpeakerInfo, PortraitVideosIdleBridge) == 0x000038, "Member 'FConversationSpeakerInfo::PortraitVideosIdleBridge' has a wrong offset!");
static_assert(offsetof(FConversationSpeakerInfo, IdleBridgeVideoInterval) == 0x000048, "Member 'FConversationSpeakerInfo::IdleBridgeVideoInterval' has a wrong offset!");

// ScriptStruct man.CorrosiveAgentData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCorrosiveAgentData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCorrosiveAgentData) == 0x000008, "Wrong alignment on FCorrosiveAgentData");
static_assert(sizeof(FCorrosiveAgentData) == 0x000018, "Wrong size on FCorrosiveAgentData");

// ScriptStruct man.GenderProperties
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FGenderProperties final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenderProperties) == 0x000004, "Wrong alignment on FGenderProperties");
static_assert(sizeof(FGenderProperties) == 0x000018, "Wrong size on FGenderProperties");

// ScriptStruct man.AllowedDemoTypes
// 0x0068 (0x0068 - 0x0000)
struct FAllowedDemoTypes final
{
public:
	EDemoMode                                     DemoMode;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UCustomCharacterSlot>> MaleFaces;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterSlot>> FemaleFaces;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterSlot>> MaleHairStyles;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterSlot>> FemaleHairStyles;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterTattoo>> MaleTattoos;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCustomCharacterTattoo>> FemaleTattoos;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAllowedDemoTypes) == 0x000008, "Wrong alignment on FAllowedDemoTypes");
static_assert(sizeof(FAllowedDemoTypes) == 0x000068, "Wrong size on FAllowedDemoTypes");
static_assert(offsetof(FAllowedDemoTypes, DemoMode) == 0x000000, "Member 'FAllowedDemoTypes::DemoMode' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, MaleFaces) == 0x000008, "Member 'FAllowedDemoTypes::MaleFaces' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, FemaleFaces) == 0x000018, "Member 'FAllowedDemoTypes::FemaleFaces' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, MaleHairStyles) == 0x000028, "Member 'FAllowedDemoTypes::MaleHairStyles' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, FemaleHairStyles) == 0x000038, "Member 'FAllowedDemoTypes::FemaleHairStyles' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, MaleTattoos) == 0x000048, "Member 'FAllowedDemoTypes::MaleTattoos' has a wrong offset!");
static_assert(offsetof(FAllowedDemoTypes, FemaleTattoos) == 0x000058, "Member 'FAllowedDemoTypes::FemaleTattoos' has a wrong offset!");

// ScriptStruct man.CutsceneCinematicSubtitleLine
// 0x0030 (0x0030 - 0x0000)
struct FCutsceneCinematicSubtitleLine final
{
public:
	class UPrimalConversationSpeaker*             Speaker;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	double                                        FromMs;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ToMs;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutsceneCinematicSubtitleLine) == 0x000008, "Wrong alignment on FCutsceneCinematicSubtitleLine");
static_assert(sizeof(FCutsceneCinematicSubtitleLine) == 0x000030, "Wrong size on FCutsceneCinematicSubtitleLine");
static_assert(offsetof(FCutsceneCinematicSubtitleLine, Speaker) == 0x000000, "Member 'FCutsceneCinematicSubtitleLine::Speaker' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSubtitleLine, Text) == 0x000008, "Member 'FCutsceneCinematicSubtitleLine::Text' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSubtitleLine, FromMs) == 0x000020, "Member 'FCutsceneCinematicSubtitleLine::FromMs' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSubtitleLine, ToMs) == 0x000028, "Member 'FCutsceneCinematicSubtitleLine::ToMs' has a wrong offset!");

// ScriptStruct man.CutsceneCinematicSoundTrack
// 0x0030 (0x0030 - 0x0000)
struct FCutsceneCinematicSoundTrack final
{
public:
	int32                                         BinkAudioTrackIndex;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterVoice*                  VoiceType;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LanguageId;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCutsceneCinematicSubtitleLine> CutsceneCinematicSubtitleLines;                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCutsceneCinematicSoundTrack) == 0x000008, "Wrong alignment on FCutsceneCinematicSoundTrack");
static_assert(sizeof(FCutsceneCinematicSoundTrack) == 0x000030, "Wrong size on FCutsceneCinematicSoundTrack");
static_assert(offsetof(FCutsceneCinematicSoundTrack, BinkAudioTrackIndex) == 0x000000, "Member 'FCutsceneCinematicSoundTrack::BinkAudioTrackIndex' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSoundTrack, VoiceType) == 0x000008, "Member 'FCutsceneCinematicSoundTrack::VoiceType' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSoundTrack, LanguageId) == 0x000010, "Member 'FCutsceneCinematicSoundTrack::LanguageId' has a wrong offset!");
static_assert(offsetof(FCutsceneCinematicSoundTrack, CutsceneCinematicSubtitleLines) == 0x000020, "Member 'FCutsceneCinematicSoundTrack::CutsceneCinematicSubtitleLines' has a wrong offset!");

// ScriptStruct man.LootFragmentInstanceData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLootFragmentInstanceData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootFragmentInstanceData) == 0x000004, "Wrong alignment on FLootFragmentInstanceData");
static_assert(sizeof(FLootFragmentInstanceData) == 0x000010, "Wrong size on FLootFragmentInstanceData");

// ScriptStruct man.DamageLogNode
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDamageLogNode final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageLogNode) == 0x000008, "Wrong alignment on FDamageLogNode");
static_assert(sizeof(FDamageLogNode) == 0x000018, "Wrong size on FDamageLogNode");

// ScriptStruct man.LeverWheelTurnAnimData
// 0x0028 (0x0028 - 0x0000)
struct FLeverWheelTurnAnimData final
{
public:
	class UAnimID*                                LeverPullStartAnimID;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                LeverPullStartBWAnimID;                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                LeverPullAnimID;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                LeverPullEndAnimID;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextDistanceThreshold;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeverWheelTurnAnimData) == 0x000008, "Wrong alignment on FLeverWheelTurnAnimData");
static_assert(sizeof(FLeverWheelTurnAnimData) == 0x000028, "Wrong size on FLeverWheelTurnAnimData");
static_assert(offsetof(FLeverWheelTurnAnimData, LeverPullStartAnimID) == 0x000000, "Member 'FLeverWheelTurnAnimData::LeverPullStartAnimID' has a wrong offset!");
static_assert(offsetof(FLeverWheelTurnAnimData, LeverPullStartBWAnimID) == 0x000008, "Member 'FLeverWheelTurnAnimData::LeverPullStartBWAnimID' has a wrong offset!");
static_assert(offsetof(FLeverWheelTurnAnimData, LeverPullAnimID) == 0x000010, "Member 'FLeverWheelTurnAnimData::LeverPullAnimID' has a wrong offset!");
static_assert(offsetof(FLeverWheelTurnAnimData, LeverPullEndAnimID) == 0x000018, "Member 'FLeverWheelTurnAnimData::LeverPullEndAnimID' has a wrong offset!");
static_assert(offsetof(FLeverWheelTurnAnimData, Distance) == 0x000020, "Member 'FLeverWheelTurnAnimData::Distance' has a wrong offset!");
static_assert(offsetof(FLeverWheelTurnAnimData, NextDistanceThreshold) == 0x000024, "Member 'FLeverWheelTurnAnimData::NextDistanceThreshold' has a wrong offset!");

// ScriptStruct man.DamageLogString
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDamageLogString final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageLogString) == 0x000008, "Wrong alignment on FDamageLogString");
static_assert(sizeof(FDamageLogString) == 0x000018, "Wrong size on FDamageLogString");

// ScriptStruct man.BasicAttackHitSequenceNode
// 0x0030 (0x0030 - 0x0000)
struct FBasicAttackHitSequenceNode final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                recoveryForceAnimId;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomHitEvent;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDefaultDamage;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Length;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offset;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBasicAttackHitSequenceNode) == 0x000008, "Wrong alignment on FBasicAttackHitSequenceNode");
static_assert(sizeof(FBasicAttackHitSequenceNode) == 0x000030, "Wrong size on FBasicAttackHitSequenceNode");
static_assert(offsetof(FBasicAttackHitSequenceNode, AnimID) == 0x000000, "Member 'FBasicAttackHitSequenceNode::AnimID' has a wrong offset!");
static_assert(offsetof(FBasicAttackHitSequenceNode, recoveryForceAnimId) == 0x000008, "Member 'FBasicAttackHitSequenceNode::recoveryForceAnimId' has a wrong offset!");
static_assert(offsetof(FBasicAttackHitSequenceNode, CustomHitEvent) == 0x000010, "Member 'FBasicAttackHitSequenceNode::CustomHitEvent' has a wrong offset!");
static_assert(offsetof(FBasicAttackHitSequenceNode, bDoDefaultDamage) == 0x000018, "Member 'FBasicAttackHitSequenceNode::bDoDefaultDamage' has a wrong offset!");
static_assert(offsetof(FBasicAttackHitSequenceNode, Length) == 0x00001C, "Member 'FBasicAttackHitSequenceNode::Length' has a wrong offset!");
static_assert(offsetof(FBasicAttackHitSequenceNode, Offset) == 0x000020, "Member 'FBasicAttackHitSequenceNode::Offset' has a wrong offset!");

// ScriptStruct man.LevelUserIntefaceSceneCaptureVisual
// 0x0018 (0x0018 - 0x0000)
struct FLevelUserIntefaceSceneCaptureVisual final
{
public:
	bool                                          bOverrideSkyLight;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelUserIntefaceSceneCaptureSkyLightOverride SkyLightOverride;                                  // 0x0004(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelUserIntefaceSceneCaptureVisual) == 0x000004, "Wrong alignment on FLevelUserIntefaceSceneCaptureVisual");
static_assert(sizeof(FLevelUserIntefaceSceneCaptureVisual) == 0x000018, "Wrong size on FLevelUserIntefaceSceneCaptureVisual");
static_assert(offsetof(FLevelUserIntefaceSceneCaptureVisual, bOverrideSkyLight) == 0x000000, "Member 'FLevelUserIntefaceSceneCaptureVisual::bOverrideSkyLight' has a wrong offset!");
static_assert(offsetof(FLevelUserIntefaceSceneCaptureVisual, SkyLightOverride) == 0x000004, "Member 'FLevelUserIntefaceSceneCaptureVisual::SkyLightOverride' has a wrong offset!");

// ScriptStruct man.LevelVisualInfo
// 0x0090 (0x0090 - 0x0000)
struct FLevelVisualInfo final
{
public:
	struct FSoftObjectPath                        VisibleLevel;                                      // 0x0000(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LightingScenario;                                  // 0x0018(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AdditionalDecorations;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AudioLevel;                                        // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVendorDecorationInfo>          VendorDecorations;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLevelUserIntefaceSceneCaptureVisual   UserInterfaceSceneCaptureVisual;                   // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DecorationExclusiveActorTags;                      // 0x0080(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelVisualInfo) == 0x000008, "Wrong alignment on FLevelVisualInfo");
static_assert(sizeof(FLevelVisualInfo) == 0x000090, "Wrong size on FLevelVisualInfo");
static_assert(offsetof(FLevelVisualInfo, VisibleLevel) == 0x000000, "Member 'FLevelVisualInfo::VisibleLevel' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, LightingScenario) == 0x000018, "Member 'FLevelVisualInfo::LightingScenario' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, AdditionalDecorations) == 0x000030, "Member 'FLevelVisualInfo::AdditionalDecorations' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, AudioLevel) == 0x000040, "Member 'FLevelVisualInfo::AudioLevel' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, VendorDecorations) == 0x000058, "Member 'FLevelVisualInfo::VendorDecorations' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, UserInterfaceSceneCaptureVisual) == 0x000068, "Member 'FLevelVisualInfo::UserInterfaceSceneCaptureVisual' has a wrong offset!");
static_assert(offsetof(FLevelVisualInfo, DecorationExclusiveActorTags) == 0x000080, "Member 'FLevelVisualInfo::DecorationExclusiveActorTags' has a wrong offset!");

// ScriptStruct man.StatusEffectAndDamageData
// 0x0008 (0x0008 - 0x0000)
struct FStatusEffectAndDamageData final
{
public:
	EStatusEffectType                             StatusEffect;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectAndDamageData) == 0x000004, "Wrong alignment on FStatusEffectAndDamageData");
static_assert(sizeof(FStatusEffectAndDamageData) == 0x000008, "Wrong size on FStatusEffectAndDamageData");
static_assert(offsetof(FStatusEffectAndDamageData, StatusEffect) == 0x000000, "Member 'FStatusEffectAndDamageData::StatusEffect' has a wrong offset!");
static_assert(offsetof(FStatusEffectAndDamageData, DamageType) == 0x000001, "Member 'FStatusEffectAndDamageData::DamageType' has a wrong offset!");
static_assert(offsetof(FStatusEffectAndDamageData, Value) == 0x000004, "Member 'FStatusEffectAndDamageData::Value' has a wrong offset!");

// ScriptStruct man.DamageCollectionData
// 0x0008 (0x0008 - 0x0000)
struct FDamageCollectionData final
{
public:
	EDamageCollectionType                         CollectionType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageCollectionData) == 0x000004, "Wrong alignment on FDamageCollectionData");
static_assert(sizeof(FDamageCollectionData) == 0x000008, "Wrong size on FDamageCollectionData");
static_assert(offsetof(FDamageCollectionData, CollectionType) == 0x000000, "Member 'FDamageCollectionData::CollectionType' has a wrong offset!");
static_assert(offsetof(FDamageCollectionData, Value) == 0x000004, "Member 'FDamageCollectionData::Value' has a wrong offset!");

// ScriptStruct man.LootDropFlyWeight
// 0x0018 (0x0018 - 0x0000)
struct FLootDropFlyWeight final
{
public:
	TArray<EMainItemType>                         ItemTypes;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              FlyTimeExtraMinMax;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootDropFlyWeight) == 0x000008, "Wrong alignment on FLootDropFlyWeight");
static_assert(sizeof(FLootDropFlyWeight) == 0x000018, "Wrong size on FLootDropFlyWeight");
static_assert(offsetof(FLootDropFlyWeight, ItemTypes) == 0x000000, "Member 'FLootDropFlyWeight::ItemTypes' has a wrong offset!");
static_assert(offsetof(FLootDropFlyWeight, FlyTimeExtraMinMax) == 0x000010, "Member 'FLootDropFlyWeight::FlyTimeExtraMinMax' has a wrong offset!");

// ScriptStruct man.DamageModifier
// 0x000C (0x000C - 0x0000)
struct FDamageModifier final
{
public:
	EDamageType                                   DamageType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiplier;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageModifier) == 0x000004, "Wrong alignment on FDamageModifier");
static_assert(sizeof(FDamageModifier) == 0x00000C, "Wrong size on FDamageModifier");
static_assert(offsetof(FDamageModifier, DamageType) == 0x000000, "Member 'FDamageModifier::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageModifier, Value) == 0x000004, "Member 'FDamageModifier::Value' has a wrong offset!");
static_assert(offsetof(FDamageModifier, bMultiplier) == 0x000008, "Member 'FDamageModifier::bMultiplier' has a wrong offset!");

// ScriptStruct man.AccumulatedDamageModifierNode
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAccumulatedDamageModifierNode final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccumulatedDamageModifierNode) == 0x000004, "Wrong alignment on FAccumulatedDamageModifierNode");
static_assert(sizeof(FAccumulatedDamageModifierNode) == 0x000008, "Wrong size on FAccumulatedDamageModifierNode");

// ScriptStruct man.WeaponWeaponDamageTrailMatrixVFX
// 0x0010 (0x0010 - 0x0000)
struct FWeaponWeaponDamageTrailMatrixVFX final
{
public:
	TSubclassOf<class AVisualEntity>              VisualEntity;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSocketRotation;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponWeaponDamageTrailMatrixVFX) == 0x000008, "Wrong alignment on FWeaponWeaponDamageTrailMatrixVFX");
static_assert(sizeof(FWeaponWeaponDamageTrailMatrixVFX) == 0x000010, "Wrong size on FWeaponWeaponDamageTrailMatrixVFX");
static_assert(offsetof(FWeaponWeaponDamageTrailMatrixVFX, VisualEntity) == 0x000000, "Member 'FWeaponWeaponDamageTrailMatrixVFX::VisualEntity' has a wrong offset!");
static_assert(offsetof(FWeaponWeaponDamageTrailMatrixVFX, bUseSocketRotation) == 0x000008, "Member 'FWeaponWeaponDamageTrailMatrixVFX::bUseSocketRotation' has a wrong offset!");

// ScriptStruct man.FastLearnerPatternNode
// 0x0003 (0x0003 - 0x0000)
struct FFastLearnerPatternNode final
{
public:
	bool                                          bTop;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMiddle;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBottom;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFastLearnerPatternNode) == 0x000001, "Wrong alignment on FFastLearnerPatternNode");
static_assert(sizeof(FFastLearnerPatternNode) == 0x000003, "Wrong size on FFastLearnerPatternNode");
static_assert(offsetof(FFastLearnerPatternNode, bTop) == 0x000000, "Member 'FFastLearnerPatternNode::bTop' has a wrong offset!");
static_assert(offsetof(FFastLearnerPatternNode, bMiddle) == 0x000001, "Member 'FFastLearnerPatternNode::bMiddle' has a wrong offset!");
static_assert(offsetof(FFastLearnerPatternNode, bBottom) == 0x000002, "Member 'FFastLearnerPatternNode::bBottom' has a wrong offset!");

// ScriptStruct man.MatrixVFX
// 0x0048 (0x0048 - 0x0000)
struct FMatrixVFX final
{
public:
	EDamageMatrixVEForceRotation                  ForcedRotation;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TiltMinMax;                                        // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageMAtrixType                             position;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomRollWeight;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGuaranteedPlay;                                   // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AVisualEntity>              VisualEntityClassRef;                              // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   VisualEntity;                                      // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMatrixVFX) == 0x000008, "Wrong alignment on FMatrixVFX");
static_assert(sizeof(FMatrixVFX) == 0x000048, "Wrong size on FMatrixVFX");
static_assert(offsetof(FMatrixVFX, ForcedRotation) == 0x000000, "Member 'FMatrixVFX::ForcedRotation' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, TiltMinMax) == 0x000004, "Member 'FMatrixVFX::TiltMinMax' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, position) == 0x00000C, "Member 'FMatrixVFX::position' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, RandomRollWeight) == 0x000010, "Member 'FMatrixVFX::RandomRollWeight' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, bGuaranteedPlay) == 0x000014, "Member 'FMatrixVFX::bGuaranteedPlay' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, bAttach) == 0x000015, "Member 'FMatrixVFX::bAttach' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, VisualEntityClassRef) == 0x000018, "Member 'FMatrixVFX::VisualEntityClassRef' has a wrong offset!");
static_assert(offsetof(FMatrixVFX, VisualEntity) == 0x000020, "Member 'FMatrixVFX::VisualEntity' has a wrong offset!");

// ScriptStruct man.MatrixSound
// 0x0028 (0x0028 - 0x0000)
struct FMatrixSound final
{
public:
	class UAkAudioEvent*                          Sound;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DOTStartAKEvent;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DOTEndAKEvent;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         SWITCH;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageMAtrixType                             position;                                          // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatrixSound) == 0x000008, "Wrong alignment on FMatrixSound");
static_assert(sizeof(FMatrixSound) == 0x000028, "Wrong size on FMatrixSound");
static_assert(offsetof(FMatrixSound, Sound) == 0x000000, "Member 'FMatrixSound::Sound' has a wrong offset!");
static_assert(offsetof(FMatrixSound, DOTStartAKEvent) == 0x000008, "Member 'FMatrixSound::DOTStartAKEvent' has a wrong offset!");
static_assert(offsetof(FMatrixSound, DOTEndAKEvent) == 0x000010, "Member 'FMatrixSound::DOTEndAKEvent' has a wrong offset!");
static_assert(offsetof(FMatrixSound, SWITCH) == 0x000018, "Member 'FMatrixSound::SWITCH' has a wrong offset!");
static_assert(offsetof(FMatrixSound, position) == 0x000020, "Member 'FMatrixSound::position' has a wrong offset!");
static_assert(offsetof(FMatrixSound, bAttach) == 0x000021, "Member 'FMatrixSound::bAttach' has a wrong offset!");

// ScriptStruct man.ManConversationInstance
// 0x0008 (0x0008 - 0x0000)
struct FManConversationInstance final
{
public:
	class UVarlist*                               Varlist;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManConversationInstance) == 0x000008, "Wrong alignment on FManConversationInstance");
static_assert(sizeof(FManConversationInstance) == 0x000008, "Wrong size on FManConversationInstance");
static_assert(offsetof(FManConversationInstance, Varlist) == 0x000000, "Member 'FManConversationInstance::Varlist' has a wrong offset!");

// ScriptStruct man.DarkVenomData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDarkVenomData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkVenomData) == 0x000008, "Wrong alignment on FDarkVenomData");
static_assert(sizeof(FDarkVenomData) == 0x000018, "Wrong size on FDarkVenomData");

// ScriptStruct man.PushbackSetting
// 0x0008 (0x0008 - 0x0000)
struct FPushbackSetting final
{
public:
	float                                         PushbackSpeed;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushbackDuration;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushbackSetting) == 0x000004, "Wrong alignment on FPushbackSetting");
static_assert(sizeof(FPushbackSetting) == 0x000008, "Wrong size on FPushbackSetting");
static_assert(offsetof(FPushbackSetting, PushbackSpeed) == 0x000000, "Member 'FPushbackSetting::PushbackSpeed' has a wrong offset!");
static_assert(offsetof(FPushbackSetting, PushbackDuration) == 0x000004, "Member 'FPushbackSetting::PushbackDuration' has a wrong offset!");

// ScriptStruct man.ManFloatingTextGroup
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FManFloatingTextGroup final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManFloatingTextGroup) == 0x000008, "Wrong alignment on FManFloatingTextGroup");
static_assert(sizeof(FManFloatingTextGroup) == 0x000038, "Wrong size on FManFloatingTextGroup");

// ScriptStruct man.AnimByItemFilter
// 0x0038 (0x0038 - 0x0000)
struct FAnimByItemFilter final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemFilterData                        ItemFilter;                                        // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bLockAttackResource;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockMoveResource;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockFacingDuringContinuousRunning;                // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockStaminaRegen;                                // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimByItemFilter) == 0x000008, "Wrong alignment on FAnimByItemFilter");
static_assert(sizeof(FAnimByItemFilter) == 0x000038, "Wrong size on FAnimByItemFilter");
static_assert(offsetof(FAnimByItemFilter, AnimID) == 0x000000, "Member 'FAnimByItemFilter::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimByItemFilter, ItemFilter) == 0x000008, "Member 'FAnimByItemFilter::ItemFilter' has a wrong offset!");
static_assert(offsetof(FAnimByItemFilter, bLockAttackResource) == 0x000030, "Member 'FAnimByItemFilter::bLockAttackResource' has a wrong offset!");
static_assert(offsetof(FAnimByItemFilter, bLockMoveResource) == 0x000031, "Member 'FAnimByItemFilter::bLockMoveResource' has a wrong offset!");
static_assert(offsetof(FAnimByItemFilter, bLockFacingDuringContinuousRunning) == 0x000032, "Member 'FAnimByItemFilter::bLockFacingDuringContinuousRunning' has a wrong offset!");
static_assert(offsetof(FAnimByItemFilter, bBlockStaminaRegen) == 0x000033, "Member 'FAnimByItemFilter::bBlockStaminaRegen' has a wrong offset!");

// ScriptStruct man.DieOfChaosProjectileLootVariant
// 0x0010 (0x0010 - 0x0000)
struct FDieOfChaosProjectileLootVariant final
{
public:
	TArray<TSubclassOf<class UAbilityBase>>       LootedBuffs;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDieOfChaosProjectileLootVariant) == 0x000008, "Wrong alignment on FDieOfChaosProjectileLootVariant");
static_assert(sizeof(FDieOfChaosProjectileLootVariant) == 0x000010, "Wrong size on FDieOfChaosProjectileLootVariant");
static_assert(offsetof(FDieOfChaosProjectileLootVariant, LootedBuffs) == 0x000000, "Member 'FDieOfChaosProjectileLootVariant::LootedBuffs' has a wrong offset!");

// ScriptStruct man.PetFollowerData
// 0x0030 (0x0030 - 0x0000)
struct FPetFollowerData final
{
public:
	EPetFollower                                  Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPetFollowerData) == 0x000008, "Wrong alignment on FPetFollowerData");
static_assert(sizeof(FPetFollowerData) == 0x000030, "Wrong size on FPetFollowerData");
static_assert(offsetof(FPetFollowerData, Type) == 0x000000, "Member 'FPetFollowerData::Type' has a wrong offset!");
static_assert(offsetof(FPetFollowerData, CharacterClass) == 0x000008, "Member 'FPetFollowerData::CharacterClass' has a wrong offset!");

// ScriptStruct man.DialogueActorLine
// 0x0010 (0x0010 - 0x0000)
struct FDialogueActorLine final
{
public:
	class UAkAudioEvent*                          Sound;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogueActorLine) == 0x000008, "Wrong alignment on FDialogueActorLine");
static_assert(sizeof(FDialogueActorLine) == 0x000010, "Wrong size on FDialogueActorLine");
static_assert(offsetof(FDialogueActorLine, Sound) == 0x000000, "Member 'FDialogueActorLine::Sound' has a wrong offset!");
static_assert(offsetof(FDialogueActorLine, Delay) == 0x000008, "Member 'FDialogueActorLine::Delay' has a wrong offset!");

// ScriptStruct man.PlayerMonologue
// 0x0028 (0x0028 - 0x0000)
struct FPlayerMonologue final
{
public:
	float                                         FadeInAnimDuration;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutAnimDuration;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Music;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Picture;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              Video;                                             // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerMonologue) == 0x000008, "Wrong alignment on FPlayerMonologue");
static_assert(sizeof(FPlayerMonologue) == 0x000028, "Wrong size on FPlayerMonologue");
static_assert(offsetof(FPlayerMonologue, FadeInAnimDuration) == 0x000000, "Member 'FPlayerMonologue::FadeInAnimDuration' has a wrong offset!");
static_assert(offsetof(FPlayerMonologue, FadeOutAnimDuration) == 0x000004, "Member 'FPlayerMonologue::FadeOutAnimDuration' has a wrong offset!");
static_assert(offsetof(FPlayerMonologue, Music) == 0x000008, "Member 'FPlayerMonologue::Music' has a wrong offset!");
static_assert(offsetof(FPlayerMonologue, Picture) == 0x000010, "Member 'FPlayerMonologue::Picture' has a wrong offset!");
static_assert(offsetof(FPlayerMonologue, Video) == 0x000018, "Member 'FPlayerMonologue::Video' has a wrong offset!");

// ScriptStruct man.MAPerfFrame
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FMAPerfFrame final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMAPerfFrame) == 0x000004, "Wrong alignment on FMAPerfFrame");
static_assert(sizeof(FMAPerfFrame) == 0x00000C, "Wrong size on FMAPerfFrame");

// ScriptStruct man.DialogueNode
// 0x0068 (0x0068 - 0x0000)
struct FDialogueNode final
{
public:
	class FName                                   LineID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresVoiceOver;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimalConversationSpeaker*             Speaker;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConversationSpeakerPosition                  position;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         TextVisibleTime;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextDelay;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogueDelay;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortraitFadeInTime;                                // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortraitFadeOutTime;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          VoiceOverAkEvent;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepVOWhenTextNotVisible;                         // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogueBubbleType                           DialogueBubbleType;                                // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectWeight;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAudioOnly;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSkip;                                      // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogueNode) == 0x000008, "Wrong alignment on FDialogueNode");
static_assert(sizeof(FDialogueNode) == 0x000068, "Wrong size on FDialogueNode");
static_assert(offsetof(FDialogueNode, LineID) == 0x000000, "Member 'FDialogueNode::LineID' has a wrong offset!");
static_assert(offsetof(FDialogueNode, bRequiresVoiceOver) == 0x000008, "Member 'FDialogueNode::bRequiresVoiceOver' has a wrong offset!");
static_assert(offsetof(FDialogueNode, Speaker) == 0x000010, "Member 'FDialogueNode::Speaker' has a wrong offset!");
static_assert(offsetof(FDialogueNode, position) == 0x000018, "Member 'FDialogueNode::position' has a wrong offset!");
static_assert(offsetof(FDialogueNode, Text) == 0x000020, "Member 'FDialogueNode::Text' has a wrong offset!");
static_assert(offsetof(FDialogueNode, TextVisibleTime) == 0x000038, "Member 'FDialogueNode::TextVisibleTime' has a wrong offset!");
static_assert(offsetof(FDialogueNode, TextDelay) == 0x00003C, "Member 'FDialogueNode::TextDelay' has a wrong offset!");
static_assert(offsetof(FDialogueNode, DialogueDelay) == 0x000040, "Member 'FDialogueNode::DialogueDelay' has a wrong offset!");
static_assert(offsetof(FDialogueNode, PortraitFadeInTime) == 0x000044, "Member 'FDialogueNode::PortraitFadeInTime' has a wrong offset!");
static_assert(offsetof(FDialogueNode, PortraitFadeOutTime) == 0x000048, "Member 'FDialogueNode::PortraitFadeOutTime' has a wrong offset!");
static_assert(offsetof(FDialogueNode, VoiceOverAkEvent) == 0x000050, "Member 'FDialogueNode::VoiceOverAkEvent' has a wrong offset!");
static_assert(offsetof(FDialogueNode, bKeepVOWhenTextNotVisible) == 0x000058, "Member 'FDialogueNode::bKeepVOWhenTextNotVisible' has a wrong offset!");
static_assert(offsetof(FDialogueNode, DialogueBubbleType) == 0x000059, "Member 'FDialogueNode::DialogueBubbleType' has a wrong offset!");
static_assert(offsetof(FDialogueNode, SelectWeight) == 0x00005C, "Member 'FDialogueNode::SelectWeight' has a wrong offset!");
static_assert(offsetof(FDialogueNode, bAudioOnly) == 0x000060, "Member 'FDialogueNode::bAudioOnly' has a wrong offset!");
static_assert(offsetof(FDialogueNode, bDisableSkip) == 0x000061, "Member 'FDialogueNode::bDisableSkip' has a wrong offset!");

// ScriptStruct man.BestiaryResistance
// 0x0008 (0x0008 - 0x0000)
struct FBestiaryResistance final
{
public:
	float                                         ResistanceValue;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribute                                    ResistanceType;                                    // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBestiaryResistance) == 0x000004, "Wrong alignment on FBestiaryResistance");
static_assert(sizeof(FBestiaryResistance) == 0x000008, "Wrong size on FBestiaryResistance");
static_assert(offsetof(FBestiaryResistance, ResistanceValue) == 0x000000, "Member 'FBestiaryResistance::ResistanceValue' has a wrong offset!");
static_assert(offsetof(FBestiaryResistance, ResistanceType) == 0x000004, "Member 'FBestiaryResistance::ResistanceType' has a wrong offset!");

// ScriptStruct man.DragonFireExplosionNode
// 0x0040 (0x0040 - 0x0000)
struct FDragonFireExplosionNode final
{
public:
	struct FAbilityEventEditor                    TriggerEvent;                                      // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonFireExplosionNode) == 0x000008, "Wrong alignment on FDragonFireExplosionNode");
static_assert(sizeof(FDragonFireExplosionNode) == 0x000040, "Wrong size on FDragonFireExplosionNode");
static_assert(offsetof(FDragonFireExplosionNode, TriggerEvent) == 0x000000, "Member 'FDragonFireExplosionNode::TriggerEvent' has a wrong offset!");
static_assert(offsetof(FDragonFireExplosionNode, ActorClass) == 0x000030, "Member 'FDragonFireExplosionNode::ActorClass' has a wrong offset!");
static_assert(offsetof(FDragonFireExplosionNode, Width) == 0x000038, "Member 'FDragonFireExplosionNode::Width' has a wrong offset!");

// ScriptStruct man.DragonGroundStrikePillarParam
// 0x0048 (0x0048 - 0x0000)
struct FDragonGroundStrikePillarParam final
{
public:
	float                                         RandomMin;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomMax;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomMinTime;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomMaxTime;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbilityEventEditor                    CustomHitEvent;                                    // 0x0010(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonGroundStrikePillarParam) == 0x000008, "Wrong alignment on FDragonGroundStrikePillarParam");
static_assert(sizeof(FDragonGroundStrikePillarParam) == 0x000048, "Wrong size on FDragonGroundStrikePillarParam");
static_assert(offsetof(FDragonGroundStrikePillarParam, RandomMin) == 0x000000, "Member 'FDragonGroundStrikePillarParam::RandomMin' has a wrong offset!");
static_assert(offsetof(FDragonGroundStrikePillarParam, RandomMax) == 0x000004, "Member 'FDragonGroundStrikePillarParam::RandomMax' has a wrong offset!");
static_assert(offsetof(FDragonGroundStrikePillarParam, RandomMinTime) == 0x000008, "Member 'FDragonGroundStrikePillarParam::RandomMinTime' has a wrong offset!");
static_assert(offsetof(FDragonGroundStrikePillarParam, RandomMaxTime) == 0x00000C, "Member 'FDragonGroundStrikePillarParam::RandomMaxTime' has a wrong offset!");
static_assert(offsetof(FDragonGroundStrikePillarParam, CustomHitEvent) == 0x000010, "Member 'FDragonGroundStrikePillarParam::CustomHitEvent' has a wrong offset!");

// ScriptStruct man.QuantisedItemAbility
// 0x0010 (0x0010 - 0x0000)
struct FQuantisedItemAbility final
{
public:
	TSubclassOf<class UItemAbility>               ItemAbility;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuantisedItemAbility) == 0x000008, "Wrong alignment on FQuantisedItemAbility");
static_assert(sizeof(FQuantisedItemAbility) == 0x000010, "Wrong size on FQuantisedItemAbility");
static_assert(offsetof(FQuantisedItemAbility, ItemAbility) == 0x000000, "Member 'FQuantisedItemAbility::ItemAbility' has a wrong offset!");
static_assert(offsetof(FQuantisedItemAbility, Quantity) == 0x000008, "Member 'FQuantisedItemAbility::Quantity' has a wrong offset!");

// ScriptStruct man.DarkFirePhaseSettings
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDarkFirePhaseSettings final
{
public:
	float                                         IceBlockSizeMin;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IceBlockSizeMax;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSpreadSpeed;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMeltTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMaxSpread;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkFirePhaseSettings) == 0x000008, "Wrong alignment on FDarkFirePhaseSettings");
static_assert(sizeof(FDarkFirePhaseSettings) == 0x000028, "Wrong size on FDarkFirePhaseSettings");
static_assert(offsetof(FDarkFirePhaseSettings, IceBlockSizeMin) == 0x000000, "Member 'FDarkFirePhaseSettings::IceBlockSizeMin' has a wrong offset!");
static_assert(offsetof(FDarkFirePhaseSettings, IceBlockSizeMax) == 0x000004, "Member 'FDarkFirePhaseSettings::IceBlockSizeMax' has a wrong offset!");
static_assert(offsetof(FDarkFirePhaseSettings, FireSpreadSpeed) == 0x000008, "Member 'FDarkFirePhaseSettings::FireSpreadSpeed' has a wrong offset!");
static_assert(offsetof(FDarkFirePhaseSettings, FireMeltTime) == 0x00000C, "Member 'FDarkFirePhaseSettings::FireMeltTime' has a wrong offset!");
static_assert(offsetof(FDarkFirePhaseSettings, FireMaxSpread) == 0x000010, "Member 'FDarkFirePhaseSettings::FireMaxSpread' has a wrong offset!");

// ScriptStruct man.DarkFireValidSummonSize
// 0x0003 (0x0003 - 0x0000)
struct FDarkFireValidSummonSize final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkFireValidSummonSize) == 0x000001, "Wrong alignment on FDarkFireValidSummonSize");
static_assert(sizeof(FDarkFireValidSummonSize) == 0x000003, "Wrong size on FDarkFireValidSummonSize");

// ScriptStruct man.OptionsSlider
// 0x00B0 (0x00B0 - 0x0000)
struct FOptionsSlider final
{
public:
	EOptionsType                                  OptionsType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSize;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValueModifier;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPercentage;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Unit;                                              // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DisplayTextAtMin;                                  // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DisplayTextAtMax;                                  // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUsingCustomSpeed;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultSpeed;                                      // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepSizeMultiplierAtMaxSpeed;                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOptionsSlider) == 0x000008, "Wrong alignment on FOptionsSlider");
static_assert(sizeof(FOptionsSlider) == 0x0000B0, "Wrong size on FOptionsSlider");
static_assert(offsetof(FOptionsSlider, OptionsType) == 0x000000, "Member 'FOptionsSlider::OptionsType' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, DisplayName) == 0x000008, "Member 'FOptionsSlider::DisplayName' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, Description) == 0x000020, "Member 'FOptionsSlider::Description' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, MinValue) == 0x000038, "Member 'FOptionsSlider::MinValue' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, MaxValue) == 0x00003C, "Member 'FOptionsSlider::MaxValue' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, StepSize) == 0x000040, "Member 'FOptionsSlider::StepSize' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, DisplayValueModifier) == 0x000044, "Member 'FOptionsSlider::DisplayValueModifier' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, bShowPercentage) == 0x000048, "Member 'FOptionsSlider::bShowPercentage' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, Unit) == 0x000050, "Member 'FOptionsSlider::Unit' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, DisplayTextAtMin) == 0x000068, "Member 'FOptionsSlider::DisplayTextAtMin' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, DisplayTextAtMax) == 0x000080, "Member 'FOptionsSlider::DisplayTextAtMax' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, bUsingCustomSpeed) == 0x000098, "Member 'FOptionsSlider::bUsingCustomSpeed' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, DefaultSpeed) == 0x00009C, "Member 'FOptionsSlider::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, MaxSpeed) == 0x0000A0, "Member 'FOptionsSlider::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, Acceleration) == 0x0000A4, "Member 'FOptionsSlider::Acceleration' has a wrong offset!");
static_assert(offsetof(FOptionsSlider, StepSizeMultiplierAtMaxSpeed) == 0x0000A8, "Member 'FOptionsSlider::StepSizeMultiplierAtMaxSpeed' has a wrong offset!");

// ScriptStruct man.DarkFireIceBlockSetup
// 0x0020 (0x0020 - 0x0000)
struct FDarkFireIceBlockSetup final
{
public:
	float                                         MinDist;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDist;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepDist;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastTimeMin;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastTimeMax;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartHeight;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkFireIceBlockSetup) == 0x000004, "Wrong alignment on FDarkFireIceBlockSetup");
static_assert(sizeof(FDarkFireIceBlockSetup) == 0x000020, "Wrong size on FDarkFireIceBlockSetup");
static_assert(offsetof(FDarkFireIceBlockSetup, MinDist) == 0x000000, "Member 'FDarkFireIceBlockSetup::MinDist' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, MaxDist) == 0x000004, "Member 'FDarkFireIceBlockSetup::MaxDist' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, KeepDist) == 0x000008, "Member 'FDarkFireIceBlockSetup::KeepDist' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, CastTimeMin) == 0x00000C, "Member 'FDarkFireIceBlockSetup::CastTimeMin' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, CastTimeMax) == 0x000010, "Member 'FDarkFireIceBlockSetup::CastTimeMax' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, Num) == 0x000014, "Member 'FDarkFireIceBlockSetup::Num' has a wrong offset!");
static_assert(offsetof(FDarkFireIceBlockSetup, StartHeight) == 0x000018, "Member 'FDarkFireIceBlockSetup::StartHeight' has a wrong offset!");

// ScriptStruct man.DarkFireIcePillarSetup
// 0x0030 (0x0030 - 0x0000)
struct FDarkFireIcePillarSetup final
{
public:
	TSubclassOf<class AActorBase>                 Class;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRadiusMin;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRadiusMax;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepDistanceX;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepDistanceZ;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRandomBottom;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRandomTop;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMin;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMax;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDarkFireIcePillarSetup) == 0x000008, "Wrong alignment on FDarkFireIcePillarSetup");
static_assert(sizeof(FDarkFireIcePillarSetup) == 0x000030, "Wrong size on FDarkFireIcePillarSetup");
static_assert(offsetof(FDarkFireIcePillarSetup, Class) == 0x000000, "Member 'FDarkFireIcePillarSetup::Class' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, Num) == 0x000008, "Member 'FDarkFireIcePillarSetup::Num' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, DropRadiusMin) == 0x00000C, "Member 'FDarkFireIcePillarSetup::DropRadiusMin' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, DropRadiusMax) == 0x000010, "Member 'FDarkFireIcePillarSetup::DropRadiusMax' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, KeepDistanceX) == 0x000014, "Member 'FDarkFireIcePillarSetup::KeepDistanceX' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, KeepDistanceZ) == 0x000018, "Member 'FDarkFireIcePillarSetup::KeepDistanceZ' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, HeightRandomBottom) == 0x00001C, "Member 'FDarkFireIcePillarSetup::HeightRandomBottom' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, HeightRandomTop) == 0x000020, "Member 'FDarkFireIcePillarSetup::HeightRandomTop' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, DelayMin) == 0x000024, "Member 'FDarkFireIcePillarSetup::DelayMin' has a wrong offset!");
static_assert(offsetof(FDarkFireIcePillarSetup, DelayMax) == 0x000028, "Member 'FDarkFireIcePillarSetup::DelayMax' has a wrong offset!");

// ScriptStruct man.BestiaryDamageType
// 0x0020 (0x0020 - 0x0000)
struct FBestiaryDamageType final
{
public:
	class FText                                   DamageTypeName;                                    // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAttribute                                    DamageTypeType;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBestiaryDamageType) == 0x000008, "Wrong alignment on FBestiaryDamageType");
static_assert(sizeof(FBestiaryDamageType) == 0x000020, "Wrong size on FBestiaryDamageType");
static_assert(offsetof(FBestiaryDamageType, DamageTypeName) == 0x000000, "Member 'FBestiaryDamageType::DamageTypeName' has a wrong offset!");
static_assert(offsetof(FBestiaryDamageType, DamageTypeType) == 0x000018, "Member 'FBestiaryDamageType::DamageTypeType' has a wrong offset!");

// ScriptStruct man.DynamicPlatformBoxInertiaSettingsPlatformMove
// 0x0002 (0x0002 - 0x0000)
struct FDynamicPlatformBoxInertiaSettingsPlatformMove final
{
public:
	bool                                          bInheritXComponent;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritZComponent;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicPlatformBoxInertiaSettingsPlatformMove) == 0x000001, "Wrong alignment on FDynamicPlatformBoxInertiaSettingsPlatformMove");
static_assert(sizeof(FDynamicPlatformBoxInertiaSettingsPlatformMove) == 0x000002, "Wrong size on FDynamicPlatformBoxInertiaSettingsPlatformMove");
static_assert(offsetof(FDynamicPlatformBoxInertiaSettingsPlatformMove, bInheritXComponent) == 0x000000, "Member 'FDynamicPlatformBoxInertiaSettingsPlatformMove::bInheritXComponent' has a wrong offset!");
static_assert(offsetof(FDynamicPlatformBoxInertiaSettingsPlatformMove, bInheritZComponent) == 0x000001, "Member 'FDynamicPlatformBoxInertiaSettingsPlatformMove::bInheritZComponent' has a wrong offset!");

// ScriptStruct man.DynamicPlatformBoxInertiaSettingsjumpType
// 0x0004 (0x0004 - 0x0000)
struct FDynamicPlatformBoxInertiaSettingsjumpType final
{
public:
	struct FDynamicPlatformBoxInertiaSettingsPlatformMove PlatformXMove;                                     // 0x0000(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDynamicPlatformBoxInertiaSettingsPlatformMove PlatformZMove;                                     // 0x0002(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicPlatformBoxInertiaSettingsjumpType) == 0x000001, "Wrong alignment on FDynamicPlatformBoxInertiaSettingsjumpType");
static_assert(sizeof(FDynamicPlatformBoxInertiaSettingsjumpType) == 0x000004, "Wrong size on FDynamicPlatformBoxInertiaSettingsjumpType");
static_assert(offsetof(FDynamicPlatformBoxInertiaSettingsjumpType, PlatformXMove) == 0x000000, "Member 'FDynamicPlatformBoxInertiaSettingsjumpType::PlatformXMove' has a wrong offset!");
static_assert(offsetof(FDynamicPlatformBoxInertiaSettingsjumpType, PlatformZMove) == 0x000002, "Member 'FDynamicPlatformBoxInertiaSettingsjumpType::PlatformZMove' has a wrong offset!");

// ScriptStruct man.QuestDLCSettings
// 0x0001 (0x0001 - 0x0000)
struct FQuestDLCSettings final
{
public:
	bool                                          bBaseGame;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestDLCSettings) == 0x000001, "Wrong alignment on FQuestDLCSettings");
static_assert(sizeof(FQuestDLCSettings) == 0x000001, "Wrong size on FQuestDLCSettings");
static_assert(offsetof(FQuestDLCSettings, bBaseGame) == 0x000000, "Member 'FQuestDLCSettings::bBaseGame' has a wrong offset!");

// ScriptStruct man.AINavMove
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FAINavMove final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAINavMove) == 0x000008, "Wrong alignment on FAINavMove");
static_assert(sizeof(FAINavMove) == 0x000058, "Wrong size on FAINavMove");

// ScriptStruct man.Entity
// 0x03D8 (0x03D8 - 0x0000)
struct alignas(0x08) FEntity final
{
public:
	uint8                                         Pad_0[0x3D8];                                      // 0x0000(0x03D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntity) == 0x000008, "Wrong alignment on FEntity");
static_assert(sizeof(FEntity) == 0x0003D8, "Wrong size on FEntity");

// ScriptStruct man.ManObjectSaveHeader
// 0x0020 (0x0020 - 0x0000)
struct FManObjectSaveHeader final
{
public:
	class UClass*                                 Class;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentUnique;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectSerializeUnique;                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManObjectSaveHeader) == 0x000008, "Wrong alignment on FManObjectSaveHeader");
static_assert(sizeof(FManObjectSaveHeader) == 0x000020, "Wrong size on FManObjectSaveHeader");
static_assert(offsetof(FManObjectSaveHeader, Class) == 0x000000, "Member 'FManObjectSaveHeader::Class' has a wrong offset!");
static_assert(offsetof(FManObjectSaveHeader, Name) == 0x000008, "Member 'FManObjectSaveHeader::Name' has a wrong offset!");
static_assert(offsetof(FManObjectSaveHeader, ParentUnique) == 0x000010, "Member 'FManObjectSaveHeader::ParentUnique' has a wrong offset!");
static_assert(offsetof(FManObjectSaveHeader, ObjectSerializeUnique) == 0x000014, "Member 'FManObjectSaveHeader::ObjectSerializeUnique' has a wrong offset!");

// ScriptStruct man.EntityAnimSpeedOverride
// 0x0010 (0x0010 - 0x0000)
struct FEntityAnimSpeedOverride final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveMultiply;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreGlobalAnimPlayRateMultiplier;               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityAnimSpeedOverride) == 0x000008, "Wrong alignment on FEntityAnimSpeedOverride");
static_assert(sizeof(FEntityAnimSpeedOverride) == 0x000010, "Wrong size on FEntityAnimSpeedOverride");
static_assert(offsetof(FEntityAnimSpeedOverride, AnimID) == 0x000000, "Member 'FEntityAnimSpeedOverride::AnimID' has a wrong offset!");
static_assert(offsetof(FEntityAnimSpeedOverride, AdditiveMultiply) == 0x000008, "Member 'FEntityAnimSpeedOverride::AdditiveMultiply' has a wrong offset!");
static_assert(offsetof(FEntityAnimSpeedOverride, bIgnoreGlobalAnimPlayRateMultiplier) == 0x00000C, "Member 'FEntityAnimSpeedOverride::bIgnoreGlobalAnimPlayRateMultiplier' has a wrong offset!");

// ScriptStruct man.EntityAnimIDOverride
// 0x0010 (0x0010 - 0x0000)
struct FEntityAnimIDOverride final
{
public:
	class UAnimID*                                GameplayAnimId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                VisualAnimID;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntityAnimIDOverride) == 0x000008, "Wrong alignment on FEntityAnimIDOverride");
static_assert(sizeof(FEntityAnimIDOverride) == 0x000010, "Wrong size on FEntityAnimIDOverride");
static_assert(offsetof(FEntityAnimIDOverride, GameplayAnimId) == 0x000000, "Member 'FEntityAnimIDOverride::GameplayAnimId' has a wrong offset!");
static_assert(offsetof(FEntityAnimIDOverride, VisualAnimID) == 0x000008, "Member 'FEntityAnimIDOverride::VisualAnimID' has a wrong offset!");

// ScriptStruct man.ObjectiveCompletionData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FObjectiveCompletionData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveCompletionData) == 0x000008, "Wrong alignment on FObjectiveCompletionData");
static_assert(sizeof(FObjectiveCompletionData) == 0x000038, "Wrong size on FObjectiveCompletionData");

// ScriptStruct man.AttachedVisualEntity
// 0x000C (0x000C - 0x0000)
struct FAttachedVisualEntity final
{
public:
	TWeakObjectPtr<class AVisualEntity>           VisualEntityPtr;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HideCounter;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachedVisualEntity) == 0x000004, "Wrong alignment on FAttachedVisualEntity");
static_assert(sizeof(FAttachedVisualEntity) == 0x00000C, "Wrong size on FAttachedVisualEntity");
static_assert(offsetof(FAttachedVisualEntity, VisualEntityPtr) == 0x000000, "Member 'FAttachedVisualEntity::VisualEntityPtr' has a wrong offset!");
static_assert(offsetof(FAttachedVisualEntity, HideCounter) == 0x000008, "Member 'FAttachedVisualEntity::HideCounter' has a wrong offset!");

// ScriptStruct man.EntityHardSleepData
// 0x0060 (0x0060 - 0x0000)
struct FEntityHardSleepData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEntityHardSleepData) == 0x000008, "Wrong alignment on FEntityHardSleepData");
static_assert(sizeof(FEntityHardSleepData) == 0x000060, "Wrong size on FEntityHardSleepData");
static_assert(offsetof(FEntityHardSleepData, Actor) == 0x000058, "Member 'FEntityHardSleepData::Actor' has a wrong offset!");

// ScriptStruct man.AttachedWeaponActor
// 0x0068 (0x0068 - 0x0000)
struct FAttachedWeaponActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEntityHardSleepData                   EntityHardSleepData;                               // 0x0008(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachedWeaponActor) == 0x000008, "Wrong alignment on FAttachedWeaponActor");
static_assert(sizeof(FAttachedWeaponActor) == 0x000068, "Wrong size on FAttachedWeaponActor");
static_assert(offsetof(FAttachedWeaponActor, Actor) == 0x000000, "Member 'FAttachedWeaponActor::Actor' has a wrong offset!");
static_assert(offsetof(FAttachedWeaponActor, EntityHardSleepData) == 0x000008, "Member 'FAttachedWeaponActor::EntityHardSleepData' has a wrong offset!");

// ScriptStruct man.SortType
// 0x0002 (0x0002 - 0x0000)
struct FSortType final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSortType) == 0x000001, "Wrong alignment on FSortType");
static_assert(sizeof(FSortType) == 0x000002, "Wrong size on FSortType");

// ScriptStruct man.EntityAnimLog
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FEntityAnimLog final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityAnimLog) == 0x000008, "Wrong alignment on FEntityAnimLog");
static_assert(sizeof(FEntityAnimLog) == 0x000018, "Wrong size on FEntityAnimLog");

// ScriptStruct man.ManMainMenuPackage
// 0x0118 (0x0118 - 0x0000)
struct FManMainMenuPackage final
{
public:
	int32                                         CharacterSetupIndex;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterName;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaleCharacter;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCustomCharacterVoice>   SavedVoice;                                        // 0x0020(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomCharacterSlot>    SavedFace;                                         // 0x0048(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomCharacterSkinColor> SavedSkinColor;                                    // 0x0070(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomCharacterSlot>    SavedHairStyle;                                    // 0x0098(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomCharacterHairColor> SavedHairColor;                                    // 0x00C0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomCharacterTattoo>  SavedTattoo;                                       // 0x00E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterSetupTemplate>    ChosenCharacterTemplate;                           // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManMainMenuPackage) == 0x000008, "Wrong alignment on FManMainMenuPackage");
static_assert(sizeof(FManMainMenuPackage) == 0x000118, "Wrong size on FManMainMenuPackage");
static_assert(offsetof(FManMainMenuPackage, CharacterSetupIndex) == 0x000000, "Member 'FManMainMenuPackage::CharacterSetupIndex' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, CharacterName) == 0x000008, "Member 'FManMainMenuPackage::CharacterName' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, bMaleCharacter) == 0x000018, "Member 'FManMainMenuPackage::bMaleCharacter' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedVoice) == 0x000020, "Member 'FManMainMenuPackage::SavedVoice' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedFace) == 0x000048, "Member 'FManMainMenuPackage::SavedFace' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedSkinColor) == 0x000070, "Member 'FManMainMenuPackage::SavedSkinColor' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedHairStyle) == 0x000098, "Member 'FManMainMenuPackage::SavedHairStyle' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedHairColor) == 0x0000C0, "Member 'FManMainMenuPackage::SavedHairColor' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, SavedTattoo) == 0x0000E8, "Member 'FManMainMenuPackage::SavedTattoo' has a wrong offset!");
static_assert(offsetof(FManMainMenuPackage, ChosenCharacterTemplate) == 0x000110, "Member 'FManMainMenuPackage::ChosenCharacterTemplate' has a wrong offset!");

// ScriptStruct man.HitBoxProjection
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FHitBoxProjection final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitBoxProjection) == 0x000008, "Wrong alignment on FHitBoxProjection");
static_assert(sizeof(FHitBoxProjection) == 0x000010, "Wrong size on FHitBoxProjection");

// ScriptStruct man.EntityAnimIdMapNode
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FEntityAnimIdMapNode final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityAnimIdMapNode) == 0x000008, "Wrong alignment on FEntityAnimIdMapNode");
static_assert(sizeof(FEntityAnimIdMapNode) == 0x000058, "Wrong size on FEntityAnimIdMapNode");

// ScriptStruct man.ManSkillTreeNodeAttributeData
// 0x0014 (0x0014 - 0x0000)
struct FManSkillTreeNodeAttributeData final
{
public:
	EAttribute                                    MandragoraAttribute;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeModifier                     AttributeModifier;                                 // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManSkillTreeNodeAttributeData) == 0x000004, "Wrong alignment on FManSkillTreeNodeAttributeData");
static_assert(sizeof(FManSkillTreeNodeAttributeData) == 0x000014, "Wrong size on FManSkillTreeNodeAttributeData");
static_assert(offsetof(FManSkillTreeNodeAttributeData, MandragoraAttribute) == 0x000000, "Member 'FManSkillTreeNodeAttributeData::MandragoraAttribute' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeAttributeData, AttributeModifier) == 0x000004, "Member 'FManSkillTreeNodeAttributeData::AttributeModifier' has a wrong offset!");

// ScriptStruct man.ManSkillTreeNodeStageData
// 0x0088 (0x0088 - 0x0000)
struct FManSkillTreeNodeStageData final
{
public:
	TArray<struct FManSkillTreeNodeAttributeData> AwardedAttributes;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAdvancedAttributeModifier*>     AdvancedAttributeModifiers;                        // 0x0010(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       AwardedAbilities;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EWeaponType>                           AwardedWeaponTypeUnlock;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECharacterClass                               UnlockedForCharacterClass;                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StageSkillPointCost;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StageLanternEssenceCost;                           // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelRequirement;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StageDescription;                                  // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSmartText                             StageDescriptionSmartText;                         // 0x0068(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAllowUnlockWithoutNeighbour;                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNextNodeStageSelect;                              // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0xE];                                       // 0x007A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManSkillTreeNodeStageData) == 0x000008, "Wrong alignment on FManSkillTreeNodeStageData");
static_assert(sizeof(FManSkillTreeNodeStageData) == 0x000088, "Wrong size on FManSkillTreeNodeStageData");
static_assert(offsetof(FManSkillTreeNodeStageData, AwardedAttributes) == 0x000000, "Member 'FManSkillTreeNodeStageData::AwardedAttributes' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, AdvancedAttributeModifiers) == 0x000010, "Member 'FManSkillTreeNodeStageData::AdvancedAttributeModifiers' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, AwardedAbilities) == 0x000020, "Member 'FManSkillTreeNodeStageData::AwardedAbilities' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, AwardedWeaponTypeUnlock) == 0x000030, "Member 'FManSkillTreeNodeStageData::AwardedWeaponTypeUnlock' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, UnlockedForCharacterClass) == 0x000040, "Member 'FManSkillTreeNodeStageData::UnlockedForCharacterClass' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, StageSkillPointCost) == 0x000044, "Member 'FManSkillTreeNodeStageData::StageSkillPointCost' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, StageLanternEssenceCost) == 0x000048, "Member 'FManSkillTreeNodeStageData::StageLanternEssenceCost' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, LevelRequirement) == 0x00004C, "Member 'FManSkillTreeNodeStageData::LevelRequirement' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, StageDescription) == 0x000050, "Member 'FManSkillTreeNodeStageData::StageDescription' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, StageDescriptionSmartText) == 0x000068, "Member 'FManSkillTreeNodeStageData::StageDescriptionSmartText' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, bAllowUnlockWithoutNeighbour) == 0x000078, "Member 'FManSkillTreeNodeStageData::bAllowUnlockWithoutNeighbour' has a wrong offset!");
static_assert(offsetof(FManSkillTreeNodeStageData, bNextNodeStageSelect) == 0x000079, "Member 'FManSkillTreeNodeStageData::bNextNodeStageSelect' has a wrong offset!");

// ScriptStruct man.NodeStageRewardAlternative
// 0x0038 (0x0038 - 0x0000)
struct FNodeStageRewardAlternative final
{
public:
	class FName                                   RewardGroupName;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SkillNodeName;                                     // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkillNodeIcon;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FManSkillTreeNodeStageData>     StageRewards;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNodeStageRewardAlternative) == 0x000008, "Wrong alignment on FNodeStageRewardAlternative");
static_assert(sizeof(FNodeStageRewardAlternative) == 0x000038, "Wrong size on FNodeStageRewardAlternative");
static_assert(offsetof(FNodeStageRewardAlternative, RewardGroupName) == 0x000000, "Member 'FNodeStageRewardAlternative::RewardGroupName' has a wrong offset!");
static_assert(offsetof(FNodeStageRewardAlternative, SkillNodeName) == 0x000008, "Member 'FNodeStageRewardAlternative::SkillNodeName' has a wrong offset!");
static_assert(offsetof(FNodeStageRewardAlternative, SkillNodeIcon) == 0x000020, "Member 'FNodeStageRewardAlternative::SkillNodeIcon' has a wrong offset!");
static_assert(offsetof(FNodeStageRewardAlternative, StageRewards) == 0x000028, "Member 'FNodeStageRewardAlternative::StageRewards' has a wrong offset!");

// ScriptStruct man.EntityAnimIdMapSequenceNode
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEntityAnimIdMapSequenceNode final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityAnimIdMapSequenceNode) == 0x000008, "Wrong alignment on FEntityAnimIdMapSequenceNode");
static_assert(sizeof(FEntityAnimIdMapSequenceNode) == 0x000010, "Wrong size on FEntityAnimIdMapSequenceNode");

// ScriptStruct man.RiftWaveRewardData
// 0x0018 (0x0018 - 0x0000)
struct FRiftWaveRewardData final
{
public:
	TArray<struct FManLootData>                   RiftWaveRewards;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EntropicEssence;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRiftWaveRewardData) == 0x000008, "Wrong alignment on FRiftWaveRewardData");
static_assert(sizeof(FRiftWaveRewardData) == 0x000018, "Wrong size on FRiftWaveRewardData");
static_assert(offsetof(FRiftWaveRewardData, RiftWaveRewards) == 0x000000, "Member 'FRiftWaveRewardData::RiftWaveRewards' has a wrong offset!");
static_assert(offsetof(FRiftWaveRewardData, EntropicEssence) == 0x000010, "Member 'FRiftWaveRewardData::EntropicEssence' has a wrong offset!");

// ScriptStruct man.ManSaveVersion
// 0x0018 (0x0018 - 0x0000)
struct FManSaveVersion final
{
public:
	uint16                                        FormatVersion;                                     // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        BuildMajorVersion;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BuildMinorVersion;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BuildHotfixVersion;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BuildChangeListVersion;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BuildDemoMode;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManSaveVersion) == 0x000004, "Wrong alignment on FManSaveVersion");
static_assert(sizeof(FManSaveVersion) == 0x000018, "Wrong size on FManSaveVersion");
static_assert(offsetof(FManSaveVersion, FormatVersion) == 0x000000, "Member 'FManSaveVersion::FormatVersion' has a wrong offset!");
static_assert(offsetof(FManSaveVersion, BuildMajorVersion) == 0x000004, "Member 'FManSaveVersion::BuildMajorVersion' has a wrong offset!");
static_assert(offsetof(FManSaveVersion, BuildMinorVersion) == 0x000008, "Member 'FManSaveVersion::BuildMinorVersion' has a wrong offset!");
static_assert(offsetof(FManSaveVersion, BuildHotfixVersion) == 0x00000C, "Member 'FManSaveVersion::BuildHotfixVersion' has a wrong offset!");
static_assert(offsetof(FManSaveVersion, BuildChangeListVersion) == 0x000010, "Member 'FManSaveVersion::BuildChangeListVersion' has a wrong offset!");
static_assert(offsetof(FManSaveVersion, BuildDemoMode) == 0x000014, "Member 'FManSaveVersion::BuildDemoMode' has a wrong offset!");

// ScriptStruct man.EntropySpawnNode
// 0x0018 (0x0018 - 0x0000)
struct FEntropySpawnNode final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterBase>             Enemy;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YOffset;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntropySpawnNode) == 0x000008, "Wrong alignment on FEntropySpawnNode");
static_assert(sizeof(FEntropySpawnNode) == 0x000018, "Wrong size on FEntropySpawnNode");
static_assert(offsetof(FEntropySpawnNode, Time) == 0x000000, "Member 'FEntropySpawnNode::Time' has a wrong offset!");
static_assert(offsetof(FEntropySpawnNode, Enemy) == 0x000008, "Member 'FEntropySpawnNode::Enemy' has a wrong offset!");
static_assert(offsetof(FEntropySpawnNode, YOffset) == 0x000010, "Member 'FEntropySpawnNode::YOffset' has a wrong offset!");

// ScriptStruct man.EntropyWaveSpawn
// 0x0010 (0x0010 - 0x0000)
struct FEntropyWaveSpawn final
{
public:
	TArray<struct FEntropySpawnNode>              Nodes;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntropyWaveSpawn) == 0x000008, "Wrong alignment on FEntropyWaveSpawn");
static_assert(sizeof(FEntropyWaveSpawn) == 0x000010, "Wrong size on FEntropyWaveSpawn");
static_assert(offsetof(FEntropyWaveSpawn, Nodes) == 0x000000, "Member 'FEntropyWaveSpawn::Nodes' has a wrong offset!");

// ScriptStruct man.QuestReward
// 0x0028 (0x0028 - 0x0000)
struct FQuestReward final
{
public:
	TArray<struct FQuestItemReward>               ItemRewards;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Essence;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     RewardIcons;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestReward) == 0x000008, "Wrong alignment on FQuestReward");
static_assert(sizeof(FQuestReward) == 0x000028, "Wrong size on FQuestReward");
static_assert(offsetof(FQuestReward, ItemRewards) == 0x000000, "Member 'FQuestReward::ItemRewards' has a wrong offset!");
static_assert(offsetof(FQuestReward, Gold) == 0x000010, "Member 'FQuestReward::Gold' has a wrong offset!");
static_assert(offsetof(FQuestReward, Essence) == 0x000014, "Member 'FQuestReward::Essence' has a wrong offset!");
static_assert(offsetof(FQuestReward, RewardIcons) == 0x000018, "Member 'FQuestReward::RewardIcons' has a wrong offset!");

// ScriptStruct man.ExplodingOrbDmgCache
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FExplodingOrbDmgCache final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplodingOrbDmgCache) == 0x000008, "Wrong alignment on FExplodingOrbDmgCache");
static_assert(sizeof(FExplodingOrbDmgCache) == 0x000040, "Wrong size on FExplodingOrbDmgCache");

// ScriptStruct man.FallLandingEvents
// 0x000C (0x000C - 0x0000)
struct FFallLandingEvents final
{
public:
	float                                         GreaterEqualFallDistance;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomEventToEmit;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallLandingEvents) == 0x000004, "Wrong alignment on FFallLandingEvents");
static_assert(sizeof(FFallLandingEvents) == 0x00000C, "Wrong size on FFallLandingEvents");
static_assert(offsetof(FFallLandingEvents, GreaterEqualFallDistance) == 0x000000, "Member 'FFallLandingEvents::GreaterEqualFallDistance' has a wrong offset!");
static_assert(offsetof(FFallLandingEvents, CustomEventToEmit) == 0x000004, "Member 'FFallLandingEvents::CustomEventToEmit' has a wrong offset!");

// ScriptStruct man.ChainStrikeNode
// 0x0020 (0x0020 - 0x0000)
struct FChainStrikeNode final
{
public:
	EAnimEventType                                SwitchEvent;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimID*                                AnimID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                AnimStopId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChainStrikeNode) == 0x000008, "Wrong alignment on FChainStrikeNode");
static_assert(sizeof(FChainStrikeNode) == 0x000020, "Wrong size on FChainStrikeNode");
static_assert(offsetof(FChainStrikeNode, SwitchEvent) == 0x000000, "Member 'FChainStrikeNode::SwitchEvent' has a wrong offset!");
static_assert(offsetof(FChainStrikeNode, AnimID) == 0x000008, "Member 'FChainStrikeNode::AnimID' has a wrong offset!");
static_assert(offsetof(FChainStrikeNode, AnimStopId) == 0x000010, "Member 'FChainStrikeNode::AnimStopId' has a wrong offset!");
static_assert(offsetof(FChainStrikeNode, Chance) == 0x000018, "Member 'FChainStrikeNode::Chance' has a wrong offset!");

// ScriptStruct man.BloodVialData
// 0x0004 (0x0004 - 0x0000)
struct FBloodVialData final
{
public:
	float                                         HealthTriggerInPercent;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodVialData) == 0x000004, "Wrong alignment on FBloodVialData");
static_assert(sizeof(FBloodVialData) == 0x000004, "Wrong size on FBloodVialData");
static_assert(offsetof(FBloodVialData, HealthTriggerInPercent) == 0x000000, "Member 'FBloodVialData::HealthTriggerInPercent' has a wrong offset!");

// ScriptStruct man.CachedWidget
// 0x0010 (0x0010 - 0x0000)
struct FCachedWidget final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CachedSize;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedWidget) == 0x000008, "Wrong alignment on FCachedWidget");
static_assert(sizeof(FCachedWidget) == 0x000010, "Wrong size on FCachedWidget");
static_assert(offsetof(FCachedWidget, Widget) == 0x000000, "Member 'FCachedWidget::Widget' has a wrong offset!");
static_assert(offsetof(FCachedWidget, CachedSize) == 0x000008, "Member 'FCachedWidget::CachedSize' has a wrong offset!");

// ScriptStruct man.CopiedAbilityData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCopiedAbilityData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCopiedAbilityData) == 0x000008, "Wrong alignment on FCopiedAbilityData");
static_assert(sizeof(FCopiedAbilityData) == 0x000010, "Wrong size on FCopiedAbilityData");

// ScriptStruct man.ForkedLightningData
// 0x0018 (0x0018 - 0x0000)
struct FForkedLightningData final
{
public:
	class AActor*                                 TargetEntity;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTimeRemain;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRampUpPercent;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVisualEntity*                          LightningVE;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForkedLightningData) == 0x000008, "Wrong alignment on FForkedLightningData");
static_assert(sizeof(FForkedLightningData) == 0x000018, "Wrong size on FForkedLightningData");
static_assert(offsetof(FForkedLightningData, TargetEntity) == 0x000000, "Member 'FForkedLightningData::TargetEntity' has a wrong offset!");
static_assert(offsetof(FForkedLightningData, DamageTimeRemain) == 0x000008, "Member 'FForkedLightningData::DamageTimeRemain' has a wrong offset!");
static_assert(offsetof(FForkedLightningData, DamageRampUpPercent) == 0x00000C, "Member 'FForkedLightningData::DamageRampUpPercent' has a wrong offset!");
static_assert(offsetof(FForkedLightningData, LightningVE) == 0x000010, "Member 'FForkedLightningData::LightningVE' has a wrong offset!");

// ScriptStruct man.ManStackMeasureNodeReference
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FManStackMeasureNodeReference final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManStackMeasureNodeReference) == 0x000008, "Wrong alignment on FManStackMeasureNodeReference");
static_assert(sizeof(FManStackMeasureNodeReference) == 0x000008, "Wrong size on FManStackMeasureNodeReference");

// ScriptStruct man.CameraTarget
// 0x0020 (0x0020 - 0x0000)
struct FCameraTarget final
{
public:
	class ACharacterBase*                         Character;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraTarget) == 0x000008, "Wrong alignment on FCameraTarget");
static_assert(sizeof(FCameraTarget) == 0x000020, "Wrong size on FCameraTarget");
static_assert(offsetof(FCameraTarget, Character) == 0x000000, "Member 'FCameraTarget::Character' has a wrong offset!");

// ScriptStruct man.GameCameraConversationSettings
// 0x0078 (0x0078 - 0x0000)
struct FGameCameraConversationSettings final
{
public:
	float                                         TransitionInDuration;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionOutDuration;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVRate;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomRate;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApertureRate;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLocationY;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationOffset;                                    // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x34];                                      // 0x0024(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       TargetSphere;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameCameraConversationSettings) == 0x000008, "Wrong alignment on FGameCameraConversationSettings");
static_assert(sizeof(FGameCameraConversationSettings) == 0x000078, "Wrong size on FGameCameraConversationSettings");
static_assert(offsetof(FGameCameraConversationSettings, TransitionInDuration) == 0x000000, "Member 'FGameCameraConversationSettings::TransitionInDuration' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, TransitionOutDuration) == 0x000004, "Member 'FGameCameraConversationSettings::TransitionOutDuration' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, FOVRate) == 0x000008, "Member 'FGameCameraConversationSettings::FOVRate' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, ZoomRate) == 0x00000C, "Member 'FGameCameraConversationSettings::ZoomRate' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, ApertureRate) == 0x000010, "Member 'FGameCameraConversationSettings::ApertureRate' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, TargetLocationY) == 0x000014, "Member 'FGameCameraConversationSettings::TargetLocationY' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, RotationOffset) == 0x000018, "Member 'FGameCameraConversationSettings::RotationOffset' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, TargetActor) == 0x000058, "Member 'FGameCameraConversationSettings::TargetActor' has a wrong offset!");
static_assert(offsetof(FGameCameraConversationSettings, TargetSphere) == 0x000060, "Member 'FGameCameraConversationSettings::TargetSphere' has a wrong offset!");

// ScriptStruct man.ManShaderCacheGenerator_CameraConfig
// 0x0020 (0x0020 - 0x0000)
struct FManShaderCacheGenerator_CameraConfig final
{
public:
	bool                                          bUseManualCamera;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CameraFrames;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LVVChangeAdditionalFrames;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepWidth;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepHeight;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraHalfWidth;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraHalfHeight;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDepth;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManShaderCacheGenerator_CameraConfig) == 0x000004, "Wrong alignment on FManShaderCacheGenerator_CameraConfig");
static_assert(sizeof(FManShaderCacheGenerator_CameraConfig) == 0x000020, "Wrong size on FManShaderCacheGenerator_CameraConfig");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, bUseManualCamera) == 0x000000, "Member 'FManShaderCacheGenerator_CameraConfig::bUseManualCamera' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, CameraFrames) == 0x000004, "Member 'FManShaderCacheGenerator_CameraConfig::CameraFrames' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, LVVChangeAdditionalFrames) == 0x000008, "Member 'FManShaderCacheGenerator_CameraConfig::LVVChangeAdditionalFrames' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, StepWidth) == 0x00000C, "Member 'FManShaderCacheGenerator_CameraConfig::StepWidth' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, StepHeight) == 0x000010, "Member 'FManShaderCacheGenerator_CameraConfig::StepHeight' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, CameraHalfWidth) == 0x000014, "Member 'FManShaderCacheGenerator_CameraConfig::CameraHalfWidth' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, CameraHalfHeight) == 0x000018, "Member 'FManShaderCacheGenerator_CameraConfig::CameraHalfHeight' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_CameraConfig, CameraDepth) == 0x00001C, "Member 'FManShaderCacheGenerator_CameraConfig::CameraDepth' has a wrong offset!");

// ScriptStruct man.CameraManual
// 0x0010 (0x0010 - 0x0000)
struct FCameraManual final
{
public:
	float                                         MaxDistanceUp;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDown;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlDamping;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseDamping;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraManual) == 0x000004, "Wrong alignment on FCameraManual");
static_assert(sizeof(FCameraManual) == 0x000010, "Wrong size on FCameraManual");
static_assert(offsetof(FCameraManual, MaxDistanceUp) == 0x000000, "Member 'FCameraManual::MaxDistanceUp' has a wrong offset!");
static_assert(offsetof(FCameraManual, MaxDistanceDown) == 0x000004, "Member 'FCameraManual::MaxDistanceDown' has a wrong offset!");
static_assert(offsetof(FCameraManual, ControlDamping) == 0x000008, "Member 'FCameraManual::ControlDamping' has a wrong offset!");
static_assert(offsetof(FCameraManual, ReleaseDamping) == 0x00000C, "Member 'FCameraManual::ReleaseDamping' has a wrong offset!");

// ScriptStruct man.CameraBorder
// 0x0010 (0x0010 - 0x0000)
struct FCameraBorder final
{
public:
	float                                         UpStart;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpEnd;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownStart;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownEnd;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraBorder) == 0x000004, "Wrong alignment on FCameraBorder");
static_assert(sizeof(FCameraBorder) == 0x000010, "Wrong size on FCameraBorder");
static_assert(offsetof(FCameraBorder, UpStart) == 0x000000, "Member 'FCameraBorder::UpStart' has a wrong offset!");
static_assert(offsetof(FCameraBorder, UpEnd) == 0x000004, "Member 'FCameraBorder::UpEnd' has a wrong offset!");
static_assert(offsetof(FCameraBorder, DownStart) == 0x000008, "Member 'FCameraBorder::DownStart' has a wrong offset!");
static_assert(offsetof(FCameraBorder, DownEnd) == 0x00000C, "Member 'FCameraBorder::DownEnd' has a wrong offset!");

// ScriptStruct man.KingPriestVoidPlatformData
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidPlatformData final
{
public:
	EKingPriestVoidPlatformType                   PlatformType;                                      // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AVolume*                                PlatformVolume;                                    // 0x0008(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidPlatformData) == 0x000008, "Wrong alignment on FKingPriestVoidPlatformData");
static_assert(sizeof(FKingPriestVoidPlatformData) == 0x000010, "Wrong size on FKingPriestVoidPlatformData");
static_assert(offsetof(FKingPriestVoidPlatformData, PlatformType) == 0x000000, "Member 'FKingPriestVoidPlatformData::PlatformType' has a wrong offset!");
static_assert(offsetof(FKingPriestVoidPlatformData, PlatformVolume) == 0x000008, "Member 'FKingPriestVoidPlatformData::PlatformVolume' has a wrong offset!");

// ScriptStruct man.CameraParams
// 0x00B0 (0x00B0 - 0x0000)
struct FCameraParams final
{
public:
	float                                         TransitionTime;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalDamping;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDamping;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingDamping;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontDistance;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepDistance;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalDistance;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlatformLock;                                      // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          JustInClimb;                                       // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Zoom;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraAperture;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraManualMaxDistanceUp;                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraManualMaxDistanceDown;               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraManualControlDamping;                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraManualReleaseDamping;                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorLock;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpsideDown;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalMaxOffset;                               // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalMaxOffset;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomMinOffset;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomMaxOffset;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFactor;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossFocusZoom;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossAppearDuration;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossDisappearDuration;                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossDiscardByZDuration;                            // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossMinZ;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BossMaxZ;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVertigoEnabled;                                   // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VertigoBlendInDuration;                            // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoBlendOutDuration;                           // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoTiltMin;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoTiltMax;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoFOVMin;                                     // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoFOVMax;                                     // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoSpeedMin;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoSpeedMax;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoTimeMin;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertigoTimeMax;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraParams) == 0x000008, "Wrong alignment on FCameraParams");
static_assert(sizeof(FCameraParams) == 0x0000B0, "Wrong size on FCameraParams");
static_assert(offsetof(FCameraParams, TransitionTime) == 0x000000, "Member 'FCameraParams::TransitionTime' has a wrong offset!");
static_assert(offsetof(FCameraParams, HorizontalDamping) == 0x000004, "Member 'FCameraParams::HorizontalDamping' has a wrong offset!");
static_assert(offsetof(FCameraParams, VerticalDamping) == 0x000008, "Member 'FCameraParams::VerticalDamping' has a wrong offset!");
static_assert(offsetof(FCameraParams, FallingDamping) == 0x00000C, "Member 'FCameraParams::FallingDamping' has a wrong offset!");
static_assert(offsetof(FCameraParams, FrontDistance) == 0x000010, "Member 'FCameraParams::FrontDistance' has a wrong offset!");
static_assert(offsetof(FCameraParams, KeepDistance) == 0x000014, "Member 'FCameraParams::KeepDistance' has a wrong offset!");
static_assert(offsetof(FCameraParams, VerticalDistance) == 0x000018, "Member 'FCameraParams::VerticalDistance' has a wrong offset!");
static_assert(offsetof(FCameraParams, PlatformLock) == 0x00001C, "Member 'FCameraParams::PlatformLock' has a wrong offset!");
static_assert(offsetof(FCameraParams, JustInClimb) == 0x00001D, "Member 'FCameraParams::JustInClimb' has a wrong offset!");
static_assert(offsetof(FCameraParams, Zoom) == 0x000020, "Member 'FCameraParams::Zoom' has a wrong offset!");
static_assert(offsetof(FCameraParams, FOV) == 0x000024, "Member 'FCameraParams::FOV' has a wrong offset!");
static_assert(offsetof(FCameraParams, OverrideCameraAperture) == 0x000028, "Member 'FCameraParams::OverrideCameraAperture' has a wrong offset!");
static_assert(offsetof(FCameraParams, OverrideCameraManualMaxDistanceUp) == 0x00002C, "Member 'FCameraParams::OverrideCameraManualMaxDistanceUp' has a wrong offset!");
static_assert(offsetof(FCameraParams, OverrideCameraManualMaxDistanceDown) == 0x000030, "Member 'FCameraParams::OverrideCameraManualMaxDistanceDown' has a wrong offset!");
static_assert(offsetof(FCameraParams, OverrideCameraManualControlDamping) == 0x000034, "Member 'FCameraParams::OverrideCameraManualControlDamping' has a wrong offset!");
static_assert(offsetof(FCameraParams, OverrideCameraManualReleaseDamping) == 0x000038, "Member 'FCameraParams::OverrideCameraManualReleaseDamping' has a wrong offset!");
static_assert(offsetof(FCameraParams, ActorLock) == 0x000040, "Member 'FCameraParams::ActorLock' has a wrong offset!");
static_assert(offsetof(FCameraParams, UpsideDown) == 0x000048, "Member 'FCameraParams::UpsideDown' has a wrong offset!");
static_assert(offsetof(FCameraParams, HorizontalMaxOffset) == 0x00004C, "Member 'FCameraParams::HorizontalMaxOffset' has a wrong offset!");
static_assert(offsetof(FCameraParams, VerticalMaxOffset) == 0x000050, "Member 'FCameraParams::VerticalMaxOffset' has a wrong offset!");
static_assert(offsetof(FCameraParams, ZoomMinOffset) == 0x000054, "Member 'FCameraParams::ZoomMinOffset' has a wrong offset!");
static_assert(offsetof(FCameraParams, ZoomMaxOffset) == 0x000058, "Member 'FCameraParams::ZoomMaxOffset' has a wrong offset!");
static_assert(offsetof(FCameraParams, ZoomFactor) == 0x00005C, "Member 'FCameraParams::ZoomFactor' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossFocusZoom) == 0x000060, "Member 'FCameraParams::BossFocusZoom' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossAppearDuration) == 0x000064, "Member 'FCameraParams::BossAppearDuration' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossDisappearDuration) == 0x000068, "Member 'FCameraParams::BossDisappearDuration' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossDiscardByZDuration) == 0x00006C, "Member 'FCameraParams::BossDiscardByZDuration' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossMinZ) == 0x000070, "Member 'FCameraParams::BossMinZ' has a wrong offset!");
static_assert(offsetof(FCameraParams, BossMaxZ) == 0x000074, "Member 'FCameraParams::BossMaxZ' has a wrong offset!");
static_assert(offsetof(FCameraParams, bVertigoEnabled) == 0x000078, "Member 'FCameraParams::bVertigoEnabled' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoBlendInDuration) == 0x00007C, "Member 'FCameraParams::VertigoBlendInDuration' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoBlendOutDuration) == 0x000080, "Member 'FCameraParams::VertigoBlendOutDuration' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoTiltMin) == 0x000084, "Member 'FCameraParams::VertigoTiltMin' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoTiltMax) == 0x000088, "Member 'FCameraParams::VertigoTiltMax' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoFOVMin) == 0x00008C, "Member 'FCameraParams::VertigoFOVMin' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoFOVMax) == 0x000090, "Member 'FCameraParams::VertigoFOVMax' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoSpeedMin) == 0x000094, "Member 'FCameraParams::VertigoSpeedMin' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoSpeedMax) == 0x000098, "Member 'FCameraParams::VertigoSpeedMax' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoTimeMin) == 0x00009C, "Member 'FCameraParams::VertigoTimeMin' has a wrong offset!");
static_assert(offsetof(FCameraParams, VertigoTimeMax) == 0x0000A0, "Member 'FCameraParams::VertigoTimeMax' has a wrong offset!");

// ScriptStruct man.OarSlamShockwaveParams
// 0x000C (0x000C - 0x0000)
struct FOarSlamShockwaveParams final
{
public:
	float                                         StartSpeed;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOarSlamShockwaveParams) == 0x000004, "Wrong alignment on FOarSlamShockwaveParams");
static_assert(sizeof(FOarSlamShockwaveParams) == 0x00000C, "Wrong size on FOarSlamShockwaveParams");
static_assert(offsetof(FOarSlamShockwaveParams, StartSpeed) == 0x000000, "Member 'FOarSlamShockwaveParams::StartSpeed' has a wrong offset!");
static_assert(offsetof(FOarSlamShockwaveParams, MaxSpeed) == 0x000004, "Member 'FOarSlamShockwaveParams::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FOarSlamShockwaveParams, Acceleration) == 0x000008, "Member 'FOarSlamShockwaveParams::Acceleration' has a wrong offset!");

// ScriptStruct man.MapExplorationGrid
// 0x0020 (0x0020 - 0x0000)
struct FMapExplorationGrid final
{
public:
	struct FIntPoint                              GlobalPos;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Size;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMapExplorationTile>            Tiles;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapExplorationGrid) == 0x000008, "Wrong alignment on FMapExplorationGrid");
static_assert(sizeof(FMapExplorationGrid) == 0x000020, "Wrong size on FMapExplorationGrid");
static_assert(offsetof(FMapExplorationGrid, GlobalPos) == 0x000000, "Member 'FMapExplorationGrid::GlobalPos' has a wrong offset!");
static_assert(offsetof(FMapExplorationGrid, Size) == 0x000008, "Member 'FMapExplorationGrid::Size' has a wrong offset!");
static_assert(offsetof(FMapExplorationGrid, Tiles) == 0x000010, "Member 'FMapExplorationGrid::Tiles' has a wrong offset!");

// ScriptStruct man.MapOverviewLevelSegmentBuiltData
// 0x0030 (0x0030 - 0x0000)
struct FMapOverviewLevelSegmentBuiltData final
{
public:
	class UMapSegmentVolumeID*                    SegmentID;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapExplorationGrid                    ExplorationGrid;                                   // 0x0008(0x0020)(NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapOverviewLevelSegmentBuiltData) == 0x000008, "Wrong alignment on FMapOverviewLevelSegmentBuiltData");
static_assert(sizeof(FMapOverviewLevelSegmentBuiltData) == 0x000030, "Wrong size on FMapOverviewLevelSegmentBuiltData");
static_assert(offsetof(FMapOverviewLevelSegmentBuiltData, SegmentID) == 0x000000, "Member 'FMapOverviewLevelSegmentBuiltData::SegmentID' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSegmentBuiltData, ExplorationGrid) == 0x000008, "Member 'FMapOverviewLevelSegmentBuiltData::ExplorationGrid' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSegmentBuiltData, LayerIndex) == 0x000028, "Member 'FMapOverviewLevelSegmentBuiltData::LayerIndex' has a wrong offset!");

// ScriptStruct man.CallWeblingsSummonSettings
// 0x0020 (0x0020 - 0x0000)
struct FCallWeblingsSummonSettings final
{
public:
	float                                         HPPercentPerPhase;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SummonTime;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCallWeblingsSummonSettings) == 0x000008, "Wrong alignment on FCallWeblingsSummonSettings");
static_assert(sizeof(FCallWeblingsSummonSettings) == 0x000020, "Wrong size on FCallWeblingsSummonSettings");
static_assert(offsetof(FCallWeblingsSummonSettings, HPPercentPerPhase) == 0x000000, "Member 'FCallWeblingsSummonSettings::HPPercentPerPhase' has a wrong offset!");
static_assert(offsetof(FCallWeblingsSummonSettings, SummonTime) == 0x000008, "Member 'FCallWeblingsSummonSettings::SummonTime' has a wrong offset!");
static_assert(offsetof(FCallWeblingsSummonSettings, LoopTime) == 0x000018, "Member 'FCallWeblingsSummonSettings::LoopTime' has a wrong offset!");

// ScriptStruct man.GlossaryItem
// 0x0050 (0x0050 - 0x0000)
struct FGlossaryItem final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSmartText                             DescriptionSmartText;                              // 0x0030(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<EAttribute>                            NameIcons;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlossaryItem) == 0x000008, "Wrong alignment on FGlossaryItem");
static_assert(sizeof(FGlossaryItem) == 0x000050, "Wrong size on FGlossaryItem");
static_assert(offsetof(FGlossaryItem, Name) == 0x000000, "Member 'FGlossaryItem::Name' has a wrong offset!");
static_assert(offsetof(FGlossaryItem, Description) == 0x000018, "Member 'FGlossaryItem::Description' has a wrong offset!");
static_assert(offsetof(FGlossaryItem, DescriptionSmartText) == 0x000030, "Member 'FGlossaryItem::DescriptionSmartText' has a wrong offset!");
static_assert(offsetof(FGlossaryItem, NameIcons) == 0x000040, "Member 'FGlossaryItem::NameIcons' has a wrong offset!");

// ScriptStruct man.SkyPlaneInfo
// 0x0028 (0x0028 - 0x0000)
struct FSkyPlaneInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkyPlaneInfo) == 0x000008, "Wrong alignment on FSkyPlaneInfo");
static_assert(sizeof(FSkyPlaneInfo) == 0x000028, "Wrong size on FSkyPlaneInfo");
static_assert(offsetof(FSkyPlaneInfo, Actor) == 0x000000, "Member 'FSkyPlaneInfo::Actor' has a wrong offset!");
static_assert(offsetof(FSkyPlaneInfo, Offset) == 0x000008, "Member 'FSkyPlaneInfo::Offset' has a wrong offset!");

// ScriptStruct man.GlossaryPage
// 0x0020 (0x0020 - 0x0000)
struct FGlossaryPage final
{
public:
	TArray<int32>                                 LeftGlossaryItemIndexes;                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RightGlossaryItemIndexes;                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlossaryPage) == 0x000008, "Wrong alignment on FGlossaryPage");
static_assert(sizeof(FGlossaryPage) == 0x000020, "Wrong size on FGlossaryPage");
static_assert(offsetof(FGlossaryPage, LeftGlossaryItemIndexes) == 0x000000, "Member 'FGlossaryPage::LeftGlossaryItemIndexes' has a wrong offset!");
static_assert(offsetof(FGlossaryPage, RightGlossaryItemIndexes) == 0x000010, "Member 'FGlossaryPage::RightGlossaryItemIndexes' has a wrong offset!");

// ScriptStruct man.KingPriestVoidDarkWallData
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidDarkWallData final
{
public:
	float                                         NextWallDelayInSec;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActorBase>                 WallBP;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidDarkWallData) == 0x000008, "Wrong alignment on FKingPriestVoidDarkWallData");
static_assert(sizeof(FKingPriestVoidDarkWallData) == 0x000010, "Wrong size on FKingPriestVoidDarkWallData");
static_assert(offsetof(FKingPriestVoidDarkWallData, NextWallDelayInSec) == 0x000000, "Member 'FKingPriestVoidDarkWallData::NextWallDelayInSec' has a wrong offset!");
static_assert(offsetof(FKingPriestVoidDarkWallData, WallBP) == 0x000008, "Member 'FKingPriestVoidDarkWallData::WallBP' has a wrong offset!");

// ScriptStruct man.KingPriestVoidDarkWallDataSequence
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidDarkWallDataSequence final
{
public:
	TArray<struct FKingPriestVoidDarkWallData>    OneSequence;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidDarkWallDataSequence) == 0x000008, "Wrong alignment on FKingPriestVoidDarkWallDataSequence");
static_assert(sizeof(FKingPriestVoidDarkWallDataSequence) == 0x000010, "Wrong size on FKingPriestVoidDarkWallDataSequence");
static_assert(offsetof(FKingPriestVoidDarkWallDataSequence, OneSequence) == 0x000000, "Member 'FKingPriestVoidDarkWallDataSequence::OneSequence' has a wrong offset!");

// ScriptStruct man.LedgeOff
// 0x001C (0x001C - 0x0000)
struct FLedgeOff final
{
public:
	float                                         inputTreshold;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         glassWallLocation;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         fallLocation;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         backwardSpeed;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         smallLedgeStepSize;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         smallLedgeSpeed;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceLedgeFall;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLedgeOff) == 0x000004, "Wrong alignment on FLedgeOff");
static_assert(sizeof(FLedgeOff) == 0x00001C, "Wrong size on FLedgeOff");
static_assert(offsetof(FLedgeOff, inputTreshold) == 0x000000, "Member 'FLedgeOff::inputTreshold' has a wrong offset!");
static_assert(offsetof(FLedgeOff, glassWallLocation) == 0x000004, "Member 'FLedgeOff::glassWallLocation' has a wrong offset!");
static_assert(offsetof(FLedgeOff, fallLocation) == 0x000008, "Member 'FLedgeOff::fallLocation' has a wrong offset!");
static_assert(offsetof(FLedgeOff, backwardSpeed) == 0x00000C, "Member 'FLedgeOff::backwardSpeed' has a wrong offset!");
static_assert(offsetof(FLedgeOff, smallLedgeStepSize) == 0x000010, "Member 'FLedgeOff::smallLedgeStepSize' has a wrong offset!");
static_assert(offsetof(FLedgeOff, smallLedgeSpeed) == 0x000014, "Member 'FLedgeOff::smallLedgeSpeed' has a wrong offset!");
static_assert(offsetof(FLedgeOff, ForceLedgeFall) == 0x000018, "Member 'FLedgeOff::ForceLedgeFall' has a wrong offset!");

// ScriptStruct man.PushedAction
// 0x0020 (0x0020 - 0x0000)
struct FPushedAction final
{
public:
	class AActor*                                 Pusher;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPushedAction) == 0x000008, "Wrong alignment on FPushedAction");
static_assert(sizeof(FPushedAction) == 0x000020, "Wrong size on FPushedAction");
static_assert(offsetof(FPushedAction, Pusher) == 0x000000, "Member 'FPushedAction::Pusher' has a wrong offset!");

// ScriptStruct man.MapOverviewLevelSecretAreaBuiltData
// 0x001C (0x001C - 0x0000)
struct FMapOverviewLevelSecretAreaBuiltData final
{
public:
	class FName                                   SecretAreaId;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GlobalRectMin;                                     // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GlobalRectMax;                                     // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapOverviewLevelSecretAreaBuiltData) == 0x000004, "Wrong alignment on FMapOverviewLevelSecretAreaBuiltData");
static_assert(sizeof(FMapOverviewLevelSecretAreaBuiltData) == 0x00001C, "Wrong size on FMapOverviewLevelSecretAreaBuiltData");
static_assert(offsetof(FMapOverviewLevelSecretAreaBuiltData, SecretAreaId) == 0x000000, "Member 'FMapOverviewLevelSecretAreaBuiltData::SecretAreaId' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSecretAreaBuiltData, LayerIndex) == 0x000008, "Member 'FMapOverviewLevelSecretAreaBuiltData::LayerIndex' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSecretAreaBuiltData, GlobalRectMin) == 0x00000C, "Member 'FMapOverviewLevelSecretAreaBuiltData::GlobalRectMin' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSecretAreaBuiltData, GlobalRectMax) == 0x000014, "Member 'FMapOverviewLevelSecretAreaBuiltData::GlobalRectMax' has a wrong offset!");

// ScriptStruct man.InsideGMAADamageData
// 0x0010 (0x0010 - 0x0000)
struct FInsideGMAADamageData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInsideGMAADamageData) == 0x000008, "Wrong alignment on FInsideGMAADamageData");
static_assert(sizeof(FInsideGMAADamageData) == 0x000010, "Wrong size on FInsideGMAADamageData");
static_assert(offsetof(FInsideGMAADamageData, Target) == 0x000000, "Member 'FInsideGMAADamageData::Target' has a wrong offset!");
static_assert(offsetof(FInsideGMAADamageData, DamageTime) == 0x000008, "Member 'FInsideGMAADamageData::DamageTime' has a wrong offset!");

// ScriptStruct man.HealValue
// 0x0008 (0x0008 - 0x0000)
struct FHealValue final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHealValue) == 0x000004, "Wrong alignment on FHealValue");
static_assert(sizeof(FHealValue) == 0x000008, "Wrong size on FHealValue");
static_assert(offsetof(FHealValue, Value) == 0x000000, "Member 'FHealValue::Value' has a wrong offset!");

// ScriptStruct man.MiniMapIconGameplayData
// 0x0050 (0x0050 - 0x0000)
struct FMiniMapIconGameplayData final
{
public:
	class FName                                   ObjectName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TypeIcon;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ExplorationGlobalTilePos;                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetPosOffset;                                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapLayerIndex;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SegmentEntryIdx;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckpointEntryIdx;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMiniMapActorComponent*                 MiniMapActorComponent;                             // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LiveExplorationGlobalTilePos;                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LiveSegmentEntryIdx;                               // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x8];                                       // 0x0044(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EMiniMapGatewaySide                           GatewaySide;                                       // 0x004C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniMapGatewayState                          GatewayState;                                      // 0x004D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapIconGameplayData) == 0x000008, "Wrong alignment on FMiniMapIconGameplayData");
static_assert(sizeof(FMiniMapIconGameplayData) == 0x000050, "Wrong size on FMiniMapIconGameplayData");
static_assert(offsetof(FMiniMapIconGameplayData, ObjectName) == 0x000000, "Member 'FMiniMapIconGameplayData::ObjectName' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, TypeIcon) == 0x000008, "Member 'FMiniMapIconGameplayData::TypeIcon' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, ExplorationGlobalTilePos) == 0x000010, "Member 'FMiniMapIconGameplayData::ExplorationGlobalTilePos' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, WidgetPosOffset) == 0x000018, "Member 'FMiniMapIconGameplayData::WidgetPosOffset' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, MapLayerIndex) == 0x000020, "Member 'FMiniMapIconGameplayData::MapLayerIndex' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, SegmentEntryIdx) == 0x000024, "Member 'FMiniMapIconGameplayData::SegmentEntryIdx' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, CheckpointEntryIdx) == 0x000028, "Member 'FMiniMapIconGameplayData::CheckpointEntryIdx' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, MiniMapActorComponent) == 0x000030, "Member 'FMiniMapIconGameplayData::MiniMapActorComponent' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, LiveExplorationGlobalTilePos) == 0x000038, "Member 'FMiniMapIconGameplayData::LiveExplorationGlobalTilePos' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, LiveSegmentEntryIdx) == 0x000040, "Member 'FMiniMapIconGameplayData::LiveSegmentEntryIdx' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, GatewaySide) == 0x00004C, "Member 'FMiniMapIconGameplayData::GatewaySide' has a wrong offset!");
static_assert(offsetof(FMiniMapIconGameplayData, GatewayState) == 0x00004D, "Member 'FMiniMapIconGameplayData::GatewayState' has a wrong offset!");

// ScriptStruct man.SavedMapExplorationGridTileOverride
// 0x000C (0x000C - 0x0000)
struct FSavedMapExplorationGridTileOverride final
{
public:
	struct FIntPoint                              GlobalTilePos;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               TopEdge;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               RightEdge;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               BottomEdge;                                        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeOverride               LeftEdge;                                          // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedMapExplorationGridTileOverride) == 0x000004, "Wrong alignment on FSavedMapExplorationGridTileOverride");
static_assert(sizeof(FSavedMapExplorationGridTileOverride) == 0x00000C, "Wrong size on FSavedMapExplorationGridTileOverride");
static_assert(offsetof(FSavedMapExplorationGridTileOverride, GlobalTilePos) == 0x000000, "Member 'FSavedMapExplorationGridTileOverride::GlobalTilePos' has a wrong offset!");
static_assert(offsetof(FSavedMapExplorationGridTileOverride, TopEdge) == 0x000008, "Member 'FSavedMapExplorationGridTileOverride::TopEdge' has a wrong offset!");
static_assert(offsetof(FSavedMapExplorationGridTileOverride, RightEdge) == 0x000009, "Member 'FSavedMapExplorationGridTileOverride::RightEdge' has a wrong offset!");
static_assert(offsetof(FSavedMapExplorationGridTileOverride, BottomEdge) == 0x00000A, "Member 'FSavedMapExplorationGridTileOverride::BottomEdge' has a wrong offset!");
static_assert(offsetof(FSavedMapExplorationGridTileOverride, LeftEdge) == 0x00000B, "Member 'FSavedMapExplorationGridTileOverride::LeftEdge' has a wrong offset!");

// ScriptStruct man.SavedMapSegmentData
// 0x0070 (0x0070 - 0x0000)
struct FSavedMapSegmentData final
{
public:
	class UMapSegmentVolumeID*                    MapSegmentID;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSegmentUnlocked;                                  // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              MapExplorationGridGlobalPos;                       // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              MapExplorationGridSize;                            // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMiniMapIconGameplayData>       TrackedObjects;                                    // 0x0020(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSavedMapExplorationGridTileOverride> MapExplorationGridTileOverrides;                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ArrayIndx;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedMapSegmentData) == 0x000008, "Wrong alignment on FSavedMapSegmentData");
static_assert(sizeof(FSavedMapSegmentData) == 0x000070, "Wrong size on FSavedMapSegmentData");
static_assert(offsetof(FSavedMapSegmentData, MapSegmentID) == 0x000000, "Member 'FSavedMapSegmentData::MapSegmentID' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, bSegmentUnlocked) == 0x000008, "Member 'FSavedMapSegmentData::bSegmentUnlocked' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, MapExplorationGridGlobalPos) == 0x00000C, "Member 'FSavedMapSegmentData::MapExplorationGridGlobalPos' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, MapExplorationGridSize) == 0x000014, "Member 'FSavedMapSegmentData::MapExplorationGridSize' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, TrackedObjects) == 0x000020, "Member 'FSavedMapSegmentData::TrackedObjects' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, MapExplorationGridTileOverrides) == 0x000030, "Member 'FSavedMapSegmentData::MapExplorationGridTileOverrides' has a wrong offset!");
static_assert(offsetof(FSavedMapSegmentData, ArrayIndx) == 0x000068, "Member 'FSavedMapSegmentData::ArrayIndx' has a wrong offset!");

// ScriptStruct man.AbilitySlotIndexPair
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAbilitySlotIndexPair final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilitySlotIndexPair) == 0x000004, "Wrong alignment on FAbilitySlotIndexPair");
static_assert(sizeof(FAbilitySlotIndexPair) == 0x000008, "Wrong size on FAbilitySlotIndexPair");

// ScriptStruct man.UnlockedAbilityData
// 0x0020 (0x0020 - 0x0000)
struct FUnlockedAbilityData final
{
public:
	TSubclassOf<class UAbilityBase>               UnlockedAbility;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           UnlockedAbilityModifiers;                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAbilityLocked;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewAbility;                                       // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockedAbilityData) == 0x000008, "Wrong alignment on FUnlockedAbilityData");
static_assert(sizeof(FUnlockedAbilityData) == 0x000020, "Wrong size on FUnlockedAbilityData");
static_assert(offsetof(FUnlockedAbilityData, UnlockedAbility) == 0x000000, "Member 'FUnlockedAbilityData::UnlockedAbility' has a wrong offset!");
static_assert(offsetof(FUnlockedAbilityData, UnlockedAbilityModifiers) == 0x000008, "Member 'FUnlockedAbilityData::UnlockedAbilityModifiers' has a wrong offset!");
static_assert(offsetof(FUnlockedAbilityData, bAbilityLocked) == 0x000018, "Member 'FUnlockedAbilityData::bAbilityLocked' has a wrong offset!");
static_assert(offsetof(FUnlockedAbilityData, bNewAbility) == 0x000019, "Member 'FUnlockedAbilityData::bNewAbility' has a wrong offset!");

// ScriptStruct man.HeroAbilitySlot
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHeroAbilitySlot final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroAbilitySlot) == 0x000008, "Wrong alignment on FHeroAbilitySlot");
static_assert(sizeof(FHeroAbilitySlot) == 0x000028, "Wrong size on FHeroAbilitySlot");

// ScriptStruct man.CharSlowVolData
// 0x0010 (0x0010 - 0x0000)
struct FCharSlowVolData final
{
public:
	TWeakObjectPtr<class ACharacterBase>          Character;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowRate;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionLocked;                                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharSlowVolData) == 0x000004, "Wrong alignment on FCharSlowVolData");
static_assert(sizeof(FCharSlowVolData) == 0x000010, "Wrong size on FCharSlowVolData");
static_assert(offsetof(FCharSlowVolData, Character) == 0x000000, "Member 'FCharSlowVolData::Character' has a wrong offset!");
static_assert(offsetof(FCharSlowVolData, SlowRate) == 0x000008, "Member 'FCharSlowVolData::SlowRate' has a wrong offset!");
static_assert(offsetof(FCharSlowVolData, bActionLocked) == 0x00000C, "Member 'FCharSlowVolData::bActionLocked' has a wrong offset!");

// ScriptStruct man.HeroInputRestricts
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FHeroInputRestricts final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroInputRestricts) == 0x000008, "Wrong alignment on FHeroInputRestricts");
static_assert(sizeof(FHeroInputRestricts) == 0x000028, "Wrong size on FHeroInputRestricts");

// ScriptStruct man.ScreenSideEffectElement
// 0x0010 (0x0010 - 0x0000)
struct FScreenSideEffectElement final
{
public:
	EScreenSideEffect                             EffectType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Source;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenSideEffectElement) == 0x000008, "Wrong alignment on FScreenSideEffectElement");
static_assert(sizeof(FScreenSideEffectElement) == 0x000010, "Wrong size on FScreenSideEffectElement");
static_assert(offsetof(FScreenSideEffectElement, EffectType) == 0x000000, "Member 'FScreenSideEffectElement::EffectType' has a wrong offset!");
static_assert(offsetof(FScreenSideEffectElement, EffectTime) == 0x000004, "Member 'FScreenSideEffectElement::EffectTime' has a wrong offset!");
static_assert(offsetof(FScreenSideEffectElement, Source) == 0x000008, "Member 'FScreenSideEffectElement::Source' has a wrong offset!");

// ScriptStruct man.ImpactVolumeFromDefendPercentage
// 0x0008 (0x0008 - 0x0000)
struct FImpactVolumeFromDefendPercentage final
{
public:
	float                                         VolumeMultiplier;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefendPercentage;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactVolumeFromDefendPercentage) == 0x000004, "Wrong alignment on FImpactVolumeFromDefendPercentage");
static_assert(sizeof(FImpactVolumeFromDefendPercentage) == 0x000008, "Wrong size on FImpactVolumeFromDefendPercentage");
static_assert(offsetof(FImpactVolumeFromDefendPercentage, VolumeMultiplier) == 0x000000, "Member 'FImpactVolumeFromDefendPercentage::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(FImpactVolumeFromDefendPercentage, DefendPercentage) == 0x000004, "Member 'FImpactVolumeFromDefendPercentage::DefendPercentage' has a wrong offset!");

// ScriptStruct man.MultiTypeProjectileElement
// 0x0010 (0x0010 - 0x0000)
struct FMultiTypeProjectileElement final
{
public:
	TSubclassOf<class AManProjectile>             Projectile;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollWeight;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiTypeProjectileElement) == 0x000008, "Wrong alignment on FMultiTypeProjectileElement");
static_assert(sizeof(FMultiTypeProjectileElement) == 0x000010, "Wrong size on FMultiTypeProjectileElement");
static_assert(offsetof(FMultiTypeProjectileElement, Projectile) == 0x000000, "Member 'FMultiTypeProjectileElement::Projectile' has a wrong offset!");
static_assert(offsetof(FMultiTypeProjectileElement, RollWeight) == 0x000008, "Member 'FMultiTypeProjectileElement::RollWeight' has a wrong offset!");

// ScriptStruct man.BestiaryAttribute
// 0x0048 (0x0048 - 0x0000)
struct FBestiaryAttribute final
{
public:
	float                                         HealthMin;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthMax;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorMin;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorMax;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoiseMin;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoiseMax;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBestiaryResistance>            Resistances;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAttribute>                            Immunities;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ImmunitiesName;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryAttribute) == 0x000008, "Wrong alignment on FBestiaryAttribute");
static_assert(sizeof(FBestiaryAttribute) == 0x000048, "Wrong size on FBestiaryAttribute");
static_assert(offsetof(FBestiaryAttribute, HealthMin) == 0x000000, "Member 'FBestiaryAttribute::HealthMin' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, HealthMax) == 0x000004, "Member 'FBestiaryAttribute::HealthMax' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, ArmorMin) == 0x000008, "Member 'FBestiaryAttribute::ArmorMin' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, ArmorMax) == 0x00000C, "Member 'FBestiaryAttribute::ArmorMax' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, PoiseMin) == 0x000010, "Member 'FBestiaryAttribute::PoiseMin' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, PoiseMax) == 0x000014, "Member 'FBestiaryAttribute::PoiseMax' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, Resistances) == 0x000018, "Member 'FBestiaryAttribute::Resistances' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, Immunities) == 0x000028, "Member 'FBestiaryAttribute::Immunities' has a wrong offset!");
static_assert(offsetof(FBestiaryAttribute, ImmunitiesName) == 0x000038, "Member 'FBestiaryAttribute::ImmunitiesName' has a wrong offset!");

// ScriptStruct man.BestiaryExtraEffect
// 0x0018 (0x0018 - 0x0000)
struct FBestiaryExtraEffect final
{
public:
	class FText                                   ExtraEffectName;                                   // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryExtraEffect) == 0x000008, "Wrong alignment on FBestiaryExtraEffect");
static_assert(sizeof(FBestiaryExtraEffect) == 0x000018, "Wrong size on FBestiaryExtraEffect");
static_assert(offsetof(FBestiaryExtraEffect, ExtraEffectName) == 0x000000, "Member 'FBestiaryExtraEffect::ExtraEffectName' has a wrong offset!");

// ScriptStruct man.BestiaryOffense
// 0x0020 (0x0020 - 0x0000)
struct FBestiaryOffense final
{
public:
	TArray<struct FBestiaryDamageType>            DamageTypes;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBestiaryExtraEffect>           ExtraEffects;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryOffense) == 0x000008, "Wrong alignment on FBestiaryOffense");
static_assert(sizeof(FBestiaryOffense) == 0x000020, "Wrong size on FBestiaryOffense");
static_assert(offsetof(FBestiaryOffense, DamageTypes) == 0x000000, "Member 'FBestiaryOffense::DamageTypes' has a wrong offset!");
static_assert(offsetof(FBestiaryOffense, ExtraEffects) == 0x000010, "Member 'FBestiaryOffense::ExtraEffects' has a wrong offset!");

// ScriptStruct man.BestiaryItemDrop
// 0x0028 (0x0028 - 0x0000)
struct FBestiaryItemDrop final
{
public:
	float                                         GoldMin;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoldMax;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EssenceMin;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EssenceMax;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntropicEssenceMin;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntropicEssenceMax;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Items;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryItemDrop) == 0x000008, "Wrong alignment on FBestiaryItemDrop");
static_assert(sizeof(FBestiaryItemDrop) == 0x000028, "Wrong size on FBestiaryItemDrop");
static_assert(offsetof(FBestiaryItemDrop, GoldMin) == 0x000000, "Member 'FBestiaryItemDrop::GoldMin' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, GoldMax) == 0x000004, "Member 'FBestiaryItemDrop::GoldMax' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, EssenceMin) == 0x000008, "Member 'FBestiaryItemDrop::EssenceMin' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, EssenceMax) == 0x00000C, "Member 'FBestiaryItemDrop::EssenceMax' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, EntropicEssenceMin) == 0x000010, "Member 'FBestiaryItemDrop::EntropicEssenceMin' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, EntropicEssenceMax) == 0x000014, "Member 'FBestiaryItemDrop::EntropicEssenceMax' has a wrong offset!");
static_assert(offsetof(FBestiaryItemDrop, Items) == 0x000018, "Member 'FBestiaryItemDrop::Items' has a wrong offset!");

// ScriptStruct man.BestiaryItem
// 0x0148 (0x0148 - 0x0000)
struct FBestiaryItem final
{
public:
	TSoftClassPtr<class UClass>                   Class;                                             // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           EntropicShadesClasses;                             // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ComplementaryClasses;                              // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EBestiaryCategory                             Category;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Picture;                                           // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBestiaryAttribute                     attribute;                                         // 0x00A8(0x0048)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FBestiaryOffense                       Offense;                                           // 0x00F0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FBestiaryItemDrop                      ItemDrop;                                          // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	int32                                         Section1KillRequirement;                           // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Section2KillRequirement;                           // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Section3KillRequirement;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBestiaryItem) == 0x000008, "Wrong alignment on FBestiaryItem");
static_assert(sizeof(FBestiaryItem) == 0x000148, "Wrong size on FBestiaryItem");
static_assert(offsetof(FBestiaryItem, Class) == 0x000000, "Member 'FBestiaryItem::Class' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, EntropicShadesClasses) == 0x000028, "Member 'FBestiaryItem::EntropicShadesClasses' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, ComplementaryClasses) == 0x000038, "Member 'FBestiaryItem::ComplementaryClasses' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Category) == 0x000048, "Member 'FBestiaryItem::Category' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Name) == 0x000050, "Member 'FBestiaryItem::Name' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Description) == 0x000068, "Member 'FBestiaryItem::Description' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Picture) == 0x000080, "Member 'FBestiaryItem::Picture' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, attribute) == 0x0000A8, "Member 'FBestiaryItem::attribute' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Offense) == 0x0000F0, "Member 'FBestiaryItem::Offense' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, ItemDrop) == 0x000110, "Member 'FBestiaryItem::ItemDrop' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Section1KillRequirement) == 0x000138, "Member 'FBestiaryItem::Section1KillRequirement' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Section2KillRequirement) == 0x00013C, "Member 'FBestiaryItem::Section2KillRequirement' has a wrong offset!");
static_assert(offsetof(FBestiaryItem, Section3KillRequirement) == 0x000140, "Member 'FBestiaryItem::Section3KillRequirement' has a wrong offset!");

// ScriptStruct man.TempHeroTeleportStructToTriggerUnrealHeaderTool
// 0x0001 (0x0001 - 0x0000)
struct FTempHeroTeleportStructToTriggerUnrealHeaderTool final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTempHeroTeleportStructToTriggerUnrealHeaderTool) == 0x000001, "Wrong alignment on FTempHeroTeleportStructToTriggerUnrealHeaderTool");
static_assert(sizeof(FTempHeroTeleportStructToTriggerUnrealHeaderTool) == 0x000001, "Wrong size on FTempHeroTeleportStructToTriggerUnrealHeaderTool");

// ScriptStruct man.GamepadHotkey
// 0x0020 (0x0020 - 0x0000)
struct FGamepadHotkey final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadHotkey) == 0x000008, "Wrong alignment on FGamepadHotkey");
static_assert(sizeof(FGamepadHotkey) == 0x000020, "Wrong size on FGamepadHotkey");
static_assert(offsetof(FGamepadHotkey, ActionName) == 0x000000, "Member 'FGamepadHotkey::ActionName' has a wrong offset!");
static_assert(offsetof(FGamepadHotkey, Key) == 0x000008, "Member 'FGamepadHotkey::Key' has a wrong offset!");

// ScriptStruct man.GamepadPreset
// 0x0028 (0x0028 - 0x0000)
struct FGamepadPreset final
{
public:
	class FText                                   PresetName;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGamepadHotkey>                 Keys;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadPreset) == 0x000008, "Wrong alignment on FGamepadPreset");
static_assert(sizeof(FGamepadPreset) == 0x000028, "Wrong size on FGamepadPreset");
static_assert(offsetof(FGamepadPreset, PresetName) == 0x000000, "Member 'FGamepadPreset::PresetName' has a wrong offset!");
static_assert(offsetof(FGamepadPreset, Keys) == 0x000018, "Member 'FGamepadPreset::Keys' has a wrong offset!");

// ScriptStruct man.MiniMapElementStateData
// 0x0010 (0x0010 - 0x0000)
struct FMiniMapElementStateData final
{
public:
	EMiniMapActorState                            State;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             StateIcon;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniMapElementStateData) == 0x000008, "Wrong alignment on FMiniMapElementStateData");
static_assert(sizeof(FMiniMapElementStateData) == 0x000010, "Wrong size on FMiniMapElementStateData");
static_assert(offsetof(FMiniMapElementStateData, State) == 0x000000, "Member 'FMiniMapElementStateData::State' has a wrong offset!");
static_assert(offsetof(FMiniMapElementStateData, StateIcon) == 0x000008, "Member 'FMiniMapElementStateData::StateIcon' has a wrong offset!");

// ScriptStruct man.MiniMapElementData
// 0x0038 (0x0038 - 0x0000)
struct FMiniMapElementData final
{
public:
	class FName                                   EditorListDisplayName;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Actors;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bApplyToSubclasses;                                // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMiniMapElementStateData>       StateData;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredVendorLevel;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVisibility;                                    // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapElementData) == 0x000008, "Wrong alignment on FMiniMapElementData");
static_assert(sizeof(FMiniMapElementData) == 0x000038, "Wrong size on FMiniMapElementData");
static_assert(offsetof(FMiniMapElementData, EditorListDisplayName) == 0x000000, "Member 'FMiniMapElementData::EditorListDisplayName' has a wrong offset!");
static_assert(offsetof(FMiniMapElementData, Actors) == 0x000008, "Member 'FMiniMapElementData::Actors' has a wrong offset!");
static_assert(offsetof(FMiniMapElementData, bApplyToSubclasses) == 0x000018, "Member 'FMiniMapElementData::bApplyToSubclasses' has a wrong offset!");
static_assert(offsetof(FMiniMapElementData, StateData) == 0x000020, "Member 'FMiniMapElementData::StateData' has a wrong offset!");
static_assert(offsetof(FMiniMapElementData, RequiredVendorLevel) == 0x000030, "Member 'FMiniMapElementData::RequiredVendorLevel' has a wrong offset!");
static_assert(offsetof(FMiniMapElementData, bUseVisibility) == 0x000034, "Member 'FMiniMapElementData::bUseVisibility' has a wrong offset!");

// ScriptStruct man.KeyboardHotkeyData
// 0x0080 (0x0080 - 0x0000)
struct FKeyboardHotkeyData final
{
public:
	TArray<struct FKey>                           Keys;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   KeyboardUniqueName;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              KeyboardImage;                                     // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HoldKeyboardImage;                                 // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyboardHotkeyData) == 0x000008, "Wrong alignment on FKeyboardHotkeyData");
static_assert(sizeof(FKeyboardHotkeyData) == 0x000080, "Wrong size on FKeyboardHotkeyData");
static_assert(offsetof(FKeyboardHotkeyData, Keys) == 0x000000, "Member 'FKeyboardHotkeyData::Keys' has a wrong offset!");
static_assert(offsetof(FKeyboardHotkeyData, DisplayName) == 0x000010, "Member 'FKeyboardHotkeyData::DisplayName' has a wrong offset!");
static_assert(offsetof(FKeyboardHotkeyData, KeyboardUniqueName) == 0x000028, "Member 'FKeyboardHotkeyData::KeyboardUniqueName' has a wrong offset!");
static_assert(offsetof(FKeyboardHotkeyData, KeyboardImage) == 0x000030, "Member 'FKeyboardHotkeyData::KeyboardImage' has a wrong offset!");
static_assert(offsetof(FKeyboardHotkeyData, HoldKeyboardImage) == 0x000058, "Member 'FKeyboardHotkeyData::HoldKeyboardImage' has a wrong offset!");

// ScriptStruct man.MarionetteDollsOrderData
// 0x0010 (0x0010 - 0x0000)
struct FMarionetteDollsOrderData final
{
public:
	float                                         NextDollHPThreshold;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEnemyCharacter>            MarionetteDoll;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarionetteDollsOrderData) == 0x000008, "Wrong alignment on FMarionetteDollsOrderData");
static_assert(sizeof(FMarionetteDollsOrderData) == 0x000010, "Wrong size on FMarionetteDollsOrderData");
static_assert(offsetof(FMarionetteDollsOrderData, NextDollHPThreshold) == 0x000000, "Member 'FMarionetteDollsOrderData::NextDollHPThreshold' has a wrong offset!");
static_assert(offsetof(FMarionetteDollsOrderData, MarionetteDoll) == 0x000008, "Member 'FMarionetteDollsOrderData::MarionetteDoll' has a wrong offset!");

// ScriptStruct man.GamepadHotkeyData
// 0x0118 (0x0118 - 0x0000)
struct FGamepadHotkeyData final
{
public:
	TArray<struct FKey>                           Keys;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   XboxSeriesUniqueName;                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              XboxSeriesXImage;                                  // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HoldXboxSeriesXImage;                              // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PS5UniqueName;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PS5Image;                                          // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HoldPS5Image;                                      // 0x0098(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchUniqueName;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SwitchImage;                                       // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HoldSwitchImage;                                   // 0x00F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadHotkeyData) == 0x000008, "Wrong alignment on FGamepadHotkeyData");
static_assert(sizeof(FGamepadHotkeyData) == 0x000118, "Wrong size on FGamepadHotkeyData");
static_assert(offsetof(FGamepadHotkeyData, Keys) == 0x000000, "Member 'FGamepadHotkeyData::Keys' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, XboxSeriesUniqueName) == 0x000010, "Member 'FGamepadHotkeyData::XboxSeriesUniqueName' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, XboxSeriesXImage) == 0x000018, "Member 'FGamepadHotkeyData::XboxSeriesXImage' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, HoldXboxSeriesXImage) == 0x000040, "Member 'FGamepadHotkeyData::HoldXboxSeriesXImage' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, PS5UniqueName) == 0x000068, "Member 'FGamepadHotkeyData::PS5UniqueName' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, PS5Image) == 0x000070, "Member 'FGamepadHotkeyData::PS5Image' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, HoldPS5Image) == 0x000098, "Member 'FGamepadHotkeyData::HoldPS5Image' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, SwitchUniqueName) == 0x0000C0, "Member 'FGamepadHotkeyData::SwitchUniqueName' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, SwitchImage) == 0x0000C8, "Member 'FGamepadHotkeyData::SwitchImage' has a wrong offset!");
static_assert(offsetof(FGamepadHotkeyData, HoldSwitchImage) == 0x0000F0, "Member 'FGamepadHotkeyData::HoldSwitchImage' has a wrong offset!");

// ScriptStruct man.HotkeySetting
// 0x0050 (0x0050 - 0x0000)
struct FHotkeySetting final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActionNames;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AxisName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardLocked;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControllerLocked;                                 // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeyboardEmpty;                                    // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControllerEmpty;                                  // 0x003F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           NotAllowedUIActionNames;                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHotkeySetting) == 0x000008, "Wrong alignment on FHotkeySetting");
static_assert(sizeof(FHotkeySetting) == 0x000050, "Wrong size on FHotkeySetting");
static_assert(offsetof(FHotkeySetting, DisplayName) == 0x000000, "Member 'FHotkeySetting::DisplayName' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, ActionNames) == 0x000018, "Member 'FHotkeySetting::ActionNames' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, ActionName) == 0x000028, "Member 'FHotkeySetting::ActionName' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, AxisName) == 0x000030, "Member 'FHotkeySetting::AxisName' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, AxisScale) == 0x000038, "Member 'FHotkeySetting::AxisScale' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, bKeyboardLocked) == 0x00003C, "Member 'FHotkeySetting::bKeyboardLocked' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, bControllerLocked) == 0x00003D, "Member 'FHotkeySetting::bControllerLocked' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, bKeyboardEmpty) == 0x00003E, "Member 'FHotkeySetting::bKeyboardEmpty' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, bControllerEmpty) == 0x00003F, "Member 'FHotkeySetting::bControllerEmpty' has a wrong offset!");
static_assert(offsetof(FHotkeySetting, NotAllowedUIActionNames) == 0x000040, "Member 'FHotkeySetting::NotAllowedUIActionNames' has a wrong offset!");

// ScriptStruct man.NpcAnimSet
// 0x0018 (0x0018 - 0x0000)
struct FNpcAnimSet final
{
public:
	int32                                         IdleBridgeChance;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 IdleBridgeChances;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcAnimSet) == 0x000008, "Wrong alignment on FNpcAnimSet");
static_assert(sizeof(FNpcAnimSet) == 0x000018, "Wrong size on FNpcAnimSet");
static_assert(offsetof(FNpcAnimSet, IdleBridgeChance) == 0x000000, "Member 'FNpcAnimSet::IdleBridgeChance' has a wrong offset!");
static_assert(offsetof(FNpcAnimSet, IdleBridgeChances) == 0x000008, "Member 'FNpcAnimSet::IdleBridgeChances' has a wrong offset!");

// ScriptStruct man.RequestBarValueChange
// 0x0010 (0x0010 - 0x0000)
struct FRequestBarValueChange final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightChange;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearReservedValue;                               // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedExtraHighlight;                               // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestBarValueChange) == 0x000004, "Wrong alignment on FRequestBarValueChange");
static_assert(sizeof(FRequestBarValueChange) == 0x000010, "Wrong size on FRequestBarValueChange");
static_assert(offsetof(FRequestBarValueChange, Value) == 0x000000, "Member 'FRequestBarValueChange::Value' has a wrong offset!");
static_assert(offsetof(FRequestBarValueChange, bHighlightChange) == 0x000004, "Member 'FRequestBarValueChange::bHighlightChange' has a wrong offset!");
static_assert(offsetof(FRequestBarValueChange, bAnimate) == 0x000005, "Member 'FRequestBarValueChange::bAnimate' has a wrong offset!");
static_assert(offsetof(FRequestBarValueChange, bClearReservedValue) == 0x000006, "Member 'FRequestBarValueChange::bClearReservedValue' has a wrong offset!");
static_assert(offsetof(FRequestBarValueChange, DelayTime) == 0x000008, "Member 'FRequestBarValueChange::DelayTime' has a wrong offset!");
static_assert(offsetof(FRequestBarValueChange, bNeedExtraHighlight) == 0x00000C, "Member 'FRequestBarValueChange::bNeedExtraHighlight' has a wrong offset!");

// ScriptStruct man.AddedResourceHandler
// 0x0010 (0x0010 - 0x0000)
struct FAddedResourceHandler final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentValue;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddedValue;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowRequest;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddedResourceHandler) == 0x000004, "Wrong alignment on FAddedResourceHandler");
static_assert(sizeof(FAddedResourceHandler) == 0x000010, "Wrong size on FAddedResourceHandler");
static_assert(offsetof(FAddedResourceHandler, PropertyType) == 0x000000, "Member 'FAddedResourceHandler::PropertyType' has a wrong offset!");
static_assert(offsetof(FAddedResourceHandler, CurrentValue) == 0x000004, "Member 'FAddedResourceHandler::CurrentValue' has a wrong offset!");
static_assert(offsetof(FAddedResourceHandler, AddedValue) == 0x000008, "Member 'FAddedResourceHandler::AddedValue' has a wrong offset!");
static_assert(offsetof(FAddedResourceHandler, bShowRequest) == 0x00000C, "Member 'FAddedResourceHandler::bShowRequest' has a wrong offset!");

// ScriptStruct man.BestiaryFilterItem
// 0x0010 (0x0010 - 0x0000)
struct FBestiaryFilterItem final
{
public:
	TArray<int32>                                 ItemIndexes;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryFilterItem) == 0x000008, "Wrong alignment on FBestiaryFilterItem");
static_assert(sizeof(FBestiaryFilterItem) == 0x000010, "Wrong size on FBestiaryFilterItem");
static_assert(offsetof(FBestiaryFilterItem, ItemIndexes) == 0x000000, "Member 'FBestiaryFilterItem::ItemIndexes' has a wrong offset!");

// ScriptStruct man.BossParams
// 0x0028 (0x0028 - 0x0000)
struct FBossParams final
{
public:
	class UAttributeContainer*                    AttributeContainer;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHUDAnimatedProgressBarUserWidget*      HPProgressBarUserWidget;                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedHealth;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedBarrier;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedMaxBarrier;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedDamageReportValue;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedBarrierDamageReportValue;                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticalHit;                                      // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBossParams) == 0x000008, "Wrong alignment on FBossParams");
static_assert(sizeof(FBossParams) == 0x000028, "Wrong size on FBossParams");
static_assert(offsetof(FBossParams, AttributeContainer) == 0x000000, "Member 'FBossParams::AttributeContainer' has a wrong offset!");
static_assert(offsetof(FBossParams, HPProgressBarUserWidget) == 0x000008, "Member 'FBossParams::HPProgressBarUserWidget' has a wrong offset!");
static_assert(offsetof(FBossParams, CachedHealth) == 0x000010, "Member 'FBossParams::CachedHealth' has a wrong offset!");
static_assert(offsetof(FBossParams, CachedBarrier) == 0x000014, "Member 'FBossParams::CachedBarrier' has a wrong offset!");
static_assert(offsetof(FBossParams, CachedMaxBarrier) == 0x000018, "Member 'FBossParams::CachedMaxBarrier' has a wrong offset!");
static_assert(offsetof(FBossParams, CachedDamageReportValue) == 0x00001C, "Member 'FBossParams::CachedDamageReportValue' has a wrong offset!");
static_assert(offsetof(FBossParams, CachedBarrierDamageReportValue) == 0x000020, "Member 'FBossParams::CachedBarrierDamageReportValue' has a wrong offset!");
static_assert(offsetof(FBossParams, bCriticalHit) == 0x000024, "Member 'FBossParams::bCriticalHit' has a wrong offset!");

// ScriptStruct man.DelayedNotification
// 0x0020 (0x0020 - 0x0000)
struct FDelayedNotification final
{
public:
	class UManQuest*                              ManQuest;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UManQuestObjective*>             Objectives;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelayedNotification) == 0x000008, "Wrong alignment on FDelayedNotification");
static_assert(sizeof(FDelayedNotification) == 0x000020, "Wrong size on FDelayedNotification");
static_assert(offsetof(FDelayedNotification, ManQuest) == 0x000000, "Member 'FDelayedNotification::ManQuest' has a wrong offset!");
static_assert(offsetof(FDelayedNotification, Objectives) == 0x000008, "Member 'FDelayedNotification::Objectives' has a wrong offset!");
static_assert(offsetof(FDelayedNotification, RemainingTime) == 0x000018, "Member 'FDelayedNotification::RemainingTime' has a wrong offset!");

// ScriptStruct man.HUDPopupQueue
// 0x0058 (0x0058 - 0x0000)
struct FHUDPopupQueue final
{
public:
	EWidgetsZorder                                WidgetsZorder;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timeout;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuest*                              ManQuest;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManQuestObjective*                     ManQuestObject;                                    // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVendorType                                   VendorType;                                        // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialMovementType                          SpecialMovementType;                               // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDPopupType                                 HUDPopupType;                                      // 0x0052(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCounterText;                                  // 0x0053(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDPopupQueue) == 0x000008, "Wrong alignment on FHUDPopupQueue");
static_assert(sizeof(FHUDPopupQueue) == 0x000058, "Wrong size on FHUDPopupQueue");
static_assert(offsetof(FHUDPopupQueue, WidgetsZorder) == 0x000000, "Member 'FHUDPopupQueue::WidgetsZorder' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, Timeout) == 0x000004, "Member 'FHUDPopupQueue::Timeout' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, Title) == 0x000008, "Member 'FHUDPopupQueue::Title' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, Name) == 0x000020, "Member 'FHUDPopupQueue::Name' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, Icon) == 0x000038, "Member 'FHUDPopupQueue::Icon' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, ManQuest) == 0x000040, "Member 'FHUDPopupQueue::ManQuest' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, ManQuestObject) == 0x000048, "Member 'FHUDPopupQueue::ManQuestObject' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, VendorType) == 0x000050, "Member 'FHUDPopupQueue::VendorType' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, SpecialMovementType) == 0x000051, "Member 'FHUDPopupQueue::SpecialMovementType' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, HUDPopupType) == 0x000052, "Member 'FHUDPopupQueue::HUDPopupType' has a wrong offset!");
static_assert(offsetof(FHUDPopupQueue, bShowCounterText) == 0x000053, "Member 'FHUDPopupQueue::bShowCounterText' has a wrong offset!");

// ScriptStruct man.CachedNotification
// 0x0058 (0x0058 - 0x0000)
struct FCachedNotification final
{
public:
	EHUDNotificationType                          HUDNotificationType;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConversationAddItemShowingRemainingTime;           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemAbility*                           ItemAbility;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedNotification) == 0x000008, "Wrong alignment on FCachedNotification");
static_assert(sizeof(FCachedNotification) == 0x000058, "Wrong size on FCachedNotification");
static_assert(offsetof(FCachedNotification, HUDNotificationType) == 0x000000, "Member 'FCachedNotification::HUDNotificationType' has a wrong offset!");
static_assert(offsetof(FCachedNotification, ItemName) == 0x000008, "Member 'FCachedNotification::ItemName' has a wrong offset!");
static_assert(offsetof(FCachedNotification, ItemDescription) == 0x000020, "Member 'FCachedNotification::ItemDescription' has a wrong offset!");
static_assert(offsetof(FCachedNotification, Icon) == 0x000038, "Member 'FCachedNotification::Icon' has a wrong offset!");
static_assert(offsetof(FCachedNotification, Timeout) == 0x000040, "Member 'FCachedNotification::Timeout' has a wrong offset!");
static_assert(offsetof(FCachedNotification, Number) == 0x000044, "Member 'FCachedNotification::Number' has a wrong offset!");
static_assert(offsetof(FCachedNotification, ConversationAddItemShowingRemainingTime) == 0x000048, "Member 'FCachedNotification::ConversationAddItemShowingRemainingTime' has a wrong offset!");
static_assert(offsetof(FCachedNotification, ItemAbility) == 0x000050, "Member 'FCachedNotification::ItemAbility' has a wrong offset!");

// ScriptStruct man.MovieSceneDialogueTemplate
// 0x0008 (0x0028 - 0x0020)
struct FMovieSceneDialogueTemplate final : public FMovieSceneEvalTemplate
{
public:
	class UMovieSceneDialogueSection*             Section;                                           // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneDialogueTemplate) == 0x000008, "Wrong alignment on FMovieSceneDialogueTemplate");
static_assert(sizeof(FMovieSceneDialogueTemplate) == 0x000028, "Wrong size on FMovieSceneDialogueTemplate");
static_assert(offsetof(FMovieSceneDialogueTemplate, Section) == 0x000020, "Member 'FMovieSceneDialogueTemplate::Section' has a wrong offset!");

// ScriptStruct man.InteractParams
// 0x0030 (0x0030 - 0x0000)
struct FInteractParams final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHasEnoughResource;                                // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractParams) == 0x000008, "Wrong alignment on FInteractParams");
static_assert(sizeof(FInteractParams) == 0x000030, "Wrong size on FInteractParams");
static_assert(offsetof(FInteractParams, Icon) == 0x000000, "Member 'FInteractParams::Icon' has a wrong offset!");
static_assert(offsetof(FInteractParams, ItemCount) == 0x000008, "Member 'FInteractParams::ItemCount' has a wrong offset!");
static_assert(offsetof(FInteractParams, ItemName) == 0x000010, "Member 'FInteractParams::ItemName' has a wrong offset!");
static_assert(offsetof(FInteractParams, bHasEnoughResource) == 0x000028, "Member 'FInteractParams::bHasEnoughResource' has a wrong offset!");

// ScriptStruct man.InquisitorAITutorialScript
// 0x0190 (0x0190 - 0x0000)
struct FInquisitorAITutorialScript final
{
public:
	int32                                         AttackCounter1;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCounterSparWithMaddick;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCounterPostOptionsMenuClosed;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestDodgeTimer;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreDodgeIdleTime;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreRollIdleTime;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostRollRequestedIdleTime;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreAttackSignWaitTime;                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialIdleTime;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightTimer1;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightTimer2;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollRequestDistance;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAbilityBase>               RequestedHeroAbility;                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAbilityBase>>       OnDamagedRequestedHeroAbility;                     // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptDodge;                                       // 0x0048(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptRoll;                                        // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptAttack;                                      // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptAttackWithaFireBolt;                         // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptAttack5time;                                 // 0x00C8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptContinueSparWithMaddick;                     // 0x00E8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTutorialPrompt                        PromptOpenMenu;                                    // 0x0108(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTutorialCastAction>            TutorialCastActions;                               // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaddickTauntCooldownMin;                           // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaddickTauntCooldownMax;                           // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KezkaTauntCooldownMin;                             // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KezkaTauntCooldownMax;                             // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     KezkaClass;                                        // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     OlenClass;                                         // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDialogueDataAsset*>             MaddickTauntLines;                                 // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueDataAsset*>             KezkaTauntLines;                                   // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueDataAsset*>             OlenTauntLines;                                    // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInquisitorAITutorialScript) == 0x000008, "Wrong alignment on FInquisitorAITutorialScript");
static_assert(sizeof(FInquisitorAITutorialScript) == 0x000190, "Wrong size on FInquisitorAITutorialScript");
static_assert(offsetof(FInquisitorAITutorialScript, AttackCounter1) == 0x000000, "Member 'FInquisitorAITutorialScript::AttackCounter1' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, HitCounterSparWithMaddick) == 0x000004, "Member 'FInquisitorAITutorialScript::HitCounterSparWithMaddick' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, HitCounterPostOptionsMenuClosed) == 0x000008, "Member 'FInquisitorAITutorialScript::HitCounterPostOptionsMenuClosed' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, RequestDodgeTimer) == 0x00000C, "Member 'FInquisitorAITutorialScript::RequestDodgeTimer' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PreDodgeIdleTime) == 0x000010, "Member 'FInquisitorAITutorialScript::PreDodgeIdleTime' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PreRollIdleTime) == 0x000014, "Member 'FInquisitorAITutorialScript::PreRollIdleTime' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PostRollRequestedIdleTime) == 0x000018, "Member 'FInquisitorAITutorialScript::PostRollRequestedIdleTime' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PreAttackSignWaitTime) == 0x00001C, "Member 'FInquisitorAITutorialScript::PreAttackSignWaitTime' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, InitialIdleTime) == 0x000020, "Member 'FInquisitorAITutorialScript::InitialIdleTime' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, FightTimer1) == 0x000024, "Member 'FInquisitorAITutorialScript::FightTimer1' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, FightTimer2) == 0x000028, "Member 'FInquisitorAITutorialScript::FightTimer2' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, RollRequestDistance) == 0x00002C, "Member 'FInquisitorAITutorialScript::RollRequestDistance' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, RequestedHeroAbility) == 0x000030, "Member 'FInquisitorAITutorialScript::RequestedHeroAbility' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, OnDamagedRequestedHeroAbility) == 0x000038, "Member 'FInquisitorAITutorialScript::OnDamagedRequestedHeroAbility' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptDodge) == 0x000048, "Member 'FInquisitorAITutorialScript::PromptDodge' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptRoll) == 0x000068, "Member 'FInquisitorAITutorialScript::PromptRoll' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptAttack) == 0x000088, "Member 'FInquisitorAITutorialScript::PromptAttack' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptAttackWithaFireBolt) == 0x0000A8, "Member 'FInquisitorAITutorialScript::PromptAttackWithaFireBolt' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptAttack5time) == 0x0000C8, "Member 'FInquisitorAITutorialScript::PromptAttack5time' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptContinueSparWithMaddick) == 0x0000E8, "Member 'FInquisitorAITutorialScript::PromptContinueSparWithMaddick' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, PromptOpenMenu) == 0x000108, "Member 'FInquisitorAITutorialScript::PromptOpenMenu' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, TutorialCastActions) == 0x000128, "Member 'FInquisitorAITutorialScript::TutorialCastActions' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, MaddickTauntCooldownMin) == 0x000140, "Member 'FInquisitorAITutorialScript::MaddickTauntCooldownMin' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, MaddickTauntCooldownMax) == 0x000144, "Member 'FInquisitorAITutorialScript::MaddickTauntCooldownMax' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, KezkaTauntCooldownMin) == 0x000148, "Member 'FInquisitorAITutorialScript::KezkaTauntCooldownMin' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, KezkaTauntCooldownMax) == 0x00014C, "Member 'FInquisitorAITutorialScript::KezkaTauntCooldownMax' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, KezkaClass) == 0x000150, "Member 'FInquisitorAITutorialScript::KezkaClass' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, OlenClass) == 0x000158, "Member 'FInquisitorAITutorialScript::OlenClass' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, MaddickTauntLines) == 0x000160, "Member 'FInquisitorAITutorialScript::MaddickTauntLines' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, KezkaTauntLines) == 0x000170, "Member 'FInquisitorAITutorialScript::KezkaTauntLines' has a wrong offset!");
static_assert(offsetof(FInquisitorAITutorialScript, OlenTauntLines) == 0x000180, "Member 'FInquisitorAITutorialScript::OlenTauntLines' has a wrong offset!");

// ScriptStruct man.TransmogItem
// 0x0010 (0x0010 - 0x0000)
struct FTransmogItem final
{
public:
	class UItemAbility*                           Item;                                              // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     ItemSlotType;                                      // 0x0008(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransmogItem) == 0x000008, "Wrong alignment on FTransmogItem");
static_assert(sizeof(FTransmogItem) == 0x000010, "Wrong size on FTransmogItem");
static_assert(offsetof(FTransmogItem, Item) == 0x000000, "Member 'FTransmogItem::Item' has a wrong offset!");
static_assert(offsetof(FTransmogItem, ItemSlotType) == 0x000008, "Member 'FTransmogItem::ItemSlotType' has a wrong offset!");

// ScriptStruct man.HasInventoryResourceResult
// 0x0001 (0x0001 - 0x0000)
struct FHasInventoryResourceResult final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHasInventoryResourceResult) == 0x000001, "Wrong alignment on FHasInventoryResourceResult");
static_assert(sizeof(FHasInventoryResourceResult) == 0x000001, "Wrong size on FHasInventoryResourceResult");

// ScriptStruct man.CraftRecipe
// 0x0030 (0x0030 - 0x0000)
struct FCraftRecipe final
{
public:
	TSubclassOf<class UItemAbility>               CraftedItem;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CraftingGoldCost;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRequiredMaterial>              RequiredMaterials;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DiagramLevel;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraftExperience;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraftExperienceReductionPerLevel;                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCraftRecipe) == 0x000008, "Wrong alignment on FCraftRecipe");
static_assert(sizeof(FCraftRecipe) == 0x000030, "Wrong size on FCraftRecipe");
static_assert(offsetof(FCraftRecipe, CraftedItem) == 0x000000, "Member 'FCraftRecipe::CraftedItem' has a wrong offset!");
static_assert(offsetof(FCraftRecipe, CraftingGoldCost) == 0x000008, "Member 'FCraftRecipe::CraftingGoldCost' has a wrong offset!");
static_assert(offsetof(FCraftRecipe, RequiredMaterials) == 0x000010, "Member 'FCraftRecipe::RequiredMaterials' has a wrong offset!");
static_assert(offsetof(FCraftRecipe, DiagramLevel) == 0x000020, "Member 'FCraftRecipe::DiagramLevel' has a wrong offset!");
static_assert(offsetof(FCraftRecipe, CraftExperience) == 0x000024, "Member 'FCraftRecipe::CraftExperience' has a wrong offset!");
static_assert(offsetof(FCraftRecipe, CraftExperienceReductionPerLevel) == 0x000028, "Member 'FCraftRecipe::CraftExperienceReductionPerLevel' has a wrong offset!");

// ScriptStruct man.Item
// 0x0048 (0x0048 - 0x0000)
struct FItem final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ItemAbility;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptySlot;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemCategory                          ItemCategory;                                      // 0x0018(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FItem) == 0x000008, "Wrong alignment on FItem");
static_assert(sizeof(FItem) == 0x000048, "Wrong size on FItem");
static_assert(offsetof(FItem, ManItemSlotBase) == 0x000000, "Member 'FItem::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(FItem, ItemAbility) == 0x000008, "Member 'FItem::ItemAbility' has a wrong offset!");
static_assert(offsetof(FItem, bEmptySlot) == 0x000010, "Member 'FItem::bEmptySlot' has a wrong offset!");
static_assert(offsetof(FItem, ItemCategory) == 0x000018, "Member 'FItem::ItemCategory' has a wrong offset!");

// ScriptStruct man.DamageTypeText
// 0x0020 (0x0020 - 0x0000)
struct FDamageTypeText final
{
public:
	EDamageType                                   DamageType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NativeText;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeText) == 0x000008, "Wrong alignment on FDamageTypeText");
static_assert(sizeof(FDamageTypeText) == 0x000020, "Wrong size on FDamageTypeText");
static_assert(offsetof(FDamageTypeText, DamageType) == 0x000000, "Member 'FDamageTypeText::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageTypeText, NativeText) == 0x000008, "Member 'FDamageTypeText::NativeText' has a wrong offset!");

// ScriptStruct man.AttributeVariableText
// 0x0058 (0x0058 - 0x0000)
struct FAttributeVariableText final
{
public:
	EAttributeVariable                            AttributeVariable;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NativeText;                                        // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AddText;                                           // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MulText;                                           // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowPercentage;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeVariableText) == 0x000008, "Wrong alignment on FAttributeVariableText");
static_assert(sizeof(FAttributeVariableText) == 0x000058, "Wrong size on FAttributeVariableText");
static_assert(offsetof(FAttributeVariableText, AttributeVariable) == 0x000000, "Member 'FAttributeVariableText::AttributeVariable' has a wrong offset!");
static_assert(offsetof(FAttributeVariableText, NativeText) == 0x000008, "Member 'FAttributeVariableText::NativeText' has a wrong offset!");
static_assert(offsetof(FAttributeVariableText, AddText) == 0x000020, "Member 'FAttributeVariableText::AddText' has a wrong offset!");
static_assert(offsetof(FAttributeVariableText, MulText) == 0x000038, "Member 'FAttributeVariableText::MulText' has a wrong offset!");
static_assert(offsetof(FAttributeVariableText, bShowPercentage) == 0x000050, "Member 'FAttributeVariableText::bShowPercentage' has a wrong offset!");

// ScriptStruct man.WeaponTypeText
// 0x0050 (0x0050 - 0x0000)
struct FWeaponTypeText final
{
public:
	EWeaponType                                   WeaponType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubItemType                                  ItemSubType;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WeaponTypeText;                                    // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   WeaponTypeText_1H;                                 // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   WeaponTypeText_2H;                                 // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTypeText) == 0x000008, "Wrong alignment on FWeaponTypeText");
static_assert(sizeof(FWeaponTypeText) == 0x000050, "Wrong size on FWeaponTypeText");
static_assert(offsetof(FWeaponTypeText, WeaponType) == 0x000000, "Member 'FWeaponTypeText::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponTypeText, ItemSubType) == 0x000001, "Member 'FWeaponTypeText::ItemSubType' has a wrong offset!");
static_assert(offsetof(FWeaponTypeText, WeaponTypeText) == 0x000008, "Member 'FWeaponTypeText::WeaponTypeText' has a wrong offset!");
static_assert(offsetof(FWeaponTypeText, WeaponTypeText_1H) == 0x000020, "Member 'FWeaponTypeText::WeaponTypeText_1H' has a wrong offset!");
static_assert(offsetof(FWeaponTypeText, WeaponTypeText_2H) == 0x000038, "Member 'FWeaponTypeText::WeaponTypeText_2H' has a wrong offset!");

// ScriptStruct man.DamageScaling
// 0x0038 (0x0038 - 0x0000)
struct FDamageScaling final
{
public:
	float                                         MaxValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DamageScaleText;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DamageScaleText2;                                  // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageScaling) == 0x000008, "Wrong alignment on FDamageScaling");
static_assert(sizeof(FDamageScaling) == 0x000038, "Wrong size on FDamageScaling");
static_assert(offsetof(FDamageScaling, MaxValue) == 0x000000, "Member 'FDamageScaling::MaxValue' has a wrong offset!");
static_assert(offsetof(FDamageScaling, DamageScaleText) == 0x000008, "Member 'FDamageScaling::DamageScaleText' has a wrong offset!");
static_assert(offsetof(FDamageScaling, DamageScaleText2) == 0x000020, "Member 'FDamageScaling::DamageScaleText2' has a wrong offset!");

// ScriptStruct man.AnimChanceNode
// 0x0010 (0x0010 - 0x0000)
struct FAnimChanceNode final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimChanceNode) == 0x000008, "Wrong alignment on FAnimChanceNode");
static_assert(sizeof(FAnimChanceNode) == 0x000010, "Wrong size on FAnimChanceNode");
static_assert(offsetof(FAnimChanceNode, AnimID) == 0x000000, "Member 'FAnimChanceNode::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimChanceNode, Chance) == 0x000008, "Member 'FAnimChanceNode::Chance' has a wrong offset!");

// ScriptStruct man.KingPriestVoidEntropicCatharsisProjectileData
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidEntropicCatharsisProjectileData final
{
public:
	TArray<struct FKingPriestVoidEntropicCatharsisProjectileDataInAWave> Wave;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidEntropicCatharsisProjectileData) == 0x000008, "Wrong alignment on FKingPriestVoidEntropicCatharsisProjectileData");
static_assert(sizeof(FKingPriestVoidEntropicCatharsisProjectileData) == 0x000010, "Wrong size on FKingPriestVoidEntropicCatharsisProjectileData");
static_assert(offsetof(FKingPriestVoidEntropicCatharsisProjectileData, Wave) == 0x000000, "Member 'FKingPriestVoidEntropicCatharsisProjectileData::Wave' has a wrong offset!");

// ScriptStruct man.KingPriestVoidAttackEntropicBeamDeltaPositionData
// 0x0010 (0x0010 - 0x0000)
struct FKingPriestVoidAttackEntropicBeamDeltaPositionData final
{
public:
	EKingPriestVoidPlatformType                   PlatformType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DeltaSpawnPositionFromPlatform;                    // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKingPriestVoidAttackEntropicBeamDeltaPositionData) == 0x000004, "Wrong alignment on FKingPriestVoidAttackEntropicBeamDeltaPositionData");
static_assert(sizeof(FKingPriestVoidAttackEntropicBeamDeltaPositionData) == 0x000010, "Wrong size on FKingPriestVoidAttackEntropicBeamDeltaPositionData");
static_assert(offsetof(FKingPriestVoidAttackEntropicBeamDeltaPositionData, PlatformType) == 0x000000, "Member 'FKingPriestVoidAttackEntropicBeamDeltaPositionData::PlatformType' has a wrong offset!");
static_assert(offsetof(FKingPriestVoidAttackEntropicBeamDeltaPositionData, DeltaSpawnPositionFromPlatform) == 0x000004, "Member 'FKingPriestVoidAttackEntropicBeamDeltaPositionData::DeltaSpawnPositionFromPlatform' has a wrong offset!");

// ScriptStruct man.LeverPullAnimData
// 0x0018 (0x0018 - 0x0000)
struct FLeverPullAnimData final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimID*                                BWAnimID;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextDistanceThreshold;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeverPullAnimData) == 0x000008, "Wrong alignment on FLeverPullAnimData");
static_assert(sizeof(FLeverPullAnimData) == 0x000018, "Wrong size on FLeverPullAnimData");
static_assert(offsetof(FLeverPullAnimData, AnimID) == 0x000000, "Member 'FLeverPullAnimData::AnimID' has a wrong offset!");
static_assert(offsetof(FLeverPullAnimData, BWAnimID) == 0x000008, "Member 'FLeverPullAnimData::BWAnimID' has a wrong offset!");
static_assert(offsetof(FLeverPullAnimData, Distance) == 0x000010, "Member 'FLeverPullAnimData::Distance' has a wrong offset!");
static_assert(offsetof(FLeverPullAnimData, NextDistanceThreshold) == 0x000014, "Member 'FLeverPullAnimData::NextDistanceThreshold' has a wrong offset!");

// ScriptStruct man.FastLearnerPattern
// 0x0018 (0x0018 - 0x0000)
struct FFastLearnerPattern final
{
public:
	bool                                          bRandomize;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFastLearnerPatternNode>        Waves;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFastLearnerPattern) == 0x000008, "Wrong alignment on FFastLearnerPattern");
static_assert(sizeof(FFastLearnerPattern) == 0x000018, "Wrong size on FFastLearnerPattern");
static_assert(offsetof(FFastLearnerPattern, bRandomize) == 0x000000, "Member 'FFastLearnerPattern::bRandomize' has a wrong offset!");
static_assert(offsetof(FFastLearnerPattern, Waves) == 0x000008, "Member 'FFastLearnerPattern::Waves' has a wrong offset!");

// ScriptStruct man.LootWave
// 0x0010 (0x0010 - 0x0000)
struct FLootWave final
{
public:
	TArray<struct FManLootData>                   LootData;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootWave) == 0x000008, "Wrong alignment on FLootWave");
static_assert(sizeof(FLootWave) == 0x000010, "Wrong size on FLootWave");
static_assert(offsetof(FLootWave, LootData) == 0x000000, "Member 'FLootWave::LootData' has a wrong offset!");

// ScriptStruct man.LootDropGroup
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FLootDropGroup final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootDropGroup) == 0x000008, "Wrong alignment on FLootDropGroup");
static_assert(sizeof(FLootDropGroup) == 0x000018, "Wrong size on FLootDropGroup");

// ScriptStruct man.LootFragmentData
// 0x0010 (0x0010 - 0x0000)
struct FLootFragmentData final
{
public:
	TSubclassOf<class ALootFragmentActor>         Fragment;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootFragmentData) == 0x000008, "Wrong alignment on FLootFragmentData");
static_assert(sizeof(FLootFragmentData) == 0x000010, "Wrong size on FLootFragmentData");
static_assert(offsetof(FLootFragmentData, Fragment) == 0x000000, "Member 'FLootFragmentData::Fragment' has a wrong offset!");
static_assert(offsetof(FLootFragmentData, Weight) == 0x000008, "Member 'FLootFragmentData::Weight' has a wrong offset!");

// ScriptStruct man.MAPerfMapNode
// 0x0040 (0x0040 - 0x0000)
struct FMAPerfMapNode final
{
public:
	class UClass*                                 Class;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorArray;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEntityHardSleepData>           HardSleepDataArray;                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMAPerfMapNode) == 0x000008, "Wrong alignment on FMAPerfMapNode");
static_assert(sizeof(FMAPerfMapNode) == 0x000040, "Wrong size on FMAPerfMapNode");
static_assert(offsetof(FMAPerfMapNode, Class) == 0x000000, "Member 'FMAPerfMapNode::Class' has a wrong offset!");
static_assert(offsetof(FMAPerfMapNode, ActorArray) == 0x000008, "Member 'FMAPerfMapNode::ActorArray' has a wrong offset!");
static_assert(offsetof(FMAPerfMapNode, HardSleepDataArray) == 0x000018, "Member 'FMAPerfMapNode::HardSleepDataArray' has a wrong offset!");

// ScriptStruct man.AreaHudItem
// 0x0010 (0x0010 - 0x0000)
struct FAreaHudItem final
{
public:
	class UMapSegmentVolumeID*                    SegmentUniqueID;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaHudItem) == 0x000008, "Wrong alignment on FAreaHudItem");
static_assert(sizeof(FAreaHudItem) == 0x000010, "Wrong size on FAreaHudItem");
static_assert(offsetof(FAreaHudItem, SegmentUniqueID) == 0x000000, "Member 'FAreaHudItem::SegmentUniqueID' has a wrong offset!");
static_assert(offsetof(FAreaHudItem, Delay) == 0x000008, "Member 'FAreaHudItem::Delay' has a wrong offset!");

// ScriptStruct man.MandragoraTendrilSettings
// 0x0030 (0x0030 - 0x0000)
struct FMandragoraTendrilSettings final
{
public:
	float                                         SummomnRandomTimeMin;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummomnRandomTimeMax;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonChance;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondChance;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacterBase*                         TendrilCharacter;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMandragoraTendrilSettings) == 0x000008, "Wrong alignment on FMandragoraTendrilSettings");
static_assert(sizeof(FMandragoraTendrilSettings) == 0x000030, "Wrong size on FMandragoraTendrilSettings");
static_assert(offsetof(FMandragoraTendrilSettings, SummomnRandomTimeMin) == 0x000000, "Member 'FMandragoraTendrilSettings::SummomnRandomTimeMin' has a wrong offset!");
static_assert(offsetof(FMandragoraTendrilSettings, SummomnRandomTimeMax) == 0x000004, "Member 'FMandragoraTendrilSettings::SummomnRandomTimeMax' has a wrong offset!");
static_assert(offsetof(FMandragoraTendrilSettings, SummonChance) == 0x000008, "Member 'FMandragoraTendrilSettings::SummonChance' has a wrong offset!");
static_assert(offsetof(FMandragoraTendrilSettings, SecondChance) == 0x00000C, "Member 'FMandragoraTendrilSettings::SecondChance' has a wrong offset!");
static_assert(offsetof(FMandragoraTendrilSettings, TendrilCharacter) == 0x000010, "Member 'FMandragoraTendrilSettings::TendrilCharacter' has a wrong offset!");

// ScriptStruct man.DOTDamageMatrixSoundNode
// 0x0050 (0x0050 - 0x0000)
struct FDOTDamageMatrixSoundNode final
{
public:
	struct FMatrixSound                           CauserSound;                                       // 0x0000(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADummyActor*                            Dummy;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDOTDamageMatrixSoundNode) == 0x000008, "Wrong alignment on FDOTDamageMatrixSoundNode");
static_assert(sizeof(FDOTDamageMatrixSoundNode) == 0x000050, "Wrong size on FDOTDamageMatrixSoundNode");
static_assert(offsetof(FDOTDamageMatrixSoundNode, CauserSound) == 0x000000, "Member 'FDOTDamageMatrixSoundNode::CauserSound' has a wrong offset!");
static_assert(offsetof(FDOTDamageMatrixSoundNode, SourceActor) == 0x000028, "Member 'FDOTDamageMatrixSoundNode::SourceActor' has a wrong offset!");
static_assert(offsetof(FDOTDamageMatrixSoundNode, TargetActor) == 0x000030, "Member 'FDOTDamageMatrixSoundNode::TargetActor' has a wrong offset!");
static_assert(offsetof(FDOTDamageMatrixSoundNode, Dummy) == 0x000038, "Member 'FDOTDamageMatrixSoundNode::Dummy' has a wrong offset!");

// ScriptStruct man.SkillTargetingSetting
// 0x004C (0x004C - 0x0000)
struct FSkillTargetingSetting final
{
public:
	bool                                          bInstantTargeting;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantTargetingMouse;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimTurnXValueMax;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTurnValueAfterTurning;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingSpeed;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingUpMax;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingDownMax;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingDefaultAngle;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickyDeadzoneAngle;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickyDeadzoneAngleDucking;                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStickyDeadzone;                                // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimTurnTresholdX;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTurnCooldown;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingControllerDeadZoneValue;                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockMouseAimingInputWhileTurning;                // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseTargetingSpeedMultiplier;                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingPointDefaultDistance;                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinMaxTargetPointDistance;                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimInputMode                                 AimInputMode;                                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillTargetingSetting) == 0x000004, "Wrong alignment on FSkillTargetingSetting");
static_assert(sizeof(FSkillTargetingSetting) == 0x00004C, "Wrong size on FSkillTargetingSetting");
static_assert(offsetof(FSkillTargetingSetting, bInstantTargeting) == 0x000000, "Member 'FSkillTargetingSetting::bInstantTargeting' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, bInstantTargetingMouse) == 0x000001, "Member 'FSkillTargetingSetting::bInstantTargetingMouse' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, AimTurnXValueMax) == 0x000004, "Member 'FSkillTargetingSetting::AimTurnXValueMax' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, AimTurnValueAfterTurning) == 0x000008, "Member 'FSkillTargetingSetting::AimTurnValueAfterTurning' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingSpeed) == 0x00000C, "Member 'FSkillTargetingSetting::TargetingSpeed' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingUpMax) == 0x000010, "Member 'FSkillTargetingSetting::TargetingUpMax' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingDownMax) == 0x000014, "Member 'FSkillTargetingSetting::TargetingDownMax' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingDefaultAngle) == 0x000018, "Member 'FSkillTargetingSetting::TargetingDefaultAngle' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, StickyDeadzoneAngle) == 0x00001C, "Member 'FSkillTargetingSetting::StickyDeadzoneAngle' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, StickyDeadzoneAngleDucking) == 0x000020, "Member 'FSkillTargetingSetting::StickyDeadzoneAngleDucking' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, bUseStickyDeadzone) == 0x000024, "Member 'FSkillTargetingSetting::bUseStickyDeadzone' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, AimTurnTresholdX) == 0x000028, "Member 'FSkillTargetingSetting::AimTurnTresholdX' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, AimTurnCooldown) == 0x00002C, "Member 'FSkillTargetingSetting::AimTurnCooldown' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingControllerDeadZoneValue) == 0x000030, "Member 'FSkillTargetingSetting::TargetingControllerDeadZoneValue' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, bBlockMouseAimingInputWhileTurning) == 0x000034, "Member 'FSkillTargetingSetting::bBlockMouseAimingInputWhileTurning' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, MouseTargetingSpeedMultiplier) == 0x000038, "Member 'FSkillTargetingSetting::MouseTargetingSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, TargetingPointDefaultDistance) == 0x00003C, "Member 'FSkillTargetingSetting::TargetingPointDefaultDistance' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, MinMaxTargetPointDistance) == 0x000040, "Member 'FSkillTargetingSetting::MinMaxTargetPointDistance' has a wrong offset!");
static_assert(offsetof(FSkillTargetingSetting, AimInputMode) == 0x000048, "Member 'FSkillTargetingSetting::AimInputMode' has a wrong offset!");

// ScriptStruct man.EntityToHardSleep
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FEntityToHardSleep final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEntityToHardSleep) == 0x000008, "Wrong alignment on FEntityToHardSleep");
static_assert(sizeof(FEntityToHardSleep) == 0x000028, "Wrong size on FEntityToHardSleep");

// ScriptStruct man.ManFloatingTextElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FManFloatingTextElement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManFloatingTextElement) == 0x000008, "Wrong alignment on FManFloatingTextElement");
static_assert(sizeof(FManFloatingTextElement) == 0x000018, "Wrong size on FManFloatingTextElement");

// ScriptStruct man.DynamicResolutionSettings
// 0x000C (0x000C - 0x0000)
struct FDynamicResolutionSettings final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameTime;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicResolutionSettings) == 0x000004, "Wrong alignment on FDynamicResolutionSettings");
static_assert(sizeof(FDynamicResolutionSettings) == 0x00000C, "Wrong size on FDynamicResolutionSettings");
static_assert(offsetof(FDynamicResolutionSettings, Min) == 0x000000, "Member 'FDynamicResolutionSettings::Min' has a wrong offset!");
static_assert(offsetof(FDynamicResolutionSettings, Max) == 0x000004, "Member 'FDynamicResolutionSettings::Max' has a wrong offset!");
static_assert(offsetof(FDynamicResolutionSettings, FrameTime) == 0x000008, "Member 'FDynamicResolutionSettings::FrameTime' has a wrong offset!");

// ScriptStruct man.ManMap
// 0x0020 (0x0020 - 0x0000)
struct FManMap final
{
public:
	class FName                                   DisplayName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Map;                                               // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManMap) == 0x000008, "Wrong alignment on FManMap");
static_assert(sizeof(FManMap) == 0x000020, "Wrong size on FManMap");
static_assert(offsetof(FManMap, DisplayName) == 0x000000, "Member 'FManMap::DisplayName' has a wrong offset!");
static_assert(offsetof(FManMap, Map) == 0x000008, "Member 'FManMap::Map' has a wrong offset!");

// ScriptStruct man.TextAndStoryParams
// 0x0038 (0x0038 - 0x0000)
struct FTextAndStoryParams final
{
public:
	class FString                                 StoryArgumentName;                                 // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextArgumentName;                                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuantisedItemAbility>          QuantisedItemAbility;                              // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextAndStoryParams) == 0x000008, "Wrong alignment on FTextAndStoryParams");
static_assert(sizeof(FTextAndStoryParams) == 0x000038, "Wrong size on FTextAndStoryParams");
static_assert(offsetof(FTextAndStoryParams, StoryArgumentName) == 0x000000, "Member 'FTextAndStoryParams::StoryArgumentName' has a wrong offset!");
static_assert(offsetof(FTextAndStoryParams, TextArgumentName) == 0x000010, "Member 'FTextAndStoryParams::TextArgumentName' has a wrong offset!");
static_assert(offsetof(FTextAndStoryParams, Number) == 0x000020, "Member 'FTextAndStoryParams::Number' has a wrong offset!");
static_assert(offsetof(FTextAndStoryParams, QuantisedItemAbility) == 0x000028, "Member 'FTextAndStoryParams::QuantisedItemAbility' has a wrong offset!");

// ScriptStruct man.QuestMarker
// 0x0010 (0x0010 - 0x0000)
struct FQuestMarker final
{
public:
	EMapQuestObjectiveType                        MapQuestObjectiveType;                             // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapLayerIndex;                                     // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GlobalTilePos;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestMarker) == 0x000004, "Wrong alignment on FQuestMarker");
static_assert(sizeof(FQuestMarker) == 0x000010, "Wrong size on FQuestMarker");
static_assert(offsetof(FQuestMarker, MapQuestObjectiveType) == 0x000000, "Member 'FQuestMarker::MapQuestObjectiveType' has a wrong offset!");
static_assert(offsetof(FQuestMarker, MapLayerIndex) == 0x000004, "Member 'FQuestMarker::MapLayerIndex' has a wrong offset!");
static_assert(offsetof(FQuestMarker, GlobalTilePos) == 0x000008, "Member 'FQuestMarker::GlobalTilePos' has a wrong offset!");

// ScriptStruct man.QuestEventData
// 0x0028 (0x0028 - 0x0000)
struct FQuestEventData final
{
public:
	EQuestEvent                                   EventType;                                         // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemAbility*                           ItemAbility;                                       // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemStack;                                         // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GlobalVariableName;                                // 0x001C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestEventData) == 0x000008, "Wrong alignment on FQuestEventData");
static_assert(sizeof(FQuestEventData) == 0x000028, "Wrong size on FQuestEventData");
static_assert(offsetof(FQuestEventData, EventType) == 0x000000, "Member 'FQuestEventData::EventType' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Actor) == 0x000008, "Member 'FQuestEventData::Actor' has a wrong offset!");
static_assert(offsetof(FQuestEventData, ItemAbility) == 0x000010, "Member 'FQuestEventData::ItemAbility' has a wrong offset!");
static_assert(offsetof(FQuestEventData, ItemStack) == 0x000018, "Member 'FQuestEventData::ItemStack' has a wrong offset!");
static_assert(offsetof(FQuestEventData, GlobalVariableName) == 0x00001C, "Member 'FQuestEventData::GlobalVariableName' has a wrong offset!");

// ScriptStruct man.ManSavePackage
// 0x0038 (0x0038 - 0x0000)
struct FManSavePackage final
{
public:
	TArray<uint8>                                 ArchiveBuffer;                                     // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         SerializedNames;                                   // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 WorldName;                                         // 0x0020(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESavePackageType                              PackageType;                                       // 0x0030(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManSavePackage) == 0x000008, "Wrong alignment on FManSavePackage");
static_assert(sizeof(FManSavePackage) == 0x000038, "Wrong size on FManSavePackage");
static_assert(offsetof(FManSavePackage, ArchiveBuffer) == 0x000000, "Member 'FManSavePackage::ArchiveBuffer' has a wrong offset!");
static_assert(offsetof(FManSavePackage, SerializedNames) == 0x000010, "Member 'FManSavePackage::SerializedNames' has a wrong offset!");
static_assert(offsetof(FManSavePackage, WorldName) == 0x000020, "Member 'FManSavePackage::WorldName' has a wrong offset!");
static_assert(offsetof(FManSavePackage, PackageType) == 0x000030, "Member 'FManSavePackage::PackageType' has a wrong offset!");

// ScriptStruct man.ManActorSaveHeader
// 0x0070 (0x0070 - 0x0000)
struct FManActorSaveHeader final
{
public:
	class UClass*                                 Class;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OwnerName;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LevelIndex;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectSerializeUnique;                             // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnerUnique;                                       // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorType;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManActorSaveHeader) == 0x000010, "Wrong alignment on FManActorSaveHeader");
static_assert(sizeof(FManActorSaveHeader) == 0x000070, "Wrong size on FManActorSaveHeader");
static_assert(offsetof(FManActorSaveHeader, Class) == 0x000000, "Member 'FManActorSaveHeader::Class' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, Name) == 0x000008, "Member 'FManActorSaveHeader::Name' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, OwnerName) == 0x000010, "Member 'FManActorSaveHeader::OwnerName' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, Transform) == 0x000020, "Member 'FManActorSaveHeader::Transform' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, LevelIndex) == 0x000050, "Member 'FManActorSaveHeader::LevelIndex' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, ObjectSerializeUnique) == 0x000054, "Member 'FManActorSaveHeader::ObjectSerializeUnique' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, OwnerUnique) == 0x000058, "Member 'FManActorSaveHeader::OwnerUnique' has a wrong offset!");
static_assert(offsetof(FManActorSaveHeader, ActorType) == 0x00005C, "Member 'FManActorSaveHeader::ActorType' has a wrong offset!");

// ScriptStruct man.ManShaderCacheGenerator_LevelTeleportData
// 0x0058 (0x0058 - 0x0000)
struct FManShaderCacheGenerator_LevelTeleportData final
{
public:
	TSoftObjectPtr<class UWorld>                  LevelReference;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideUseManualCamera;                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitForGameTime;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreaseGameTime;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManShaderCacheGenerator_CameraConfig  CameraOverride;                                    // 0x0034(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAbilityTestMode;                                  // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManShaderCacheGenerator_LevelTeleportData) == 0x000008, "Wrong alignment on FManShaderCacheGenerator_LevelTeleportData");
static_assert(sizeof(FManShaderCacheGenerator_LevelTeleportData) == 0x000058, "Wrong size on FManShaderCacheGenerator_LevelTeleportData");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, LevelReference) == 0x000000, "Member 'FManShaderCacheGenerator_LevelTeleportData::LevelReference' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, bOverrideUseManualCamera) == 0x000028, "Member 'FManShaderCacheGenerator_LevelTeleportData::bOverrideUseManualCamera' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, WaitForGameTime) == 0x00002C, "Member 'FManShaderCacheGenerator_LevelTeleportData::WaitForGameTime' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, IncreaseGameTime) == 0x000030, "Member 'FManShaderCacheGenerator_LevelTeleportData::IncreaseGameTime' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, CameraOverride) == 0x000034, "Member 'FManShaderCacheGenerator_LevelTeleportData::CameraOverride' has a wrong offset!");
static_assert(offsetof(FManShaderCacheGenerator_LevelTeleportData, bAbilityTestMode) == 0x000054, "Member 'FManShaderCacheGenerator_LevelTeleportData::bAbilityTestMode' has a wrong offset!");

// ScriptStruct man.NodeStageAlternative
// 0x00B8 (0x00B8 - 0x0000)
struct FNodeStageAlternative final
{
public:
	class FText                                   SkillNodeStageName;                                // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkillNodeStageIcon;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 StageLevelToBeIncluded;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FManSkillTreeNodeStageData             StageData;                                         // 0x0030(0x0088)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNodeStageAlternative) == 0x000008, "Wrong alignment on FNodeStageAlternative");
static_assert(sizeof(FNodeStageAlternative) == 0x0000B8, "Wrong size on FNodeStageAlternative");
static_assert(offsetof(FNodeStageAlternative, SkillNodeStageName) == 0x000000, "Member 'FNodeStageAlternative::SkillNodeStageName' has a wrong offset!");
static_assert(offsetof(FNodeStageAlternative, SkillNodeStageIcon) == 0x000018, "Member 'FNodeStageAlternative::SkillNodeStageIcon' has a wrong offset!");
static_assert(offsetof(FNodeStageAlternative, StageLevelToBeIncluded) == 0x000020, "Member 'FNodeStageAlternative::StageLevelToBeIncluded' has a wrong offset!");
static_assert(offsetof(FNodeStageAlternative, StageData) == 0x000030, "Member 'FNodeStageAlternative::StageData' has a wrong offset!");

// ScriptStruct man.ManSoundEvent
// 0x0018 (0x0018 - 0x0000)
struct FManSoundEvent final
{
public:
	class UAkAudioEvent*                          AkEvent;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StopDuration;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManSoundEvent) == 0x000008, "Wrong alignment on FManSoundEvent");
static_assert(sizeof(FManSoundEvent) == 0x000018, "Wrong size on FManSoundEvent");
static_assert(offsetof(FManSoundEvent, AkEvent) == 0x000000, "Member 'FManSoundEvent::AkEvent' has a wrong offset!");
static_assert(offsetof(FManSoundEvent, StopDuration) == 0x00000C, "Member 'FManSoundEvent::StopDuration' has a wrong offset!");

// ScriptStruct man.ManStackMeasureNode
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FManStackMeasureNode final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManStackMeasureNode) == 0x000008, "Wrong alignment on FManStackMeasureNode");
static_assert(sizeof(FManStackMeasureNode) == 0x000058, "Wrong size on FManStackMeasureNode");

// ScriptStruct man.ManStackMeasureKey
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FManStackMeasureKey final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManStackMeasureKey) == 0x000008, "Wrong alignment on FManStackMeasureKey");
static_assert(sizeof(FManStackMeasureKey) == 0x000018, "Wrong size on FManStackMeasureKey");

// ScriptStruct man.ManTextLink
// 0x0028 (0x0028 - 0x0000)
struct FManTextLink final
{
public:
	class FString                                 TextKey;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TextNamespace;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TextTableName;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FManTextLink) == 0x000008, "Wrong alignment on FManTextLink");
static_assert(sizeof(FManTextLink) == 0x000028, "Wrong size on FManTextLink");
static_assert(offsetof(FManTextLink, TextKey) == 0x000000, "Member 'FManTextLink::TextKey' has a wrong offset!");
static_assert(offsetof(FManTextLink, TextNamespace) == 0x000010, "Member 'FManTextLink::TextNamespace' has a wrong offset!");
static_assert(offsetof(FManTextLink, TextTableName) == 0x000020, "Member 'FManTextLink::TextTableName' has a wrong offset!");

// ScriptStruct man.FocusRequest
// 0x0010 (0x0010 - 0x0000)
struct FFocusRequest final
{
public:
	class UManSlotUserWidgetBase*                 ManSlotUserWidgetBase;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocused;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusRequest) == 0x000008, "Wrong alignment on FFocusRequest");
static_assert(sizeof(FFocusRequest) == 0x000010, "Wrong size on FFocusRequest");
static_assert(offsetof(FFocusRequest, ManSlotUserWidgetBase) == 0x000000, "Member 'FFocusRequest::ManSlotUserWidgetBase' has a wrong offset!");
static_assert(offsetof(FFocusRequest, bFocused) == 0x000008, "Member 'FFocusRequest::bFocused' has a wrong offset!");
static_assert(offsetof(FFocusRequest, bAnimate) == 0x000009, "Member 'FFocusRequest::bAnimate' has a wrong offset!");

// ScriptStruct man.CachedPropertyChanged
// 0x0014 (0x0014 - 0x0000)
struct FCachedPropertyChanged final
{
public:
	EHeroProperty                                 PropertyType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribute                                    AttributeType;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundedFloatValue;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundedIntValue;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimate;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedPropertyChanged) == 0x000004, "Wrong alignment on FCachedPropertyChanged");
static_assert(sizeof(FCachedPropertyChanged) == 0x000014, "Wrong size on FCachedPropertyChanged");
static_assert(offsetof(FCachedPropertyChanged, PropertyType) == 0x000000, "Member 'FCachedPropertyChanged::PropertyType' has a wrong offset!");
static_assert(offsetof(FCachedPropertyChanged, AttributeType) == 0x000001, "Member 'FCachedPropertyChanged::AttributeType' has a wrong offset!");
static_assert(offsetof(FCachedPropertyChanged, Value) == 0x000004, "Member 'FCachedPropertyChanged::Value' has a wrong offset!");
static_assert(offsetof(FCachedPropertyChanged, RoundedFloatValue) == 0x000008, "Member 'FCachedPropertyChanged::RoundedFloatValue' has a wrong offset!");
static_assert(offsetof(FCachedPropertyChanged, RoundedIntValue) == 0x00000C, "Member 'FCachedPropertyChanged::RoundedIntValue' has a wrong offset!");
static_assert(offsetof(FCachedPropertyChanged, bAnimate) == 0x000010, "Member 'FCachedPropertyChanged::bAnimate' has a wrong offset!");

// ScriptStruct man.MapExplorationTileEdges
// 0x0006 (0x0006 - 0x0000)
struct FMapExplorationTileEdges
{
public:
	bool                                          bExplorable;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplored;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeType                   TopEdge;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeType                   RightEdge;                                         // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeType                   BottomEdge;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapExplorationTileEdgeType                   LeftEdge;                                          // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapExplorationTileEdges) == 0x000001, "Wrong alignment on FMapExplorationTileEdges");
static_assert(sizeof(FMapExplorationTileEdges) == 0x000006, "Wrong size on FMapExplorationTileEdges");
static_assert(offsetof(FMapExplorationTileEdges, bExplorable) == 0x000000, "Member 'FMapExplorationTileEdges::bExplorable' has a wrong offset!");
static_assert(offsetof(FMapExplorationTileEdges, bExplored) == 0x000001, "Member 'FMapExplorationTileEdges::bExplored' has a wrong offset!");
static_assert(offsetof(FMapExplorationTileEdges, TopEdge) == 0x000002, "Member 'FMapExplorationTileEdges::TopEdge' has a wrong offset!");
static_assert(offsetof(FMapExplorationTileEdges, RightEdge) == 0x000003, "Member 'FMapExplorationTileEdges::RightEdge' has a wrong offset!");
static_assert(offsetof(FMapExplorationTileEdges, BottomEdge) == 0x000004, "Member 'FMapExplorationTileEdges::BottomEdge' has a wrong offset!");
static_assert(offsetof(FMapExplorationTileEdges, LeftEdge) == 0x000005, "Member 'FMapExplorationTileEdges::LeftEdge' has a wrong offset!");

// ScriptStruct man.MapExplorationSubTileEdges
// 0x000A (0x0010 - 0x0006)
struct FMapExplorationSubTileEdges final : public FMapExplorationTileEdges
{
public:
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              Pos;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapExplorationSubTileEdges) == 0x000004, "Wrong alignment on FMapExplorationSubTileEdges");
static_assert(sizeof(FMapExplorationSubTileEdges) == 0x000010, "Wrong size on FMapExplorationSubTileEdges");
static_assert(offsetof(FMapExplorationSubTileEdges, Pos) == 0x000008, "Member 'FMapExplorationSubTileEdges::Pos' has a wrong offset!");

// ScriptStruct man.MapSegmentLink
// 0x0014 (0x0014 - 0x0000)
struct FMapSegmentLink final
{
public:
	struct FIntPoint                              LeftGlobalPos;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              RightGlobalPos;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapSegmentLink) == 0x000004, "Wrong alignment on FMapSegmentLink");
static_assert(sizeof(FMapSegmentLink) == 0x000014, "Wrong size on FMapSegmentLink");
static_assert(offsetof(FMapSegmentLink, LeftGlobalPos) == 0x000000, "Member 'FMapSegmentLink::LeftGlobalPos' has a wrong offset!");
static_assert(offsetof(FMapSegmentLink, RightGlobalPos) == 0x000008, "Member 'FMapSegmentLink::RightGlobalPos' has a wrong offset!");
static_assert(offsetof(FMapSegmentLink, LayerIndex) == 0x000010, "Member 'FMapSegmentLink::LayerIndex' has a wrong offset!");

// ScriptStruct man.MinimapPosition
// 0x0018 (0x0018 - 0x0000)
struct FMinimapPosition final
{
public:
	struct FIntPoint                              GlobalTilePos;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapSegmentVolumeID*                    MapSegmentID;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalTileRotated180;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapPosition) == 0x000008, "Wrong alignment on FMinimapPosition");
static_assert(sizeof(FMinimapPosition) == 0x000018, "Wrong size on FMinimapPosition");
static_assert(offsetof(FMinimapPosition, GlobalTilePos) == 0x000000, "Member 'FMinimapPosition::GlobalTilePos' has a wrong offset!");
static_assert(offsetof(FMinimapPosition, MapSegmentID) == 0x000008, "Member 'FMinimapPosition::MapSegmentID' has a wrong offset!");
static_assert(offsetof(FMinimapPosition, bGlobalTileRotated180) == 0x000010, "Member 'FMinimapPosition::bGlobalTileRotated180' has a wrong offset!");

// ScriptStruct man.MapOverviewLevelSegmentLinkBuiltData
// 0x0018 (0x0018 - 0x0000)
struct FMapOverviewLevelSegmentLinkBuiltData final
{
public:
	struct FIntPoint                              LeftGlobalPos;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              RightGlobalPos;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftFinalSegmentIndex;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightFinalSegmentIndex;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapOverviewLevelSegmentLinkBuiltData) == 0x000004, "Wrong alignment on FMapOverviewLevelSegmentLinkBuiltData");
static_assert(sizeof(FMapOverviewLevelSegmentLinkBuiltData) == 0x000018, "Wrong size on FMapOverviewLevelSegmentLinkBuiltData");
static_assert(offsetof(FMapOverviewLevelSegmentLinkBuiltData, LeftGlobalPos) == 0x000000, "Member 'FMapOverviewLevelSegmentLinkBuiltData::LeftGlobalPos' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSegmentLinkBuiltData, RightGlobalPos) == 0x000008, "Member 'FMapOverviewLevelSegmentLinkBuiltData::RightGlobalPos' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSegmentLinkBuiltData, LeftFinalSegmentIndex) == 0x000010, "Member 'FMapOverviewLevelSegmentLinkBuiltData::LeftFinalSegmentIndex' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSegmentLinkBuiltData, RightFinalSegmentIndex) == 0x000014, "Member 'FMapOverviewLevelSegmentLinkBuiltData::RightFinalSegmentIndex' has a wrong offset!");

// ScriptStruct man.MapOverviewLevelSourceSegmentVolumeBuiltData
// 0x0028 (0x0028 - 0x0000)
struct FMapOverviewLevelSourceSegmentVolumeBuiltData final
{
public:
	struct FMapExplorationGrid                    ExplorationGrid;                                   // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	int32                                         LayerIndex;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapOverviewLevelSourceSegmentVolumeBuiltData) == 0x000008, "Wrong alignment on FMapOverviewLevelSourceSegmentVolumeBuiltData");
static_assert(sizeof(FMapOverviewLevelSourceSegmentVolumeBuiltData) == 0x000028, "Wrong size on FMapOverviewLevelSourceSegmentVolumeBuiltData");
static_assert(offsetof(FMapOverviewLevelSourceSegmentVolumeBuiltData, ExplorationGrid) == 0x000000, "Member 'FMapOverviewLevelSourceSegmentVolumeBuiltData::ExplorationGrid' has a wrong offset!");
static_assert(offsetof(FMapOverviewLevelSourceSegmentVolumeBuiltData, LayerIndex) == 0x000020, "Member 'FMapOverviewLevelSourceSegmentVolumeBuiltData::LayerIndex' has a wrong offset!");

// ScriptStruct man.SavedCheckpointData
// 0x0018 (0x0018 - 0x0000)
struct FSavedCheckpointData final
{
public:
	class FName                                   ObjectName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckpointData*                        CheckpointData;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckPointUnlocked;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTravelEnabled;                                    // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ArrayIndx;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCheckpointData) == 0x000008, "Wrong alignment on FSavedCheckpointData");
static_assert(sizeof(FSavedCheckpointData) == 0x000018, "Wrong size on FSavedCheckpointData");
static_assert(offsetof(FSavedCheckpointData, ObjectName) == 0x000000, "Member 'FSavedCheckpointData::ObjectName' has a wrong offset!");
static_assert(offsetof(FSavedCheckpointData, CheckpointData) == 0x000008, "Member 'FSavedCheckpointData::CheckpointData' has a wrong offset!");
static_assert(offsetof(FSavedCheckpointData, bCheckPointUnlocked) == 0x000010, "Member 'FSavedCheckpointData::bCheckPointUnlocked' has a wrong offset!");
static_assert(offsetof(FSavedCheckpointData, bTravelEnabled) == 0x000011, "Member 'FSavedCheckpointData::bTravelEnabled' has a wrong offset!");
static_assert(offsetof(FSavedCheckpointData, ArrayIndx) == 0x000014, "Member 'FSavedCheckpointData::ArrayIndx' has a wrong offset!");

// ScriptStruct man.SavedMapData
// 0x0040 (0x0040 - 0x0000)
struct FSavedMapData final
{
public:
	TArray<struct FSavedMapSegmentData>           SegmentData;                                       // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSavedCheckpointData>           CheckpointData;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMiniMapIconGameplayData>       MarkersData;                                       // 0x0020(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExploredSecretAreas;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedMapData) == 0x000008, "Wrong alignment on FSavedMapData");
static_assert(sizeof(FSavedMapData) == 0x000040, "Wrong size on FSavedMapData");
static_assert(offsetof(FSavedMapData, SegmentData) == 0x000000, "Member 'FSavedMapData::SegmentData' has a wrong offset!");
static_assert(offsetof(FSavedMapData, CheckpointData) == 0x000010, "Member 'FSavedMapData::CheckpointData' has a wrong offset!");
static_assert(offsetof(FSavedMapData, MarkersData) == 0x000020, "Member 'FSavedMapData::MarkersData' has a wrong offset!");
static_assert(offsetof(FSavedMapData, ExploredSecretAreas) == 0x000030, "Member 'FSavedMapData::ExploredSecretAreas' has a wrong offset!");

// ScriptStruct man.CharacterSplitAbility_Node
// 0x0020 (0x0020 - 0x0000)
struct FCharacterSplitAbility_Node final
{
public:
	TSubclassOf<class ACharacterBase>             SplitClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterSplitAbilityEffect> SplitEffectClass;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinalForm;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacterBase*                         SpawnedCharacter;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSplitAbility_Node) == 0x000008, "Wrong alignment on FCharacterSplitAbility_Node");
static_assert(sizeof(FCharacterSplitAbility_Node) == 0x000020, "Wrong size on FCharacterSplitAbility_Node");
static_assert(offsetof(FCharacterSplitAbility_Node, SplitClass) == 0x000000, "Member 'FCharacterSplitAbility_Node::SplitClass' has a wrong offset!");
static_assert(offsetof(FCharacterSplitAbility_Node, SplitEffectClass) == 0x000008, "Member 'FCharacterSplitAbility_Node::SplitEffectClass' has a wrong offset!");
static_assert(offsetof(FCharacterSplitAbility_Node, bFinalForm) == 0x000010, "Member 'FCharacterSplitAbility_Node::bFinalForm' has a wrong offset!");
static_assert(offsetof(FCharacterSplitAbility_Node, SpawnedCharacter) == 0x000018, "Member 'FCharacterSplitAbility_Node::SpawnedCharacter' has a wrong offset!");

// ScriptStruct man.BestiaryImmunityNode
// 0x0028 (0x0028 - 0x0000)
struct FBestiaryImmunityNode final
{
public:
	TSubclassOf<class UAbilityBase>               Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAttribute>                            Immunity;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ImmunityName;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBestiaryImmunityNode) == 0x000008, "Wrong alignment on FBestiaryImmunityNode");
static_assert(sizeof(FBestiaryImmunityNode) == 0x000028, "Wrong size on FBestiaryImmunityNode");
static_assert(offsetof(FBestiaryImmunityNode, Ability) == 0x000000, "Member 'FBestiaryImmunityNode::Ability' has a wrong offset!");
static_assert(offsetof(FBestiaryImmunityNode, Immunity) == 0x000008, "Member 'FBestiaryImmunityNode::Immunity' has a wrong offset!");
static_assert(offsetof(FBestiaryImmunityNode, ImmunityName) == 0x000018, "Member 'FBestiaryImmunityNode::ImmunityName' has a wrong offset!");

// ScriptStruct man.BestiaryNewRegistry
// 0x000C (0x000C - 0x0000)
struct FBestiaryNewRegistry final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewRegistry;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBestiaryNewRegistry) == 0x000004, "Wrong alignment on FBestiaryNewRegistry");
static_assert(sizeof(FBestiaryNewRegistry) == 0x00000C, "Wrong size on FBestiaryNewRegistry");
static_assert(offsetof(FBestiaryNewRegistry, AssetName) == 0x000000, "Member 'FBestiaryNewRegistry::AssetName' has a wrong offset!");
static_assert(offsetof(FBestiaryNewRegistry, bNewRegistry) == 0x000008, "Member 'FBestiaryNewRegistry::bNewRegistry' has a wrong offset!");

// ScriptStruct man.OfferingShrineDataElement
// 0x0030 (0x0030 - 0x0000)
struct FOfferingShrineDataElement final
{
public:
	TSoftClassPtr<class UClass>                   Item;                                              // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOfferingShrineDataElement) == 0x000008, "Wrong alignment on FOfferingShrineDataElement");
static_assert(sizeof(FOfferingShrineDataElement) == 0x000030, "Wrong size on FOfferingShrineDataElement");
static_assert(offsetof(FOfferingShrineDataElement, Item) == 0x000000, "Member 'FOfferingShrineDataElement::Item' has a wrong offset!");
static_assert(offsetof(FOfferingShrineDataElement, Count) == 0x000028, "Member 'FOfferingShrineDataElement::Count' has a wrong offset!");

// ScriptStruct man.OptionsSelector
// 0x0048 (0x0048 - 0x0000)
struct FOptionsSelector final
{
public:
	EOptionsType                                  OptionsType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FText>                           Options;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionsSelector) == 0x000008, "Wrong alignment on FOptionsSelector");
static_assert(sizeof(FOptionsSelector) == 0x000048, "Wrong size on FOptionsSelector");
static_assert(offsetof(FOptionsSelector, OptionsType) == 0x000000, "Member 'FOptionsSelector::OptionsType' has a wrong offset!");
static_assert(offsetof(FOptionsSelector, DisplayName) == 0x000008, "Member 'FOptionsSelector::DisplayName' has a wrong offset!");
static_assert(offsetof(FOptionsSelector, Description) == 0x000020, "Member 'FOptionsSelector::Description' has a wrong offset!");
static_assert(offsetof(FOptionsSelector, Options) == 0x000038, "Member 'FOptionsSelector::Options' has a wrong offset!");

// ScriptStruct man.OptionsButton
// 0x0040 (0x0040 - 0x0000)
struct FOptionsButton final
{
public:
	EOptionsType                                  OptionsType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOptionsButton) == 0x000008, "Wrong alignment on FOptionsButton");
static_assert(sizeof(FOptionsButton) == 0x000040, "Wrong size on FOptionsButton");
static_assert(offsetof(FOptionsButton, OptionsType) == 0x000000, "Member 'FOptionsButton::OptionsType' has a wrong offset!");
static_assert(offsetof(FOptionsButton, DisplayName) == 0x000008, "Member 'FOptionsButton::DisplayName' has a wrong offset!");
static_assert(offsetof(FOptionsButton, Description) == 0x000020, "Member 'FOptionsButton::Description' has a wrong offset!");

// ScriptStruct man.PersistentDeathEssenceData
// 0x00C0 (0x00C0 - 0x0000)
struct FPersistentDeathEssenceData final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0040(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EssenceValue;                                      // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SafeEssenceTransform;                              // 0x0060(0x0030)(SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 SafeEssenceLevelName;                              // 0x0090(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapSegmentVolumeID*                    SafeMapSegmentID;                                  // 0x00A0(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              SafeMapGlobalTilePos;                              // 0x00A8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapSegmentVolumeID*                    MapSegmentID;                                      // 0x00B0(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              MapGlobalTilePos;                                  // 0x00B8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPersistentDeathEssenceData) == 0x000010, "Wrong alignment on FPersistentDeathEssenceData");
static_assert(sizeof(FPersistentDeathEssenceData) == 0x0000C0, "Wrong size on FPersistentDeathEssenceData");
static_assert(offsetof(FPersistentDeathEssenceData, bActive) == 0x000000, "Member 'FPersistentDeathEssenceData::bActive' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, Transform) == 0x000010, "Member 'FPersistentDeathEssenceData::Transform' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, LevelName) == 0x000040, "Member 'FPersistentDeathEssenceData::LevelName' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, EssenceValue) == 0x000050, "Member 'FPersistentDeathEssenceData::EssenceValue' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, SafeEssenceTransform) == 0x000060, "Member 'FPersistentDeathEssenceData::SafeEssenceTransform' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, SafeEssenceLevelName) == 0x000090, "Member 'FPersistentDeathEssenceData::SafeEssenceLevelName' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, SafeMapSegmentID) == 0x0000A0, "Member 'FPersistentDeathEssenceData::SafeMapSegmentID' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, SafeMapGlobalTilePos) == 0x0000A8, "Member 'FPersistentDeathEssenceData::SafeMapGlobalTilePos' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, MapSegmentID) == 0x0000B0, "Member 'FPersistentDeathEssenceData::MapSegmentID' has a wrong offset!");
static_assert(offsetof(FPersistentDeathEssenceData, MapGlobalTilePos) == 0x0000B8, "Member 'FPersistentDeathEssenceData::MapGlobalTilePos' has a wrong offset!");

// ScriptStruct man.DifficultyDefaultSetting
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDifficultyDefaultSetting final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDifficultyDefaultSetting) == 0x000004, "Wrong alignment on FDifficultyDefaultSetting");
static_assert(sizeof(FDifficultyDefaultSetting) == 0x00000C, "Wrong size on FDifficultyDefaultSetting");

// ScriptStruct man.PersonalCartActorNode
// 0x0030 (0x0030 - 0x0000)
struct FPersonalCartActorNode final
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountOnLevels;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPersonalCartActorNode) == 0x000008, "Wrong alignment on FPersonalCartActorNode");
static_assert(sizeof(FPersonalCartActorNode) == 0x000030, "Wrong size on FPersonalCartActorNode");
static_assert(offsetof(FPersonalCartActorNode, ActorClass) == 0x000000, "Member 'FPersonalCartActorNode::ActorClass' has a wrong offset!");
static_assert(offsetof(FPersonalCartActorNode, CountOnLevels) == 0x000028, "Member 'FPersonalCartActorNode::CountOnLevels' has a wrong offset!");

// ScriptStruct man.PSD_PlayerDamageTakenNode
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPSD_PlayerDamageTakenNode final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPSD_PlayerDamageTakenNode) == 0x000008, "Wrong alignment on FPSD_PlayerDamageTakenNode");
static_assert(sizeof(FPSD_PlayerDamageTakenNode) == 0x000010, "Wrong size on FPSD_PlayerDamageTakenNode");

// ScriptStruct man.PSD_PerEnemyLevelType
// 0x000C (0x000C - 0x0000)
struct FPSD_PerEnemyLevelType final
{
public:
	int32                                         NumKilled;                                         // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumKilledBy;                                       // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewRegistry;                                      // 0x0008(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPSD_PerEnemyLevelType) == 0x000004, "Wrong alignment on FPSD_PerEnemyLevelType");
static_assert(sizeof(FPSD_PerEnemyLevelType) == 0x00000C, "Wrong size on FPSD_PerEnemyLevelType");
static_assert(offsetof(FPSD_PerEnemyLevelType, NumKilled) == 0x000000, "Member 'FPSD_PerEnemyLevelType::NumKilled' has a wrong offset!");
static_assert(offsetof(FPSD_PerEnemyLevelType, NumKilledBy) == 0x000004, "Member 'FPSD_PerEnemyLevelType::NumKilledBy' has a wrong offset!");
static_assert(offsetof(FPSD_PerEnemyLevelType, bNewRegistry) == 0x000008, "Member 'FPSD_PerEnemyLevelType::bNewRegistry' has a wrong offset!");

// ScriptStruct man.PSD_PerEnemyLevelTypeKey
// 0x000C (0x000C - 0x0000)
struct FPSD_PerEnemyLevelTypeKey final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPSD_PerEnemyLevelTypeKey) == 0x000004, "Wrong alignment on FPSD_PerEnemyLevelTypeKey");
static_assert(sizeof(FPSD_PerEnemyLevelTypeKey) == 0x00000C, "Wrong size on FPSD_PerEnemyLevelTypeKey");
static_assert(offsetof(FPSD_PerEnemyLevelTypeKey, Name) == 0x000000, "Member 'FPSD_PerEnemyLevelTypeKey::Name' has a wrong offset!");
static_assert(offsetof(FPSD_PerEnemyLevelTypeKey, Level) == 0x000008, "Member 'FPSD_PerEnemyLevelTypeKey::Level' has a wrong offset!");

// ScriptStruct man.PlaytestSignpostItem
// 0x0010 (0x0010 - 0x0000)
struct FPlaytestSignpostItem final
{
public:
	TSubclassOf<class UItemAbility>               Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaytestSignpostItem) == 0x000008, "Wrong alignment on FPlaytestSignpostItem");
static_assert(sizeof(FPlaytestSignpostItem) == 0x000010, "Wrong size on FPlaytestSignpostItem");
static_assert(offsetof(FPlaytestSignpostItem, Item) == 0x000000, "Member 'FPlaytestSignpostItem::Item' has a wrong offset!");
static_assert(offsetof(FPlaytestSignpostItem, Num) == 0x000008, "Member 'FPlaytestSignpostItem::Num' has a wrong offset!");

// ScriptStruct man.PrimalSlotMaterialCustomTextureParameter
// 0x0010 (0x0010 - 0x0000)
struct FPrimalSlotMaterialCustomTextureParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Value;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimalSlotMaterialCustomTextureParameter) == 0x000008, "Wrong alignment on FPrimalSlotMaterialCustomTextureParameter");
static_assert(sizeof(FPrimalSlotMaterialCustomTextureParameter) == 0x000010, "Wrong size on FPrimalSlotMaterialCustomTextureParameter");
static_assert(offsetof(FPrimalSlotMaterialCustomTextureParameter, Name) == 0x000000, "Member 'FPrimalSlotMaterialCustomTextureParameter::Name' has a wrong offset!");
static_assert(offsetof(FPrimalSlotMaterialCustomTextureParameter, Value) == 0x000008, "Member 'FPrimalSlotMaterialCustomTextureParameter::Value' has a wrong offset!");

// ScriptStruct man.PrimalSlotMaterialCustomColorParameter
// 0x0018 (0x0018 - 0x0000)
struct FPrimalSlotMaterialCustomColorParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimalSlotMaterialCustomColorParameter) == 0x000004, "Wrong alignment on FPrimalSlotMaterialCustomColorParameter");
static_assert(sizeof(FPrimalSlotMaterialCustomColorParameter) == 0x000018, "Wrong size on FPrimalSlotMaterialCustomColorParameter");
static_assert(offsetof(FPrimalSlotMaterialCustomColorParameter, Name) == 0x000000, "Member 'FPrimalSlotMaterialCustomColorParameter::Name' has a wrong offset!");
static_assert(offsetof(FPrimalSlotMaterialCustomColorParameter, Value) == 0x000008, "Member 'FPrimalSlotMaterialCustomColorParameter::Value' has a wrong offset!");

// ScriptStruct man.PrimalSlotRule
// 0x0020 (0x0020 - 0x0000)
struct FPrimalSlotRule final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlotsToHide;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PostProcess;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrimalSlotRule) == 0x000008, "Wrong alignment on FPrimalSlotRule");
static_assert(sizeof(FPrimalSlotRule) == 0x000020, "Wrong size on FPrimalSlotRule");
static_assert(offsetof(FPrimalSlotRule, SlotName) == 0x000000, "Member 'FPrimalSlotRule::SlotName' has a wrong offset!");
static_assert(offsetof(FPrimalSlotRule, SlotsToHide) == 0x000008, "Member 'FPrimalSlotRule::SlotsToHide' has a wrong offset!");
static_assert(offsetof(FPrimalSlotRule, PostProcess) == 0x000018, "Member 'FPrimalSlotRule::PostProcess' has a wrong offset!");

// ScriptStruct man.RakeLaunchData
// 0x0010 (0x0010 - 0x0000)
struct FRakeLaunchData final
{
public:
	float                                         InitialSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngle;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngleRandomAddition;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRakeLaunchData) == 0x000004, "Wrong alignment on FRakeLaunchData");
static_assert(sizeof(FRakeLaunchData) == 0x000010, "Wrong size on FRakeLaunchData");
static_assert(offsetof(FRakeLaunchData, InitialSpeed) == 0x000000, "Member 'FRakeLaunchData::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FRakeLaunchData, Gravity) == 0x000004, "Member 'FRakeLaunchData::Gravity' has a wrong offset!");
static_assert(offsetof(FRakeLaunchData, LaunchAngle) == 0x000008, "Member 'FRakeLaunchData::LaunchAngle' has a wrong offset!");
static_assert(offsetof(FRakeLaunchData, LaunchAngleRandomAddition) == 0x00000C, "Member 'FRakeLaunchData::LaunchAngleRandomAddition' has a wrong offset!");

// ScriptStruct man.RatingResultCategory
// 0x0010 (0x0010 - 0x0000)
struct FRatingResultCategory final
{
public:
	TArray<TScriptInterface<class IRatingObjectInterface>> Players;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRatingResultCategory) == 0x000008, "Wrong alignment on FRatingResultCategory");
static_assert(sizeof(FRatingResultCategory) == 0x000010, "Wrong size on FRatingResultCategory");
static_assert(offsetof(FRatingResultCategory, Players) == 0x000000, "Member 'FRatingResultCategory::Players' has a wrong offset!");

// ScriptStruct man.PlayerRatingProcessInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPlayerRatingProcessInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerRatingProcessInfo) == 0x000008, "Wrong alignment on FPlayerRatingProcessInfo");
static_assert(sizeof(FPlayerRatingProcessInfo) == 0x000020, "Wrong size on FPlayerRatingProcessInfo");

// ScriptStruct man.MatchOfPlayerRatingProcessInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMatchOfPlayerRatingProcessInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchOfPlayerRatingProcessInfo) == 0x000008, "Wrong alignment on FMatchOfPlayerRatingProcessInfo");
static_assert(sizeof(FMatchOfPlayerRatingProcessInfo) == 0x000018, "Wrong size on FMatchOfPlayerRatingProcessInfo");

// ScriptStruct man.RatingSystemSettings_Glicko
// 0x000C (0x000C - 0x0000)
struct FRatingSystemSettings_Glicko final
{
public:
	float                                         InitialRating;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRatingsDeviation;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationChange;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRatingSystemSettings_Glicko) == 0x000004, "Wrong alignment on FRatingSystemSettings_Glicko");
static_assert(sizeof(FRatingSystemSettings_Glicko) == 0x00000C, "Wrong size on FRatingSystemSettings_Glicko");
static_assert(offsetof(FRatingSystemSettings_Glicko, InitialRating) == 0x000000, "Member 'FRatingSystemSettings_Glicko::InitialRating' has a wrong offset!");
static_assert(offsetof(FRatingSystemSettings_Glicko, InitialRatingsDeviation) == 0x000004, "Member 'FRatingSystemSettings_Glicko::InitialRatingsDeviation' has a wrong offset!");
static_assert(offsetof(FRatingSystemSettings_Glicko, DeviationChange) == 0x000008, "Member 'FRatingSystemSettings_Glicko::DeviationChange' has a wrong offset!");

// ScriptStruct man.RingGroupElement
// 0x0018 (0x0018 - 0x0000)
struct FRingGroupElement final
{
public:
	class FName                                   RingGroupName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ItemsInGroup;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRingGroupElement) == 0x000008, "Wrong alignment on FRingGroupElement");
static_assert(sizeof(FRingGroupElement) == 0x000018, "Wrong size on FRingGroupElement");
static_assert(offsetof(FRingGroupElement, RingGroupName) == 0x000000, "Member 'FRingGroupElement::RingGroupName' has a wrong offset!");
static_assert(offsetof(FRingGroupElement, ItemsInGroup) == 0x000008, "Member 'FRingGroupElement::ItemsInGroup' has a wrong offset!");

// ScriptStruct man.AnimPerDistance
// 0x0010 (0x0010 - 0x0000)
struct FAnimPerDistance final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimPerDistance) == 0x000008, "Wrong alignment on FAnimPerDistance");
static_assert(sizeof(FAnimPerDistance) == 0x000010, "Wrong size on FAnimPerDistance");
static_assert(offsetof(FAnimPerDistance, AnimID) == 0x000000, "Member 'FAnimPerDistance::AnimID' has a wrong offset!");
static_assert(offsetof(FAnimPerDistance, Distance) == 0x000008, "Member 'FAnimPerDistance::Distance' has a wrong offset!");

// ScriptStruct man.BallisticOverride
// 0x0024 (0x0024 - 0x0000)
struct FBallisticOverride final
{
public:
	float                                         BelowDistanceRange;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitDistance;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToInterceptPerUnitDistance;                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAnimShotAngle;                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimShotAngleOverride;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixDistanceBelowMinDistance;                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHDistance;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVDistance;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToInterceptBelowMinDist;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBallisticOverride) == 0x000004, "Wrong alignment on FBallisticOverride");
static_assert(sizeof(FBallisticOverride) == 0x000024, "Wrong size on FBallisticOverride");
static_assert(offsetof(FBallisticOverride, BelowDistanceRange) == 0x000000, "Member 'FBallisticOverride::BelowDistanceRange' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, UnitDistance) == 0x000004, "Member 'FBallisticOverride::UnitDistance' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, TimeToInterceptPerUnitDistance) == 0x000008, "Member 'FBallisticOverride::TimeToInterceptPerUnitDistance' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, bOverrideAnimShotAngle) == 0x00000C, "Member 'FBallisticOverride::bOverrideAnimShotAngle' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, AnimShotAngleOverride) == 0x000010, "Member 'FBallisticOverride::AnimShotAngleOverride' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, bFixDistanceBelowMinDistance) == 0x000014, "Member 'FBallisticOverride::bFixDistanceBelowMinDistance' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, MinHDistance) == 0x000018, "Member 'FBallisticOverride::MinHDistance' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, MaxVDistance) == 0x00001C, "Member 'FBallisticOverride::MaxVDistance' has a wrong offset!");
static_assert(offsetof(FBallisticOverride, TimeToInterceptBelowMinDist) == 0x000020, "Member 'FBallisticOverride::TimeToInterceptBelowMinDist' has a wrong offset!");

// ScriptStruct man.ShootData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FShootData final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShootData) == 0x000008, "Wrong alignment on FShootData");
static_assert(sizeof(FShootData) == 0x000040, "Wrong size on FShootData");

// ScriptStruct man.ShootMomentSnapshot
// 0x004C (0x004C - 0x0000)
struct FShootMomentSnapshot final
{
public:
	struct FVector                                ShotPos;                                           // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetFeetLoc;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetCenterLoc;                                   // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetHeadLoc;                                     // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetStandingHeadLoc;                             // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PredictedTargetDisplacement;                       // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShootMomentSnapshot) == 0x000004, "Wrong alignment on FShootMomentSnapshot");
static_assert(sizeof(FShootMomentSnapshot) == 0x00004C, "Wrong size on FShootMomentSnapshot");
static_assert(offsetof(FShootMomentSnapshot, ShotPos) == 0x000000, "Member 'FShootMomentSnapshot::ShotPos' has a wrong offset!");
static_assert(offsetof(FShootMomentSnapshot, TargetFeetLoc) == 0x00000C, "Member 'FShootMomentSnapshot::TargetFeetLoc' has a wrong offset!");
static_assert(offsetof(FShootMomentSnapshot, TargetCenterLoc) == 0x000018, "Member 'FShootMomentSnapshot::TargetCenterLoc' has a wrong offset!");
static_assert(offsetof(FShootMomentSnapshot, TargetHeadLoc) == 0x000024, "Member 'FShootMomentSnapshot::TargetHeadLoc' has a wrong offset!");
static_assert(offsetof(FShootMomentSnapshot, TargetStandingHeadLoc) == 0x000030, "Member 'FShootMomentSnapshot::TargetStandingHeadLoc' has a wrong offset!");
static_assert(offsetof(FShootMomentSnapshot, PredictedTargetDisplacement) == 0x00003C, "Member 'FShootMomentSnapshot::PredictedTargetDisplacement' has a wrong offset!");

// ScriptStruct man.TreeNodeCheckData
// 0x0020 (0x0020 - 0x0000)
struct FTreeNodeCheckData final
{
public:
	class UPrimalSkillTreeNode*                   CheckOrigin;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidSubtree;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimalSkillTreeNode*>           TraversedNodes;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeNodeCheckData) == 0x000008, "Wrong alignment on FTreeNodeCheckData");
static_assert(sizeof(FTreeNodeCheckData) == 0x000020, "Wrong size on FTreeNodeCheckData");
static_assert(offsetof(FTreeNodeCheckData, CheckOrigin) == 0x000000, "Member 'FTreeNodeCheckData::CheckOrigin' has a wrong offset!");
static_assert(offsetof(FTreeNodeCheckData, bValidSubtree) == 0x000008, "Member 'FTreeNodeCheckData::bValidSubtree' has a wrong offset!");
static_assert(offsetof(FTreeNodeCheckData, TraversedNodes) == 0x000010, "Member 'FTreeNodeCheckData::TraversedNodes' has a wrong offset!");

// ScriptStruct man.SkillTreeContainer
// 0x0048 (0x0048 - 0x0000)
struct FSkillTreeContainer final
{
public:
	TSoftObjectPtr<class UPrimalSkillTree>        SoftTreePtr;                                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimalSkillTree*                       SkillTree;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailablePoints;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StageUnlocksInTree;                                // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECharacterClass>                       UnlockedStartNodes;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillTreeContainer) == 0x000008, "Wrong alignment on FSkillTreeContainer");
static_assert(sizeof(FSkillTreeContainer) == 0x000048, "Wrong size on FSkillTreeContainer");
static_assert(offsetof(FSkillTreeContainer, SoftTreePtr) == 0x000000, "Member 'FSkillTreeContainer::SoftTreePtr' has a wrong offset!");
static_assert(offsetof(FSkillTreeContainer, SkillTree) == 0x000028, "Member 'FSkillTreeContainer::SkillTree' has a wrong offset!");
static_assert(offsetof(FSkillTreeContainer, AvailablePoints) == 0x000030, "Member 'FSkillTreeContainer::AvailablePoints' has a wrong offset!");
static_assert(offsetof(FSkillTreeContainer, StageUnlocksInTree) == 0x000034, "Member 'FSkillTreeContainer::StageUnlocksInTree' has a wrong offset!");
static_assert(offsetof(FSkillTreeContainer, UnlockedStartNodes) == 0x000038, "Member 'FSkillTreeContainer::UnlockedStartNodes' has a wrong offset!");

// ScriptStruct man.TreeUnlockCache
// 0x0018 (0x0018 - 0x0000)
struct FTreeUnlockCache final
{
public:
	class UPrimalSkillTreeNode*                   Node;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTreeUnlockCache) == 0x000008, "Wrong alignment on FTreeUnlockCache");
static_assert(sizeof(FTreeUnlockCache) == 0x000018, "Wrong size on FTreeUnlockCache");
static_assert(offsetof(FTreeUnlockCache, Node) == 0x000000, "Member 'FTreeUnlockCache::Node' has a wrong offset!");

// ScriptStruct man.SlotMaterialColorParameter
// 0x0018 (0x0018 - 0x0000)
struct FSlotMaterialColorParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotMaterialColorParameter) == 0x000004, "Wrong alignment on FSlotMaterialColorParameter");
static_assert(sizeof(FSlotMaterialColorParameter) == 0x000018, "Wrong size on FSlotMaterialColorParameter");
static_assert(offsetof(FSlotMaterialColorParameter, Name) == 0x000000, "Member 'FSlotMaterialColorParameter::Name' has a wrong offset!");
static_assert(offsetof(FSlotMaterialColorParameter, Value) == 0x000008, "Member 'FSlotMaterialColorParameter::Value' has a wrong offset!");

// ScriptStruct man.SlotMaterialScalarParameter
// 0x000C (0x000C - 0x0000)
struct FSlotMaterialScalarParameter final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotMaterialScalarParameter) == 0x000004, "Wrong alignment on FSlotMaterialScalarParameter");
static_assert(sizeof(FSlotMaterialScalarParameter) == 0x00000C, "Wrong size on FSlotMaterialScalarParameter");
static_assert(offsetof(FSlotMaterialScalarParameter, Name) == 0x000000, "Member 'FSlotMaterialScalarParameter::Name' has a wrong offset!");
static_assert(offsetof(FSlotMaterialScalarParameter, Value) == 0x000008, "Member 'FSlotMaterialScalarParameter::Value' has a wrong offset!");

// ScriptStruct man.SlotRule
// 0x0028 (0x0028 - 0x0000)
struct FSlotRule final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlotsToHide;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlotsToReplace;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotRule) == 0x000008, "Wrong alignment on FSlotRule");
static_assert(sizeof(FSlotRule) == 0x000028, "Wrong size on FSlotRule");
static_assert(offsetof(FSlotRule, SlotName) == 0x000000, "Member 'FSlotRule::SlotName' has a wrong offset!");
static_assert(offsetof(FSlotRule, SlotsToHide) == 0x000008, "Member 'FSlotRule::SlotsToHide' has a wrong offset!");
static_assert(offsetof(FSlotRule, SlotsToReplace) == 0x000018, "Member 'FSlotRule::SlotsToReplace' has a wrong offset!");

// ScriptStruct man.SlotReplacement
// 0x0050 (0x0050 - 0x0000)
struct FSlotReplacement final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Replacement;                                       // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotReplacement) == 0x000008, "Wrong alignment on FSlotReplacement");
static_assert(sizeof(FSlotReplacement) == 0x000050, "Wrong size on FSlotReplacement");
static_assert(offsetof(FSlotReplacement, Mesh) == 0x000000, "Member 'FSlotReplacement::Mesh' has a wrong offset!");
static_assert(offsetof(FSlotReplacement, Replacement) == 0x000028, "Member 'FSlotReplacement::Replacement' has a wrong offset!");

// ScriptStruct man.Slot
// 0x0090 (0x0090 - 0x0000)
struct FSlot final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           DefaultMaleMesh;                                   // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           DefaultFemaleMesh;                                 // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CCBFemaleMesh;                                     // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   Items;                                             // 0x0080(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlot) == 0x000008, "Wrong alignment on FSlot");
static_assert(sizeof(FSlot) == 0x000090, "Wrong size on FSlot");
static_assert(offsetof(FSlot, Name) == 0x000000, "Member 'FSlot::Name' has a wrong offset!");
static_assert(offsetof(FSlot, DefaultMaleMesh) == 0x000008, "Member 'FSlot::DefaultMaleMesh' has a wrong offset!");
static_assert(offsetof(FSlot, DefaultFemaleMesh) == 0x000030, "Member 'FSlot::DefaultFemaleMesh' has a wrong offset!");
static_assert(offsetof(FSlot, CCBFemaleMesh) == 0x000058, "Member 'FSlot::CCBFemaleMesh' has a wrong offset!");
static_assert(offsetof(FSlot, Items) == 0x000080, "Member 'FSlot::Items' has a wrong offset!");

// ScriptStruct man.TextArgument
// 0x0020 (0x0020 - 0x0000)
struct FTextArgument final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSign;                                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPercentage;                                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLink;                                             // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttribute                                    attribute;                                         // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextArgument) == 0x000008, "Wrong alignment on FTextArgument");
static_assert(sizeof(FTextArgument) == 0x000020, "Wrong size on FTextArgument");
static_assert(offsetof(FTextArgument, Key) == 0x000000, "Member 'FTextArgument::Key' has a wrong offset!");
static_assert(offsetof(FTextArgument, Value) == 0x000008, "Member 'FTextArgument::Value' has a wrong offset!");
static_assert(offsetof(FTextArgument, bSign) == 0x000018, "Member 'FTextArgument::bSign' has a wrong offset!");
static_assert(offsetof(FTextArgument, bPercentage) == 0x000019, "Member 'FTextArgument::bPercentage' has a wrong offset!");
static_assert(offsetof(FTextArgument, bLink) == 0x00001A, "Member 'FTextArgument::bLink' has a wrong offset!");
static_assert(offsetof(FTextArgument, attribute) == 0x00001B, "Member 'FTextArgument::attribute' has a wrong offset!");

// ScriptStruct man.SpeechTableNode
// 0x0008 (0x0008 - 0x0000)
struct FSpeechTableNode final
{
public:
	class UDialogueDataAsset*                     DialogueDataAsset;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeechTableNode) == 0x000008, "Wrong alignment on FSpeechTableNode");
static_assert(sizeof(FSpeechTableNode) == 0x000008, "Wrong size on FSpeechTableNode");
static_assert(offsetof(FSpeechTableNode, DialogueDataAsset) == 0x000000, "Member 'FSpeechTableNode::DialogueDataAsset' has a wrong offset!");

// ScriptStruct man.StatusEffectMaterialController
// 0x00F0 (0x00F0 - 0x0000)
struct FStatusEffectMaterialController final
{
public:
	TArray<EStatusEffectType>                     StatusEffectTypes;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              StatusEffectMaterials;                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ScalarParameterNames;                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           VectorParameterNames;                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   UniquenessWeightParameterName;                     // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniquenessWeightPower;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutParameterName;                              // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInDuration;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutDuration;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x94];                                      // 0x005C(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectMaterialController) == 0x000008, "Wrong alignment on FStatusEffectMaterialController");
static_assert(sizeof(FStatusEffectMaterialController) == 0x0000F0, "Wrong size on FStatusEffectMaterialController");
static_assert(offsetof(FStatusEffectMaterialController, StatusEffectTypes) == 0x000000, "Member 'FStatusEffectMaterialController::StatusEffectTypes' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, StatusEffectMaterials) == 0x000010, "Member 'FStatusEffectMaterialController::StatusEffectMaterials' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, ScalarParameterNames) == 0x000020, "Member 'FStatusEffectMaterialController::ScalarParameterNames' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, VectorParameterNames) == 0x000030, "Member 'FStatusEffectMaterialController::VectorParameterNames' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, UniquenessWeightParameterName) == 0x000040, "Member 'FStatusEffectMaterialController::UniquenessWeightParameterName' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, UniquenessWeightPower) == 0x000048, "Member 'FStatusEffectMaterialController::UniquenessWeightPower' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, FadeOutParameterName) == 0x00004C, "Member 'FStatusEffectMaterialController::FadeOutParameterName' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, BlendInDuration) == 0x000054, "Member 'FStatusEffectMaterialController::BlendInDuration' has a wrong offset!");
static_assert(offsetof(FStatusEffectMaterialController, BlendOutDuration) == 0x000058, "Member 'FStatusEffectMaterialController::BlendOutDuration' has a wrong offset!");

// ScriptStruct man.StickAngleIput
// 0x0010 (0x0010 - 0x0000)
struct FStickAngleIput final
{
public:
	float                                         AngleLeft;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRight;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStickAngleIputSizeType                       SizeType;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertSizeCheck;                                  // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStickAngleIput) == 0x000004, "Wrong alignment on FStickAngleIput");
static_assert(sizeof(FStickAngleIput) == 0x000010, "Wrong size on FStickAngleIput");
static_assert(offsetof(FStickAngleIput, AngleLeft) == 0x000000, "Member 'FStickAngleIput::AngleLeft' has a wrong offset!");
static_assert(offsetof(FStickAngleIput, AngleRight) == 0x000004, "Member 'FStickAngleIput::AngleRight' has a wrong offset!");
static_assert(offsetof(FStickAngleIput, Size) == 0x000008, "Member 'FStickAngleIput::Size' has a wrong offset!");
static_assert(offsetof(FStickAngleIput, SizeType) == 0x00000C, "Member 'FStickAngleIput::SizeType' has a wrong offset!");
static_assert(offsetof(FStickAngleIput, bInvertSizeCheck) == 0x00000D, "Member 'FStickAngleIput::bInvertSizeCheck' has a wrong offset!");

// ScriptStruct man.SubtitleBlock
// 0x0038 (0x0038 - 0x0000)
struct FSubtitleBlock final
{
public:
	class FText                                   Subtitle;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   LineID;                                            // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	float                                         VisibleTime;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitleBlock) == 0x000008, "Wrong alignment on FSubtitleBlock");
static_assert(sizeof(FSubtitleBlock) == 0x000038, "Wrong size on FSubtitleBlock");
static_assert(offsetof(FSubtitleBlock, Subtitle) == 0x000000, "Member 'FSubtitleBlock::Subtitle' has a wrong offset!");
static_assert(offsetof(FSubtitleBlock, LineID) == 0x000018, "Member 'FSubtitleBlock::LineID' has a wrong offset!");
static_assert(offsetof(FSubtitleBlock, VisibleTime) == 0x000030, "Member 'FSubtitleBlock::VisibleTime' has a wrong offset!");
static_assert(offsetof(FSubtitleBlock, DelayTime) == 0x000034, "Member 'FSubtitleBlock::DelayTime' has a wrong offset!");

// ScriptStruct man.CustomSurfaceVFXData
// 0x0010 (0x0010 - 0x0000)
struct FCustomSurfaceVFXData final
{
public:
	class FName                                   CustomName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         VFX;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSurfaceVFXData) == 0x000008, "Wrong alignment on FCustomSurfaceVFXData");
static_assert(sizeof(FCustomSurfaceVFXData) == 0x000010, "Wrong size on FCustomSurfaceVFXData");
static_assert(offsetof(FCustomSurfaceVFXData, CustomName) == 0x000000, "Member 'FCustomSurfaceVFXData::CustomName' has a wrong offset!");
static_assert(offsetof(FCustomSurfaceVFXData, VFX) == 0x000008, "Member 'FCustomSurfaceVFXData::VFX' has a wrong offset!");

// ScriptStruct man.GlobalLevelTeleportData
// 0x0008 (0x0038 - 0x0030)
struct FGlobalLevelTeleportData final : public FLevelTeleportData
{
public:
	class UCheckpointData*                        TargetCheckpoint;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlobalLevelTeleportData) == 0x000008, "Wrong alignment on FGlobalLevelTeleportData");
static_assert(sizeof(FGlobalLevelTeleportData) == 0x000038, "Wrong size on FGlobalLevelTeleportData");
static_assert(offsetof(FGlobalLevelTeleportData, TargetCheckpoint) == 0x000030, "Member 'FGlobalLevelTeleportData::TargetCheckpoint' has a wrong offset!");

// ScriptStruct man.ActorOverlapReference
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FActorOverlapReference final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorOverlapReference) == 0x000004, "Wrong alignment on FActorOverlapReference");
static_assert(sizeof(FActorOverlapReference) == 0x00000C, "Wrong size on FActorOverlapReference");

// ScriptStruct man.TutorialScreenBlock
// 0x0038 (0x0038 - 0x0000)
struct FTutorialScreenBlock final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              Video;                                             // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActionNames;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialScreenBlock) == 0x000008, "Wrong alignment on FTutorialScreenBlock");
static_assert(sizeof(FTutorialScreenBlock) == 0x000038, "Wrong size on FTutorialScreenBlock");
static_assert(offsetof(FTutorialScreenBlock, Text) == 0x000000, "Member 'FTutorialScreenBlock::Text' has a wrong offset!");
static_assert(offsetof(FTutorialScreenBlock, Video) == 0x000018, "Member 'FTutorialScreenBlock::Video' has a wrong offset!");
static_assert(offsetof(FTutorialScreenBlock, ActionNames) == 0x000028, "Member 'FTutorialScreenBlock::ActionNames' has a wrong offset!");

// ScriptStruct man.VLEquilibriumOrbNode
// 0x0008 (0x0008 - 0x0000)
struct FVLEquilibriumOrbNode final
{
public:
	class AActorBase*                             Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVLEquilibriumOrbNode) == 0x000008, "Wrong alignment on FVLEquilibriumOrbNode");
static_assert(sizeof(FVLEquilibriumOrbNode) == 0x000008, "Wrong size on FVLEquilibriumOrbNode");
static_assert(offsetof(FVLEquilibriumOrbNode, Actor) == 0x000000, "Member 'FVLEquilibriumOrbNode::Actor' has a wrong offset!");

// ScriptStruct man.VLEquilibriumOrbRing
// 0x0040 (0x0040 - 0x0000)
struct FVLEquilibriumOrbRing final
{
public:
	TSubclassOf<class AActorBase>                 ActorClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterOffset;                                      // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAngle;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfWidth;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVLEquilibriumOrbNode>          Nodes;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVLEquilibriumOrbRing) == 0x000008, "Wrong alignment on FVLEquilibriumOrbRing");
static_assert(sizeof(FVLEquilibriumOrbRing) == 0x000040, "Wrong size on FVLEquilibriumOrbRing");
static_assert(offsetof(FVLEquilibriumOrbRing, ActorClass) == 0x000000, "Member 'FVLEquilibriumOrbRing::ActorClass' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, Num) == 0x000008, "Member 'FVLEquilibriumOrbRing::Num' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, CenterOffset) == 0x00000C, "Member 'FVLEquilibriumOrbRing::CenterOffset' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, Radius) == 0x000018, "Member 'FVLEquilibriumOrbRing::Radius' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, Speed) == 0x00001C, "Member 'FVLEquilibriumOrbRing::Speed' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, StartAngle) == 0x000020, "Member 'FVLEquilibriumOrbRing::StartAngle' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, HalfWidth) == 0x000024, "Member 'FVLEquilibriumOrbRing::HalfWidth' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, bRelativeRotation) == 0x000028, "Member 'FVLEquilibriumOrbRing::bRelativeRotation' has a wrong offset!");
static_assert(offsetof(FVLEquilibriumOrbRing, Nodes) == 0x000030, "Member 'FVLEquilibriumOrbRing::Nodes' has a wrong offset!");

// ScriptStruct man.VariableBool
// 0x0018 (0x0048 - 0x0030)
struct FVariableBool final : public FVariable
{
public:
	bool                                          Value;                                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableBool) == 0x000008, "Wrong alignment on FVariableBool");
static_assert(sizeof(FVariableBool) == 0x000048, "Wrong size on FVariableBool");
static_assert(offsetof(FVariableBool, Value) == 0x000030, "Member 'FVariableBool::Value' has a wrong offset!");

// ScriptStruct man.VariableInt
// 0x0018 (0x0048 - 0x0030)
struct FVariableInt final : public FVariable
{
public:
	int32                                         Value;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableInt) == 0x000008, "Wrong alignment on FVariableInt");
static_assert(sizeof(FVariableInt) == 0x000048, "Wrong size on FVariableInt");
static_assert(offsetof(FVariableInt, Value) == 0x000030, "Member 'FVariableInt::Value' has a wrong offset!");

// ScriptStruct man.VariableActorArray
// 0x0018 (0x0048 - 0x0030)
struct FVariableActorArray final : public FVariable
{
public:
	TArray<class AActor*>                         Value;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableActorArray) == 0x000008, "Wrong alignment on FVariableActorArray");
static_assert(sizeof(FVariableActorArray) == 0x000048, "Wrong size on FVariableActorArray");
static_assert(offsetof(FVariableActorArray, Value) == 0x000030, "Member 'FVariableActorArray::Value' has a wrong offset!");

// ScriptStruct man.VariableActorClassList
// 0x0020 (0x0050 - 0x0030)
struct FVariableActorClassList final : public FVariable
{
public:
	TArray<TSubclassOf<class AActorBase>>         Value;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableActorClassList) == 0x000008, "Wrong alignment on FVariableActorClassList");
static_assert(sizeof(FVariableActorClassList) == 0x000050, "Wrong size on FVariableActorClassList");
static_assert(offsetof(FVariableActorClassList, Value) == 0x000030, "Member 'FVariableActorClassList::Value' has a wrong offset!");

// ScriptStruct man.VariableActorClass
// 0x0010 (0x0040 - 0x0030)
struct FVariableActorClass final : public FVariable
{
public:
	TSubclassOf<class AActorBase>                 Value;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableActorClass) == 0x000008, "Wrong alignment on FVariableActorClass");
static_assert(sizeof(FVariableActorClass) == 0x000040, "Wrong size on FVariableActorClass");
static_assert(offsetof(FVariableActorClass, Value) == 0x000030, "Member 'FVariableActorClass::Value' has a wrong offset!");

// ScriptStruct man.VariableActor
// 0x0018 (0x0048 - 0x0030)
struct FVariableActor final : public FVariable
{
public:
	TWeakObjectPtr<class AActor>                  Value;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableActor) == 0x000008, "Wrong alignment on FVariableActor");
static_assert(sizeof(FVariableActor) == 0x000048, "Wrong size on FVariableActor");
static_assert(offsetof(FVariableActor, Value) == 0x000030, "Member 'FVariableActor::Value' has a wrong offset!");

// ScriptStruct man.VariableAbility
// 0x0018 (0x0048 - 0x0030)
struct FVariableAbility final : public FVariable
{
public:
	TSubclassOf<class UAbilityBase>               Value;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableAbility) == 0x000008, "Wrong alignment on FVariableAbility");
static_assert(sizeof(FVariableAbility) == 0x000048, "Wrong size on FVariableAbility");
static_assert(offsetof(FVariableAbility, Value) == 0x000030, "Member 'FVariableAbility::Value' has a wrong offset!");

// ScriptStruct man.VariableText
// 0x0028 (0x0058 - 0x0030)
struct FVariableText final : public FVariable
{
public:
	class FText                                   Value;                                             // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariableText) == 0x000008, "Wrong alignment on FVariableText");
static_assert(sizeof(FVariableText) == 0x000058, "Wrong size on FVariableText");
static_assert(offsetof(FVariableText, Value) == 0x000030, "Member 'FVariableText::Value' has a wrong offset!");

// ScriptStruct man.VendorPriceData
// 0x0008 (0x0008 - 0x0000)
struct FVendorPriceData final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeroProperty                                 Type;                                              // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendorPriceData) == 0x000004, "Wrong alignment on FVendorPriceData");
static_assert(sizeof(FVendorPriceData) == 0x000008, "Wrong size on FVendorPriceData");
static_assert(offsetof(FVendorPriceData, Value) == 0x000000, "Member 'FVendorPriceData::Value' has a wrong offset!");
static_assert(offsetof(FVendorPriceData, Type) == 0x000004, "Member 'FVendorPriceData::Type' has a wrong offset!");

// ScriptStruct man.VendorCartUpgradeElement
// 0x0030 (0x0030 - 0x0000)
struct FVendorCartUpgradeElement final
{
public:
	TSoftClassPtr<class UClass>                   Item;                                              // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendorCartUpgradeElement) == 0x000008, "Wrong alignment on FVendorCartUpgradeElement");
static_assert(sizeof(FVendorCartUpgradeElement) == 0x000030, "Wrong size on FVendorCartUpgradeElement");
static_assert(offsetof(FVendorCartUpgradeElement, Item) == 0x000000, "Member 'FVendorCartUpgradeElement::Item' has a wrong offset!");
static_assert(offsetof(FVendorCartUpgradeElement, ItemCount) == 0x000028, "Member 'FVendorCartUpgradeElement::ItemCount' has a wrong offset!");

// ScriptStruct man.VendorCartUpgradeLevel
// 0x0040 (0x0040 - 0x0000)
struct FVendorCartUpgradeLevel final
{
public:
	TArray<struct FVendorCartUpgradeElement>      UpgardeList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GoldCost;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredVendorLevel;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CartName;                                          // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSmartText                             CartDescription;                                   // 0x0030(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendorCartUpgradeLevel) == 0x000008, "Wrong alignment on FVendorCartUpgradeLevel");
static_assert(sizeof(FVendorCartUpgradeLevel) == 0x000040, "Wrong size on FVendorCartUpgradeLevel");
static_assert(offsetof(FVendorCartUpgradeLevel, UpgardeList) == 0x000000, "Member 'FVendorCartUpgradeLevel::UpgardeList' has a wrong offset!");
static_assert(offsetof(FVendorCartUpgradeLevel, GoldCost) == 0x000010, "Member 'FVendorCartUpgradeLevel::GoldCost' has a wrong offset!");
static_assert(offsetof(FVendorCartUpgradeLevel, RequiredVendorLevel) == 0x000014, "Member 'FVendorCartUpgradeLevel::RequiredVendorLevel' has a wrong offset!");
static_assert(offsetof(FVendorCartUpgradeLevel, CartName) == 0x000018, "Member 'FVendorCartUpgradeLevel::CartName' has a wrong offset!");
static_assert(offsetof(FVendorCartUpgradeLevel, CartDescription) == 0x000030, "Member 'FVendorCartUpgradeLevel::CartDescription' has a wrong offset!");

// ScriptStruct man.OverridedSlotParams
// 0x0040 (0x0040 - 0x0000)
struct FOverridedSlotParams final
{
public:
	EVendorType                                   VendorType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SlotName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconDisabled;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconNormal;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconOver;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconSelected;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverridedSlotParams) == 0x000008, "Wrong alignment on FOverridedSlotParams");
static_assert(sizeof(FOverridedSlotParams) == 0x000040, "Wrong size on FOverridedSlotParams");
static_assert(offsetof(FOverridedSlotParams, VendorType) == 0x000000, "Member 'FOverridedSlotParams::VendorType' has a wrong offset!");
static_assert(offsetof(FOverridedSlotParams, SlotName) == 0x000008, "Member 'FOverridedSlotParams::SlotName' has a wrong offset!");
static_assert(offsetof(FOverridedSlotParams, IconDisabled) == 0x000020, "Member 'FOverridedSlotParams::IconDisabled' has a wrong offset!");
static_assert(offsetof(FOverridedSlotParams, IconNormal) == 0x000028, "Member 'FOverridedSlotParams::IconNormal' has a wrong offset!");
static_assert(offsetof(FOverridedSlotParams, IconOver) == 0x000030, "Member 'FOverridedSlotParams::IconOver' has a wrong offset!");
static_assert(offsetof(FOverridedSlotParams, IconSelected) == 0x000038, "Member 'FOverridedSlotParams::IconSelected' has a wrong offset!");

// ScriptStruct man.CachedSellItem
// 0x0010 (0x0010 - 0x0000)
struct FCachedSellItem final
{
public:
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackNum;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedSellItem) == 0x000008, "Wrong alignment on FCachedSellItem");
static_assert(sizeof(FCachedSellItem) == 0x000010, "Wrong size on FCachedSellItem");
static_assert(offsetof(FCachedSellItem, ManItemSlotBase) == 0x000000, "Member 'FCachedSellItem::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(FCachedSellItem, StackNum) == 0x000008, "Member 'FCachedSellItem::StackNum' has a wrong offset!");

// ScriptStruct man.SellHistoryItem
// 0x0058 (0x0058 - 0x0000)
struct FSellHistoryItem final
{
public:
	struct FGeometry                              PaintSpaceGeometry;                                // 0x0000(0x0038)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UManItemSlotBase*                       ManItemSlotBase;                                   // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackNum;                                          // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemAbility>               ItemAbilityClass;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSellHistoryItem) == 0x000008, "Wrong alignment on FSellHistoryItem");
static_assert(sizeof(FSellHistoryItem) == 0x000058, "Wrong size on FSellHistoryItem");
static_assert(offsetof(FSellHistoryItem, PaintSpaceGeometry) == 0x000000, "Member 'FSellHistoryItem::PaintSpaceGeometry' has a wrong offset!");
static_assert(offsetof(FSellHistoryItem, ManItemSlotBase) == 0x000038, "Member 'FSellHistoryItem::ManItemSlotBase' has a wrong offset!");
static_assert(offsetof(FSellHistoryItem, Price) == 0x000040, "Member 'FSellHistoryItem::Price' has a wrong offset!");
static_assert(offsetof(FSellHistoryItem, StackNum) == 0x000044, "Member 'FSellHistoryItem::StackNum' has a wrong offset!");
static_assert(offsetof(FSellHistoryItem, Icon) == 0x000048, "Member 'FSellHistoryItem::Icon' has a wrong offset!");
static_assert(offsetof(FSellHistoryItem, ItemAbilityClass) == 0x000050, "Member 'FSellHistoryItem::ItemAbilityClass' has a wrong offset!");

// ScriptStruct man.TransmogCost
// 0x0008 (0x0008 - 0x0000)
struct FTransmogCost final
{
public:
	int32                                         Price;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSlot                                     ItemSlotType;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransmogCost) == 0x000004, "Wrong alignment on FTransmogCost");
static_assert(sizeof(FTransmogCost) == 0x000008, "Wrong size on FTransmogCost");
static_assert(offsetof(FTransmogCost, Price) == 0x000000, "Member 'FTransmogCost::Price' has a wrong offset!");
static_assert(offsetof(FTransmogCost, ItemSlotType) == 0x000004, "Member 'FTransmogCost::ItemSlotType' has a wrong offset!");

// ScriptStruct man.VendorUnlockParam
// 0x0048 (0x0048 - 0x0000)
struct FVendorUnlockParam final
{
public:
	class FName                                   VendorKey;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimalConversationSpeaker*             Speaker;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SoftPtrIcon;                                       // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UManQuest>                  QClass;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVendorType                                   VendorType;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendorUnlockParam) == 0x000008, "Wrong alignment on FVendorUnlockParam");
static_assert(sizeof(FVendorUnlockParam) == 0x000048, "Wrong size on FVendorUnlockParam");
static_assert(offsetof(FVendorUnlockParam, VendorKey) == 0x000000, "Member 'FVendorUnlockParam::VendorKey' has a wrong offset!");
static_assert(offsetof(FVendorUnlockParam, Speaker) == 0x000008, "Member 'FVendorUnlockParam::Speaker' has a wrong offset!");
static_assert(offsetof(FVendorUnlockParam, SoftPtrIcon) == 0x000010, "Member 'FVendorUnlockParam::SoftPtrIcon' has a wrong offset!");
static_assert(offsetof(FVendorUnlockParam, QClass) == 0x000038, "Member 'FVendorUnlockParam::QClass' has a wrong offset!");
static_assert(offsetof(FVendorUnlockParam, VendorType) == 0x000040, "Member 'FVendorUnlockParam::VendorType' has a wrong offset!");

// ScriptStruct man.VoidBossAttackEntropyRainData
// 0x000C (0x000C - 0x0000)
struct FVoidBossAttackEntropyRainData final
{
public:
	float                                         RandomXMin;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomXMax;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoidBossAttackEntropyRainData) == 0x000004, "Wrong alignment on FVoidBossAttackEntropyRainData");
static_assert(sizeof(FVoidBossAttackEntropyRainData) == 0x00000C, "Wrong size on FVoidBossAttackEntropyRainData");
static_assert(offsetof(FVoidBossAttackEntropyRainData, RandomXMin) == 0x000000, "Member 'FVoidBossAttackEntropyRainData::RandomXMin' has a wrong offset!");
static_assert(offsetof(FVoidBossAttackEntropyRainData, RandomXMax) == 0x000004, "Member 'FVoidBossAttackEntropyRainData::RandomXMax' has a wrong offset!");
static_assert(offsetof(FVoidBossAttackEntropyRainData, Delay) == 0x000008, "Member 'FVoidBossAttackEntropyRainData::Delay' has a wrong offset!");

// ScriptStruct man.VoidWitchAnamorphosisRayDataSequence
// 0x0010 (0x0010 - 0x0000)
struct FVoidWitchAnamorphosisRayDataSequence final
{
public:
	TArray<struct FVoidWitchAnamorphosisRayData>  OneSequence;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoidWitchAnamorphosisRayDataSequence) == 0x000008, "Wrong alignment on FVoidWitchAnamorphosisRayDataSequence");
static_assert(sizeof(FVoidWitchAnamorphosisRayDataSequence) == 0x000010, "Wrong size on FVoidWitchAnamorphosisRayDataSequence");
static_assert(offsetof(FVoidWitchAnamorphosisRayDataSequence, OneSequence) == 0x000000, "Member 'FVoidWitchAnamorphosisRayDataSequence::OneSequence' has a wrong offset!");

// ScriptStruct man.PlatformGrabAnimData
// 0x0018 (0x0018 - 0x0000)
struct FPlatformGrabAnimData final
{
public:
	class UAnimID*                                AnimID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimID*                                CliffHangingAnimID;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformGrabAnimData) == 0x000008, "Wrong alignment on FPlatformGrabAnimData");
static_assert(sizeof(FPlatformGrabAnimData) == 0x000018, "Wrong size on FPlatformGrabAnimData");
static_assert(offsetof(FPlatformGrabAnimData, AnimID) == 0x000000, "Member 'FPlatformGrabAnimData::AnimID' has a wrong offset!");
static_assert(offsetof(FPlatformGrabAnimData, AnimTime) == 0x000008, "Member 'FPlatformGrabAnimData::AnimTime' has a wrong offset!");
static_assert(offsetof(FPlatformGrabAnimData, CliffHangingAnimID) == 0x000010, "Member 'FPlatformGrabAnimData::CliffHangingAnimID' has a wrong offset!");

// ScriptStruct man.CycleOfLifeHealData
// 0x0008 (0x0008 - 0x0000)
struct FCycleOfLifeHealData final
{
public:
	float                                         HealValue;                                         // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealRemainingTime;                                 // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCycleOfLifeHealData) == 0x000004, "Wrong alignment on FCycleOfLifeHealData");
static_assert(sizeof(FCycleOfLifeHealData) == 0x000008, "Wrong size on FCycleOfLifeHealData");
static_assert(offsetof(FCycleOfLifeHealData, HealValue) == 0x000000, "Member 'FCycleOfLifeHealData::HealValue' has a wrong offset!");
static_assert(offsetof(FCycleOfLifeHealData, HealRemainingTime) == 0x000004, "Member 'FCycleOfLifeHealData::HealRemainingTime' has a wrong offset!");

}

